,user_input,retrieved_contexts,response,reference,context_precision,context_recall,answer_relevancy,faithfulness,bleu_score,rouge_score,factual_correctness
0,Ce este SQL?,"['1. ', ""copyright@www.adrian.runceanu.ro \n  Clauza WHERE a acestei cereri SQL compară \nnumele din tabela Angajaţi cu 'Smith'.  \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat. \nExemplu: \n \nSELECT empno, UPPER(ename), job, deptno \nFROM EMP \nWHERE INITCAP(ename) = 'Smith'; \nCurs 4 - BAZE DE DATE 24 \n4.2.1. Funcţii pentru şiruri de caractere"", '\n', '2. ', ""copyright@www.adrian.runceanu.ro \n  Clauza WHERE a acestei cereri SQL compară \nnumele din tabela Angajaţi cu 'Smith'.  \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat. \nExemplu: \n \nSELECT empno, UPPER(ename), job, deptno \nFROM EMP \nWHERE INITCAP(ename) = 'Smith'; \nCurs 4 - BAZE DE DATE 24 \n4.2.1. Funcţii pentru şiruri de caractere"", '\n', '3. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.1. Funcţii \n4.2. Funcţii referitoare la o singură înregistrare \n \nCurs 4 - BAZE DE DATE 3', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.1. Funcţii \n4.2. Funcţii referitoare la o singură înregistrare \n \nCurs 4 - BAZE DE DATE 3', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă \n \n3.1. SELECT. Sintaxa. Efect. Rezultat \n3.2. Lista SELECT \n3.3. Clauza WHERE \n3.4. Clauza ORDER BY \nCurs - Baze de date 3', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă \n \n3.1. SELECT. Sintaxa. Efect. Rezultat \n3.2. Lista SELECT \n3.3. Clauza WHERE \n3.4. Clauza ORDER BY \nCurs - Baze de date 3', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nOrdinea de executie a functiilor de \ngrup \n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei.  \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează.  \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă.  \nCurs 5 - BAZE DE DATE 50', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nOrdinea de executie a functiilor de \ngrup \n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei.  \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează.  \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă.  \nCurs 5 - BAZE DE DATE 50', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \n \nCereri SELECT pe o tabelă \n \n3.1. SELECT. Sintaxa. Efect. Rezultat \n3.2. Lista SELECT \n3.3. Clauza WHERE \n3.4. Clauza ORDER BY \nCurs - Baze de date 20', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \n \nCereri SELECT pe o tabelă \n \n3.1. SELECT. Sintaxa. Efect. Rezultat \n3.2. Lista SELECT \n3.3. Clauza WHERE \n3.4. Clauza ORDER BY \nCurs - Baze de date 20', '\n']","Folosind informatiile din curs, SQL (Limbajul structurat de interogare) este un limbaj utilizat pentru a interoga baze de date. Un exemplu de cerere SQL este `SELECT empno, UPPER(ename), job, deptno FROM EMP WHERE INITCAP(ename) = 'Smith';`, care selectează anumite coloane din tabela `EMP` unde numele, convertit la majuscule la început, este 'Smith'.
",SQL este un limbaj de interogare a bazelor de date.,0.1367554858888584,1.0,0.8219430695451112,,0.10062635309001745,0.22222222222222224,0.4
1,Care este sintaxa de bază a unei interogări SELECT?,"['1. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \n6. SUBQUERIES (Subinterogari) \n  În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem. \n \n\uf0d8O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT. \nCurs 6 - BAZE DE DATE 4', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \n6. SUBQUERIES (Subinterogari) \n  În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem. \n \n\uf0d8O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT. \nCurs 6 - BAZE DE DATE 4', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \n6.1. SINGLE ROW SUBQUERIES \n• Subinterogările pot fi plasate şi în clauza HAVING.  \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup. \nCurs 6 - BAZE DE DATE 22', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \n6.1. SINGLE ROW SUBQUERIES \n• Subinterogările pot fi plasate şi în clauza HAVING.  \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup. \nCurs 6 - BAZE DE DATE 22', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \n6. SUBQUERIES (Subinterogari) \n\uf0d8Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale. \n \n\uf0d8Un subquery nu poate avea propria clauză ORDER BY. \n \n\uf0d8Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare. \n \n\uf0d8Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic. \nCurs 6 - BAZE DE DATE 8', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \n6. SUBQUERIES (Subinterogari) \n\uf0d8Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale. \n \n\uf0d8Un subquery nu poate avea propria clauză ORDER BY. \n \n\uf0d8Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare. \n \n\uf0d8Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic. \nCurs 6 - BAZE DE DATE 8', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nFuncţii referitoare la o singură înregistrare \nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în: \n \na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule, \netc.  \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile)  \n \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare \nCurs 4 - BAZE DE DATE 14', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nFuncţii referitoare la o singură înregistrare \nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în: \n \na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule, \netc.  \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile)  \n \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare \nCurs 4 - BAZE DE DATE 14', '\n']","Folosind informatiile din curs, o subinterogare (subquery) este o instrucțiune SELECT care este inclusă în clauza unei alte instrucțiuni SELECT. 
",SELECT [DISTINCT] lista_de_expresii FROM nume_tabela WHERE conditie_linie ORDER BY criterii_sortare_rezultat;,,0.0,0.8853377961573391,,0.015095250248540108,0.052631578947368425,0.0
2,Ce face clauza WHERE într-o interogare SQL?,"['1. ', 'copyright@www.adrian.runceanu.ro \nOrdinea de executie a functiilor de \ngrup \n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei.  \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează.  \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă.  \nCurs 5 - BAZE DE DATE 50', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \nOrdinea de executie a functiilor de \ngrup \n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei.  \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează.  \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă.  \nCurs 5 - BAZE DE DATE 50', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă \n \n3.1. SELECT. Sintaxa. Efect. Rezultat \n3.2. Lista SELECT \n3.3. Clauza WHERE \n3.4. Clauza ORDER BY \nCurs - Baze de date 3', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă \n \n3.1. SELECT. Sintaxa. Efect. Rezultat \n3.2. Lista SELECT \n3.3. Clauza WHERE \n3.4. Clauza ORDER BY \nCurs - Baze de date 3', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \n \nCereri SELECT pe o tabelă \n \n3.1. SELECT. Sintaxa. Efect. Rezultat \n3.2. Lista SELECT \n3.3. Clauza WHERE \n3.4. Clauza ORDER BY \nCurs - Baze de date 20', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \n \nCereri SELECT pe o tabelă \n \n3.1. SELECT. Sintaxa. Efect. Rezultat \n3.2. Lista SELECT \n3.3. Clauza WHERE \n3.4. Clauza ORDER BY \nCurs - Baze de date 20', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \n \nCereri SELECT pe o tabelă \n \n3.1. SELECT. Sintaxa. Efect. Rezultat \n3.2. Lista SELECT \n3.3. Clauza WHERE \n3.4. Clauza ORDER BY \nCurs - Baze de date 69', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \n \nCereri SELECT pe o tabelă \n \n3.1. SELECT. Sintaxa. Efect. Rezultat \n3.2. Lista SELECT \n3.3. Clauza WHERE \n3.4. Clauza ORDER BY \nCurs - Baze de date 69', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \n \nCereri SELECT pe o tabelă \n \n3.1. SELECT. Sintaxa. Efect. Rezultat \n3.2. Lista SELECT \n3.3. Clauza WHERE \n3.4. Clauza ORDER BY \nCurs - Baze de date 9', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \n \nCereri SELECT pe o tabelă \n \n3.1. SELECT. Sintaxa. Efect. Rezultat \n3.2. Lista SELECT \n3.3. Clauza WHERE \n3.4. Clauza ORDER BY \nCurs - Baze de date 9', '\n']","Folosind informatiile din curs, clauza WHERE este folosită pentru a elimina înregistrări/grupuri și are un impact direct asupra vitezei de execuție a unei interogări SQL. Cu cât mai multe înregistrări sunt eliminate folosind clauza WHERE, cu atât mai rapidă va fi interogarea. 
",Clauza WHERE restricționează rândurile returnate la cele care îndeplinesc condiția specificată.,,1.0,0.8916513204443843,,0.013353534059549444,0.06349206349206349,0.0
3,Care este efectul utilizării DISTINCT într-o interogare?,"['1. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \nExercitii \nSe considera tabela EMP avand urmatoarea structura: \n \n \n \n \nsi avand urmatoarele valori introduse:  \nCurs - Baze de date 82', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \nExercitii \nSe considera tabela EMP avand urmatoarea structura: \n \n \n \n \nsi avand urmatoarele valori introduse:  \nCurs - Baze de date 82', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \n Operatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare. \n \nAstfel,  \n < ANY inseamna mai mic decat maximul  \n ANY inseamna mai mare decat minimul \n = ANY este echivalent cu IN \nCurs 6 - BAZE DE DATE 49', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \n Operatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare. \n \nAstfel,  \n < ANY inseamna mai mic decat maximul  \n ANY inseamna mai mare decat minimul \n = ANY este echivalent cu IN \nCurs 6 - BAZE DE DATE 49', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nREZULTAT \n  Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT.  \n  Aceste expresii dau si numele coloanelor din \nrezultat. \n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela. \nCurs - Baze de date 7', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nREZULTAT \n  Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT.  \n  Aceste expresii dau si numele coloanelor din \nrezultat. \n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela. \nCurs - Baze de date 7', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listează toţi angajaţii care nu au \ncomision.  \nCurs - Baze de date 62', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listează toţi angajaţii care nu au \ncomision.  \nCurs - Baze de date 62', '\n']","Folosind informatiile din curs, în lipsa clauzei DISTINCT, numarul de linii din rezultat este egal cu numarul liniilor din tabela care îndeplinesc conditia WHERE sau, când clauza respectiva lipseste, cu numarul total de linii din tabela. 
",DISTINCT elimină rândurile duplicat din rezultatul interogării.,,0.0,0.8047808295683044,,0.01092534162077208,0.08695652173913043,0.0
4,Ce face clauza ORDER BY?,"['1. ', 'copyright@www.adrian.runceanu.ro \nEFECT \n  Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat. \n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY. \n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela. \nCurs - Baze de date 6', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \nEFECT \n  Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat. \n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY. \n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela. \nCurs - Baze de date 6', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \nClauza ORDER BY \n\uf0d8 Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare, salariu şi comision (în ordine crescătoare).  \nCurs - Baze de date 79', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \nClauza ORDER BY \n\uf0d8 Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare, salariu şi comision (în ordine crescătoare).  \nCurs - Baze de date 79', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \nClauza ORDER BY \n\uf0d8În clauza ORDER BY se pot folosi coloane care nu sunt \nconţinute în SELECT. \n  \nExemplu:  \n  Listaţi toţi angajaţii ordonându-i după salariu (în \nordine crescătoare). \n \nSELECT ename, job \nFROM EMP \nORDER BY sal;   \nCurs - Baze de date 80', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \nClauza ORDER BY \n\uf0d8În clauza ORDER BY se pot folosi coloane care nu sunt \nconţinute în SELECT. \n  \nExemplu:  \n  Listaţi toţi angajaţii ordonându-i după salariu (în \nordine crescătoare). \n \nSELECT ename, job \nFROM EMP \nORDER BY sal;   \nCurs - Baze de date 80', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \n \nCereri SELECT pe o tabelă \n \n3.1. SELECT. Sintaxa. Efect. Rezultat \n3.2. Lista SELECT \n3.3. Clauza WHERE \n3.4. Clauza ORDER BY \nCurs - Baze de date 69', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \n \nCereri SELECT pe o tabelă \n \n3.1. SELECT. Sintaxa. Efect. Rezultat \n3.2. Lista SELECT \n3.3. Clauza WHERE \n3.4. Clauza ORDER BY \nCurs - Baze de date 69', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nClauza ORDER BY \nunde: \nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile \nASC - Ordonează rândurile crescător \nDESC - Ordonează rândurile descrescător  \nSintaxa:  \nSELECT coloana \nFROM tabela \n[WHERE conditie]  \n[ORDER BY {coloana, expresie} \n[ASC/DESC]]; \nCurs - Baze de date 71', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nClauza ORDER BY \nunde: \nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile \nASC - Ordonează rândurile crescător \nDESC - Ordonează rândurile descrescător  \nSintaxa:  \nSELECT coloana \nFROM tabela \n[WHERE conditie]  \n[ORDER BY {coloana, expresie} \n[ASC/DESC]]; \nCurs - Baze de date 71', '\n']","Folosind informatiile din curs,  Înainte de a trimite rezultatul, serverul îl sorteaza în functie de criteriile specificate de clauza ORDER BY. În cazul în care ORDER BY lipseste, liniile din rezultat sunt într-o ordine independenta de conținutul lor sau de ordinea în care ele au fost adaugate în tabela. 
",Clauza ORDER BY sortează rezultatele în funcție de coloanele specificate.,,1.0,0.7486400861129917,,0.04141141330484801,0.16129032258064516,0.5
5,Ce este o funcție în SQL?,"['1. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \n  O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null.  \n  Singurele funcţii care nu respectă această regulă \nsunt:  \n– CONCAT \n– DECODE \n– DUMP \n– NVL \n– REPLACE \nCurs 4 - BAZE DE DATE 12', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \n  O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null.  \n  Singurele funcţii care nu respectă această regulă \nsunt:  \n– CONCAT \n– DECODE \n– DUMP \n– NVL \n– REPLACE \nCurs 4 - BAZE DE DATE 12', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \n  O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null.  \n  Singurele funcţii care nu respectă această regulă \nsunt:  \n– CONCAT \n– DECODE \n– DUMP \n– NVL \n– REPLACE \nCurs 5 - BAZE DE DATE 12', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \n  O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null.  \n  Singurele funcţii care nu respectă această regulă \nsunt:  \n– CONCAT \n– DECODE \n– DUMP \n– NVL \n– REPLACE \nCurs 5 - BAZE DE DATE 12', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.1. Funcţii \n4.2. Funcţii referitoare la o singură înregistrare \n \nCurs 4 - BAZE DE DATE 3', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.1. Funcţii \n4.2. Funcţii referitoare la o singură înregistrare \n \nCurs 4 - BAZE DE DATE 3', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră \n 4.2.4. Funcţii de conversie dintr-un tip în altul \n 4.2.5. Funcţii generale \n  4.2.6. Funcţii condiţionale \nCurs 4 - BAZE DE DATE 32', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră \n 4.2.4. Funcţii de conversie dintr-un tip în altul \n 4.2.5. Funcţii generale \n  4.2.6. Funcţii condiţionale \nCurs 4 - BAZE DE DATE 32', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nOrdinea de executie a functiilor de \ngrup \n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei.  \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează.  \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă.  \nCurs 5 - BAZE DE DATE 50', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nOrdinea de executie a functiilor de \ngrup \n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei.  \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează.  \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă.  \nCurs 5 - BAZE DE DATE 50', '\n']","Folosind informatiile din curs, o funcție în SQL este un element care primește un argument (parametru) și returnează o valoare. O observație importantă este că dacă argumentul funcției are valoarea Null, atunci în mod automat rezultatul va avea valoarea Null. Singurele excepții de la această regulă sunt funcțiile: CONCAT, DECODE, DUMP, NVL și REPLACE.
","Funcțiile sunt utilizate pentru a realiza calcule asupra datelor, a modifica date și a manipula grupuri de înregistrări.",,,0.8300779313331531,,0.01958224832501124,0.075,0.0
6,Ce tipuri de funcții există în SQL?,"['1. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \n  O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null.  \n  Singurele funcţii care nu respectă această regulă \nsunt:  \n– CONCAT \n– DECODE \n– DUMP \n– NVL \n– REPLACE \nCurs 5 - BAZE DE DATE 12', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \n  O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null.  \n  Singurele funcţii care nu respectă această regulă \nsunt:  \n– CONCAT \n– DECODE \n– DUMP \n– NVL \n– REPLACE \nCurs 5 - BAZE DE DATE 12', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \n  O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null.  \n  Singurele funcţii care nu respectă această regulă \nsunt:  \n– CONCAT \n– DECODE \n– DUMP \n– NVL \n– REPLACE \nCurs 4 - BAZE DE DATE 12', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \n  O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null.  \n  Singurele funcţii care nu respectă această regulă \nsunt:  \n– CONCAT \n– DECODE \n– DUMP \n– NVL \n– REPLACE \nCurs 4 - BAZE DE DATE 12', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră \n 4.2.4. Funcţii de conversie dintr-un tip în altul \n 4.2.5. Funcţii generale \n  4.2.6. Funcţii condiţionale \nCurs 4 - BAZE DE DATE 32', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră \n 4.2.4. Funcţii de conversie dintr-un tip în altul \n 4.2.5. Funcţii generale \n  4.2.6. Funcţii condiţionale \nCurs 4 - BAZE DE DATE 32', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră \n 4.2.4. Funcţii de conversie dintr-un tip în altul \n 4.2.5. Funcţii generale \n  4.2.6. Funcţii condiţionale \nCurs 4 - BAZE DE DATE 15', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră \n 4.2.4. Funcţii de conversie dintr-un tip în altul \n 4.2.5. Funcţii generale \n  4.2.6. Funcţii condiţionale \nCurs 4 - BAZE DE DATE 15', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \n4.2.5. Funcţii generale \n\uf0d8SGBD-ul ORACLE pune la dispozitia \nprogramatorilor, in cadrul limbajului SQL, o \nfunctie si o expresie conditionala.  \n \n\uf0d8Acestea sunt alternative foarte bune la \nstructurile de tip IF-THEN-ELSE.  \n\uf0d8Functia se numeste DECODE, iar expresia \nconditionala este CASE. \nCurs 4 - BAZE DE DATE 106', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \n4.2.5. Funcţii generale \n\uf0d8SGBD-ul ORACLE pune la dispozitia \nprogramatorilor, in cadrul limbajului SQL, o \nfunctie si o expresie conditionala.  \n \n\uf0d8Acestea sunt alternative foarte bune la \nstructurile de tip IF-THEN-ELSE.  \n\uf0d8Functia se numeste DECODE, iar expresia \nconditionala este CASE. \nCurs 4 - BAZE DE DATE 106', '\n']","Folosind informatiile din curs, exista următoarele tipuri de funcții SQL:

* **Funcţii pentru şiruri de caractere**
* **Funcţii de tip numeric**
* **Funcţii de tip dată calendaristică şi oră**
* **Funcţii de conversie dintr-un tip în altul**
* **Funcţii generale**
* **Funcţii condiţionale** 
 
 Aceste funcții pot fi folosite pentru a manipula datele dintr-o bază de date. De exemplu, funcțiile pentru șiruri de caractere pot fi folosite pentru a concatena șiruri de caractere, pentru a extrage subșiruri de caractere sau pentru a converti șiruri de caractere în litere mari sau mici.

Este important de reținut că dacă se apelează o funcție SQL cu un argument egal cu valoarea Null, atunci rezultatul va fi de asemenea Null. Singurele excepții de la această regulă sunt funcțiile: CONCAT, DECODE, DUMP, NVL și REPLACE.

În plus față de aceste funcții, SQL oferă și o funcție numită DECODE și o expresie condițională numită CASE. Acestea pot fi folosite ca alternative la structurile IF-THEN-ELSE.
",Există funcții pentru o singură înregistrare și funcții pentru mai multe înregistrări (funcții de grup).,,,0.8769638195864405,0.5555555555555556,0.006568156923422029,0.10362694300518134,
7,Care sunt principalele funcții pentru șiruri de caractere?,"['1. ', ""copyright@www.adrian.runceanu.ro \n\uf0d8Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime.  \n\uf0d8Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior.  \n \n\uf0d8Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea:  \nCurs 4 - BAZE DE DATE 28 \n4.2.1. Funcţii pentru şiruri de caractere"", '\n', '2. ', ""copyright@www.adrian.runceanu.ro \n\uf0d8Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime.  \n\uf0d8Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior.  \n \n\uf0d8Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea:  \nCurs 4 - BAZE DE DATE 28 \n4.2.1. Funcţii pentru şiruri de caractere"", '\n', '3. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \nRezultat obtinut:  \n \nCurs 4 - BAZE DE DATE 23 \n4.2.1. Funcţii pentru şiruri de caractere', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \nRezultat obtinut:  \n \nCurs 4 - BAZE DE DATE 23 \n4.2.1. Funcţii pentru şiruri de caractere', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nRezultat obtinut:  \nCurs 4 - BAZE DE DATE 21 \n4.2.1. Funcţii pentru şiruri de caractere', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nRezultat obtinut:  \nCurs 4 - BAZE DE DATE 21 \n4.2.1. Funcţii pentru şiruri de caractere', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nRezultatul obtinut: \nCurs 4 - BAZE DE DATE 25 \n4.2.1. Funcţii pentru şiruri de caractere', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nRezultatul obtinut: \nCurs 4 - BAZE DE DATE 25 \n4.2.1. Funcţii pentru şiruri de caractere', '\n']","Folosind informatiile din curs, functiile pentru siruri de caractere pot fi imbricate pana la orice adancime, iar daca functiile sunt imbricate, atunci ele sunt evaluate din interior spre exterior. 
","LOWER, UPPER, INITCAP, CONCAT, SUBSTR, LENGTH, INSTR, REPLACE.",,,0.775792497312812,,0.01526608193588886,0.0,0.0
8,Ce face funcția LENGTH?,"['1. ', 'copyright@www.adrian.runceanu.ro \nExemplu de utilizare a \nfuncţiei LENGTH: \n \n \nSELECT LENGTH(ename)  \nFROM EMP;  \nCurs 4 - BAZE DE DATE 18 \n4.2.1. Funcţii pentru şiruri de caractere', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \nExemplu de utilizare a \nfuncţiei LENGTH: \n \n \nSELECT LENGTH(ename)  \nFROM EMP;  \nCurs 4 - BAZE DE DATE 18 \n4.2.1. Funcţii pentru şiruri de caractere', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \nExemplu de utilizare a funcţiei LENGTH – rezultatul \nobtinut:  \nCurs 4 - BAZE DE DATE 19 \n4.2.1. Funcţii pentru şiruri de caractere', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \nExemplu de utilizare a funcţiei LENGTH – rezultatul \nobtinut:  \nCurs 4 - BAZE DE DATE 19 \n4.2.1. Funcţii pentru şiruri de caractere', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \n4.3. Funcții de grup \nExemplul 7 - Comisionul mediu în departamentul 30 \n(ignorând sau nu valorile nule):  \nSELECT AVG(comm), AVG(NVL(comm, 0)) \nFROM EMP \nWHERE deptno = 30; \nCurs 5 - BAZE DE DATE 29', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \n4.3. Funcții de grup \nExemplul 7 - Comisionul mediu în departamentul 30 \n(ignorând sau nu valorile nule):  \nSELECT AVG(comm), AVG(NVL(comm, 0)) \nFROM EMP \nWHERE deptno = 30; \nCurs 5 - BAZE DE DATE 29', '\n', '7. ', ""copyright@www.adrian.runceanu.ro \nSELECT ename, LENGTH (ename) - LENGTH (TRANSLATE(ename, 'DA', \n'D'))  \nFROM EMP; \nCurs 4 - BAZE DE DATE 29 \n4.2.1. Funcţii pentru şiruri de caractere"", '\n', '8. ', ""copyright@www.adrian.runceanu.ro \nSELECT ename, LENGTH (ename) - LENGTH (TRANSLATE(ename, 'DA', \n'D'))  \nFROM EMP; \nCurs 4 - BAZE DE DATE 29 \n4.2.1. Funcţii pentru şiruri de caractere"", '\n', '9. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING) \nRezultatul obtinut - Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$.  \nCurs 5 - BAZE DE DATE 43', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING) \nRezultatul obtinut - Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$.  \nCurs 5 - BAZE DE DATE 43', '\n']","Folosind informatiile din curs,  funcția LENGTH este o funcție pentru șiruri de caractere care este utilizată pentru a determina lungimea unui șir de caractere. 
",Funcția LENGTH returnează numărul de caractere dintr-un șir de caractere.,0.4499999999775,,0.9030212087507671,1.0,0.07378790595215932,0.4102564102564103,1.0
9,Cum se utilizează funcția CONCAT?,"['1. ', ""copyright@www.adrian.runceanu.ro \nLISTA SELECT \nExpresii concatenate: \n \nExemplu 5: \nSELECT 'Specializarea '|| NUME ||' are codul ', CODS \nFROM SPECIALIZARE; \n \n \nExemplu 6: \nCu valori nule: \nSELECT TIP , ' are valoarea ' || SUMA || '.Lei' \nFROM BURSA; \nCurs - Baze de date 16"", '\n', '2. ', ""copyright@www.adrian.runceanu.ro \nLISTA SELECT \nExpresii concatenate: \n \nExemplu 5: \nSELECT 'Specializarea '|| NUME ||' are codul ', CODS \nFROM SPECIALIZARE; \n \n \nExemplu 6: \nCu valori nule: \nSELECT TIP , ' are valoarea ' || SUMA || '.Lei' \nFROM BURSA; \nCurs - Baze de date 16"", '\n', '3. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \nFuncţiile se pot clasifica în două categorii: \n \n1. Funcţii referitoare la o singură înregistrare \n(single-row functions) \n \n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions) \nCurs 4 - BAZE DE DATE 8', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \nFuncţiile se pot clasifica în două categorii: \n \n1. Funcţii referitoare la o singură înregistrare \n(single-row functions) \n \n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions) \nCurs 4 - BAZE DE DATE 8', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \n  O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null.  \n  Singurele funcţii care nu respectă această regulă \nsunt:  \n– CONCAT \n– DECODE \n– DUMP \n– NVL \n– REPLACE \nCurs 4 - BAZE DE DATE 12', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \n  O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null.  \n  Singurele funcţii care nu respectă această regulă \nsunt:  \n– CONCAT \n– DECODE \n– DUMP \n– NVL \n– REPLACE \nCurs 4 - BAZE DE DATE 12', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \n  O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null.  \n  Singurele funcţii care nu respectă această regulă \nsunt:  \n– CONCAT \n– DECODE \n– DUMP \n– NVL \n– REPLACE \nCurs 5 - BAZE DE DATE 12', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \n  O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null.  \n  Singurele funcţii care nu respectă această regulă \nsunt:  \n– CONCAT \n– DECODE \n– DUMP \n– NVL \n– REPLACE \nCurs 5 - BAZE DE DATE 12', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \nFuncţiile se clasifică în două tipuri: \n \n1. Funcţii referitoare la o singură înregistrare \n(single-row functions) \n \n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions) \nCurs 5 - BAZE DE DATE 8', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \nFuncţiile se clasifică în două tipuri: \n \n1. Funcţii referitoare la o singură înregistrare \n(single-row functions) \n \n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions) \nCurs 5 - BAZE DE DATE 8', '\n']","Folosind informatiile din curs, funcția CONCAT se utilizează pentru concatenarea șirurilor de caractere. De exemplu, se poate utiliza sintaxa 'Specializarea '|| NUME ||' are codul ', CODS pentru a concatena șirurile de caractere 'Specializarea ', valoarea coloanei NUME, ' are codul ' și valoarea coloanei CODS. Aceasta va crea un singur șir de caractere care conține toate aceste elemente concatenate. 
",Funcția CONCAT concatenează două sau mai multe șiruri de caractere într-unul singur.,,,0.8849313495740637,,0.06285596338261262,0.17142857142857143,0.5
10,Ce este o subinterogare?,"['1. ', 'copyright@www.adrian.runceanu.ro \n6. SUBQUERIES (Subinterogari) \n  În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem. \n \n\uf0d8O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT. \nCurs 6 - BAZE DE DATE 4', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \n6. SUBQUERIES (Subinterogari) \n  În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem. \n \n\uf0d8O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT. \nCurs 6 - BAZE DE DATE 4', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \n6. SUBQUERIES (Subinterogari) \nReguli de folosire a subinterogarilor  \n \n\uf0d8O subinterogare se pune între paranteze rotunde \n \n\uf0d8O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare \n \n\uf0d8Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite \nCurs 6 - BAZE DE DATE 7', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \n6. SUBQUERIES (Subinterogari) \nReguli de folosire a subinterogarilor  \n \n\uf0d8O subinterogare se pune între paranteze rotunde \n \n\uf0d8O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare \n \n\uf0d8Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite \nCurs 6 - BAZE DE DATE 7', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \n6.1. SINGLE ROW SUBQUERIES \n• Subinterogările pot fi plasate şi în clauza HAVING.  \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup. \nCurs 6 - BAZE DE DATE 22', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \n6.1. SINGLE ROW SUBQUERIES \n• Subinterogările pot fi plasate şi în clauza HAVING.  \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup. \nCurs 6 - BAZE DE DATE 22', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \n6. SUBQUERIES (Subinterogari) \n\uf0d8Subinterogarea poate fi plasata în una din \nurmătoarele clauze:  \n\uf0d8WHERE \n\uf0d8HAVING  \n\uf0d8FROM \n\uf0d8Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query). \nCurs 6 - BAZE DE DATE 5', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \n6. SUBQUERIES (Subinterogari) \n\uf0d8Subinterogarea poate fi plasata în una din \nurmătoarele clauze:  \n\uf0d8WHERE \n\uf0d8HAVING  \n\uf0d8FROM \n\uf0d8Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query). \nCurs 6 - BAZE DE DATE 5', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \n6. SUBQUERIES (Subinterogari) \n\uf0d8Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale. \n \n\uf0d8Un subquery nu poate avea propria clauză ORDER BY. \n \n\uf0d8Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare. \n \n\uf0d8Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic. \nCurs 6 - BAZE DE DATE 8', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \n6. SUBQUERIES (Subinterogari) \n\uf0d8Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale. \n \n\uf0d8Un subquery nu poate avea propria clauză ORDER BY. \n \n\uf0d8Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare. \n \n\uf0d8Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic. \nCurs 6 - BAZE DE DATE 8', '\n']","Folosind informatiile din curs, o subinterogare (subquery) este o instrucțiune SELECT care este inclusă în clauza unei alte instrucțiuni SELECT. În SQL, subinterogările ne permit să aflăm o informație care ne este necesară pentru a obține informația pe care o vrem. 
",O subinterogare este o instrucțiune SELECT inclusă într-o altă instrucțiune SELECT.,,,0.8093465209475287,,0.11856660123276004,0.3548387096774194,0.0
11,În ce clauze poate fi plasată o subinterogare?,"['1. ', 'copyright@www.adrian.runceanu.ro \n6.1. SINGLE ROW SUBQUERIES \n• Subinterogările pot fi plasate şi în clauza HAVING.  \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup. \nCurs 6 - BAZE DE DATE 22', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \n6.1. SINGLE ROW SUBQUERIES \n• Subinterogările pot fi plasate şi în clauza HAVING.  \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup. \nCurs 6 - BAZE DE DATE 22', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n1. BETWEEN...AND...  \n \n  Condiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie). \n  Intervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată \ntrebuie să fie limita inferioară.  \nCurs - Baze de date 44', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n1. BETWEEN...AND...  \n \n  Condiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie). \n  Intervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată \ntrebuie să fie limita inferioară.  \nCurs - Baze de date 44', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \n4.3.1. Clauza GROUP BY \nGruparea după mai multe coloane.  \n \n  Câteodată este necesară obţinerea de rezultate \npentru grupuri în alte grupuri.  \n  Atunci în dreptul clauzei GROUP BY vom întâlni \nmai multe coloane. \nCurs 5 - BAZE DE DATE 37', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \n4.3.1. Clauza GROUP BY \nGruparea după mai multe coloane.  \n \n  Câteodată este necesară obţinerea de rezultate \npentru grupuri în alte grupuri.  \n  Atunci în dreptul clauzei GROUP BY vom întâlni \nmai multe coloane. \nCurs 5 - BAZE DE DATE 37', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \n4.3.1. Clauza GROUP BY \nRezultatul obtinut - Salariul total pe fiecare departament si pe \nfiecare functie, iar rezultatele ordonate după salariul mediu pe \ndepartament.  \n \nCurs 5 - BAZE DE DATE 39', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \n4.3.1. Clauza GROUP BY \nRezultatul obtinut - Salariul total pe fiecare departament si pe \nfiecare functie, iar rezultatele ordonate după salariul mediu pe \ndepartament.  \n \nCurs 5 - BAZE DE DATE 39', '\n']","Folosind informatiile din curs, subinterogările pot fi plasate în clauza HAVING.  Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi subinterogarea va avea aproape întotdeauna o condiţie de grup. 
","Subinterogările pot fi plasate în clauzele WHERE, HAVING și FROM.",,,0.8042768763468234,,0.23462350320527997,0.36363636363636365,0.33
12,Ce este clauza GROUP BY?,"['1. ', 'copyright@www.adrian.runceanu.ro \n4.3.1. Clauza GROUP BY \n\uf0d8Până acum toate funcţiile de grup au fost aplicate \nîntregii tabele.  \n  \n\uf0d8Pentru a putea împărţi tabela în grupuri mai mici se \nfoloseşte clauza GROUP BY.  \n \n\uf0d8Folosirea acesteia returnează informaţii sumare despre \nfiecare grup.  \nCurs 5 - BAZE DE DATE 31', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \n4.3.1. Clauza GROUP BY \n\uf0d8Până acum toate funcţiile de grup au fost aplicate \nîntregii tabele.  \n  \n\uf0d8Pentru a putea împărţi tabela în grupuri mai mici se \nfoloseşte clauza GROUP BY.  \n \n\uf0d8Folosirea acesteia returnează informaţii sumare despre \nfiecare grup.  \nCurs 5 - BAZE DE DATE 31', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \n6.2. MULTIPLE ROW SUBQUERIES \nClauzele GROUP BY si HAVING \nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare \nCurs 6 - BAZE DE DATE 39', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \n6.2. MULTIPLE ROW SUBQUERIES \nClauzele GROUP BY si HAVING \nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare \nCurs 6 - BAZE DE DATE 39', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \n4.3.1. Clauza GROUP BY \n\uf0d8Folosind GROUP BY nu se pot extrage şi coloane \nindividuale, ci doar coloane ce rămân identice în tot \ngrupul. \n\uf0d8Folosind WHERE se pot exclude rânduri, înaintea \nîmpărţirii lor în grupuri. \n\uf0d8Nu pot fi folosite aliasuri de coloane în clauza GROUP \nBY. \n\uf0d8Implicit, rândurile sunt sortate crescător după coloana \n(coloanele) specificate în GROUP BY.  \n\uf0d8Acest lucru poate fi schimbat folosind ORDER BY. \nCurs 5 - BAZE DE DATE 32', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \n4.3.1. Clauza GROUP BY \n\uf0d8Folosind GROUP BY nu se pot extrage şi coloane \nindividuale, ci doar coloane ce rămân identice în tot \ngrupul. \n\uf0d8Folosind WHERE se pot exclude rânduri, înaintea \nîmpărţirii lor în grupuri. \n\uf0d8Nu pot fi folosite aliasuri de coloane în clauza GROUP \nBY. \n\uf0d8Implicit, rândurile sunt sortate crescător după coloana \n(coloanele) specificate în GROUP BY.  \n\uf0d8Acest lucru poate fi schimbat folosind ORDER BY. \nCurs 5 - BAZE DE DATE 32', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \n4.3.1. Clauza GROUP BY \nGruparea după mai multe coloane.  \n \n  Câteodată este necesară obţinerea de rezultate \npentru grupuri în alte grupuri.  \n  Atunci în dreptul clauzei GROUP BY vom întâlni \nmai multe coloane. \nCurs 5 - BAZE DE DATE 37', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \n4.3.1. Clauza GROUP BY \nGruparea după mai multe coloane.  \n \n  Câteodată este necesară obţinerea de rezultate \npentru grupuri în alte grupuri.  \n  Atunci în dreptul clauzei GROUP BY vom întâlni \nmai multe coloane. \nCurs 5 - BAZE DE DATE 37', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \n6.1. SINGLE ROW SUBQUERIES \nSe pot folosi funcţiile de grup în subinterogări.  \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie. \n \nCurs 6 - BAZE DE DATE 20', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \n6.1. SINGLE ROW SUBQUERIES \nSe pot folosi funcţiile de grup în subinterogări.  \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie. \n \nCurs 6 - BAZE DE DATE 20', '\n']","Folosind informatiile din curs, Clauza GROUP BY este folosită pentru a împărți o tabelă în grupuri mai mici. Aceasta permite aplicarea funcțiilor de grup, care până acum se aplicau întregii tabele, fiecărui grup în parte, returnând informații sumare despre fiecare grup. 
",Clauza GROUP BY permite gruparea rezultatelor pe baza unei sau mai multor coloane.,,,0.8415004581425523,,0.08097785064266205,0.13114754098360656,0.4
13,Cum funcționează clauza HAVING?,"['1. ', 'copyright@www.adrian.runceanu.ro \n6.1. SINGLE ROW SUBQUERIES \n• Subinterogările pot fi plasate şi în clauza HAVING.  \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup. \nCurs 6 - BAZE DE DATE 22', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \n6.1. SINGLE ROW SUBQUERIES \n• Subinterogările pot fi plasate şi în clauza HAVING.  \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup. \nCurs 6 - BAZE DE DATE 22', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING)  \n \n  Clauza HAVING funcţionează în mare ca şi clauza \nWHERE, diferenţa fiind că HAVING este folosit pentru a \nexclude anumite grupuri din rezultat, nu rânduri cum \nfăcea WHERE. \n \n Clauza HAVING poate fi folosită înainte de GROUP \nBY, însă este mai logic să fie folosită după.  \n \n  Ordinea execuţiei va rămâne aceeaşi. \nCurs 5 - BAZE DE DATE 41', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING)  \n \n  Clauza HAVING funcţionează în mare ca şi clauza \nWHERE, diferenţa fiind că HAVING este folosit pentru a \nexclude anumite grupuri din rezultat, nu rânduri cum \nfăcea WHERE. \n \n Clauza HAVING poate fi folosită înainte de GROUP \nBY, însă este mai logic să fie folosită după.  \n \n  Ordinea execuţiei va rămâne aceeaşi. \nCurs 5 - BAZE DE DATE 41', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n  Clauza WHERE poate compara valori în coloană, \nvalori literale, expresii aritmetice sau funcţii. \nWHERE - restricţionează cererea la rândurile care \nîndeplinesc o condiţie; \n \nCondiţie este alcătuită din trei elemente: \n1. Un nume de coloană  \n2. Un operator de comparaţie  \n3. Un nume de coloană, constantă sau listă de valori \nCurs - Baze de date 31', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n  Clauza WHERE poate compara valori în coloană, \nvalori literale, expresii aritmetice sau funcţii. \nWHERE - restricţionează cererea la rândurile care \nîndeplinesc o condiţie; \n \nCondiţie este alcătuită din trei elemente: \n1. Un nume de coloană  \n2. Un operator de comparaţie  \n3. Un nume de coloană, constantă sau listă de valori \nCurs - Baze de date 31', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING) \nRezultatul obtinut - Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$.  \n \nCurs 5 - BAZE DE DATE 45', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING) \nRezultatul obtinut - Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$.  \n \nCurs 5 - BAZE DE DATE 45', '\n']","Folosind informatiile din curs, clauza HAVING funcționează în mare ca și clauza WHERE, cu diferența că HAVING este folosit pentru a exclude anumite grupuri din rezultat, nu rânduri cum făcea WHERE. Clauza HAVING poate fi folosită înainte de GROUP BY, însă este mai logic să fie folosită după. Ordinea execuției va rămâne aceeași.
",Clauza HAVING filtrează grupurile de date după criterii specifice.,,,0.8447491904850195,,0.010885011049519644,0.1142857142857143,0.29
14,Care sunt principalele funcții de grup?,"['1. ', 'copyright@www.adrian.runceanu.ro \n4.3. Funcții de grup \n  Funcţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg \nsetul.  \n Parametrii şi descrierea funcţiilor de grup.  \nFuncţiile de grup sunt:  \n1. AVG  \n2. COUNT  \n3. MAX  \n4. MIN  \n5. STDDEV  \n6. SUM  \n7. VARIANCE  \nCurs 5 - BAZE DE DATE 14', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \n4.3. Funcții de grup \n  Funcţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg \nsetul.  \n Parametrii şi descrierea funcţiilor de grup.  \nFuncţiile de grup sunt:  \n1. AVG  \n2. COUNT  \n3. MAX  \n4. MIN  \n5. STDDEV  \n6. SUM  \n7. VARIANCE  \nCurs 5 - BAZE DE DATE 14', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \n  Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează:  \n\uf0d8Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei,  \n \n\uf0d8pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela. \nCurs 4 - BAZE DE DATE 11', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \n  Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează:  \n\uf0d8Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei,  \n \n\uf0d8pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela. \nCurs 4 - BAZE DE DATE 11', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \n  Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează:  \n\uf0d8Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei,  \n \n\uf0d8pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela. \nCurs 5 - BAZE DE DATE 11', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \n  Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează:  \n\uf0d8Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei,  \n \n\uf0d8pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela. \nCurs 5 - BAZE DE DATE 11', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \n4.3. Funcții de grup \nRezultatul obtinut - Numărul angajaţilor care iau comision din \ndepartamentul 30: \n  \nCurs 5 - BAZE DE DATE 27', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \n4.3. Funcții de grup \nRezultatul obtinut - Numărul angajaţilor care iau comision din \ndepartamentul 30: \n  \nCurs 5 - BAZE DE DATE 27', '\n']","Folosind informatiile din curs, principalele funcții de grup sunt: 
1. AVG 
2. COUNT 
3. MAX 
4. MIN 
5. STDDEV 
6. SUM 
7. VARIANCE 
 Acestea sunt funcții care operează pe un set de rânduri pentru a da un rezultat pe întreg setul. 
","AVG, COUNT, MAX, MIN, STDDEV, SUM, VARIANCE.",,,0.8945999016810456,,0.028666091494718774,0.2745098039215686,0.67
15,Cum se folosește funcția COUNT?,"['1. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \nFuncţiile se pot clasifica în două categorii: \n \n1. Funcţii referitoare la o singură înregistrare \n(single-row functions) \n \n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions) \nCurs 4 - BAZE DE DATE 8', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \nFuncţiile se pot clasifica în două categorii: \n \n1. Funcţii referitoare la o singură înregistrare \n(single-row functions) \n \n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions) \nCurs 4 - BAZE DE DATE 8', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \n4.3. Funcții de grup \nFuncţia COUNT  \n \nFuncţia COUNT are 3 formate:  \n \nCOUNT(*)  \nCOUNT(expr)  \nCOUNT(DISTINCT expr) \nCurs 5 - BAZE DE DATE 21', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \n4.3. Funcții de grup \nFuncţia COUNT  \n \nFuncţia COUNT are 3 formate:  \n \nCOUNT(*)  \nCOUNT(expr)  \nCOUNT(DISTINCT expr) \nCurs 5 - BAZE DE DATE 21', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \n4.3. Funcții de grup \n• În contrast, funcţia COUNT(expr) întoarce numărul \nde valori nenule din coloana specificată de expr. \n \n• COUNT(DISTINCT expr) returnează numărul de valori \ndistincte, nenule din coloana specificată de expr. \n \nCurs 5 - BAZE DE DATE 23', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \n4.3. Funcții de grup \n• În contrast, funcţia COUNT(expr) întoarce numărul \nde valori nenule din coloana specificată de expr. \n \n• COUNT(DISTINCT expr) returnează numărul de valori \ndistincte, nenule din coloana specificată de expr. \n \nCurs 5 - BAZE DE DATE 23', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \nFuncţiile se clasifică în două tipuri: \n \n1. Funcţii referitoare la o singură înregistrare \n(single-row functions) \n \n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions) \nCurs 5 - BAZE DE DATE 8', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \nFuncţiile se clasifică în două tipuri: \n \n1. Funcţii referitoare la o singură înregistrare \n(single-row functions) \n \n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions) \nCurs 5 - BAZE DE DATE 8', '\n']","Folosind informatiile din curs, Funcția COUNT are 3 formate:  
 
COUNT(*)  
COUNT(expr)  
COUNT(DISTINCT expr) 

- COUNT(expr) întoarce numărul de valori nenule din coloana specificată de expr. 
- COUNT(DISTINCT expr) returnează numărul de valori distincte, nenule din coloana specificată de expr. 
","COUNT(*) returnează numărul total de rânduri dintr-o tabelă, inclusiv cele nule și duplicate.",,,0.8326993315551011,,0.06791633087805804,0.16666666666666666,0.0
16,Ce face funcția AVG?,"['1. ', 'copyright@www.adrian.runceanu.ro \n4.3. Funcții de grup \nExemplul 7 - Comisionul mediu în departamentul 30 \n(ignorând sau nu valorile nule):  \nSELECT AVG(comm), AVG(NVL(comm, 0)) \nFROM EMP \nWHERE deptno = 30; \nCurs 5 - BAZE DE DATE 29', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \n4.3. Funcții de grup \nExemplul 7 - Comisionul mediu în departamentul 30 \n(ignorând sau nu valorile nule):  \nSELECT AVG(comm), AVG(NVL(comm, 0)) \nFROM EMP \nWHERE deptno = 30; \nCurs 5 - BAZE DE DATE 29', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING) \nRezultatul obtinut - Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$.  \nCurs 5 - BAZE DE DATE 43', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING) \nRezultatul obtinut - Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$.  \nCurs 5 - BAZE DE DATE 43', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \n4.3.1. Clauza GROUP BY \nExemplul 8 - Salariul mediu pe fiecare department: \n \nSELECT deptno, AVG(sal) \nFROM EMP \nGROUP BY deptno;  \nCurs 5 - BAZE DE DATE 33', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \n4.3.1. Clauza GROUP BY \nExemplul 8 - Salariul mediu pe fiecare department: \n \nSELECT deptno, AVG(sal) \nFROM EMP \nGROUP BY deptno;  \nCurs 5 - BAZE DE DATE 33', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981.  \nCurs - Baze de date 39', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981.  \nCurs - Baze de date 39', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \n4.3. Funcții de grup \nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \n Fiecare dintre aceste funcţii acceptă anumiţi parametri:  \nCurs 5 - BAZE DE DATE 15', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \n4.3. Funcții de grup \nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \n Fiecare dintre aceste funcţii acceptă anumiţi parametri:  \nCurs 5 - BAZE DE DATE 15', '\n']","Folosind informatiile din curs, funcția AVG calculează valoarea medie pentru grup, ignorand valorile nule. 
",Funcția AVG calculează media unei coloane numerice.,,,0.9559989482669183,,0.048911878744807256,0.3478260869565218,0.0
17,Care este diferența dintre WHERE și HAVING?,"['1. ', 'copyright@www.adrian.runceanu.ro \n6.1. SINGLE ROW SUBQUERIES \n• Subinterogările pot fi plasate şi în clauza HAVING.  \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup. \nCurs 6 - BAZE DE DATE 22', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \n6.1. SINGLE ROW SUBQUERIES \n• Subinterogările pot fi plasate şi în clauza HAVING.  \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup. \nCurs 6 - BAZE DE DATE 22', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING)  \n \n  Clauza HAVING funcţionează în mare ca şi clauza \nWHERE, diferenţa fiind că HAVING este folosit pentru a \nexclude anumite grupuri din rezultat, nu rânduri cum \nfăcea WHERE. \n \n Clauza HAVING poate fi folosită înainte de GROUP \nBY, însă este mai logic să fie folosită după.  \n \n  Ordinea execuţiei va rămâne aceeaşi. \nCurs 5 - BAZE DE DATE 41', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING)  \n \n  Clauza HAVING funcţionează în mare ca şi clauza \nWHERE, diferenţa fiind că HAVING este folosit pentru a \nexclude anumite grupuri din rezultat, nu rânduri cum \nfăcea WHERE. \n \n Clauza HAVING poate fi folosită înainte de GROUP \nBY, însă este mai logic să fie folosită după.  \n \n  Ordinea execuţiei va rămâne aceeaşi. \nCurs 5 - BAZE DE DATE 41', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING) \nRezultatul obtinut - Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$.  \n \nCurs 5 - BAZE DE DATE 45', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING) \nRezultatul obtinut - Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$.  \n \nCurs 5 - BAZE DE DATE 45', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING) \nRezultatul obtinut - Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$.  \nCurs 5 - BAZE DE DATE 43', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING) \nRezultatul obtinut - Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$.  \nCurs 5 - BAZE DE DATE 43', '\n']","Folosind informatiile din curs,  atât clauza WHERE cât și clauza HAVING pot fi utilizate pentru a filtra datele. Diferența esențială constă în momentul în care se aplică filtrarea și la ce nivel:

* **Clauza WHERE:** Această clauză filtrează **înainte** de gruparea datelor. Ea se aplică pe **fiecare rând** din tabel și verifică dacă acesta îndeplinește o anumită condiție. Rândurile care nu satisfac condiția sunt eliminate **înainte** de a se realiza gruparea. 
* **Clauza HAVING:**  Această clauză filtrează **după** gruparea datelor. Ea se aplică pe **fiecare grup** rezultat în urma grupării și verifică dacă grupul respectiv îndeplinește o anumită condiție.  Grupurile care nu satisfac condiția sunt eliminate din rezultatul final. 

Pe scurt, WHERE filtrează rânduri individuale înainte de grupare, în timp ce HAVING filtrează grupuri de rânduri după grupare.
","WHERE filtrează rândurile înainte de grupare, în timp ce HAVING filtrează grupurile după aplicarea funcțiilor de agregare.",,,0.88866574272931,,0.026643211213888948,0.16249999999999998,
18,Ce face operatorul BETWEEN?,"['1. ', 'copyright@www.adrian.runceanu.ro \n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN.  \n \n• De fapt operatorul NOT IN este echivalent cu <> ALL. \n \n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL).  \nCurs 6 - BAZE DE DATE 62', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN.  \n \n• De fapt operatorul NOT IN este echivalent cu <> ALL. \n \n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL).  \nCurs 6 - BAZE DE DATE 62', '\n', '3. ', 'CLAUZA WHERE \n Operatori de \ncomparare \n \n< Mai mic \n<= Mai mic sau egal \n> Mai mare \n>= Mai mare sau egal \n<> Diferit \n!= Diferit \n^= Diferit \nCurs - Baze de date 22', '\n', '4. ', 'CLAUZA WHERE \n Operatori de \ncomparare \n \n< Mai mic \n<= Mai mic sau egal \n> Mai mare \n>= Mai mare sau egal \n<> Diferit \n!= Diferit \n^= Diferit \nCurs - Baze de date 22', '\n', '5. ', ""copyright@www.adrian.runceanu.ro \n\uf0d8Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime.  \n\uf0d8Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior.  \n \n\uf0d8Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea:  \nCurs 4 - BAZE DE DATE 28 \n4.2.1. Funcţii pentru şiruri de caractere"", '\n', '6. ', ""copyright@www.adrian.runceanu.ro \n\uf0d8Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime.  \n\uf0d8Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior.  \n \n\uf0d8Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea:  \nCurs 4 - BAZE DE DATE 28 \n4.2.1. Funcţii pentru şiruri de caractere"", '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nOrdinea de execuţie Operator \n1. Operatorii aritmetici \n2. Operatorii de concatenare \n3. Conditiile de comparare \n4. IS [NOT] NULL, LIKE, [NOT] IN \n5. [NOT] BETWEEN \n6. Operatorul logic NOT \n7. Operatorul logic AND \n8. Operatorul logic OR \n D. Prioritatea de execuţie  \nCurs - Baze de date 64', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nOrdinea de execuţie Operator \n1. Operatorii aritmetici \n2. Operatorii de concatenare \n3. Conditiile de comparare \n4. IS [NOT] NULL, LIKE, [NOT] IN \n5. [NOT] BETWEEN \n6. Operatorul logic NOT \n7. Operatorul logic AND \n8. Operatorul logic OR \n D. Prioritatea de execuţie  \nCurs - Baze de date 64', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n  Clauza WHERE poate compara valori în coloană, \nvalori literale, expresii aritmetice sau funcţii. \nWHERE - restricţionează cererea la rândurile care \nîndeplinesc o condiţie; \n \nCondiţie este alcătuită din trei elemente: \n1. Un nume de coloană  \n2. Un operator de comparaţie  \n3. Un nume de coloană, constantă sau listă de valori \nCurs - Baze de date 31', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n  Clauza WHERE poate compara valori în coloană, \nvalori literale, expresii aritmetice sau funcţii. \nWHERE - restricţionează cererea la rândurile care \nîndeplinesc o condiţie; \n \nCondiţie este alcătuită din trei elemente: \n1. Un nume de coloană  \n2. Un operator de comparaţie  \n3. Un nume de coloană, constantă sau listă de valori \nCurs - Baze de date 31', '\n']","Folosind informatiile din curs, nu se specifica ce face operatorul BETWEEN. 
",Operatorul BETWEEN selectează rânduri ale căror valori se află într-un interval specificat.,,,0.0,,0.03705247205763761,0.15384615384615383,0.0
19,Cum funcționează operatorul IN?,"['1. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \nFuncţiile se pot clasifica în două categorii: \n \n1. Funcţii referitoare la o singură înregistrare \n(single-row functions) \n \n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions) \nCurs 4 - BAZE DE DATE 8', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \nFuncţiile se pot clasifica în două categorii: \n \n1. Funcţii referitoare la o singură înregistrare \n(single-row functions) \n \n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions) \nCurs 4 - BAZE DE DATE 8', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN.  \n \n• De fapt operatorul NOT IN este echivalent cu <> ALL. \n \n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL).  \nCurs 6 - BAZE DE DATE 62', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN.  \n \n• De fapt operatorul NOT IN este echivalent cu <> ALL. \n \n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL).  \nCurs 6 - BAZE DE DATE 62', '\n', '5. ', ""copyright@www.adrian.runceanu.ro \n\uf0d8Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime.  \n\uf0d8Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior.  \n \n\uf0d8Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea:  \nCurs 4 - BAZE DE DATE 28 \n4.2.1. Funcţii pentru şiruri de caractere"", '\n', '6. ', ""copyright@www.adrian.runceanu.ro \n\uf0d8Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime.  \n\uf0d8Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior.  \n \n\uf0d8Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea:  \nCurs 4 - BAZE DE DATE 28 \n4.2.1. Funcţii pentru şiruri de caractere"", '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \nFuncţiile se clasifică în două tipuri: \n \n1. Funcţii referitoare la o singură înregistrare \n(single-row functions) \n \n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions) \nCurs 5 - BAZE DE DATE 8', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \nFuncţiile se clasifică în două tipuri: \n \n1. Funcţii referitoare la o singură înregistrare \n(single-row functions) \n \n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions) \nCurs 5 - BAZE DE DATE 8', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n  Clauza WHERE poate compara valori în coloană, \nvalori literale, expresii aritmetice sau funcţii. \nWHERE - restricţionează cererea la rândurile care \nîndeplinesc o condiţie; \n \nCondiţie este alcătuită din trei elemente: \n1. Un nume de coloană  \n2. Un operator de comparaţie  \n3. Un nume de coloană, constantă sau listă de valori \nCurs - Baze de date 31', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n  Clauza WHERE poate compara valori în coloană, \nvalori literale, expresii aritmetice sau funcţii. \nWHERE - restricţionează cererea la rândurile care \nîndeplinesc o condiţie; \n \nCondiţie este alcătuită din trei elemente: \n1. Un nume de coloană  \n2. Un operator de comparaţie  \n3. Un nume de coloană, constantă sau listă de valori \nCurs - Baze de date 31', '\n']","Folosind informatiile din curs, operatorul `IN` este echivalent cu `= ALL`. Returnarea de valori `NULL` de catre o subinterogare, atunci cand este folosit operatorul `IN` in interogarea principala, nu reprezinta o problema. 
",Operatorul IN selectează rânduri care corespund unei liste de valori specificate.,,,0.8326517541013061,,0.024455939372403628,0.18604651162790697,0.0
20,Ce este operatorul LIKE?,"['1. ', 'copyright@www.adrian.runceanu.ro \n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN.  \n \n• De fapt operatorul NOT IN este echivalent cu <> ALL. \n \n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL).  \nCurs 6 - BAZE DE DATE 62', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN.  \n \n• De fapt operatorul NOT IN este echivalent cu <> ALL. \n \n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL).  \nCurs 6 - BAZE DE DATE 62', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \n Operatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare. \n \nAstfel,  \n < ANY inseamna mai mic decat maximul  \n ANY inseamna mai mare decat minimul \n = ANY este echivalent cu IN \nCurs 6 - BAZE DE DATE 49', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \n Operatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare. \n \nAstfel,  \n < ANY inseamna mai mic decat maximul  \n ANY inseamna mai mare decat minimul \n = ANY este echivalent cu IN \nCurs 6 - BAZE DE DATE 49', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '7. ', 'CLAUZA WHERE \n Operatori de \ncomparare \n \n< Mai mic \n<= Mai mic sau egal \n> Mai mare \n>= Mai mare sau egal \n<> Diferit \n!= Diferit \n^= Diferit \nCurs - Baze de date 22', '\n', '8. ', 'CLAUZA WHERE \n Operatori de \ncomparare \n \n< Mai mic \n<= Mai mic sau egal \n> Mai mare \n>= Mai mare sau egal \n<> Diferit \n!= Diferit \n^= Diferit \nCurs - Baze de date 22', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \n• In cazul utilizarii operatorului NOT IN in interogarea \nprincipala trebuie avut grija sa se excluda valorile NULL \ndin raspunsurile subcererii. \n \nExemplu  \n \nGasiti angajatii care nu au subordonati.  \nCurs 6 - BAZE DE DATE 65', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \n• In cazul utilizarii operatorului NOT IN in interogarea \nprincipala trebuie avut grija sa se excluda valorile NULL \ndin raspunsurile subcererii. \n \nExemplu  \n \nGasiti angajatii care nu au subordonati.  \nCurs 6 - BAZE DE DATE 65', '\n']","Folosind informatiile din curs, îmi pare rău, dar contextul furnizat nu conține informații despre operatorul LIKE. 
",Operatorul LIKE este utilizat pentru a căuta modele în datele de tip caracter.,,,0.0,,0.021476912089159056,0.12121212121212122,0.0
21,Ce face funcția REPLACE?,"['1. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING) \nRezultatul obtinut - Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$.  \nCurs 5 - BAZE DE DATE 43', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING) \nRezultatul obtinut - Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$.  \nCurs 5 - BAZE DE DATE 43', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \nExemplu: \n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER. \n \nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename) \nFROM EMP;  \nCurs 4 - BAZE DE DATE 26 \n4.2.1. Funcţii pentru şiruri de caractere', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \nExemplu: \n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER. \n \nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename) \nFROM EMP;  \nCurs 4 - BAZE DE DATE 26 \n4.2.1. Funcţii pentru şiruri de caractere', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \n4.3.1. Clauza GROUP BY \nExemplul 8 - Salariul mediu pe fiecare department: \n \nSELECT deptno, AVG(sal) \nFROM EMP \nGROUP BY deptno;  \nCurs 5 - BAZE DE DATE 33', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \n4.3.1. Clauza GROUP BY \nExemplul 8 - Salariul mediu pe fiecare department: \n \nSELECT deptno, AVG(sal) \nFROM EMP \nGROUP BY deptno;  \nCurs 5 - BAZE DE DATE 33', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \n4.3. Funcții de grup \nExemplul 7 - Comisionul mediu în departamentul 30 \n(ignorând sau nu valorile nule):  \nSELECT AVG(comm), AVG(NVL(comm, 0)) \nFROM EMP \nWHERE deptno = 30; \nCurs 5 - BAZE DE DATE 29', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \n4.3. Funcții de grup \nExemplul 7 - Comisionul mediu în departamentul 30 \n(ignorând sau nu valorile nule):  \nSELECT AVG(comm), AVG(NVL(comm, 0)) \nFROM EMP \nWHERE deptno = 30; \nCurs 5 - BAZE DE DATE 29', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \n  O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null.  \n  Singurele funcţii care nu respectă această regulă \nsunt:  \n– CONCAT \n– DECODE \n– DUMP \n– NVL \n– REPLACE \nCurs 5 - BAZE DE DATE 12', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \n  O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null.  \n  Singurele funcţii care nu respectă această regulă \nsunt:  \n– CONCAT \n– DECODE \n– DUMP \n– NVL \n– REPLACE \nCurs 5 - BAZE DE DATE 12', '\n']","Folosind informatiile din curs, REPLACE este o funcție care nu returnează valoarea Null dacă are ca parametru valoarea Null. 
",Funcția REPLACE înlocuiește un text specificat dintr-un șir de caractere cu un alt text.,,,0.8128378614708662,,0.01914603069010251,0.05405405405405405,0.4
22,Care este scopul tabelei DUAL?,"['1. ', 'Tabela DUAL \nTabela generica DUAL se foloseste pentru a testa \nfunctii si pentru a evalua diferite expresii care nu \nnecesita preluarea datelor dintr-o tabela.  \nAceastă tabela este una specială, care conţine o \nsingură coloană numită ”DUMMY” şi o singură linie.  \nCurs 4 - BAZE DE DATE 4', '\n', '2. ', 'Tabela DUAL \nTabela generica DUAL se foloseste pentru a testa \nfunctii si pentru a evalua diferite expresii care nu \nnecesita preluarea datelor dintr-o tabela.  \nAceastă tabela este una specială, care conţine o \nsingură coloană numită ”DUMMY” şi o singură linie.  \nCurs 4 - BAZE DE DATE 4', '\n', '3. ', 'Tabela DUAL \nPutem folosi tabela DUAL si atunci cand vrem sa realizăm \ndiverse calcule. \n \nExemplu: \nSELECT (12/3 + 10) \nFROM dual; \nCurs 4 - BAZE DE DATE 5', '\n', '4. ', 'Tabela DUAL \nPutem folosi tabela DUAL si atunci cand vrem sa realizăm \ndiverse calcule. \n \nExemplu: \nSELECT (12/3 + 10) \nFROM dual; \nCurs 4 - BAZE DE DATE 5', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \nTabele EMP si DEPT \nCurs 5 - BAZE DE DATE 5 \nPentru exemplele din cursuri vom folosi tabela EMP: \n \nContinutul initial al tabelei EMP.', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \nTabele EMP si DEPT \nCurs 5 - BAZE DE DATE 5 \nPentru exemplele din cursuri vom folosi tabela EMP: \n \nContinutul initial al tabelei EMP.', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nTabele EMP si DEPT \nCurs 5 - BAZE DE DATE 6 \nStructura tabelei DEPT. \nContinutul initial al tabelei DEPT.', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nTabele EMP si DEPT \nCurs 5 - BAZE DE DATE 6 \nStructura tabelei DEPT. \nContinutul initial al tabelei DEPT.', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nExemple \nConsiderăm următoarele tabele: \n \n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS \n \n2. SPECIALIZARE având structura CODS, NUME, DOMENIU \n \n3. BURSA având structura TIP, PMIN, PMAX, SUMA \n10 Curs - Baze de date', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nExemple \nConsiderăm următoarele tabele: \n \n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS \n \n2. SPECIALIZARE având structura CODS, NUME, DOMENIU \n \n3. BURSA având structura TIP, PMIN, PMAX, SUMA \n10 Curs - Baze de date', '\n']","Folosind informatiile din curs, tabela generica DUAL se foloseste pentru a testa functii si pentru a evalua diferite expresii care nu necesita preluarea datelor dintr-o tabela. 
",Tabela DUAL este folosită pentru a testa funcții și expresii fără a necesita o tabelă de date.,,,0.9116329187260984,,0.06384875295507791,0.34782608695652173,1.0
23,Cum se folosește funcția MOD?,"['1. ', 'MOD(a, b) - dacă cei doi parametrii sunt numere întregi, atunci \nfuncţia returnează acelaşi rezultat ca şi funcţia REMAINDER, \nadică restul împărţirii lui a la b.  \nTeorema împărţirii cu rest este extinsă de această funcţie şi \npentru numerele reale.  \nAdică se ţine cont de relaţia a = b * cât + rest unde restul în \nmodul, trebuie să fie strict mai mic decât b \nExemple: \n \nCurs 4 - BAZE DE DATE 40 \n4.2.2. Funcţii de tip numeric', '\n', '2. ', 'MOD(a, b) - dacă cei doi parametrii sunt numere întregi, atunci \nfuncţia returnează acelaşi rezultat ca şi funcţia REMAINDER, \nadică restul împărţirii lui a la b.  \nTeorema împărţirii cu rest este extinsă de această funcţie şi \npentru numerele reale.  \nAdică se ţine cont de relaţia a = b * cât + rest unde restul în \nmodul, trebuie să fie strict mai mic decât b \nExemple: \n \nCurs 4 - BAZE DE DATE 40 \n4.2.2. Funcţii de tip numeric', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n Rezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze.  \nCurs - Baze de date 68', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n Rezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze.  \nCurs - Baze de date 68', '\n', '5. ', ""copyright@www.adrian.runceanu.ro \n\uf0d8Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime.  \n\uf0d8Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior.  \n \n\uf0d8Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea:  \nCurs 4 - BAZE DE DATE 28 \n4.2.1. Funcţii pentru şiruri de caractere"", '\n', '6. ', ""copyright@www.adrian.runceanu.ro \n\uf0d8Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime.  \n\uf0d8Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior.  \n \n\uf0d8Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea:  \nCurs 4 - BAZE DE DATE 28 \n4.2.1. Funcţii pentru şiruri de caractere"", '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \nFuncţiile se pot clasifica în două categorii: \n \n1. Funcţii referitoare la o singură înregistrare \n(single-row functions) \n \n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions) \nCurs 4 - BAZE DE DATE 8', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \nFuncţiile se pot clasifica în două categorii: \n \n1. Funcţii referitoare la o singură înregistrare \n(single-row functions) \n \n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions) \nCurs 4 - BAZE DE DATE 8', '\n']","Folosind informatiile din curs, funcția MOD(a, b) returnează restul împărțirii lui a la b. Dacă cei doi parametrii sunt numere întregi, funcția va funcționa la fel ca funcția REMAINDER.  Această funcție extinde teorema împărțirii cu rest și pentru numere reale, ținând cont de relația a = b * cât + rest, unde restul trebuie să fie întotdeauna strict mai mic decât b. 
",Funcția MOD returnează restul împărțirii a două numere.,,,0.812772986576834,,0.08562365224473284,0.23809523809523808,0.4
24,Ce face funcția TRUNC?,"['1. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING) \nRezultatul obtinut - Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$.  \nCurs 5 - BAZE DE DATE 43', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING) \nRezultatul obtinut - Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$.  \nCurs 5 - BAZE DE DATE 43', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10. \nCurs - Baze de date 41', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10. \nCurs - Baze de date 41', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \n4.3.1. Clauza GROUP BY \nRezultatul obtinut - Salariul total pe fiecare departament si pe \nfiecare functie, iar rezultatele ordonate după salariul mediu pe \ndepartament.  \n \nCurs 5 - BAZE DE DATE 39', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \n4.3.1. Clauza GROUP BY \nRezultatul obtinut - Salariul total pe fiecare departament si pe \nfiecare functie, iar rezultatele ordonate după salariul mediu pe \ndepartament.  \n \nCurs 5 - BAZE DE DATE 39', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \n4.3.3. Imbricarea functiilor de grup \n Funcţiile de grup pot fi imbricate cu o adâncime de 2. \nRezultatul obtinut - Salariul mediu maxim.  \nCurs 5 - BAZE DE DATE 52', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \n4.3.3. Imbricarea functiilor de grup \n Funcţiile de grup pot fi imbricate cu o adâncime de 2. \nRezultatul obtinut - Salariul mediu maxim.  \nCurs 5 - BAZE DE DATE 52', '\n', '9. ', ""copyright@www.adrian.runceanu.ro \n\uf0d8Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime.  \n\uf0d8Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior.  \n \n\uf0d8Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea:  \nCurs 4 - BAZE DE DATE 28 \n4.2.1. Funcţii pentru şiruri de caractere"", '\n', '10. ', ""copyright@www.adrian.runceanu.ro \n\uf0d8Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime.  \n\uf0d8Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior.  \n \n\uf0d8Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea:  \nCurs 4 - BAZE DE DATE 28 \n4.2.1. Funcţii pentru şiruri de caractere"", '\n']","Folosind informatiile din curs, îmi pare rău, dar informațiile furnizate nu oferă detalii despre funcția TRUNC. 
",Funcția TRUNC elimină cifrele zecimale ale unui număr fără a-l rotunji.,,,0.0,,0.021476912089159056,0.17647058823529413,0.0
25,Ce este o funcție condițională?,"['1. ', 'copyright@www.adrian.runceanu.ro \n4.2.5. Funcţii generale \n\uf0d8Expresia conditionala CASE foloseste cuvinte \ncheie WHEN, THEN, ELSE si END. Ca si regula \ngenerala orice expresie care poate fi scrisa cu \najutorul functiei DECODE, poate fi transcrisa si \ncu ajutorul expresiei conditionale CASE. \n \n\uf0d8Folosind expresia conditionala CASE obtinem \nun cod mai lung, dar mai usor de inteles si de \ndepanat.  \nCurs 4 - BAZE DE DATE 111', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \n4.2.5. Funcţii generale \n\uf0d8Expresia conditionala CASE foloseste cuvinte \ncheie WHEN, THEN, ELSE si END. Ca si regula \ngenerala orice expresie care poate fi scrisa cu \najutorul functiei DECODE, poate fi transcrisa si \ncu ajutorul expresiei conditionale CASE. \n \n\uf0d8Folosind expresia conditionala CASE obtinem \nun cod mai lung, dar mai usor de inteles si de \ndepanat.  \nCurs 4 - BAZE DE DATE 111', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \n4.2.5. Funcţii generale \nExpresia conditionala CASE are urmatorul \nformat: \nCASE expresie \n WHEN valoare1_1 THEN valoare1_2 \n WHEN valoare2_1 THEN valoare2_2 \n … \n WHEN valoaren_1 THEN valoaren_2 \n ELSE valoare \nEND \n \n \nCurs 4 - BAZE DE DATE 110', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \n4.2.5. Funcţii generale \nExpresia conditionala CASE are urmatorul \nformat: \nCASE expresie \n WHEN valoare1_1 THEN valoare1_2 \n WHEN valoare2_1 THEN valoare2_2 \n … \n WHEN valoaren_1 THEN valoaren_2 \n ELSE valoare \nEND \n \n \nCurs 4 - BAZE DE DATE 110', '\n', '5. ', 'CLAUZA WHERE \n Operatori de \ncomparare \n \n< Mai mic \n<= Mai mic sau egal \n> Mai mare \n>= Mai mare sau egal \n<> Diferit \n!= Diferit \n^= Diferit \nCurs - Baze de date 22', '\n', '6. ', 'CLAUZA WHERE \n Operatori de \ncomparare \n \n< Mai mic \n<= Mai mic sau egal \n> Mai mare \n>= Mai mare sau egal \n<> Diferit \n!= Diferit \n^= Diferit \nCurs - Baze de date 22', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n  Clauza WHERE poate compara valori în coloană, \nvalori literale, expresii aritmetice sau funcţii. \nWHERE - restricţionează cererea la rândurile care \nîndeplinesc o condiţie; \n \nCondiţie este alcătuită din trei elemente: \n1. Un nume de coloană  \n2. Un operator de comparaţie  \n3. Un nume de coloană, constantă sau listă de valori \nCurs - Baze de date 31', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n  Clauza WHERE poate compara valori în coloană, \nvalori literale, expresii aritmetice sau funcţii. \nWHERE - restricţionează cererea la rândurile care \nîndeplinesc o condiţie; \n \nCondiţie este alcătuită din trei elemente: \n1. Un nume de coloană  \n2. Un operator de comparaţie  \n3. Un nume de coloană, constantă sau listă de valori \nCurs - Baze de date 31', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \n4.2.5. Funcţii generale \nFuncţii generale:  \n1. NVL  \n2. NVL2  \n3. NULLIF \n4. COALESCE \nAceste funcţii au ca argumente date de diferite \ntipuri şi returnează date de tipuri diferite. \nAceste funcţii precizează cum sunt prelucrate \nvalorile de tip NULL. \nCurs 4 - BAZE DE DATE 94', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \n4.2.5. Funcţii generale \nFuncţii generale:  \n1. NVL  \n2. NVL2  \n3. NULLIF \n4. COALESCE \nAceste funcţii au ca argumente date de diferite \ntipuri şi returnează date de tipuri diferite. \nAceste funcţii precizează cum sunt prelucrate \nvalorile de tip NULL. \nCurs 4 - BAZE DE DATE 94', '\n']","Folosind informatiile din curs, o funcție condițională este reprezentată de expresia condițională CASE. Aceasta folosește cuvintele cheie WHEN, THEN, ELSE și END și poate fi folosită pentru a transcrie orice expresie care poate fi scrisă cu ajutorul funcției DECODE. Expresia condițională CASE are avantajul că face codul mai ușor de înțeles și depanat, chiar dacă îl face mai lung. Formatul expresiei condiționale CASE este:

```sql
CASE expresie
    WHEN valoare1_1 THEN valoare1_2
    WHEN valoare2_1 THEN valoare2_2
    …
    WHEN valoaren_1 THEN valoaren_2
    ELSE valoare
END
```
",Funcțiile condiționale returnează valori diferite în funcție de anumite condiții.,,,0.8069195780443481,,0.03377156414337854,0.10810810810810811,0.0
26,Ce face funcția NVL?,"['1. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING) \nRezultatul obtinut - Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$.  \nCurs 5 - BAZE DE DATE 43', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING) \nRezultatul obtinut - Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$.  \nCurs 5 - BAZE DE DATE 43', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \n4.3.1. Clauza GROUP BY \nRezultatul obtinut - Salariul total pe fiecare departament si pe \nfiecare functie, iar rezultatele ordonate după salariul mediu pe \ndepartament.  \n \nCurs 5 - BAZE DE DATE 39', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \n4.3.1. Clauza GROUP BY \nRezultatul obtinut - Salariul total pe fiecare departament si pe \nfiecare functie, iar rezultatele ordonate după salariul mediu pe \ndepartament.  \n \nCurs 5 - BAZE DE DATE 39', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10. \nCurs - Baze de date 41', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10. \nCurs - Baze de date 41', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000). \nCurs - Baze de date 49', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000). \nCurs - Baze de date 49', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING) \nRezultatul obtinut - Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$.  \n \nCurs 5 - BAZE DE DATE 45', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING) \nRezultatul obtinut - Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$.  \n \nCurs 5 - BAZE DE DATE 45', '\n']","Folosind informatiile din curs, îmi pare rău, dar nu pot răspunde la întrebarea ta. Informațiile furnizate se referă la clauzele WHERE și HAVING din limbajul SQL, dar nu menționează funcția NVL. 
",Funcția NVL înlocuiește valorile NULL cu o valoare specificată.,,0.0,0.0,,0.0,0.1276595744680851,0.0
27,Cum funcționează operatorul ANY?,"['1. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \nFuncţiile se pot clasifica în două categorii: \n \n1. Funcţii referitoare la o singură înregistrare \n(single-row functions) \n \n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions) \nCurs 4 - BAZE DE DATE 8', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \nFuncţii \nFuncţiile se pot clasifica în două categorii: \n \n1. Funcţii referitoare la o singură înregistrare \n(single-row functions) \n \n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions) \nCurs 4 - BAZE DE DATE 8', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN.  \n \n• De fapt operatorul NOT IN este echivalent cu <> ALL. \n \n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL).  \nCurs 6 - BAZE DE DATE 62', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN.  \n \n• De fapt operatorul NOT IN este echivalent cu <> ALL. \n \n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL).  \nCurs 6 - BAZE DE DATE 62', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nOrdinea de execuţie Operator \n1. Operatorii aritmetici \n2. Operatorii de concatenare \n3. Conditiile de comparare \n4. IS [NOT] NULL, LIKE, [NOT] IN \n5. [NOT] BETWEEN \n6. Operatorul logic NOT \n7. Operatorul logic AND \n8. Operatorul logic OR \n D. Prioritatea de execuţie  \nCurs - Baze de date 64', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nOrdinea de execuţie Operator \n1. Operatorii aritmetici \n2. Operatorii de concatenare \n3. Conditiile de comparare \n4. IS [NOT] NULL, LIKE, [NOT] IN \n5. [NOT] BETWEEN \n6. Operatorul logic NOT \n7. Operatorul logic AND \n8. Operatorul logic OR \n D. Prioritatea de execuţie  \nCurs - Baze de date 64', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n  Clauza WHERE poate compara valori în coloană, \nvalori literale, expresii aritmetice sau funcţii. \nWHERE - restricţionează cererea la rândurile care \nîndeplinesc o condiţie; \n \nCondiţie este alcătuită din trei elemente: \n1. Un nume de coloană  \n2. Un operator de comparaţie  \n3. Un nume de coloană, constantă sau listă de valori \nCurs - Baze de date 31', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n  Clauza WHERE poate compara valori în coloană, \nvalori literale, expresii aritmetice sau funcţii. \nWHERE - restricţionează cererea la rândurile care \nîndeplinesc o condiţie; \n \nCondiţie este alcătuită din trei elemente: \n1. Un nume de coloană  \n2. Un operator de comparaţie  \n3. Un nume de coloană, constantă sau listă de valori \nCurs - Baze de date 31', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n 4. Conditia IS NULL  \n \n  Pentru a verifica valorile de tip NULL există condiţia IS \nNULL sau negarea acesteia IS NOT NULL.  \n  O valoare nulă este o valoare care este sau incorectă, sau \nnecunoscută, sau inaplicabilă de aceea nu poate fi testată cu \n""="".  \n  O valoare nulă nu este la fel cu ""zero"" care este un \nnumăr. \n  Dacă valoarea NULL este utilizată într-o comparaţie, \natunci operatorul de comparaţie trebuie să fie IS NULL sau IS \nNOT NULL altfel rezultatul este întotdeauna FALSE.  \nCurs - Baze de date 60', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n 4. Conditia IS NULL  \n \n  Pentru a verifica valorile de tip NULL există condiţia IS \nNULL sau negarea acesteia IS NOT NULL.  \n  O valoare nulă este o valoare care este sau incorectă, sau \nnecunoscută, sau inaplicabilă de aceea nu poate fi testată cu \n""="".  \n  O valoare nulă nu este la fel cu ""zero"" care este un \nnumăr. \n  Dacă valoarea NULL este utilizată într-o comparaţie, \natunci operatorul de comparaţie trebuie să fie IS NULL sau IS \nNOT NULL altfel rezultatul este întotdeauna FALSE.  \nCurs - Baze de date 60', '\n']","Folosind informatiile din curs, îmi pare rău, dar informațiile furnizate nu menționează operatorul ""ANY"" și funcționalitatea sa. Prin urmare, nu pot oferi un răspuns la întrebarea ta. 
",Operatorul ANY compară fiecare valoare dintr-un set returnat de o subinterogare.,,,0.0,,0.018160849415439308,0.13636363636363635,0.0
28,Ce face operatorul ALL?,"['1. ', 'copyright@www.adrian.runceanu.ro \n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN.  \n \n• De fapt operatorul NOT IN este echivalent cu <> ALL. \n \n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL).  \nCurs 6 - BAZE DE DATE 62', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN.  \n \n• De fapt operatorul NOT IN este echivalent cu <> ALL. \n \n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL).  \nCurs 6 - BAZE DE DATE 62', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \n Operatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare. \n \nAstfel,  \n < ANY inseamna mai mic decat maximul  \n ANY inseamna mai mare decat minimul \n = ANY este echivalent cu IN \nCurs 6 - BAZE DE DATE 49', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \n Operatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare. \n \nAstfel,  \n < ANY inseamna mai mic decat maximul  \n ANY inseamna mai mare decat minimul \n = ANY este echivalent cu IN \nCurs 6 - BAZE DE DATE 49', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listează toţi angajaţii care nu au \ncomision.  \nCurs - Baze de date 62', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listează toţi angajaţii care nu au \ncomision.  \nCurs - Baze de date 62', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \n4.3.1. Clauza GROUP BY \nRezultatul obtinut - Salariul total pe fiecare departament si pe \nfiecare functie, iar rezultatele ordonate după salariul mediu pe \ndepartament.  \n \nCurs 5 - BAZE DE DATE 39', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \n4.3.1. Clauza GROUP BY \nRezultatul obtinut - Salariul total pe fiecare departament si pe \nfiecare functie, iar rezultatele ordonate după salariul mediu pe \ndepartament.  \n \nCurs 5 - BAZE DE DATE 39', '\n']","Folosind informatiile din curs, operatorul = ANY este echivalent cu operatorul IN. De fapt, operatorul NOT IN este echivalent cu <> ALL. Returnarea de valori NULL de catre subinterogare nu prezinta nici o problema in cazul operatorului IN in interogarea principala (in echivalent cu = ALL).  
",Operatorul ALL compară toate valorile returnate de o subinterogare cu o expresie specificată.,,,0.757927293547444,,0.028603449943861582,0.17857142857142855,0.0
29,Cum se compară valorile NULL în SQL?,"['1. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n 4. Conditia IS NULL  \n \n  Pentru a verifica valorile de tip NULL există condiţia IS \nNULL sau negarea acesteia IS NOT NULL.  \n  O valoare nulă este o valoare care este sau incorectă, sau \nnecunoscută, sau inaplicabilă de aceea nu poate fi testată cu \n""="".  \n  O valoare nulă nu este la fel cu ""zero"" care este un \nnumăr. \n  Dacă valoarea NULL este utilizată într-o comparaţie, \natunci operatorul de comparaţie trebuie să fie IS NULL sau IS \nNOT NULL altfel rezultatul este întotdeauna FALSE.  \nCurs - Baze de date 60', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n 4. Conditia IS NULL  \n \n  Pentru a verifica valorile de tip NULL există condiţia IS \nNULL sau negarea acesteia IS NOT NULL.  \n  O valoare nulă este o valoare care este sau incorectă, sau \nnecunoscută, sau inaplicabilă de aceea nu poate fi testată cu \n""="".  \n  O valoare nulă nu este la fel cu ""zero"" care este un \nnumăr. \n  Dacă valoarea NULL este utilizată într-o comparaţie, \natunci operatorul de comparaţie trebuie să fie IS NULL sau IS \nNOT NULL altfel rezultatul este întotdeauna FALSE.  \nCurs - Baze de date 60', '\n', '3. ', 'Clauza WHERE \nC. Condiţii de comparare  \n  În SQL sunt 4 operatori care pot fi folosiţi pentru \ntoate tipurile de date:  \nOperator Semnificaţie \nBETWEEN...AND...  între 2 valori (inclusiv) \nIN (lista) compară cu o listă de valori \nLIKE compară cu un model de tip caracter \nIS NULL este o valoare nulă \nCurs - Baze de date 43', '\n', '4. ', 'Clauza WHERE \nC. Condiţii de comparare  \n  În SQL sunt 4 operatori care pot fi folosiţi pentru \ntoate tipurile de date:  \nOperator Semnificaţie \nBETWEEN...AND...  între 2 valori (inclusiv) \nIN (lista) compară cu o listă de valori \nLIKE compară cu un model de tip caracter \nIS NULL este o valoare nulă \nCurs - Baze de date 43', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \n6.2. MULTIPLE ROW SUBQUERIES \nVALORI NULL \n \n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci: \n \n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null. \n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic. \nCurs 6 - BAZE DE DATE 35', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \n6.2. MULTIPLE ROW SUBQUERIES \nVALORI NULL \n \n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci: \n \n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null. \n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic. \nCurs 6 - BAZE DE DATE 35', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \n4.2.5. Funcţii generale \n3. Funcţia NULLIF cu formatul: \n \nNULLIF(expresie1, expresie2) \n \nReturneaza NULL, daca cele doua expresii sunt \negale. \nDaca cele doua espresii sunt diferite (valorile \nlor), atunci returneaza valoarea primei expresii \n– expresie1. \nCurs 4 - BAZE DE DATE 100', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \n4.2.5. Funcţii generale \n3. Funcţia NULLIF cu formatul: \n \nNULLIF(expresie1, expresie2) \n \nReturneaza NULL, daca cele doua expresii sunt \negale. \nDaca cele doua espresii sunt diferite (valorile \nlor), atunci returneaza valoarea primei expresii \n– expresie1. \nCurs 4 - BAZE DE DATE 100', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nCLAUZA WHERE \n \nIN ignora valorile nule din lista: \n \nExemplu 16 (pentru a lua in considerare valorile \nnule): \n \nSELECT NUME, AN, GRUPA, INDRUMATOR \nFROM STUDENT \nWHERE INDRUMATOR IN (NULL, 1001, 1234); \nCurs - Baze de date 27', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nCLAUZA WHERE \n \nIN ignora valorile nule din lista: \n \nExemplu 16 (pentru a lua in considerare valorile \nnule): \n \nSELECT NUME, AN, GRUPA, INDRUMATOR \nFROM STUDENT \nWHERE INDRUMATOR IN (NULL, 1001, 1234); \nCurs - Baze de date 27', '\n']","Folosind informatiile din curs, valorile NULL in SQL nu se compara cu operatori de comparatie traditionali precum ""="" sau ""!="". Pentru a verifica valorile NULL, se folosesc operatorii ""IS NULL"" si ""IS NOT NULL"". O valoare NULL nu este echivalenta cu zero sau cu un sir gol, ci reprezinta o valoare necunoscuta sau inaplicabila.
","Valorile NULL nu pot fi comparate cu operatorii obișnuiți, ci se utilizează IS NULL și IS NOT NULL.",,,0.9032983206958919,,0.021601524349994395,0.2777777777777778,0.67
30,Ce este o subinterogare multi-row?,"['1. ', 'copyright@www.adrian.runceanu.ro \n6.1. SINGLE ROW SUBQUERIES \nSubcereri din mai multe tabele \n \n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere).  \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare.  \n  De asemenea se pot face interogări din \ntabele diferite. \nCurs 6 - BAZE DE DATE 13', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \n6.1. SINGLE ROW SUBQUERIES \nSubcereri din mai multe tabele \n \n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere).  \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare.  \n  De asemenea se pot face interogări din \ntabele diferite. \nCurs 6 - BAZE DE DATE 13', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \n6.2. MULTIPLE ROW SUBQUERIES \n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query). \nCurs 6 - BAZE DE DATE 31', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \n6.2. MULTIPLE ROW SUBQUERIES \n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query). \nCurs 6 - BAZE DE DATE 31', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \n6.2. MULTIPLE ROW SUBQUERIES \n  Sunt acele subinterogări care dau ca rezultat \nmai multe valori. \n \nFolosesc operatorii multiple row:  \n1. IN \n2. ANY \n3. ALL \n  Operatorul NOT poate fi folosit în \ncombinaţie cu oricare dintre aceştia. \nCurs 6 - BAZE DE DATE 29', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \n6.2. MULTIPLE ROW SUBQUERIES \n  Sunt acele subinterogări care dau ca rezultat \nmai multe valori. \n \nFolosesc operatorii multiple row:  \n1. IN \n2. ANY \n3. ALL \n  Operatorul NOT poate fi folosit în \ncombinaţie cu oricare dintre aceştia. \nCurs 6 - BAZE DE DATE 29', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \n6. SUBQUERIES (Subinterogari) \nSunt două tipuri de subinterogări(subqueries): \n \n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie. \n \n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii. \nCurs 6 - BAZE DE DATE 9', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \n6. SUBQUERIES (Subinterogari) \nSunt două tipuri de subinterogări(subqueries): \n \n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie. \n \n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii. \nCurs 6 - BAZE DE DATE 9', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \n6.1. SINGLE ROW SUBQUERIES \nSe pot folosi funcţiile de grup în subinterogări.  \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie. \n \nCurs 6 - BAZE DE DATE 20', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \n6.1. SINGLE ROW SUBQUERIES \nSe pot folosi funcţiile de grup în subinterogări.  \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie. \n \nCurs 6 - BAZE DE DATE 20', '\n']","Folosind informatiile din curs, o subinterogare multi-row este o subinterogare care returneaza mai multe valori ca rezultat. Aceste subinterogari folosesc operatori specifici, cum ar fi: IN, ANY, ALL. De asemenea, operatorul NOT poate fi utilizat in combinatie cu oricare dintre acestia. 
","O subinterogare multi-row returnează mai multe valori și folosește operatori precum IN, ANY și ALL.",,,0.8328498965388946,,0.10521495173810226,0.37288135593220334,0.8
31,Ce este operatorul EXISTS?,"['1. ', 'copyright@www.adrian.runceanu.ro \n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN.  \n \n• De fapt operatorul NOT IN este echivalent cu <> ALL. \n \n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL).  \nCurs 6 - BAZE DE DATE 62', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN.  \n \n• De fapt operatorul NOT IN este echivalent cu <> ALL. \n \n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL).  \nCurs 6 - BAZE DE DATE 62', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \n Operatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare. \n \nAstfel,  \n < ANY inseamna mai mic decat maximul  \n ANY inseamna mai mare decat minimul \n = ANY este echivalent cu IN \nCurs 6 - BAZE DE DATE 49', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \n Operatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare. \n \nAstfel,  \n < ANY inseamna mai mic decat maximul  \n ANY inseamna mai mare decat minimul \n = ANY este echivalent cu IN \nCurs 6 - BAZE DE DATE 49', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listează toţi angajaţii care au \nnumele de 4 caractere. \nCurs - Baze de date 56', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listează toţi angajaţii care au \nnumele de 4 caractere. \nCurs - Baze de date 56', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listează toţi angajaţii care nu au \ncomision.  \nCurs - Baze de date 62', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listează toţi angajaţii care nu au \ncomision.  \nCurs - Baze de date 62', '\n']","Folosind informatiile din curs, nu pot raspunde la intrebarea ta. In text se discuta despre operatorii ANY, SOME, NOT IN si IN, echivalentele lor si cum functioneaza in contextul subcererilor, dar nu se ofera informatii despre operatorul EXISTS. 
",Operatorul EXISTS verifică dacă o subinterogare returnează cel puțin un rezultat.,,,0.0,,0.0,0.08,0.0
32,Cum se utilizează funcția ROUND?,"['1. ', 'ROUND(a, b) - rotunjeşte valoarea lui a la un număr de cifre \nprecizat prin parametrul b.  \nDacă al doilea parametru este un număr pozitiv, atunci se vor \npăstra din a primele b zecimale, ultima dintre aceste cifre fiind \nrotunjită, în funcţie de următoarea zecimală.  \nAl doilea argument poate fi o valoare negativă, rotunjirea \nfăcându-se la stânga punctului zecimal.  \nCifra a |b|+1 din faţa punctului zecimal (numărând de la punctul \nzecimal spre stânga începând cu 1) va fi rotunjită în funcţie \ncifra aflată imediat la dreapta ei.  \nPrimele |b| cifre din stânga punctului zecimal vor deveni 0. Cel \nde al doilea argument este opţional, în cazul în care nu se \nprecizează, este considerată implicit valoarea 0. \nCurs 4 - BAZE DE DATE 43 \n4.2.2. Funcţii de tip numeric', '\n', '2. ', 'ROUND(a, b) - rotunjeşte valoarea lui a la un număr de cifre \nprecizat prin parametrul b.  \nDacă al doilea parametru este un număr pozitiv, atunci se vor \npăstra din a primele b zecimale, ultima dintre aceste cifre fiind \nrotunjită, în funcţie de următoarea zecimală.  \nAl doilea argument poate fi o valoare negativă, rotunjirea \nfăcându-se la stânga punctului zecimal.  \nCifra a |b|+1 din faţa punctului zecimal (numărând de la punctul \nzecimal spre stânga începând cu 1) va fi rotunjită în funcţie \ncifra aflată imediat la dreapta ei.  \nPrimele |b| cifre din stânga punctului zecimal vor deveni 0. Cel \nde al doilea argument este opţional, în cazul în care nu se \nprecizează, este considerată implicit valoarea 0. \nCurs 4 - BAZE DE DATE 43 \n4.2.2. Funcţii de tip numeric', '\n', '3. ', ""copyright@www.adrian.runceanu.ro \n\uf0d8Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime.  \n\uf0d8Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior.  \n \n\uf0d8Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea:  \nCurs 4 - BAZE DE DATE 28 \n4.2.1. Funcţii pentru şiruri de caractere"", '\n', '4. ', ""copyright@www.adrian.runceanu.ro \n\uf0d8Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime.  \n\uf0d8Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior.  \n \n\uf0d8Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea:  \nCurs 4 - BAZE DE DATE 28 \n4.2.1. Funcţii pentru şiruri de caractere"", '\n', '5. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n Rezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze.  \nCurs - Baze de date 68', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n Rezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze.  \nCurs - Baze de date 68', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n1. BETWEEN...AND...  \n \n  Condiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie). \n  Intervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată \ntrebuie să fie limita inferioară.  \nCurs - Baze de date 44', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n1. BETWEEN...AND...  \n \n  Condiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie). \n  Intervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată \ntrebuie să fie limita inferioară.  \nCurs - Baze de date 44', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare.  \n \nAstfel: \n \n> ALL inseamna mai mare decat maximul \n \n< ALL inseamna mai mic decat minimul \nCurs 6 - BAZE DE DATE 52', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare.  \n \nAstfel: \n \n> ALL inseamna mai mare decat maximul \n \n< ALL inseamna mai mic decat minimul \nCurs 6 - BAZE DE DATE 52', '\n']","Folosind informatiile din curs, funcția ROUND(a, b) rotunjește valoarea lui ""a"" la un număr de cifre precizat prin parametrul ""b"". 

* Dacă ""b"" este pozitiv, se păstrează primele ""b"" zecimale din ""a"", rotunjind ultima cifră în funcție de următoarea zecimală. 
* Dacă ""b"" este negativ, rotunjirea se face la stânga punctului zecimal. Cifra a |b|+1 din fața punctului zecimal (numărând de la punctul zecimal spre stânga) va fi rotunjită în funcție de cifra aflată imediat la dreapta ei. Primele |b| cifre din stânga punctului zecimal devin 0. 

Parametrul ""b"" este opțional. Dacă lipsește, se consideră implicit valoarea 0.
",Funcția ROUND rotunjește un număr la un număr specificat de zecimale.,,,0.8773296824868063,,0.05695928476566283,0.1875,0.25
33,Ce este funcția SYSDATE?,"['1. ', ""copyright@www.adrian.runceanu.ro \n\uf0d8Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime.  \n\uf0d8Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior.  \n \n\uf0d8Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea:  \nCurs 4 - BAZE DE DATE 28 \n4.2.1. Funcţii pentru şiruri de caractere"", '\n', '2. ', ""copyright@www.adrian.runceanu.ro \n\uf0d8Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime.  \n\uf0d8Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior.  \n \n\uf0d8Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea:  \nCurs 4 - BAZE DE DATE 28 \n4.2.1. Funcţii pentru şiruri de caractere"", '\n', '3. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n Rezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze.  \nCurs - Baze de date 68', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n Rezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze.  \nCurs - Baze de date 68', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \nLISTA SELECT \nNume de coloane sau * \n \nExemplu 1: \nSELECT NUME, DOMENIU \nFROM SPECIALIZARE; \n \nExemplu 2: \nSELECT * \nFROM STUDENT; \nCurs - Baze de date 13', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \nLISTA SELECT \nNume de coloane sau * \n \nExemplu 1: \nSELECT NUME, DOMENIU \nFROM SPECIALIZARE; \n \nExemplu 2: \nSELECT * \nFROM STUDENT; \nCurs - Baze de date 13', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10. \nCurs - Baze de date 41', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10. \nCurs - Baze de date 41', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n']","Folosind informatiile din curs, îmi pare rău, dar nu pot răspunde la întrebarea ta. Informațiile furnizate în contextul intern se concentrează pe funcțiile pentru șiruri de caractere și pe clauzele WHERE și SELECT din interogările SQL. Nu există informații despre funcția SYSDATE. 
",Funcția SYSDATE returnează data și ora curente ale sistemului.,,,0.0,,0.0,0.10169491525423728,0.0
34,Cum funcționează clauza ORDER BY DESC?,"['1. ', 'copyright@www.adrian.runceanu.ro \nFuncţii referitoare la o singură înregistrare \nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în: \n \na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule, \netc.  \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile)  \n \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare \nCurs 4 - BAZE DE DATE 14', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \nFuncţii referitoare la o singură înregistrare \nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în: \n \na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule, \netc.  \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile)  \n \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare \nCurs 4 - BAZE DE DATE 14', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \nClauza ORDER BY \n\uf0d8În clauza ORDER BY se pot folosi coloane care nu sunt \nconţinute în SELECT. \n  \nExemplu:  \n  Listaţi toţi angajaţii ordonându-i după salariu (în \nordine crescătoare). \n \nSELECT ename, job \nFROM EMP \nORDER BY sal;   \nCurs - Baze de date 80', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \nClauza ORDER BY \n\uf0d8În clauza ORDER BY se pot folosi coloane care nu sunt \nconţinute în SELECT. \n  \nExemplu:  \n  Listaţi toţi angajaţii ordonându-i după salariu (în \nordine crescătoare). \n \nSELECT ename, job \nFROM EMP \nORDER BY sal;   \nCurs - Baze de date 80', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \nEFECT \n  Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat. \n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY. \n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela. \nCurs - Baze de date 6', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \nEFECT \n  Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat. \n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY. \n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela. \nCurs - Baze de date 6', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nClauza ORDER BY \nunde: \nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile \nASC - Ordonează rândurile crescător \nDESC - Ordonează rândurile descrescător  \nSintaxa:  \nSELECT coloana \nFROM tabela \n[WHERE conditie]  \n[ORDER BY {coloana, expresie} \n[ASC/DESC]]; \nCurs - Baze de date 71', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nClauza ORDER BY \nunde: \nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile \nASC - Ordonează rândurile crescător \nDESC - Ordonează rândurile descrescător  \nSintaxa:  \nSELECT coloana \nFROM tabela \n[WHERE conditie]  \n[ORDER BY {coloana, expresie} \n[ASC/DESC]]; \nCurs - Baze de date 71', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nSINTAXA \nSELECT [DISTINCT] lista_de_expresii \n \nFROM nume_tabela \n \nWHERE conditie_linie  -- clauza optionala \n \nORDER BY criterii_sortare_rezultat; -- clauza \noptionala \nCurs - Baze de date 4', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nSINTAXA \nSELECT [DISTINCT] lista_de_expresii \n \nFROM nume_tabela \n \nWHERE conditie_linie  -- clauza optionala \n \nORDER BY criterii_sortare_rezultat; -- clauza \noptionala \nCurs - Baze de date 4', '\n']","Folosind informatiile din curs,  clauza ORDER BY specifică ordinea în care sunt ordonate rândurile. ORDER BY DESC ordonează rândurile descrescător. Implicit, ORDER BY va sorta crescător (ASC).
 
 Sintaxa este:
 
 ```sql
 SELECT coloana
 FROM tabela
 [WHERE conditie]
 [ORDER BY {coloana, expresie} [ASC/DESC]];
 ```
 
 De exemplu, pentru a lista toți angajații ordonându-i după salariu în ordine descrescătoare, am folosi:
 
 ```sql
 SELECT ename, job
 FROM EMP
 ORDER BY sal DESC;
 ```
 
 Serverul va sorta rezultatul înainte de a-l trimite, iar în cazul în care ORDER BY lipsește, liniile din rezultat vor fi într-o ordine independentă de conținutul lor sau de ordinea în care ele au fost adăugate în tabelă. 
",ORDER BY DESC sortează rezultatele în ordine descrescătoare.,,,0.8500720965314654,,0.05816635421147513,0.10937499999999999,0.25
35,Cum se extrage anul dintr-o dată în SQL?,"['1. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră \n 4.2.4. Funcţii de conversie dintr-un tip în altul \n 4.2.5. Funcţii generale \n  4.2.6. Funcţii condiţionale \nCurs 4 - BAZE DE DATE 32', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră \n 4.2.4. Funcţii de conversie dintr-un tip în altul \n 4.2.5. Funcţii generale \n  4.2.6. Funcţii condiţionale \nCurs 4 - BAZE DE DATE 32', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră \n 4.2.4. Funcţii de conversie dintr-un tip în altul \n 4.2.5. Funcţii generale \n  4.2.6. Funcţii condiţionale \nCurs 4 - BAZE DE DATE 54', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră \n 4.2.4. Funcţii de conversie dintr-un tip în altul \n 4.2.5. Funcţii generale \n  4.2.6. Funcţii condiţionale \nCurs 4 - BAZE DE DATE 54', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră \n 4.2.4. Funcţii de conversie dintr-un tip în altul \n 4.2.5. Funcţii generale \n  4.2.6. Funcţii condiţionale \nCurs 4 - BAZE DE DATE 46', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră \n 4.2.4. Funcţii de conversie dintr-un tip în altul \n 4.2.5. Funcţii generale \n  4.2.6. Funcţii condiţionale \nCurs 4 - BAZE DE DATE 46', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră \n 4.2.4. Funcţii de conversie dintr-un tip în altul \n 4.2.5. Funcţii generale \n 4.2.6. Funcţii condiţionale \n \nCurs 4 - BAZE DE DATE 105', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră \n 4.2.4. Funcţii de conversie dintr-un tip în altul \n 4.2.5. Funcţii generale \n 4.2.6. Funcţii condiţionale \n \nCurs 4 - BAZE DE DATE 105', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră \n 4.2.4. Funcţii de conversie dintr-un tip în altul \n 4.2.5. Funcţii generale \n  4.2.6. Funcţii condiţionale \nCurs 4 - BAZE DE DATE 15', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră \n 4.2.4. Funcţii de conversie dintr-un tip în altul \n 4.2.5. Funcţii generale \n  4.2.6. Funcţii condiţionale \nCurs 4 - BAZE DE DATE 15', '\n']","Folosind informatiile din curs, in cadrul capitolului ""Limbajul SQL - Interogări SELECT pe o singură tabelă (partea II)"", sectiunea 4.2 abordeaza ""Funcţii referitoare la o singură înregistrare"".  Aceasta se divide in diverse subcategorii de functii, printre care se numara si ""4.2.3. Funcţii de tip dată calendaristică şi oră"".  Din pacate, nu se specifica o functie concreta pentru extragerea anului dintr-o data in SQL. 
",Se folosește funcția EXTRACT(YEAR FROM data).,,,0.0,,0.012557690800697192,0.07692307692307691,0.0
36,Cum se obține suma valorilor unei coloane?,"['1. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n1. BETWEEN...AND...  \n \n  Condiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie). \n  Intervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată \ntrebuie să fie limita inferioară.  \nCurs - Baze de date 44', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n1. BETWEEN...AND...  \n \n  Condiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie). \n  Intervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată \ntrebuie să fie limita inferioară.  \nCurs - Baze de date 44', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \n Operatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare. \n \nAstfel,  \n < ANY inseamna mai mic decat maximul  \n ANY inseamna mai mare decat minimul \n = ANY este echivalent cu IN \nCurs 6 - BAZE DE DATE 49', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \n Operatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare. \n \nAstfel,  \n < ANY inseamna mai mic decat maximul  \n ANY inseamna mai mare decat minimul \n = ANY este echivalent cu IN \nCurs 6 - BAZE DE DATE 49', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n 4. Conditia IS NULL  \n \n  Pentru a verifica valorile de tip NULL există condiţia IS \nNULL sau negarea acesteia IS NOT NULL.  \n  O valoare nulă este o valoare care este sau incorectă, sau \nnecunoscută, sau inaplicabilă de aceea nu poate fi testată cu \n""="".  \n  O valoare nulă nu este la fel cu ""zero"" care este un \nnumăr. \n  Dacă valoarea NULL este utilizată într-o comparaţie, \natunci operatorul de comparaţie trebuie să fie IS NULL sau IS \nNOT NULL altfel rezultatul este întotdeauna FALSE.  \nCurs - Baze de date 60', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n 4. Conditia IS NULL  \n \n  Pentru a verifica valorile de tip NULL există condiţia IS \nNULL sau negarea acesteia IS NOT NULL.  \n  O valoare nulă este o valoare care este sau incorectă, sau \nnecunoscută, sau inaplicabilă de aceea nu poate fi testată cu \n""="".  \n  O valoare nulă nu este la fel cu ""zero"" care este un \nnumăr. \n  Dacă valoarea NULL este utilizată într-o comparaţie, \natunci operatorul de comparaţie trebuie să fie IS NULL sau IS \nNOT NULL altfel rezultatul este întotdeauna FALSE.  \nCurs - Baze de date 60', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n  Clauza WHERE poate compara valori în coloană, \nvalori literale, expresii aritmetice sau funcţii. \nWHERE - restricţionează cererea la rândurile care \nîndeplinesc o condiţie; \n \nCondiţie este alcătuită din trei elemente: \n1. Un nume de coloană  \n2. Un operator de comparaţie  \n3. Un nume de coloană, constantă sau listă de valori \nCurs - Baze de date 31', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n  Clauza WHERE poate compara valori în coloană, \nvalori literale, expresii aritmetice sau funcţii. \nWHERE - restricţionează cererea la rândurile care \nîndeplinesc o condiţie; \n \nCondiţie este alcătuită din trei elemente: \n1. Un nume de coloană  \n2. Un operator de comparaţie  \n3. Un nume de coloană, constantă sau listă de valori \nCurs - Baze de date 31', '\n']","Folosind informatiile din curs, nu pot raspunde la aceasta intrebare. Contextul ofera informatii despre clauza WHERE si operatori de comparatie in SQL, insa nu ofera detalii despre cum se poate calcula suma valorilor dintr-o coloana. 
",Se utilizează funcția SUM(coloana).,,,0.0,,0.0,0.09523809523809525,0.0
37,Ce este funcția LAST_DAY?,"['1. ', '4.2.3. Funcţii de tip dată calendaristică şi oră \nFunctia LAST_DAY - exemplu: \n \nSELECT LAST_DAY(SYSDATE) \nFROM DUAL; \n \n \n \nCurs 4 - BAZE DE DATE 50', '\n', '2. ', '4.2.3. Funcţii de tip dată calendaristică şi oră \nFunctia LAST_DAY - exemplu: \n \nSELECT LAST_DAY(SYSDATE) \nFROM DUAL; \n \n \n \nCurs 4 - BAZE DE DATE 50', '\n', '3. ', ""copyright@www.adrian.runceanu.ro \nClauza WHERE \nB. Şirurile de caractere şi date calendaristice  \n \n  Pentru a putea folosi în clauza WHERE şiruri de \ncaractere şi date calendaristice acestea trebuie \nintroduse între ghilimele simple (' '), singura \nexcepţie fiind constantele numerice.  \nCurs - Baze de date 35"", '\n', '4. ', ""copyright@www.adrian.runceanu.ro \nClauza WHERE \nB. Şirurile de caractere şi date calendaristice  \n \n  Pentru a putea folosi în clauza WHERE şiruri de \ncaractere şi date calendaristice acestea trebuie \nintroduse între ghilimele simple (' '), singura \nexcepţie fiind constantele numerice.  \nCurs - Baze de date 35"", '\n', '5. ', ""copyright@www.adrian.runceanu.ro \nClauza WHERE \n2. IN  \n \n  Condiţia IN testează valorile dintr-o listă \nspecificată. \n  Pot fi folosite orice tipuri de date, cu precizarea \ncă pentru şirurile de caractere şi date calendaristice \ntrebuie folosite ghilimelele simple (' ').  \nCurs - Baze de date 47"", '\n', '6. ', ""copyright@www.adrian.runceanu.ro \nClauza WHERE \n2. IN  \n \n  Condiţia IN testează valorile dintr-o listă \nspecificată. \n  Pot fi folosite orice tipuri de date, cu precizarea \ncă pentru şirurile de caractere şi date calendaristice \ntrebuie folosite ghilimelele simple (' ').  \nCurs - Baze de date 47"", '\n', '7. ', 'copyright@www.adrian.runceanu.ro \n4.2.4. Funcţii de conversie dintr-un tip în \naltul \na) Conversia din dată calendaristică în şir de \ncaractere \nSintaxa acestei funcţii este: TO_CHAR (dt, format) \ndt poate avea unul din tipurile pentru date \ncalendatistice: \n1. DATE, TIMESTAMP \n2. TIMESTAMP WITH TIME ZONE \n3. TIMESTAMP  \n4. WITH LOCAL TIME ZONE  \n5. INTERVAL MONTH TO YEAR \n6. INTERVAL DAY TO SECOND \nCurs 4 - BAZE DE DATE 58', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \n4.2.4. Funcţii de conversie dintr-un tip în \naltul \na) Conversia din dată calendaristică în şir de \ncaractere \nSintaxa acestei funcţii este: TO_CHAR (dt, format) \ndt poate avea unul din tipurile pentru date \ncalendatistice: \n1. DATE, TIMESTAMP \n2. TIMESTAMP WITH TIME ZONE \n3. TIMESTAMP  \n4. WITH LOCAL TIME ZONE  \n5. INTERVAL MONTH TO YEAR \n6. INTERVAL DAY TO SECOND \nCurs 4 - BAZE DE DATE 58', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \n4.2.4. Funcţii de conversie dintr-un tip în \naltul \na) Conversia din dată calendaristică în şir de \ncaractere \n \nConversia unei date calendaristice în şir de \ncaractere se poate realiza cu ajutorul funcţiei \nTO_CHAR.  \nCurs 4 - BAZE DE DATE 57', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \n4.2.4. Funcţii de conversie dintr-un tip în \naltul \na) Conversia din dată calendaristică în şir de \ncaractere \n \nConversia unei date calendaristice în şir de \ncaractere se poate realiza cu ajutorul funcţiei \nTO_CHAR.  \nCurs 4 - BAZE DE DATE 57', '\n']","Folosind informatiile din curs, LAST_DAY este o funcție de tip dată calendaristică care poate fi apelată cu sintaxa `SELECT LAST_DAY(SYSDATE) FROM DUAL;`. 
",Funcția LAST_DAY returnează ultima zi a lunii pentru o dată dată.,,,0.8621470012803468,,0.04750133160738243,0.20512820512820515,0.5
38,Cum se determină numărul de luni dintre două date?,"['1. ', ""copyright@www.adrian.runceanu.ro \nClauza WHERE \n2. IN  \n \n  Condiţia IN testează valorile dintr-o listă \nspecificată. \n  Pot fi folosite orice tipuri de date, cu precizarea \ncă pentru şirurile de caractere şi date calendaristice \ntrebuie folosite ghilimelele simple (' ').  \nCurs - Baze de date 47"", '\n', '2. ', ""copyright@www.adrian.runceanu.ro \nClauza WHERE \n2. IN  \n \n  Condiţia IN testează valorile dintr-o listă \nspecificată. \n  Pot fi folosite orice tipuri de date, cu precizarea \ncă pentru şirurile de caractere şi date calendaristice \ntrebuie folosite ghilimelele simple (' ').  \nCurs - Baze de date 47"", '\n', '3. ', ""copyright@www.adrian.runceanu.ro \nClauza WHERE \nB. Şirurile de caractere şi date calendaristice  \n \n  Pentru a putea folosi în clauza WHERE şiruri de \ncaractere şi date calendaristice acestea trebuie \nintroduse între ghilimele simple (' '), singura \nexcepţie fiind constantele numerice.  \nCurs - Baze de date 35"", '\n', '4. ', ""copyright@www.adrian.runceanu.ro \nClauza WHERE \nB. Şirurile de caractere şi date calendaristice  \n \n  Pentru a putea folosi în clauza WHERE şiruri de \ncaractere şi date calendaristice acestea trebuie \nintroduse între ghilimele simple (' '), singura \nexcepţie fiind constantele numerice.  \nCurs - Baze de date 35"", '\n', '5. ', 'copyright@www.adrian.runceanu.ro \n4.2.5. Funcţii generale \nFuncţii generale:  \n1. NVL  \n2. NVL2  \n3. NULLIF \n4. COALESCE \nAceste funcţii au ca argumente date de diferite \ntipuri şi returnează date de tipuri diferite. \nAceste funcţii precizează cum sunt prelucrate \nvalorile de tip NULL. \nCurs 4 - BAZE DE DATE 94', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \n4.2.5. Funcţii generale \nFuncţii generale:  \n1. NVL  \n2. NVL2  \n3. NULLIF \n4. COALESCE \nAceste funcţii au ca argumente date de diferite \ntipuri şi returnează date de tipuri diferite. \nAceste funcţii precizează cum sunt prelucrate \nvalorile de tip NULL. \nCurs 4 - BAZE DE DATE 94', '\n', '7. ', ""copyright@www.adrian.runceanu.ro \n4.2.4. Funcţii de conversie dintr-un tip în \naltul \nb) Conversia din şir de caractere în dată calendaristică \n \nFolosind funcţia TO_DATE se poate transforma un şir de \ncaractere precum 'Match 09, 2023' într-o dată \ncalendaristică.  \nSintaxa funcţiei este: TO_DATE(sir, format) \nFormatul nu este obligatoriu, însă dacă nu este \nprecizat, şirul trebuie să respecte formatul implicit al \ndatei calendaristice DD-MON\x02YYYY sau DD-MON-YY .  \nFormatul poate folosi aceiaşi parametrii de format ca şi \nfuncţia TO_CHAR. \nCurs 4 - BAZE DE DATE 73"", '\n', '8. ', ""copyright@www.adrian.runceanu.ro \n4.2.4. Funcţii de conversie dintr-un tip în \naltul \nb) Conversia din şir de caractere în dată calendaristică \n \nFolosind funcţia TO_DATE se poate transforma un şir de \ncaractere precum 'Match 09, 2023' într-o dată \ncalendaristică.  \nSintaxa funcţiei este: TO_DATE(sir, format) \nFormatul nu este obligatoriu, însă dacă nu este \nprecizat, şirul trebuie să respecte formatul implicit al \ndatei calendaristice DD-MON\x02YYYY sau DD-MON-YY .  \nFormatul poate folosi aceiaşi parametrii de format ca şi \nfuncţia TO_CHAR. \nCurs 4 - BAZE DE DATE 73"", '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nLISTA SELECT \n Alias de coloana: \n  Nu poate fi mai lung de 30 de caractere. \n  Începe cu o litera, contine numai litere, cifre, _, # si \n$ sau e pus intre ghilimele (tot max. 30 caractere intre \nghilimele). \n  Între ghilimele literele mici sunt considerate diferite \nde literele mari. \n  Nu poate fi folosit decât în cererea curenta. \n  Sistemul nu stocheaza în baza de date sau altundeva \naceste nume alternative. \n  Nu poate fi folosit în alte clauze ale cererii (doar in \nSELECT si ORDER BY). Curs - Baze de date 17', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nLISTA SELECT \n Alias de coloana: \n  Nu poate fi mai lung de 30 de caractere. \n  Începe cu o litera, contine numai litere, cifre, _, # si \n$ sau e pus intre ghilimele (tot max. 30 caractere intre \nghilimele). \n  Între ghilimele literele mici sunt considerate diferite \nde literele mari. \n  Nu poate fi folosit decât în cererea curenta. \n  Sistemul nu stocheaza în baza de date sau altundeva \naceste nume alternative. \n  Nu poate fi folosit în alte clauze ale cererii (doar in \nSELECT si ORDER BY). Curs - Baze de date 17', '\n']","Folosind informatiile din curs, imi pare rau, dar nu pot raspunde la intrebarea ta. Contextul ofera informatii despre clauzele WHERE si IN, despre formatul datelor calendaristice, despre functii generale si de conversie in SQL, dar nu si despre cum se calculeaza numarul de luni dintre doua date. 
","Se utilizează funcția MONTHS_BETWEEN(data1, data2).",,,0.0,,0.024455939372403628,0.03636363636363636,0.0
39,Cum se adaugă luni la o dată în SQL?,"['1. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră \n 4.2.4. Funcţii de conversie dintr-un tip în altul \n 4.2.5. Funcţii generale \n  4.2.6. Funcţii condiţionale \nCurs 4 - BAZE DE DATE 32', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră \n 4.2.4. Funcţii de conversie dintr-un tip în altul \n 4.2.5. Funcţii generale \n  4.2.6. Funcţii condiţionale \nCurs 4 - BAZE DE DATE 32', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă \n \n3.1. SELECT. Sintaxa. Efect. Rezultat \n3.2. Lista SELECT \n3.3. Clauza WHERE \n3.4. Clauza ORDER BY \nCurs - Baze de date 3', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă \n \n3.1. SELECT. Sintaxa. Efect. Rezultat \n3.2. Lista SELECT \n3.3. Clauza WHERE \n3.4. Clauza ORDER BY \nCurs - Baze de date 3', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.1. Funcţii \n4.2. Funcţii referitoare la o singură înregistrare \n \nCurs 4 - BAZE DE DATE 3', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.1. Funcţii \n4.2. Funcţii referitoare la o singură înregistrare \n \nCurs 4 - BAZE DE DATE 3', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră \n 4.2.4. Funcţii de conversie dintr-un tip în altul \n 4.2.5. Funcţii generale \n  4.2.6. Funcţii condiţionale \nCurs 4 - BAZE DE DATE 46', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră \n 4.2.4. Funcţii de conversie dintr-un tip în altul \n 4.2.5. Funcţii generale \n  4.2.6. Funcţii condiţionale \nCurs 4 - BAZE DE DATE 46', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră \n 4.2.4. Funcţii de conversie dintr-un tip în altul \n 4.2.5. Funcţii generale \n  4.2.6. Funcţii condiţionale \nCurs 4 - BAZE DE DATE 54', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră \n 4.2.4. Funcţii de conversie dintr-un tip în altul \n 4.2.5. Funcţii generale \n  4.2.6. Funcţii condiţionale \nCurs 4 - BAZE DE DATE 54', '\n']","Folosind informatiile din curs, îmi pare rău, dar nu pot răspunde la această întrebare. Informațiile oferite prezintă o structură generală a cursului despre limbajul SQL, dar nu detaliază sintaxa specifică pentru manipularea datelor. 
","Se folosește funcția ADD_MONTHS(data, numar_luni).",,,0.0,,0.024455939372403628,0.0,0.4
40,Cum se selectează doar primele N rânduri?,"['1. ', 'copyright@www.adrian.runceanu.ro \nEFECT \n  Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM. \n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii.  \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii. \n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT. \nCurs - Baze de date 5', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \nEFECT \n  Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM. \n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii.  \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii. \n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT. \nCurs - Baze de date 5', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \n4.3. Funcții de grup \n•COUNT(*) întoarce numărul de rânduri dintr-o tabela \ncare satisface criteriul de selecţie, incluzând rândurile \nduplicat şi rândurile conţinând valori nule. \n \n•Dacă clauza WHERE este introdusă, atunci COUNT(*) \nreturnează numărul de rânduri care satisfac condiţia \ndin clauza WHERE. \nCurs 5 - BAZE DE DATE 22', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \n4.3. Funcții de grup \n•COUNT(*) întoarce numărul de rânduri dintr-o tabela \ncare satisface criteriul de selecţie, incluzând rândurile \nduplicat şi rândurile conţinând valori nule. \n \n•Dacă clauza WHERE este introdusă, atunci COUNT(*) \nreturnează numărul de rânduri care satisfac condiţia \ndin clauza WHERE. \nCurs 5 - BAZE DE DATE 22', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare.  \n \nAstfel: \n \n> ALL inseamna mai mare decat maximul \n \n< ALL inseamna mai mic decat minimul \nCurs 6 - BAZE DE DATE 52', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare.  \n \nAstfel: \n \n> ALL inseamna mai mare decat maximul \n \n< ALL inseamna mai mic decat minimul \nCurs 6 - BAZE DE DATE 52', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nValori de NULL intr-o subinterogare  \n \n• In cazul in care subinterogarea returneaza \nvreuna din valori NULL si interogarea \nprincipala are operator NOT IN, atunci \ninterogarea principala nu va returna niciun \nrand.  \n \n• Motivul este ca o comparatie cu NULL conduce \nla un rezultat NULL.  \nCurs 6 - BAZE DE DATE 59', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nValori de NULL intr-o subinterogare  \n \n• In cazul in care subinterogarea returneaza \nvreuna din valori NULL si interogarea \nprincipala are operator NOT IN, atunci \ninterogarea principala nu va returna niciun \nrand.  \n \n• Motivul este ca o comparatie cu NULL conduce \nla un rezultat NULL.  \nCurs 6 - BAZE DE DATE 59', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nREZULTAT \n  Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT.  \n  Aceste expresii dau si numele coloanelor din \nrezultat. \n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela. \nCurs - Baze de date 7', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nREZULTAT \n  Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT.  \n  Aceste expresii dau si numele coloanelor din \nrezultat. \n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela. \nCurs - Baze de date 7', '\n']","Folosind informatiile din curs, nu pot raspunde la intrebare. Contextul ofera informatii generale despre sintaxa SQL, inclusiv despre clauzele SELECT, FROM, WHERE, dar nu ofera informatii despre cum se limiteaza numarul de randuri returnate intr-o interogare. 
",Se utilizează clauza LIMIT sau FETCH FIRST N ROWS ONLY.,,,0.0,,0.0,0.0425531914893617,0.33
41,Cum se verifică dacă o coloană conține o valoare NULL?,"['1. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n 4. Conditia IS NULL  \n \n  Pentru a verifica valorile de tip NULL există condiţia IS \nNULL sau negarea acesteia IS NOT NULL.  \n  O valoare nulă este o valoare care este sau incorectă, sau \nnecunoscută, sau inaplicabilă de aceea nu poate fi testată cu \n""="".  \n  O valoare nulă nu este la fel cu ""zero"" care este un \nnumăr. \n  Dacă valoarea NULL este utilizată într-o comparaţie, \natunci operatorul de comparaţie trebuie să fie IS NULL sau IS \nNOT NULL altfel rezultatul este întotdeauna FALSE.  \nCurs - Baze de date 60', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n 4. Conditia IS NULL  \n \n  Pentru a verifica valorile de tip NULL există condiţia IS \nNULL sau negarea acesteia IS NOT NULL.  \n  O valoare nulă este o valoare care este sau incorectă, sau \nnecunoscută, sau inaplicabilă de aceea nu poate fi testată cu \n""="".  \n  O valoare nulă nu este la fel cu ""zero"" care este un \nnumăr. \n  Dacă valoarea NULL este utilizată într-o comparaţie, \natunci operatorul de comparaţie trebuie să fie IS NULL sau IS \nNOT NULL altfel rezultatul este întotdeauna FALSE.  \nCurs - Baze de date 60', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \n4.2.5. Funcţii generale \n3. Funcţia NULLIF cu formatul: \n \nNULLIF(expresie1, expresie2) \n \nReturneaza NULL, daca cele doua expresii sunt \negale. \nDaca cele doua espresii sunt diferite (valorile \nlor), atunci returneaza valoarea primei expresii \n– expresie1. \nCurs 4 - BAZE DE DATE 100', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \n4.2.5. Funcţii generale \n3. Funcţia NULLIF cu formatul: \n \nNULLIF(expresie1, expresie2) \n \nReturneaza NULL, daca cele doua expresii sunt \negale. \nDaca cele doua espresii sunt diferite (valorile \nlor), atunci returneaza valoarea primei expresii \n– expresie1. \nCurs 4 - BAZE DE DATE 100', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \n4.2.5. Funcţii generale \nFuncţii generale:  \n1. NVL  \n2. NVL2  \n3. NULLIF \n4. COALESCE \nAceste funcţii au ca argumente date de diferite \ntipuri şi returnează date de tipuri diferite. \nAceste funcţii precizează cum sunt prelucrate \nvalorile de tip NULL. \nCurs 4 - BAZE DE DATE 94', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \n4.2.5. Funcţii generale \nFuncţii generale:  \n1. NVL  \n2. NVL2  \n3. NULLIF \n4. COALESCE \nAceste funcţii au ca argumente date de diferite \ntipuri şi returnează date de tipuri diferite. \nAceste funcţii precizează cum sunt prelucrate \nvalorile de tip NULL. \nCurs 4 - BAZE DE DATE 94', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nValori de NULL intr-o subinterogare  \n \n• In cazul in care subinterogarea returneaza \nvreuna din valori NULL si interogarea \nprincipala are operator NOT IN, atunci \ninterogarea principala nu va returna niciun \nrand.  \n \n• Motivul este ca o comparatie cu NULL conduce \nla un rezultat NULL.  \nCurs 6 - BAZE DE DATE 59', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nValori de NULL intr-o subinterogare  \n \n• In cazul in care subinterogarea returneaza \nvreuna din valori NULL si interogarea \nprincipala are operator NOT IN, atunci \ninterogarea principala nu va returna niciun \nrand.  \n \n• Motivul este ca o comparatie cu NULL conduce \nla un rezultat NULL.  \nCurs 6 - BAZE DE DATE 59', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n']","Folosind informatiile din curs, pentru a verifica valorile de tip NULL există condiţia IS NULL sau negarea acesteia IS NOT NULL. O valoare nulă nu poate fi testată cu ""="". Dacă valoarea NULL este utilizată într-o comparaţie, atunci operatorul de comparaţie trebuie să fie IS NULL sau IS NOT NULL altfel rezultatul este întotdeauna FALSE. 
",Se utilizează IS NULL sau IS NOT NULL.,,,0.8279051011069468,,0.10813005337959179,0.18181818181818182,0.57
42,Ce face funcția CEIL?,"['1. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING) \nRezultatul obtinut - Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$.  \nCurs 5 - BAZE DE DATE 43', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING) \nRezultatul obtinut - Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$.  \nCurs 5 - BAZE DE DATE 43', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10. \nCurs - Baze de date 41', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10. \nCurs - Baze de date 41', '\n', '5. ', ""copyright@www.adrian.runceanu.ro \n\uf0d8Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime.  \n\uf0d8Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior.  \n \n\uf0d8Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea:  \nCurs 4 - BAZE DE DATE 28 \n4.2.1. Funcţii pentru şiruri de caractere"", '\n', '6. ', ""copyright@www.adrian.runceanu.ro \n\uf0d8Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime.  \n\uf0d8Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior.  \n \n\uf0d8Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea:  \nCurs 4 - BAZE DE DATE 28 \n4.2.1. Funcţii pentru şiruri de caractere"", '\n', '7. ', 'copyright@www.adrian.runceanu.ro \nLISTA SELECT \nNume de coloane sau * \n \nExemplu 1: \nSELECT NUME, DOMENIU \nFROM SPECIALIZARE; \n \nExemplu 2: \nSELECT * \nFROM STUDENT; \nCurs - Baze de date 13', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \nLISTA SELECT \nNume de coloane sau * \n \nExemplu 1: \nSELECT NUME, DOMENIU \nFROM SPECIALIZARE; \n \nExemplu 2: \nSELECT * \nFROM STUDENT; \nCurs - Baze de date 13', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listează toţi angajaţii care au \nnumele de 4 caractere. \nCurs - Baze de date 56', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listează toţi angajaţii care au \nnumele de 4 caractere. \nCurs - Baze de date 56', '\n']","Folosind informatiile din curs, îmi pare rău, dar contextul furnizat nu oferă informații despre funcția CEIL. Prin urmare, nu pot răspunde la întrebarea ta. 
",Funcția CEIL returnează cel mai mic număr întreg mai mare sau egal cu numărul dat.,0.0,,0.0,,0.021476912089159056,0.17391304347826086,0.0
43,Ce este o cheie primară?,"['1. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \n Operatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare. \n \nAstfel,  \n < ANY inseamna mai mic decat maximul  \n ANY inseamna mai mare decat minimul \n = ANY este echivalent cu IN \nCurs 6 - BAZE DE DATE 49', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \n Operatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare. \n \nAstfel,  \n < ANY inseamna mai mic decat maximul  \n ANY inseamna mai mare decat minimul \n = ANY este echivalent cu IN \nCurs 6 - BAZE DE DATE 49', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n Rezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze.  \nCurs - Baze de date 68', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n Rezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze.  \nCurs - Baze de date 68', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING) \nRezultatul obtinut - Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$.  \n \nCurs 5 - BAZE DE DATE 45', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING) \nRezultatul obtinut - Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$.  \n \nCurs 5 - BAZE DE DATE 45', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \n6.1. SINGLE ROW SUBQUERIES \n• Subinterogările pot fi plasate şi în clauza HAVING.  \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup. \nCurs 6 - BAZE DE DATE 22', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \n6.1. SINGLE ROW SUBQUERIES \n• Subinterogările pot fi plasate şi în clauza HAVING.  \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup. \nCurs 6 - BAZE DE DATE 22', '\n']","Folosind informatiile din curs, îmi pare rău, dar nu pot răspunde la întrebarea ta. Informațiile din sursele furnizate se referă la subinterogări corelate, operatorul ANY și clauzele WHERE și HAVING în contextul bazelor de date. Nu există informații despre cheile primare. 
",O cheie primară este un identificator unic pentru fiecare rând dintr-o tabelă.,,,0.0,,0.0,0.03333333333333333,0.0
44,Ce este o cheie străină?,"['1. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \nClauza ORDER BY \n\uf0d8 Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare, salariu şi comision (în ordine crescătoare).  \nCurs - Baze de date 79', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \nClauza ORDER BY \n\uf0d8 Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare, salariu şi comision (în ordine crescătoare).  \nCurs - Baze de date 79', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n Rezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze.  \nCurs - Baze de date 68', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n Rezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze.  \nCurs - Baze de date 68', '\n', '7. ', 'copyright@www.adrian.runceanu.ro \n4.3.1. Clauza GROUP BY \nGruparea după mai multe coloane.  \n \n  Câteodată este necesară obţinerea de rezultate \npentru grupuri în alte grupuri.  \n  Atunci în dreptul clauzei GROUP BY vom întâlni \nmai multe coloane. \nCurs 5 - BAZE DE DATE 37', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \n4.3.1. Clauza GROUP BY \nGruparea după mai multe coloane.  \n \n  Câteodată este necesară obţinerea de rezultate \npentru grupuri în alte grupuri.  \n  Atunci în dreptul clauzei GROUP BY vom întâlni \nmai multe coloane. \nCurs 5 - BAZE DE DATE 37', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \n6.1. SINGLE ROW SUBQUERIES \n• Subinterogările pot fi plasate şi în clauza HAVING.  \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup. \nCurs 6 - BAZE DE DATE 22', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \n6.1. SINGLE ROW SUBQUERIES \n• Subinterogările pot fi plasate şi în clauza HAVING.  \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup. \nCurs 6 - BAZE DE DATE 22', '\n']","Folosind informatiile din curs, nu pot raspunde la aceasta intrebare. Contextul oferit descrie subinterogari corelate si diverse clauze SQL precum ORDER BY, WHERE si GROUP BY, fara a mentiona conceptul de ""cheie straina"". 
",O cheie străină este o coloană care face referire la o cheie primară din altă tabelă.,,,0.0,,0.02583112439191653,0.08,0.0
45,Ce este o interogare imbricată?,"['1. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \n4.3.3. Imbricarea functiilor de grup \n Funcţiile de grup pot fi imbricate cu o adâncime de 2. \nRezultatul obtinut - Salariul mediu maxim.  \nCurs 5 - BAZE DE DATE 52', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \n4.3.3. Imbricarea functiilor de grup \n Funcţiile de grup pot fi imbricate cu o adâncime de 2. \nRezultatul obtinut - Salariul mediu maxim.  \nCurs 5 - BAZE DE DATE 52', '\n', '5. ', ""copyright@www.adrian.runceanu.ro \n\uf0d8Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime.  \n\uf0d8Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior.  \n \n\uf0d8Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea:  \nCurs 4 - BAZE DE DATE 28 \n4.2.1. Funcţii pentru şiruri de caractere"", '\n', '6. ', ""copyright@www.adrian.runceanu.ro \n\uf0d8Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime.  \n\uf0d8Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior.  \n \n\uf0d8Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea:  \nCurs 4 - BAZE DE DATE 28 \n4.2.1. Funcţii pentru şiruri de caractere"", '\n', '7. ', 'copyright@www.adrian.runceanu.ro \n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare.  \n \nAstfel: \n \n> ALL inseamna mai mare decat maximul \n \n< ALL inseamna mai mic decat minimul \nCurs 6 - BAZE DE DATE 52', '\n', '8. ', 'copyright@www.adrian.runceanu.ro \n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare.  \n \nAstfel: \n \n> ALL inseamna mai mare decat maximul \n \n< ALL inseamna mai mic decat minimul \nCurs 6 - BAZE DE DATE 52', '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255. \nCurs 6 - BAZE DE DATE 55', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255. \nCurs 6 - BAZE DE DATE 55', '\n']","Folosind informatiile din curs, o interogare imbricată, sau subinterogare corelată, este o subinterogare care se execută o dată pentru fiecare linie considerată de interogarea principală și care la execuție folosește o valoare dintr-o coloană din interogarea exterioară.  Ea se poate identifica prin folosirea unei coloane a interogării exterioare în clauza operatorului interogării interioare. 
Numărul maxim de imbricări pentru o subinterogare este de 255. 
Funcțiile de grup pot fi imbricate cu o adâncime de 2. 
Spre deosebire de alte funcții, funcțiile caracter pot fi imbricate până la orice adâncime. Dacă funcțiile sunt imbricate, atunci ele sunt evaluate din interior spre exterior. 
Operatorul ALL din interogarea principală compară o valoare cu oricare valoare returnată de subinterogare. Astfel: 
> ALL înseamnă mai mare decât maximul 
< ALL înseamnă mai mic decât minimul. 
",O interogare imbricată este o interogare SQL inclusă în alta.,,,0.8816529981787714,1.0,0.028757116379452802,0.0784313725490196,0.0
46,Cum se poate uni rezultatele a două interogări?,"['1. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '2. ', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara. \n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', '\n', '3. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listează toţi angajaţii care nu au \ncomision.  \nCurs - Baze de date 62', '\n', '4. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listează toţi angajaţii care nu au \ncomision.  \nCurs - Baze de date 62', '\n', '5. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING) \nRezultatul obtinut - Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$.  \n \nCurs 5 - BAZE DE DATE 45', '\n', '6. ', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING) \nRezultatul obtinut - Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$.  \n \nCurs 5 - BAZE DE DATE 45', '\n', '7. ', ""copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listeaza toţi angajaţii care al doilea \ncaracter din nume 'O'.  \nCurs - Baze de date 58"", '\n', '8. ', ""copyright@www.adrian.runceanu.ro \nClauza WHERE \nRezultatul obtinut - Listeaza toţi angajaţii care al doilea \ncaracter din nume 'O'.  \nCurs - Baze de date 58"", '\n', '9. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n Rezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze.  \nCurs - Baze de date 68', '\n', '10. ', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n Rezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze.  \nCurs - Baze de date 68', '\n']","Folosind informatiile din curs, rezultatele a doua interogări pot fi unite folosind o subinterogare corelată. Aceasta se executa o data pentru fiecare linie considerata de interogarea principala si foloseste la execuție o valoare dintr-o coloana din interogarea exterioara. 
",Se utilizează operatorul UNION sau UNION ALL.,0.0,0.0,0.822928320970585,,0.0,0.04166666666666667,0.0
