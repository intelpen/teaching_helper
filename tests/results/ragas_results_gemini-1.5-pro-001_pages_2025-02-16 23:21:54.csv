,initial_Generator,initial_Dificultate,initial_Capitole Principale,initial_Capitole Asociate,initial_user_input,initial_reference,initial_Evaluare Professor,initial_Unde se afla raspunsul,initial_retrieved_contexts,initial_response,user_input,retrieved_contexts,response,reference,context_precision,context_recall,answer_relevancy,faithfulness,bleu_score,rouge_score,factual_correctness
0,O3mini-high,LOW,C1,,"În contextul noțiunilor introductive, ce model de organizare a datelor este prezentat ca predominant în curs?",relațional,Este corect,,"['copyright@www.adrian.runceanu.ro\nIntroducere\n➢Pentru o bună înţelegere a noţiunilor teoretice şi \npractice prezentate în acest curs, este necesară \nparcurgerea anterioară a disciplinelor Programarea \ncalculatoarelor, Proiectarea algoritmilor si \nProgramare orientate pe obiecte.\n➢Cursul de Baze de date este structurat în 13 cursuri \n(capitole), fiecare dintre acestea cuprinzând câte \nun număr de 13 laboratoare (activităţi practice) la \ncare prezenţa va fi obligatorie.\nCurs - Baze de date 12', 'copyright@www.adrian.runceanu.ro\nIntroducere\n➢Pentru o bună înţelegere a noţiunilor teoretice şi \npractice prezentate în acest curs, este necesară \nparcurgerea anterioară a disciplinelor Programarea \ncalculatoarelor, Proiectarea algoritmilor si \nProgramare orientate pe obiecte.\n➢Cursul de Baze de date este structurat în 13 cursuri \n(capitole), fiecare dintre acestea cuprinzând câte \nun număr de 13 laboratoare (activităţi practice) la \ncare prezenţa va fi obligatorie.\nCurs - Baze de date 12', 'copyright@www.adrian.runceanu.ro\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56', 'copyright@www.adrian.runceanu.ro\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56', 'copyright@www.adrian.runceanu.ro\nVederile se folosesc pentru că oferă: \n1. Acces restricţionat la date (vederile pot \nselecţiona anumite coloane dintr-o tabelă)\n2. Posibilitatea lucrului cu interogări complexe\n3. Independenţa datelor\n4. Posibilitatea prezentării de date identice în \nvederi diferite\nCurs - BAZE DE DATE 5']","Din păcate, informația solicitată referitoare la ""modelul de organizare a datelor predominant"" **nu este prezentă în contextul furnizat**. 

Textele oferite descriu structura unui curs de Baze de date și oferă informații despre subinterogări corelate și vederi. Nu se specifică un anumit model de organizare a datelor, cum ar fi modelul relațional, ierarhic, rețea, etc. 
","În contextul noțiunilor introductive, ce model de organizare a datelor este prezentat ca predominant în curs?","['copyright@www.adrian.runceanu.ro\nIntroducere\n➢Pentru o bună înţelegere a noţiunilor teoretice şi \npractice prezentate în acest curs, este necesară \nparcurgerea anterioară a disciplinelor Programarea \ncalculatoarelor, Proiectarea algoritmilor si \nProgramare orientate pe obiecte.\n➢Cursul de Baze de date este structurat în 13 cursuri \n(capitole), fiecare dintre acestea cuprinzând câte \nun număr de 13 laboratoare (activităţi practice) la \ncare prezenţa va fi obligatorie.\nCurs - Baze de date 12', 'copyright@www.adrian.runceanu.ro\nIntroducere\n➢Pentru o bună înţelegere a noţiunilor teoretice şi \npractice prezentate în acest curs, este necesară \nparcurgerea anterioară a disciplinelor Programarea \ncalculatoarelor, Proiectarea algoritmilor si \nProgramare orientate pe obiecte.\n➢Cursul de Baze de date este structurat în 13 cursuri \n(capitole), fiecare dintre acestea cuprinzând câte \nun număr de 13 laboratoare (activităţi practice) la \ncare prezenţa va fi obligatorie.\nCurs - Baze de date 12', 'copyright@www.adrian.runceanu.ro\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56', 'copyright@www.adrian.runceanu.ro\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56', 'copyright@www.adrian.runceanu.ro\nVederile se folosesc pentru că oferă: \n1. Acces restricţionat la date (vederile pot \nselecţiona anumite coloane dintr-o tabelă)\n2. Posibilitatea lucrului cu interogări complexe\n3. Independenţa datelor\n4. Posibilitatea prezentării de date identice în \nvederi diferite\nCurs - BAZE DE DATE 5']","Din păcate, informația solicitată referitoare la ""modelul de organizare a datelor predominant"" **nu este prezentă în contextul furnizat**. 

Textele oferite descriu structura unui curs de Baze de date și oferă informații despre subinterogări corelate și vederi. Nu se specifică un anumit model de organizare a datelor, cum ar fi modelul relațional, ierarhic, rețea, etc. 
",relațional,0.0,0.0,0.0,1.0,0.0,0.06451612903225806,0.67
1,O3mini-high,LOW,C2,,Ce limbaj integrat în Oracle este utilizat pentru scrierea procedurilor stocate?,PL/SQL,Este corect,,"['copyright@www.adrian.runceanu.ro\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7Curs - Baze de date', '2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43Curs - Baze de date', '2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oferă facilităţi din tehnologia OO, prin care se permite \ndefinirea şi utilizarea de obiecte mari şi complexe\n• Optimizează cererile de regăsire prin reutilizarea \ncomenzilor SQL identice lansate de utilizatori diferiţi şi \nprin realizarea unui plan de execuţie a instrucţiunilor \nSQL\n• Are un grad de securitate sporit prin: \n– server de criptare\n– control trafic reţea\n– niveluri de parolare, etc.\n11Curs - Baze de date\nSGBD Oracle 8i (continuare)']","Conform textului furnizat, limbajul integrat în Oracle utilizat pentru scrierea procedurilor stocate este **PL/SQL**. 
",Ce limbaj integrat în Oracle este utilizat pentru scrierea procedurilor stocate?,"['copyright@www.adrian.runceanu.ro\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7Curs - Baze de date', '2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43Curs - Baze de date', '2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oferă facilităţi din tehnologia OO, prin care se permite \ndefinirea şi utilizarea de obiecte mari şi complexe\n• Optimizează cererile de regăsire prin reutilizarea \ncomenzilor SQL identice lansate de utilizatori diferiţi şi \nprin realizarea unui plan de execuţie a instrucţiunilor \nSQL\n• Are un grad de securitate sporit prin: \n– server de criptare\n– control trafic reţea\n– niveluri de parolare, etc.\n11Curs - Baze de date\nSGBD Oracle 8i (continuare)']","Conform textului furnizat, limbajul integrat în Oracle utilizat pentru scrierea procedurilor stocate este **PL/SQL**. 
",PL/SQL,0.99999999995,1.0,0.8906415124105985,1.0,0.06760229884571736,0.23529411764705882,0.0
2,O3mini-high,LOW,C3,,Cu ce clauză SQL se filtrează rândurile dintr-o interogare?,WHERE,Este corect,,"['Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată']","Din păcate, contextul oferit nu conține informații despre clauzele SQL și cum se filtrează rândurile într-o interogare. 

Pentru a răspunde la întrebarea ta, ""Cu ce clauză SQL se filtrează rândurile dintr-o interogare?"", ai nevoie de clauza **WHERE**. 

Exemplu:

```sql
SELECT * FROM Angajati WHERE Salariu > 3000;
```

Această interogare va selecta toate coloanele (`*`) din tabelul `Angajati`  **WHERE** (unde) valoarea din coloana `Salariu` este mai mare de 3000. 
",Cu ce clauză SQL se filtrează rândurile dintr-o interogare?,"['Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată']","Din păcate, contextul oferit nu conține informații despre clauzele SQL și cum se filtrează rândurile într-o interogare. 

Pentru a răspunde la întrebarea ta, ""Cu ce clauză SQL se filtrează rândurile dintr-o interogare?"", ai nevoie de clauza **WHERE**. 

Exemplu:

```sql
SELECT * FROM Angajati WHERE Salariu > 3000;
```

Această interogare va selecta toate coloanele (`*`) din tabelul `Angajati`  **WHERE** (unde) valoarea din coloana `Salariu` este mai mare de 3000. 
",WHERE,0.0,0.0,1.0000000000000009,0.25,0.0,0.027027027027027025,0.5
3,O3mini-high,LOW,C4,,Ce funcție SQL transformă șirurile de caractere în majuscule?,UPPER,Este corect,,"['copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', 'copyright@www.adrian.runceanu.ro\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69Curs - Baze de date']","Deși contextul furnizat oferă informații despre SQL, nu menționează funcția care transformă șirurile de caractere în majuscule. 

Totuși, funcția SQL care face acest lucru se numește **UPPER()**. 

Exemplu: 

```sql
SELECT UPPER('exemplu de text');
```

Rezultatul va fi: 

```
EXEMPLU DE TEXT
``` 
",Ce funcție SQL transformă șirurile de caractere în majuscule?,"['copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', 'copyright@www.adrian.runceanu.ro\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69Curs - Baze de date']","Deși contextul furnizat oferă informații despre SQL, nu menționează funcția care transformă șirurile de caractere în majuscule. 

Totuși, funcția SQL care face acest lucru se numește **UPPER()**. 

Exemplu: 

```sql
SELECT UPPER('exemplu de text');
```

Rezultatul va fi: 

```
EXEMPLU DE TEXT
``` 
",UPPER,0.0,0.0,0.8725126228363279,0.4,0.0,0.04166666666666667,0.0
4,O3mini-high,LOW,C5,,Cu ce clauză se grupează înregistrările pentru a calcula valori agregate folosind funcțiile de grup?,GROUP BY,Este corect,,"['copyright@www.adrian.runceanu.ro\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', 'copyright@www.adrian.runceanu.ro\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', 'copyright@www.adrian.runceanu.ro\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nRezultatul obtinut - Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$. \nCurs 5 - BAZE DE DATE 45\n', 'copyright@www.adrian.runceanu.ro\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nRezultatul obtinut - Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$. \nCurs 5 - BAZE DE DATE 45\n', 'copyright@www.adrian.runceanu.ro\n4.3. Funcții de grup\nRezultatul obtinut - Numărul angajaţilor din departamentul cu id-\nul 30. \nCurs 5 - BAZE DE DATE 25\n']","Înregistrările se grupează folosind clauza **GROUP BY** pentru a calcula valori agregate folosind funcțiile de grup. 
",Cu ce clauză se grupează înregistrările pentru a calcula valori agregate folosind funcțiile de grup?,"['copyright@www.adrian.runceanu.ro\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', 'copyright@www.adrian.runceanu.ro\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', 'copyright@www.adrian.runceanu.ro\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nRezultatul obtinut - Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$. \nCurs 5 - BAZE DE DATE 45\n', 'copyright@www.adrian.runceanu.ro\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nRezultatul obtinut - Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$. \nCurs 5 - BAZE DE DATE 45\n', 'copyright@www.adrian.runceanu.ro\n4.3. Funcții de grup\nRezultatul obtinut - Numărul angajaţilor din departamentul cu id-\nul 30. \nCurs 5 - BAZE DE DATE 25\n']","Înregistrările se grupează folosind clauza **GROUP BY** pentru a calcula valori agregate folosind funcțiile de grup. 
",GROUP BY,0.0,0.0,0.9559087302252266,0.0,0.03829206138020502,0.19999999999999998,0.5
5,O3mini-high,LOW,C6,,Cum se numește subinterogarea care returnează o singură valoare pentru o condiție din clauza WHERE?,subinterogare single-row,Este corect,,"['copyright@www.adrian.runceanu.ro\nClauza WITH CHECK OPTION\n  Se foloseşte pentru a ne asigura că \noperaţia care se efectuează pe o vedere \nrespectă domeniul vederii, adică nu va \nintroduce modificări care vor determina ca \nliniile inserate să nu mai fie văzute de vedere. \nCurs - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\nClauza WITH CHECK OPTION\n  Se foloseşte pentru a ne asigura că \noperaţia care se efectuează pe o vedere \nrespectă domeniul vederii, adică nu va \nintroduce modificări care vor determina ca \nliniile inserate să nu mai fie văzute de vedere. \nCurs - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56', 'copyright@www.adrian.runceanu.ro\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56', 'copyright@www.adrian.runceanu.ro\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52']","Îmi pare rău, dar informația despre denumirea subinterogării care returnează o singură valoare pentru o condiție din clauza WHERE nu se găsește în contextul furnizat. 
",Cum se numește subinterogarea care returnează o singură valoare pentru o condiție din clauza WHERE?,"['copyright@www.adrian.runceanu.ro\nClauza WITH CHECK OPTION\n  Se foloseşte pentru a ne asigura că \noperaţia care se efectuează pe o vedere \nrespectă domeniul vederii, adică nu va \nintroduce modificări care vor determina ca \nliniile inserate să nu mai fie văzute de vedere. \nCurs - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\nClauza WITH CHECK OPTION\n  Se foloseşte pentru a ne asigura că \noperaţia care se efectuează pe o vedere \nrespectă domeniul vederii, adică nu va \nintroduce modificări care vor determina ca \nliniile inserate să nu mai fie văzute de vedere. \nCurs - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56', 'copyright@www.adrian.runceanu.ro\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56', 'copyright@www.adrian.runceanu.ro\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52']","Îmi pare rău, dar informația despre denumirea subinterogării care returnează o singură valoare pentru o condiție din clauza WHERE nu se găsește în contextul furnizat. 
",subinterogare single-row,0.0,0.0,0.0,1.0,0.0,0.0,
6,O3mini-high,LOW,C7,,Ce instrucțiune SQL permite inserarea sau actualizarea condiționată a datelor?,MERGE,Este corect,,"['copyright@www.adrian.runceanu.ro\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', '2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73Curs - Baze de date']","Contextul furnizat nu oferă informații despre instrucțiunea SQL care permite inserarea sau actualizarea condiționată a datelor. 

Totuși, pot răspunde la întrebarea ta. Instrucțiunea SQL care permite inserarea sau actualizarea condiționată a datelor este **MERGE**. 

Instrucțiunea MERGE combină operațiile INSERT și UPDATE într-o singură instrucțiune. Aceasta verifică dacă o linie există deja într-o tabelă. Dacă există, actualizează linia. Dacă nu, inserează o nouă linie.

Pentru mai multe informații despre instrucțiunea MERGE, poți căuta documentația specifică a sistemului de gestionare a bazelor de date (DBMS) pe care îl utilizezi.
",Ce instrucțiune SQL permite inserarea sau actualizarea condiționată a datelor?,"['copyright@www.adrian.runceanu.ro\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', '2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73Curs - Baze de date']","Contextul furnizat nu oferă informații despre instrucțiunea SQL care permite inserarea sau actualizarea condiționată a datelor. 

Totuși, pot răspunde la întrebarea ta. Instrucțiunea SQL care permite inserarea sau actualizarea condiționată a datelor este **MERGE**. 

Instrucțiunea MERGE combină operațiile INSERT și UPDATE într-o singură instrucțiune. Aceasta verifică dacă o linie există deja într-o tabelă. Dacă există, actualizează linia. Dacă nu, inserează o nouă linie.

Pentru mai multe informații despre instrucțiunea MERGE, poți căuta documentația specifică a sistemului de gestionare a bazelor de date (DBMS) pe care îl utilizezi.
",MERGE,0.0,0.0,0.8896966204270426,0.14285714285714285,0.0,0.01904761904761905,0.25
7,O3mini-high,LOW,C8,,Ce constrângere SQL impune ca o coloană să nu accepte valori NULL?,NOT NULL,Este corect,,"['copyright@www.adrian.runceanu.ro\nOrdinea de executie a functiilor de \ngrup\n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei. \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează. \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă. \nCurs 5 - BAZE DE DATE 50', 'copyright@www.adrian.runceanu.ro\nOrdinea de executie a functiilor de \ngrup\n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei. \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează. \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă. \nCurs 5 - BAZE DE DATE 50', 'copyright@www.adrian.runceanu.ro\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14']","Conform textului furnizat, constrângerea SQL care impune ca o coloană să nu accepte valori NULL este **NOT NULL**. 

Exemplul din text menționează: ""În exemplul următor constrângerea NOT NULL se aplică coloanelor ENAME şi HIREDATE din tabela emp_new."" 
",Ce constrângere SQL impune ca o coloană să nu accepte valori NULL?,"['copyright@www.adrian.runceanu.ro\nOrdinea de executie a functiilor de \ngrup\n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei. \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează. \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă. \nCurs 5 - BAZE DE DATE 50', 'copyright@www.adrian.runceanu.ro\nOrdinea de executie a functiilor de \ngrup\n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei. \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează. \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă. \nCurs 5 - BAZE DE DATE 50', 'copyright@www.adrian.runceanu.ro\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14']","Conform textului furnizat, constrângerea SQL care impune ca o coloană să nu accepte valori NULL este **NOT NULL**. 

Exemplul din text menționează: ""În exemplul următor constrângerea NOT NULL se aplică coloanelor ENAME şi HIREDATE din tabela emp_new."" 
",NOT NULL,0.19999999998,1.0,0.8434551732225045,1.0,0.032933284838220014,0.0909090909090909,0.5
8,O3mini-high,LOW,C9,,"Cu ce instrucțiune SQL se creează o vedere, adică o tabelă virtuală care extrage date din tabelele reale?",CREATE VIEW,Este corect,,"['copyright@www.adrian.runceanu.ro\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată']","Din păcate, informația specifică despre instrucțiunea SQL pentru crearea unei vederi nu este prezentă în context. 

Totuși, contextul menționează că o vedere ""este generată de o cerere SQL"". 

Instrucțiunea SQL pentru crearea unei vederi este **CREATE VIEW**. 

Sintaxa generală este:

```sql
CREATE VIEW nume_vedere AS
SELECT coloana1, coloana2, ...
FROM nume_tabelă
WHERE condiție;
```

Unde:

*  `nume_vedere` este numele pe care dorești să-l dai vederii.
*  `SELECT coloana1, coloana2, ...` specifică coloanele pe care dorești să le incluzi în vedere.
*  `nume_tabelă` este numele tabelului din care se extrag datele.
*  `condiție` este o clauză opțională WHERE care filtrează datele incluse în vedere. 
","Cu ce instrucțiune SQL se creează o vedere, adică o tabelă virtuală care extrage date din tabelele reale?","['copyright@www.adrian.runceanu.ro\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată']","Din păcate, informația specifică despre instrucțiunea SQL pentru crearea unei vederi nu este prezentă în context. 

Totuși, contextul menționează că o vedere ""este generată de o cerere SQL"". 

Instrucțiunea SQL pentru crearea unei vederi este **CREATE VIEW**. 

Sintaxa generală este:

```sql
CREATE VIEW nume_vedere AS
SELECT coloana1, coloana2, ...
FROM nume_tabelă
WHERE condiție;
```

Unde:

*  `nume_vedere` este numele pe care dorești să-l dai vederii.
*  `SELECT coloana1, coloana2, ...` specifică coloanele pe care dorești să le incluzi în vedere.
*  `nume_tabelă` este numele tabelului din care se extrag datele.
*  `condiție` este o clauză opțională WHERE care filtrează datele incluse în vedere. 
",CREATE VIEW,0.49999999995,0.0,0.8556319641989744,0.25,0.0,0.03508771929824561,0.33
9,O3mini-high,LOW,C10,,"Ce obiect SQL este folosit pentru a genera automat valori unice, utile de obicei pentru identificatori?",SEQUENCE,Este corect,,"['Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată']","Din păcate, contextul furnizat nu conține informații despre obiecte SQL folosite pentru a genera automat valori unice. Contextul se referă la detaliile unei cărți sau ale unui curs despre baze de date și limbajul SQL. 

Pentru a răspunde la întrebarea ta, obiectul SQL folosit pentru a genera automat valori unice, utile de obicei pentru identificatori, este **secvența** (sequence). 
","Ce obiect SQL este folosit pentru a genera automat valori unice, utile de obicei pentru identificatori?","['Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată']","Din păcate, contextul furnizat nu conține informații despre obiecte SQL folosite pentru a genera automat valori unice. Contextul se referă la detaliile unei cărți sau ale unui curs despre baze de date și limbajul SQL. 

Pentru a răspunde la întrebarea ta, obiectul SQL folosit pentru a genera automat valori unice, utile de obicei pentru identificatori, este **secvența** (sequence). 
",SEQUENCE,0.0,0.0,0.9744596074654828,0.6666666666666666,0.0,0.030303030303030307,0.5
10,O3mini-high,LOW,C11,,"Cu ce instrucțiune SQL se creează un utilizator nou în Oracle, conform politicilor de control al accesului?",CREATE USER,Este corect,,"['copyright@www.adrian.runceanu.ro\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oferă facilităţi din tehnologia OO, prin care se permite \ndefinirea şi utilizarea de obiecte mari şi complexe\n• Optimizează cererile de regăsire prin reutilizarea \ncomenzilor SQL identice lansate de utilizatori diferiţi şi \nprin realizarea unui plan de execuţie a instrucţiunilor \nSQL\n• Are un grad de securitate sporit prin: \n– server de criptare\n– control trafic reţea\n– niveluri de parolare, etc.\n11Curs - Baze de date\nSGBD Oracle 8i (continuare)', 'copyright@www.adrian.runceanu.ro\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oferă facilităţi din tehnologia OO, prin care se permite \ndefinirea şi utilizarea de obiecte mari şi complexe\n• Optimizează cererile de regăsire prin reutilizarea \ncomenzilor SQL identice lansate de utilizatori diferiţi şi \nprin realizarea unui plan de execuţie a instrucţiunilor \nSQL\n• Are un grad de securitate sporit prin: \n– server de criptare\n– control trafic reţea\n– niveluri de parolare, etc.\n11Curs - Baze de date\nSGBD Oracle 8i (continuare)', 'copyright@www.adrian.runceanu.ro\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', 'copyright@www.adrian.runceanu.ro\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată']","Informațiile furnizate în context nu conțin sintaxa SQL pentru crearea unui nou utilizator în Oracle. Pentru a crea un utilizator nou și a-i atribui privilegii în conformitate cu politicile de control al accesului, se utilizează în general instrucțiunea `CREATE USER`  împreună cu  `GRANT`. 

Iată un exemplu generic:

```sql
CREATE USER nume_utilizator IDENTIFIED BY parola;
GRANT connect, resource TO nume_utilizator; 
```

**Explicație:**

* **`CREATE USER nume_utilizator`**:  Această clauză definește numele noului utilizator.
* **`IDENTIFIED BY parola`**:  Această clauză setează o parolă pentru noul utilizator.
* **`GRANT connect, resource TO nume_utilizator`**: Această clauză acordă utilizatorului privilegiile de bază pentru a se conecta la baza de date (`connect`) și a crea obiecte (`resource`).

**Important:**

* Este recomandat să consultați documentația oficială Oracle pentru sintaxa exactă și opțiunile disponibile pentru `CREATE USER` și `GRANT`. 
* Politicile specifice de control al accesului pot necesita acordarea de privilegii suplimentare sau restricționarea accesului la anumite obiecte.
","Cu ce instrucțiune SQL se creează un utilizator nou în Oracle, conform politicilor de control al accesului?","['copyright@www.adrian.runceanu.ro\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oferă facilităţi din tehnologia OO, prin care se permite \ndefinirea şi utilizarea de obiecte mari şi complexe\n• Optimizează cererile de regăsire prin reutilizarea \ncomenzilor SQL identice lansate de utilizatori diferiţi şi \nprin realizarea unui plan de execuţie a instrucţiunilor \nSQL\n• Are un grad de securitate sporit prin: \n– server de criptare\n– control trafic reţea\n– niveluri de parolare, etc.\n11Curs - Baze de date\nSGBD Oracle 8i (continuare)', 'copyright@www.adrian.runceanu.ro\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oferă facilităţi din tehnologia OO, prin care se permite \ndefinirea şi utilizarea de obiecte mari şi complexe\n• Optimizează cererile de regăsire prin reutilizarea \ncomenzilor SQL identice lansate de utilizatori diferiţi şi \nprin realizarea unui plan de execuţie a instrucţiunilor \nSQL\n• Are un grad de securitate sporit prin: \n– server de criptare\n– control trafic reţea\n– niveluri de parolare, etc.\n11Curs - Baze de date\nSGBD Oracle 8i (continuare)', 'copyright@www.adrian.runceanu.ro\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', 'copyright@www.adrian.runceanu.ro\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată']","Informațiile furnizate în context nu conțin sintaxa SQL pentru crearea unui nou utilizator în Oracle. Pentru a crea un utilizator nou și a-i atribui privilegii în conformitate cu politicile de control al accesului, se utilizează în general instrucțiunea `CREATE USER`  împreună cu  `GRANT`. 

Iată un exemplu generic:

```sql
CREATE USER nume_utilizator IDENTIFIED BY parola;
GRANT connect, resource TO nume_utilizator; 
```

**Explicație:**

* **`CREATE USER nume_utilizator`**:  Această clauză definește numele noului utilizator.
* **`IDENTIFIED BY parola`**:  Această clauză setează o parolă pentru noul utilizator.
* **`GRANT connect, resource TO nume_utilizator`**: Această clauză acordă utilizatorului privilegiile de bază pentru a se conecta la baza de date (`connect`) și a crea obiecte (`resource`).

**Important:**

* Este recomandat să consultați documentația oficială Oracle pentru sintaxa exactă și opțiunile disponibile pentru `CREATE USER` și `GRANT`. 
* Politicile specifice de control al accesului pot necesita acordarea de privilegii suplimentare sau restricționarea accesului la anumite obiecte.
",CREATE USER,0.0,0.0,0.8653961975033123,0.125,0.0,0.025157232704402517,0.4
11,O3mini-high,LOW,C12,,"Ce model de baze de date, care organizează datele în tabele interconectate, este descris în acest capitol?",relațional,Este corect,,"['copyright@www.adrian.runceanu.ro\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4', 'copyright@www.adrian.runceanu.ro\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4', 'copyright@www.adrian.runceanu.ro\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22', 'copyright@www.adrian.runceanu.ro\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22', 'copyright@www.adrian.runceanu.ro\n1.1.Sisteme de baze de date\nDatele: \nSunt informaţii pe care diferiţi utilizatori (firme, \nagenţii, sau simpli utilizatori) le colectează pentru a-şi \nîndeplini scopurile sau misiunile. \nDatele individuale sunt stocate în mulţimi de date \nrelaţionate (legate) numite înregistrări. \nO colecţie de înregistrări dependente se numeşte \nbază de date.\nCurs - Baze de date\n 22']","Modelul de baze de date descris în context, care organizează datele în tabele interconectate, este **modelul relațional**. 

Deși textul nu menționează explicit denumirea ""model relațional"", acesta descrie elementele constitutive ale acestui model:

* **Tabele:** Textul menționează ""tabele"" ca fiind unul dintre obiectele ce pot exista într-o bază de date. Tabelele sunt elementele fundamentale ale modelului relațional, unde datele sunt organizate în rânduri și coloane.
* **Interconectare:**  Textul vorbește despre ""mulțimi de date relaționate (legate)"" și ""înregistrări dependente"". Aceste expresii sugerează existența unor relații între diferitele tabele din baza de date, ceea ce este o caracteristică definitorie a modelului relațional. 

Așadar, deși nu este specificat direct, putem deduce din context că modelul de baze de date descris este modelul relațional. 
","Ce model de baze de date, care organizează datele în tabele interconectate, este descris în acest capitol?","['copyright@www.adrian.runceanu.ro\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4', 'copyright@www.adrian.runceanu.ro\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4', 'copyright@www.adrian.runceanu.ro\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22', 'copyright@www.adrian.runceanu.ro\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22', 'copyright@www.adrian.runceanu.ro\n1.1.Sisteme de baze de date\nDatele: \nSunt informaţii pe care diferiţi utilizatori (firme, \nagenţii, sau simpli utilizatori) le colectează pentru a-şi \nîndeplini scopurile sau misiunile. \nDatele individuale sunt stocate în mulţimi de date \nrelaţionate (legate) numite înregistrări. \nO colecţie de înregistrări dependente se numeşte \nbază de date.\nCurs - Baze de date\n 22']","Modelul de baze de date descris în context, care organizează datele în tabele interconectate, este **modelul relațional**. 

Deși textul nu menționează explicit denumirea ""model relațional"", acesta descrie elementele constitutive ale acestui model:

* **Tabele:** Textul menționează ""tabele"" ca fiind unul dintre obiectele ce pot exista într-o bază de date. Tabelele sunt elementele fundamentale ale modelului relațional, unde datele sunt organizate în rânduri și coloane.
* **Interconectare:**  Textul vorbește despre ""mulțimi de date relaționate (legate)"" și ""înregistrări dependente"". Aceste expresii sugerează existența unor relații între diferitele tabele din baza de date, ceea ce este o caracteristică definitorie a modelului relațional. 

Așadar, deși nu este specificat direct, putem deduce din context că modelul de baze de date descris este modelul relațional. 
",relațional,0.0,1.0,0.9388188558353243,0.3,0.016466642419110007,0.029197080291970802,0.0
12,O3mini-high,LOW,C13,,Cu ce cuvânt cheie SQL se definește o cheie primară pentru a asigura identificarea unică a înregistrărilor în modelul relațional?,PRIMARY KEY,Este corect,,"[""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", 'copyright@www.adrian.runceanu.ro\nOrdinea de executie a functiilor de \ngrup\n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei. \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează. \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă. \nCurs 5 - BAZE DE DATE 50', 'copyright@www.adrian.runceanu.ro\nOrdinea de executie a functiilor de \ngrup\n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei. \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează. \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă. \nCurs 5 - BAZE DE DATE 50', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată']","Cuvântul cheie SQL folosit pentru a defini o cheie primară este **PRIMARY KEY**. 
",Cu ce cuvânt cheie SQL se definește o cheie primară pentru a asigura identificarea unică a înregistrărilor în modelul relațional?,"[""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", 'copyright@www.adrian.runceanu.ro\nOrdinea de executie a functiilor de \ngrup\n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei. \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează. \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă. \nCurs 5 - BAZE DE DATE 50', 'copyright@www.adrian.runceanu.ro\nOrdinea de executie a functiilor de \ngrup\n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei. \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează. \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă. \nCurs 5 - BAZE DE DATE 50', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată']","Cuvântul cheie SQL folosit pentru a defini o cheie primară este **PRIMARY KEY**. 
",PRIMARY KEY,0.99999999995,1.0,0.8559814509949555,0.0,0.04573913556123801,0.25,1.0
13,O3mini-high,LOW,C14,,"În proiectarea bazelor de date relaționale, ce etapă transformă modelul conceptual într-un model relațional, pregătind implementarea efectivă a structurii bazei?",modelarea logică,Este corect,,"['copyright@www.adrian.runceanu.ro\n1.4. Modelul de date obiect-relaţional\n Modelul de date obiect-relaţional\n(Object-Relational Model) reprezintă\nextinderea modelului relaţional cu\ncaracteristici ale modelului obiect, extindere\nnecesară pentru realizarea bazelor de date\ncare definesc şi prelucrează tipuri de date\ncomplexe.\nCurs - Baze de date 58', 'copyright@www.adrian.runceanu.ro\n1.4. Modelul de date obiect-relaţional\n Modelul de date obiect-relaţional\n(Object-Relational Model) reprezintă\nextinderea modelului relaţional cu\ncaracteristici ale modelului obiect, extindere\nnecesară pentru realizarea bazelor de date\ncare definesc şi prelucrează tipuri de date\ncomplexe.\nCurs - Baze de date 58', 'copyright@www.adrian.runceanu.ro\n1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\nCurs - Baze de date 36', 'copyright@www.adrian.runceanu.ro\n1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\nCurs - Baze de date 36', 'copyright@www.adrian.runceanu.ro\nConcepte de bază din teoria relațională a bazelor de \ndate\n➢Înainte de a începe să realizăm o aplicaţie cu \nbaze de date relaţionale trebuie să cunoaştem \nprincipalele concepte din teoria relaţională.\n➢Acestea sunt absolut necesare, atât pentru \nanaliza şi proiectarea bazei de date \nrelaţionale, cât şi pentru elaborarea \nprogramelor de aplicaţie într-un SGBD \nrelaţional ales.\nCurs - Baze de date 47']","Informațiile din context nu oferă un răspuns direct la întrebarea referitoare la etapa specifică de transformare a unui model conceptual într-un model relațional. Textele furnizate descriu modelul relațional și modelul obiect-relațional, dar nu detaliază procesul de proiectare a bazelor de date.

Etapa căutată în proiectarea bazelor de date relaționale, care transformă modelul conceptual într-un model relațional, se numește **proiectare logică**. Această etapă implică maparea entităților și relațiilor din modelul conceptual în tabele, coloane și constrângeri specifice modelului relațional. 
","În proiectarea bazelor de date relaționale, ce etapă transformă modelul conceptual într-un model relațional, pregătind implementarea efectivă a structurii bazei?","['copyright@www.adrian.runceanu.ro\n1.4. Modelul de date obiect-relaţional\n Modelul de date obiect-relaţional\n(Object-Relational Model) reprezintă\nextinderea modelului relaţional cu\ncaracteristici ale modelului obiect, extindere\nnecesară pentru realizarea bazelor de date\ncare definesc şi prelucrează tipuri de date\ncomplexe.\nCurs - Baze de date 58', 'copyright@www.adrian.runceanu.ro\n1.4. Modelul de date obiect-relaţional\n Modelul de date obiect-relaţional\n(Object-Relational Model) reprezintă\nextinderea modelului relaţional cu\ncaracteristici ale modelului obiect, extindere\nnecesară pentru realizarea bazelor de date\ncare definesc şi prelucrează tipuri de date\ncomplexe.\nCurs - Baze de date 58', 'copyright@www.adrian.runceanu.ro\n1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\nCurs - Baze de date 36', 'copyright@www.adrian.runceanu.ro\n1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\nCurs - Baze de date 36', 'copyright@www.adrian.runceanu.ro\nConcepte de bază din teoria relațională a bazelor de \ndate\n➢Înainte de a începe să realizăm o aplicaţie cu \nbaze de date relaţionale trebuie să cunoaştem \nprincipalele concepte din teoria relaţională.\n➢Acestea sunt absolut necesare, atât pentru \nanaliza şi proiectarea bazei de date \nrelaţionale, cât şi pentru elaborarea \nprogramelor de aplicaţie într-un SGBD \nrelaţional ales.\nCurs - Baze de date 47']","Informațiile din context nu oferă un răspuns direct la întrebarea referitoare la etapa specifică de transformare a unui model conceptual într-un model relațional. Textele furnizate descriu modelul relațional și modelul obiect-relațional, dar nu detaliază procesul de proiectare a bazelor de date.

Etapa căutată în proiectarea bazelor de date relaționale, care transformă modelul conceptual într-un model relațional, se numește **proiectare logică**. Această etapă implică maparea entităților și relațiilor din modelul conceptual în tabele, coloane și constrângeri specifice modelului relațional. 
",modelarea logică,0.0,0.0,0.8761490037015056,0.6,0.0,0.020833333333333336,0.57
14,O3mini-high,Medium,Curs 1,,"Ce este o bază de date, conform cursului?","O bază de date este o colecție organizată de date stocate electronic, care permite accesul, gestionarea și actualizarea eficientă a acestora.",Este corect,,"['copyright@www.adrian.runceanu.ro\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4', 'copyright@www.adrian.runceanu.ro\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4', 'copyright@www.adrian.runceanu.ro\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nSisteme de baze de date\nAlte clasificari ale sistemelor de baze de date:\n1. Clasificare după numărul de utilizatori\n2. Clasificare după numărul de staţii pe care este \nstocată baza de date\nCurs - Baze de date 66']","Conform informațiilor din context, o bază de date conține:

*  **Tabele:** Structuri fundamentale ce organizează datele în rânduri și coloane.
*  **Vederi (views):** Reprezentări virtuale ale datelor din una sau mai multe tabele, oferind o perspectivă specifică asupra informațiilor.
*  **Secvențe:** Obiecte ce generează automat numere unice, folosite de obicei pentru a crea chei primare.
*  **Indecși:** Structuri auxiliare ce accelerează căutarea și regăsirea datelor din tabele.
*  **Sinonime:** Nume alternative atribuite tabelelor sau altor obiecte din baza de date, simplificând accesul la acestea. 
","Ce este o bază de date, conform cursului?","['copyright@www.adrian.runceanu.ro\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4', 'copyright@www.adrian.runceanu.ro\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4', 'copyright@www.adrian.runceanu.ro\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nSisteme de baze de date\nAlte clasificari ale sistemelor de baze de date:\n1. Clasificare după numărul de utilizatori\n2. Clasificare după numărul de staţii pe care este \nstocată baza de date\nCurs - Baze de date 66']","Conform informațiilor din context, o bază de date conține:

*  **Tabele:** Structuri fundamentale ce organizează datele în rânduri și coloane.
*  **Vederi (views):** Reprezentări virtuale ale datelor din una sau mai multe tabele, oferind o perspectivă specifică asupra informațiilor.
*  **Secvențe:** Obiecte ce generează automat numere unice, folosite de obicei pentru a crea chei primare.
*  **Indecși:** Structuri auxiliare ce accelerează căutarea și regăsirea datelor din tabele.
*  **Sinonime:** Nume alternative atribuite tabelelor sau altor obiecte din baza de date, simplificând accesul la acestea. 
","O bază de date este o colecție organizată de date stocate electronic, care permite accesul, gestionarea și actualizarea eficientă a acestora.",0.0,0.0,0.7862277903682925,0.38461538461538464,0.017382774935542994,0.14414414414414414,0.0
15,O3mini-high,Medium,Curs 2,,Ce reprezintă Oracle în cursul prezentat?,"Oracle este un SGBD complet relațional, extins, cu facilități din tehnologia orientată obiect, operațional pe toată gama de calculatoare.",Este corect,sllde 5,"['2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43Curs - Baze de date', '2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\nConfirmarea privilegiilor acordate\n➢Daca se încearca sa se efectueze o operatie \nneautorizata – de exemplu stergerea unui rând \ndintr-o tabela asupra careia nu avem \nprivilegiul DELETE – serverul Oracle nu va \npermite ca operatia sa fie efectuata.\nCurs - BAZE DE DATE 42', 'copyright@www.adrian.runceanu.ro\nConfirmarea privilegiilor acordate\n➢Daca se încearca sa se efectueze o operatie \nneautorizata – de exemplu stergerea unui rând \ndintr-o tabela asupra careia nu avem \nprivilegiul DELETE – serverul Oracle nu va \npermite ca operatia sa fie efectuata.\nCurs - BAZE DE DATE 42', '2.4. ORACLE Database 11g Expres Edition\nPas 1: Se porneste instalarea fisierului executabil si se vor \nurma pasii indicati de catre programul de instalare.\n42Curs - Baze de date']","Din textul furnizat, înțelegem că ""Oracle"" se referă la **""ORACLE Database 11g Express Edition""**.  

Textul menționează  ""instalarea fisierului executabil"" și ""introducerea unei parole pentru utilizatorul SYS si pentru SYSTEM"", sugerând că Oracle este un **sistem de gestionare a bazelor de date (SGBD)**. 
",Ce reprezintă Oracle în cursul prezentat?,"['2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43Curs - Baze de date', '2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\nConfirmarea privilegiilor acordate\n➢Daca se încearca sa se efectueze o operatie \nneautorizata – de exemplu stergerea unui rând \ndintr-o tabela asupra careia nu avem \nprivilegiul DELETE – serverul Oracle nu va \npermite ca operatia sa fie efectuata.\nCurs - BAZE DE DATE 42', 'copyright@www.adrian.runceanu.ro\nConfirmarea privilegiilor acordate\n➢Daca se încearca sa se efectueze o operatie \nneautorizata – de exemplu stergerea unui rând \ndintr-o tabela asupra careia nu avem \nprivilegiul DELETE – serverul Oracle nu va \npermite ca operatia sa fie efectuata.\nCurs - BAZE DE DATE 42', '2.4. ORACLE Database 11g Expres Edition\nPas 1: Se porneste instalarea fisierului executabil si se vor \nurma pasii indicati de catre programul de instalare.\n42Curs - Baze de date']","Din textul furnizat, înțelegem că ""Oracle"" se referă la **""ORACLE Database 11g Express Edition""**.  

Textul menționează  ""instalarea fisierului executabil"" și ""introducerea unei parole pentru utilizatorul SYS si pentru SYSTEM"", sugerând că Oracle este un **sistem de gestionare a bazelor de date (SGBD)**. 
","Oracle este un SGBD complet relațional, extins, cu facilități din tehnologia orientată obiect, operațional pe toată gama de calculatoare.",0.0,0.0,0.837067859907029,1.0,0.01958224832501124,0.11940298507462685,0.22
16,O3mini-high,Medium,Curs 3,,Ce face clauza ORDER BY într-o interogare SELECT?,"ORDER BY sortează liniile rezultatului conform criteriilor specificate; fără aceasta, ordinea rezultatelor este independentă de ordinea inserării.",Este corect,sllde 6,"['copyright@www.adrian.runceanu.ro\nClauza ORDER BY\n➢În clauza ORDER BY se pot folosi coloane care nu sunt \nconţinute în SELECT.\n \nExemplu: \n  Listaţi toţi angajaţii ordonându-i după salariu (în \nordine crescătoare).\nSELECT ename, job\nFROM EMP\nORDER BY sal;  \nCurs - Baze de date 80', 'copyright@www.adrian.runceanu.ro\nClauza ORDER BY\n➢În clauza ORDER BY se pot folosi coloane care nu sunt \nconţinute în SELECT.\n \nExemplu: \n  Listaţi toţi angajaţii ordonându-i după salariu (în \nordine crescătoare).\nSELECT ename, job\nFROM EMP\nORDER BY sal;  \nCurs - Baze de date 80', 'copyright@www.adrian.runceanu.ro\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\nCurs - Baze de date 6', 'copyright@www.adrian.runceanu.ro\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\nCurs - Baze de date 6', 'copyright@www.adrian.runceanu.ro\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8']","Clauza `ORDER BY` într-o interogare `SELECT` este folosită pentru a sorta rezultatele interogării în funcție de una sau mai multe coloane. 

Iată câteva puncte cheie despre clauza `ORDER BY`:

* **Sortarea rezultatelor:** Serverul va sorta rezultatele interogării în funcție de criteriile specificate în clauza `ORDER BY` înainte de a le trimite înapoi.
* **Coloane specificate:** Puteți specifica una sau mai multe coloane în clauza `ORDER BY` pentru a sorta rezultatele. Aceste coloane pot fi incluse sau nu în clauza `SELECT`.
* **Ordinea sortării:** Puteți specifica ordinea sortării (ascendentă sau descendentă) pentru fiecare coloană folosind cuvintele cheie `ASC` (implicit) sau `DESC`.
* **Poziția în interogare:**  Într-o instrucțiune `SELECT` se poate folosi o singură clauză `ORDER BY` și, dacă se folosește, trebuie să fie ultima clauză a interogării principale. Un subquery nu poate avea propria clauză `ORDER BY`.
* **Lipsa ORDER BY:** În cazul în care `ORDER BY` lipsește, liniile din rezultat sunt într-o ordine independentă de conținutul lor sau de ordinea în care ele au fost adăugate în tabela.

**Exemplu:**

Pentru a lista toți angajații ordonându-i după salariu în ordine crescătoare, ați utiliza următoarea interogare:

```sql
SELECT ename, job
FROM EMP
ORDER BY sal; 
```

Această interogare va returna o listă cu numele și slujbele tuturor angajaților, sortați în ordine crescătoare a salariului lor, chiar dacă coloana `sal` nu este inclusă în clauza `SELECT`.
",Ce face clauza ORDER BY într-o interogare SELECT?,"['copyright@www.adrian.runceanu.ro\nClauza ORDER BY\n➢În clauza ORDER BY se pot folosi coloane care nu sunt \nconţinute în SELECT.\n \nExemplu: \n  Listaţi toţi angajaţii ordonându-i după salariu (în \nordine crescătoare).\nSELECT ename, job\nFROM EMP\nORDER BY sal;  \nCurs - Baze de date 80', 'copyright@www.adrian.runceanu.ro\nClauza ORDER BY\n➢În clauza ORDER BY se pot folosi coloane care nu sunt \nconţinute în SELECT.\n \nExemplu: \n  Listaţi toţi angajaţii ordonându-i după salariu (în \nordine crescătoare).\nSELECT ename, job\nFROM EMP\nORDER BY sal;  \nCurs - Baze de date 80', 'copyright@www.adrian.runceanu.ro\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\nCurs - Baze de date 6', 'copyright@www.adrian.runceanu.ro\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\nCurs - Baze de date 6', 'copyright@www.adrian.runceanu.ro\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8']","Clauza `ORDER BY` într-o interogare `SELECT` este folosită pentru a sorta rezultatele interogării în funcție de una sau mai multe coloane. 

Iată câteva puncte cheie despre clauza `ORDER BY`:

* **Sortarea rezultatelor:** Serverul va sorta rezultatele interogării în funcție de criteriile specificate în clauza `ORDER BY` înainte de a le trimite înapoi.
* **Coloane specificate:** Puteți specifica una sau mai multe coloane în clauza `ORDER BY` pentru a sorta rezultatele. Aceste coloane pot fi incluse sau nu în clauza `SELECT`.
* **Ordinea sortării:** Puteți specifica ordinea sortării (ascendentă sau descendentă) pentru fiecare coloană folosind cuvintele cheie `ASC` (implicit) sau `DESC`.
* **Poziția în interogare:**  Într-o instrucțiune `SELECT` se poate folosi o singură clauză `ORDER BY` și, dacă se folosește, trebuie să fie ultima clauză a interogării principale. Un subquery nu poate avea propria clauză `ORDER BY`.
* **Lipsa ORDER BY:** În cazul în care `ORDER BY` lipsește, liniile din rezultat sunt într-o ordine independentă de conținutul lor sau de ordinea în care ele au fost adăugate în tabela.

**Exemplu:**

Pentru a lista toți angajații ordonându-i după salariu în ordine crescătoare, ați utiliza următoarea interogare:

```sql
SELECT ename, job
FROM EMP
ORDER BY sal; 
```

Această interogare va returna o listă cu numele și slujbele tuturor angajaților, sortați în ordine crescătoare a salariului lor, chiar dacă coloana `sal` nu este inclusă în clauza `SELECT`.
","ORDER BY sortează liniile rezultatului conform criteriilor specificate; fără aceasta, ordinea rezultatelor este independentă de ordinea inserării.",0.99999999998,1.0,0.8506681089608374,0.6875,0.035823421191287175,0.05283018867924528,0.57
17,O3mini-high,Medium,Curs 4,,"În ce două categorii se împart funcțiile în SQL, conform cursului?",Funcțiile se clasifică în: 1. Funcții referitoare la o singură înregistrare; 2. Funcții referitoare la mai multe înregistrări (funcții de grup).,Este corect,slide 8,"['Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată']","Din păcate, nu pot răspunde la întrebarea ta. Deși contextul oferă informații despre un curs despre limbajul SQL, nu menționează nimic despre cele două categorii de funcții din SQL. 
","În ce două categorii se împart funcțiile în SQL, conform cursului?","['Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată']","Din păcate, nu pot răspunde la întrebarea ta. Deși contextul oferă informații despre un curs despre limbajul SQL, nu menționează nimic despre cele două categorii de funcții din SQL. 
",Funcțiile se clasifică în: 1. Funcții referitoare la o singură înregistrare; 2. Funcții referitoare la mai multe înregistrări (funcții de grup).,0.0,0.0,0.0,1.0,0.04767707020457095,0.13114754098360656,0.0
18,O3mini-high,Medium,Curs 5,,"Ce sunt funcțiile de grup în SQL, conform cursului?","Funcțiile de grup operează pe un set de rânduri, returnând un singur rezultat pentru fiecare grup (ex. AVG, COUNT, SUM).",Este corect,slide 14,"['copyright@www.adrian.runceanu.ro\nOrdinea de executie a functiilor de \ngrup\n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei. \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează. \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă. \nCurs 5 - BAZE DE DATE 50', 'copyright@www.adrian.runceanu.ro\nOrdinea de executie a functiilor de \ngrup\n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei. \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează. \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă. \nCurs 5 - BAZE DE DATE 50', 'copyright@www.adrian.runceanu.ro\nOrdinea de executie a functiilor de \ngrup\n Serverul Oracle execută funcţiile de grup într-o \nanumită ordine:\n1. Selecţia rândurilor ce respectă clauza WHERE \n2. Gruparea rândurilor obţinute, respectând clauza \nGROUP BY \n3. Calcularea rezultatelor funcţiilor de grup pentru \nfiecare grup în parte \n4. Eliminarea grupurilor ce nu respectă clauza HAVING \n5. Ordonarea rezultatelor respectând clauza GROUP BY.\nCurs 5 - BAZE DE DATE 49', 'copyright@www.adrian.runceanu.ro\nOrdinea de executie a functiilor de \ngrup\n Serverul Oracle execută funcţiile de grup într-o \nanumită ordine:\n1. Selecţia rândurilor ce respectă clauza WHERE \n2. Gruparea rândurilor obţinute, respectând clauza \nGROUP BY \n3. Calcularea rezultatelor funcţiilor de grup pentru \nfiecare grup în parte \n4. Eliminarea grupurilor ce nu respectă clauza HAVING \n5. Ordonarea rezultatelor respectând clauza GROUP BY.\nCurs 5 - BAZE DE DATE 49', 'copyright@www.adrian.runceanu.ro\n4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17']","Din păcate, informațiile furnizate nu oferă o listă explicită cu funcțiile de grup din SQL. Textul menționează doar ordinea de execuție a acestor funcții, dar nu și exemple concrete. 

Pentru a obține o listă cu funcțiile de grup din SQL, ar trebui să cauți informații suplimentare în cursul menționat sau în altă sursă de informare despre SQL. 
","Ce sunt funcțiile de grup în SQL, conform cursului?","['copyright@www.adrian.runceanu.ro\nOrdinea de executie a functiilor de \ngrup\n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei. \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează. \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă. \nCurs 5 - BAZE DE DATE 50', 'copyright@www.adrian.runceanu.ro\nOrdinea de executie a functiilor de \ngrup\n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei. \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează. \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă. \nCurs 5 - BAZE DE DATE 50', 'copyright@www.adrian.runceanu.ro\nOrdinea de executie a functiilor de \ngrup\n Serverul Oracle execută funcţiile de grup într-o \nanumită ordine:\n1. Selecţia rândurilor ce respectă clauza WHERE \n2. Gruparea rândurilor obţinute, respectând clauza \nGROUP BY \n3. Calcularea rezultatelor funcţiilor de grup pentru \nfiecare grup în parte \n4. Eliminarea grupurilor ce nu respectă clauza HAVING \n5. Ordonarea rezultatelor respectând clauza GROUP BY.\nCurs 5 - BAZE DE DATE 49', 'copyright@www.adrian.runceanu.ro\nOrdinea de executie a functiilor de \ngrup\n Serverul Oracle execută funcţiile de grup într-o \nanumită ordine:\n1. Selecţia rândurilor ce respectă clauza WHERE \n2. Gruparea rândurilor obţinute, respectând clauza \nGROUP BY \n3. Calcularea rezultatelor funcţiilor de grup pentru \nfiecare grup în parte \n4. Eliminarea grupurilor ce nu respectă clauza HAVING \n5. Ordonarea rezultatelor respectând clauza GROUP BY.\nCurs 5 - BAZE DE DATE 49', 'copyright@www.adrian.runceanu.ro\n4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17']","Din păcate, informațiile furnizate nu oferă o listă explicită cu funcțiile de grup din SQL. Textul menționează doar ordinea de execuție a acestor funcții, dar nu și exemple concrete. 

Pentru a obține o listă cu funcțiile de grup din SQL, ar trebui să cauți informații suplimentare în cursul menționat sau în altă sursă de informare despre SQL. 
","Funcțiile de grup operează pe un set de rânduri, returnând un singur rezultat pentru fiecare grup (ex. AVG, COUNT, SUM).",0.19999999998,0.0,0.0,0.6,0.04487525652041662,0.15384615384615385,0.0
19,O3mini-high,Medium,Curs 6,,Ce este o subinterogare (subquery) în SQL?,"O subinterogare este o instrucțiune SELECT inclusă într-o altă instrucțiune, executată prima, iar rezultatul ei este folosit de interogarea principală.",Este corect,"slide 4,5","['copyright@www.adrian.runceanu.ro\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4', 'copyright@www.adrian.runceanu.ro\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10']","O subinterogare (subquery) în SQL este o instrucțiune SELECT care este inclusă în clauza unei alte instrucțiuni SELECT. Aceasta ne permite să aflăm o informație care ne este necesară pentru a obține informația dorită. 
",Ce este o subinterogare (subquery) în SQL?,"['copyright@www.adrian.runceanu.ro\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4', 'copyright@www.adrian.runceanu.ro\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10']","O subinterogare (subquery) în SQL este o instrucțiune SELECT care este inclusă în clauza unei alte instrucțiuni SELECT. Aceasta ne permite să aflăm o informație care ne este necesară pentru a obține informația dorită. 
","O subinterogare este o instrucțiune SELECT inclusă într-o altă instrucțiune, executată prima, iar rezultatul ei este folosit de interogarea principală.",0.99999999995,0.0,0.8947337151037313,1.0,0.13183313065480148,0.34920634920634924,0.0
20,O3mini-high,Medium,Curs 7,,Ce permite limbajul de manipulare al datelor (DML) în SQL?,"DML permite adăugarea, modificarea și ștergerea datelor din baza de date, fiind nucleul limbajului SQL.",Este corect,slide 4,"['copyright@www.adrian.runceanu.ro\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4', 'copyright@www.adrian.runceanu.ro\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4', 'copyright@www.adrian.runceanu.ro\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59Curs - Baze de date']","Limbajul de manipulare al datelor (DML) în SQL permite **adăugarea, actualizarea și ștergerea datelor din baza de date**. 
",Ce permite limbajul de manipulare al datelor (DML) în SQL?,"['copyright@www.adrian.runceanu.ro\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4', 'copyright@www.adrian.runceanu.ro\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4', 'copyright@www.adrian.runceanu.ro\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59Curs - Baze de date']","Limbajul de manipulare al datelor (DML) în SQL permite **adăugarea, actualizarea și ștergerea datelor din baza de date**. 
","DML permite adăugarea, modificarea și ștergerea datelor din baza de date, fiind nucleul limbajului SQL.",0.99999999995,1.0,0.881791634782337,1.0,0.27274191069381915,0.6285714285714286,0.86
21,O3mini-high,Medium,Curs 8,,"Ce definește constrângerea FOREIGN KEY în SQL, conform cursului?","FOREIGN KEY stabilește o relație între coloana din tabela copil și cheia primară a tabelei părinte, asigurând integritatea referențială.",Este corect,slide 21,"['copyright@www.adrian.runceanu.ro\nExemplu\nSe poate adăuga o constrângere şi unei tabele existent (nu \nnumai odată cu crearea lui).\nÎn următorul exemplu vom creea o constrângere FOREIGN \nKEY în tabela EMP. \nConstrângerea asigură existenţa unui manager dacă \nexistă angajat în tabela EMP.\nALTER TABLE EMP\nADD CONSTRAINT FK_Mgr \nFOREIGN KEY(Mgr) REFERENCES EMP (empno)\nCurs 8 - BAZE DE DATE 31\n', 'copyright@www.adrian.runceanu.ro\nExemplu\nSe poate adăuga o constrângere şi unei tabele existent (nu \nnumai odată cu crearea lui).\nÎn următorul exemplu vom creea o constrângere FOREIGN \nKEY în tabela EMP. \nConstrângerea asigură existenţa unui manager dacă \nexistă angajat în tabela EMP.\nALTER TABLE EMP\nADD CONSTRAINT FK_Mgr \nFOREIGN KEY(Mgr) REFERENCES EMP (empno)\nCurs 8 - BAZE DE DATE 31\n', ""2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n); \n \n "", ""2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n); \n \n "", 'copyright@www.adrian.runceanu.ro\nConstrângerea FOREIGN KEY\n• Constrângerea FOREIGN KEY defineşte o coloană \nsau o combinaţie de coloane ca foreign key şi \nstabileşte o relaţie între o cheie primară şi una unică \nîn aceeaşi tabela sau în tabele diferite. \n• O valoare care apare într-o tabela trebuie să se \nregăsească şi în cea de-a 2-a tabela, pe coloana \nunde formează cheia primară. \n• Constrângerile de tip FOREIGN KEY pot fi definite la \nnivel de coloană sau tabela.\nCurs 8 - BAZE DE DATE 21']","Conform cursului, constrângerea FOREIGN KEY în SQL definește o coloană sau o combinație de coloane ca foreign key și stabilește o relație între o cheie primară și una unică, fie în aceeași tabelă, fie în tabele diferite.  

Practic, o valoare care apare într-o tabelă, la coloana definită ca foreign key, trebuie să existe și în a doua tabelă, la coloana definită ca primary key. Această constrângere asigură referențialitatea corectă între tabele.
","Ce definește constrângerea FOREIGN KEY în SQL, conform cursului?","['copyright@www.adrian.runceanu.ro\nExemplu\nSe poate adăuga o constrângere şi unei tabele existent (nu \nnumai odată cu crearea lui).\nÎn următorul exemplu vom creea o constrângere FOREIGN \nKEY în tabela EMP. \nConstrângerea asigură existenţa unui manager dacă \nexistă angajat în tabela EMP.\nALTER TABLE EMP\nADD CONSTRAINT FK_Mgr \nFOREIGN KEY(Mgr) REFERENCES EMP (empno)\nCurs 8 - BAZE DE DATE 31\n', 'copyright@www.adrian.runceanu.ro\nExemplu\nSe poate adăuga o constrângere şi unei tabele existent (nu \nnumai odată cu crearea lui).\nÎn următorul exemplu vom creea o constrângere FOREIGN \nKEY în tabela EMP. \nConstrângerea asigură existenţa unui manager dacă \nexistă angajat în tabela EMP.\nALTER TABLE EMP\nADD CONSTRAINT FK_Mgr \nFOREIGN KEY(Mgr) REFERENCES EMP (empno)\nCurs 8 - BAZE DE DATE 31\n', ""2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n); \n \n "", ""2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n); \n \n "", 'copyright@www.adrian.runceanu.ro\nConstrângerea FOREIGN KEY\n• Constrângerea FOREIGN KEY defineşte o coloană \nsau o combinaţie de coloane ca foreign key şi \nstabileşte o relaţie între o cheie primară şi una unică \nîn aceeaşi tabela sau în tabele diferite. \n• O valoare care apare într-o tabela trebuie să se \nregăsească şi în cea de-a 2-a tabela, pe coloana \nunde formează cheia primară. \n• Constrângerile de tip FOREIGN KEY pot fi definite la \nnivel de coloană sau tabela.\nCurs 8 - BAZE DE DATE 21']","Conform cursului, constrângerea FOREIGN KEY în SQL definește o coloană sau o combinație de coloane ca foreign key și stabilește o relație între o cheie primară și una unică, fie în aceeași tabelă, fie în tabele diferite.  

Practic, o valoare care apare într-o tabelă, la coloana definită ca foreign key, trebuie să existe și în a doua tabelă, la coloana definită ca primary key. Această constrângere asigură referențialitatea corectă între tabele.
","FOREIGN KEY stabilește o relație între coloana din tabela copil și cheia primară a tabelei părinte, asigurând integritatea referențială.",0.99999999998,1.0,0.8669808918346295,1.0,0.07569298710889658,0.25,0.57
22,O3mini-high,Medium,Curs 9,,"Ce este o vedere (view) în SQL, conform cursului?","O vedere este o tabelă logică generată printr-o instrucțiune SELECT, fără a stoca date proprii, ci extrăgându-le din tabele.",Este corect,slide 4,"['copyright@www.adrian.runceanu.ro\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nPentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22', 'copyright@www.adrian.runceanu.ro\nPentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3']","O vedere (view) în SQL, conform cursului, este generată de o cerere SQL și are un nume. 
","Ce este o vedere (view) în SQL, conform cursului?","['copyright@www.adrian.runceanu.ro\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nPentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22', 'copyright@www.adrian.runceanu.ro\nPentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3']","O vedere (view) în SQL, conform cursului, este generată de o cerere SQL și are un nume. 
","O vedere este o tabelă logică generată printr-o instrucțiune SELECT, fără a stoca date proprii, ci extrăgându-le din tabele.",0.99999999995,0.0,0.8989348908160504,1.0,0.047369900721408766,0.2380952380952381,0.5
23,O3mini-high,Medium,Curs 10,,"De ce se folosesc secvențele în SQL, potrivit cursului?","Secvențele generează automat numere întregi unice, esențiale pentru chei primare, evitând problemele de sincronizare.",Este corect,slide 8,"['copyright@www.adrian.runceanu.ro\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', 'copyright@www.adrian.runceanu.ro\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', ""copyright@www.adrian.runceanu.ro\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n"", ""copyright@www.adrian.runceanu.ro\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n"", 'copyright@www.adrian.runceanu.ro\ntt\n1) Securitatea sistemului acopera accesarea si \nutilizarea bazei de date la nivelul sistemului, cum \nar fi: numele utilizatorului si parola, spatiul pe \ndisc alocat utilizatorilor, si operatiile de sistem \npermise utilizatorilor. \nCurs - BAZE DE DATE 6\nhttps://www.scnsoft.com/blog/database-security-best-practices']","Nu există informații în contextul furnizat despre motivul pentru care se folosesc secvențele în SQL. Textul face referire la sinonime și oferă un exemplu de utilizare a unei secvențe pentru inserarea datelor într-o tabelă, dar nu explică **de ce** sunt utile secvențele. 
","De ce se folosesc secvențele în SQL, potrivit cursului?","['copyright@www.adrian.runceanu.ro\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', 'copyright@www.adrian.runceanu.ro\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', ""copyright@www.adrian.runceanu.ro\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n"", ""copyright@www.adrian.runceanu.ro\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n"", 'copyright@www.adrian.runceanu.ro\ntt\n1) Securitatea sistemului acopera accesarea si \nutilizarea bazei de date la nivelul sistemului, cum \nar fi: numele utilizatorului si parola, spatiul pe \ndisc alocat utilizatorilor, si operatiile de sistem \npermise utilizatorilor. \nCurs - BAZE DE DATE 6\nhttps://www.scnsoft.com/blog/database-security-best-practices']","Nu există informații în contextul furnizat despre motivul pentru care se folosesc secvențele în SQL. Textul face referire la sinonime și oferă un exemplu de utilizare a unei secvențe pentru inserarea datelor într-o tabelă, dar nu explică **de ce** sunt utile secvențele. 
","Secvențele generează automat numere întregi unice, esențiale pentru chei primare, evitând problemele de sincronizare.",0.4166666666458333,0.0,0.0,1.0,0.022999219724159393,0.125,0.0
24,O3mini-high,Medium,Curs 11,,"Ce acoperă securitatea bazei de date, conform cursului?","Securitatea bazei de date acoperă controlul accesului, acordarea privilegiilor de sistem și obiect, protejând datele într-un mediu multi-user.",Este corect,slide 4,"['copyright@www.adrian.runceanu.ro\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5', 'copyright@www.adrian.runceanu.ro\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5', 'copyright@www.adrian.runceanu.ro\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4']","Conform cursului, securitatea bazei de date poate fi clasificată în două categorii:

1. **Securitatea sistemului:** Aceasta se referă la măsurile de securitate implementate la nivel de sistem pentru a proteja baza de date în ansamblu. Aceasta poate include controlul accesului la serverul bazei de date, configurarea firewall-urilor și implementarea politicilor de securitate.

2. **Securitatea datelor:** Aceasta se referă la măsurile de securitate implementate pentru a proteja datele stocate în baza de date. Aceasta poate include criptarea datelor, controlul accesului la nivel de rând și coloană, precum și auditarea accesului la date. 
","Ce acoperă securitatea bazei de date, conform cursului?","['copyright@www.adrian.runceanu.ro\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5', 'copyright@www.adrian.runceanu.ro\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5', 'copyright@www.adrian.runceanu.ro\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4']","Conform cursului, securitatea bazei de date poate fi clasificată în două categorii:

1. **Securitatea sistemului:** Aceasta se referă la măsurile de securitate implementate la nivel de sistem pentru a proteja baza de date în ansamblu. Aceasta poate include controlul accesului la serverul bazei de date, configurarea firewall-urilor și implementarea politicilor de securitate.

2. **Securitatea datelor:** Aceasta se referă la măsurile de securitate implementate pentru a proteja datele stocate în baza de date. Aceasta poate include criptarea datelor, controlul accesului la nivel de rând și coloană, precum și auditarea accesului la date. 
","Securitatea bazei de date acoperă controlul accesului, acordarea privilegiilor de sistem și obiect, protejând datele într-un mediu multi-user.",0.4166666666458333,1.0,0.825976615427061,0.1111111111111111,0.07046301658803543,0.15517241379310343,0.0
25,O3mini-high,Medium,Curs 12,,"Care sunt avantajele bazelor de date față de fișierele tradiționale, conform cursului?","Avantajele: elimină redundanța, îmbunătățesc integritatea, oferă acces flexibil și securitate sporită.",Este corect,pagina 1,"['copyright@www.adrian.runceanu.ro\nOrice firmă utilizează baze de date pentru păstrarea \nşi gestionarea informaţiilor. Câteva astfel de aplicaţii sunt \nuzuale:\n1.bazele de date ale liniilor aeriene care sunt accesate \nsimultan din sute de agenţii pentru a realiza rezervări şi \nvânzări de locuri pentru date şi zboruri diferite\n2.bazele de date ale băncilor care permit realizarea a mii \nde tranzacţii zilnic\n3.bazele de date ale supermagazinelor care sunt accesate \natât de la casele de marcaj cât şi de la echipamentele de \ninventariere\n4.bazele de date ale bibliotecilor care păstrează milioane \nde titluri şi permit localizarea unei lucrări folosind diferite \ncriterii (cuvinte cheie, titlu, autori, domeniu)\nCurs - Baze de date 17', 'copyright@www.adrian.runceanu.ro\nOrice firmă utilizează baze de date pentru păstrarea \nşi gestionarea informaţiilor. Câteva astfel de aplicaţii sunt \nuzuale:\n1.bazele de date ale liniilor aeriene care sunt accesate \nsimultan din sute de agenţii pentru a realiza rezervări şi \nvânzări de locuri pentru date şi zboruri diferite\n2.bazele de date ale băncilor care permit realizarea a mii \nde tranzacţii zilnic\n3.bazele de date ale supermagazinelor care sunt accesate \natât de la casele de marcaj cât şi de la echipamentele de \ninventariere\n4.bazele de date ale bibliotecilor care păstrează milioane \nde titluri şi permit localizarea unei lucrări folosind diferite \ncriterii (cuvinte cheie, titlu, autori, domeniu)\nCurs - Baze de date 17', 'copyright@www.adrian.runceanu.ro\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4']","Contextul furnizat nu oferă o comparație directă între bazele de date și fișierele tradiționale. Informațiile se concentrează pe exemple de utilizare a bazelor de date și pe tipurile de obiecte dintr-o bază de date. 

Pentru a putea răspunde la întrebarea despre avantajele bazelor de date față de fișierele tradiționale, ar fi nevoie de informații suplimentare din curs care să acopere subiecte precum:

* **Gestionarea redundanței datelor:** Bazele de date sunt concepute pentru a minimiza redundanța datelor, în timp ce fișierele tradiționale pot duce la duplicarea informațiilor.
* **Consistența și integritatea datelor:** Bazele de date impun reguli de integritate pentru a asigura coerența datelor, în timp ce fișierele tradiționale sunt mai predispuse la erori și inconsistențe.
* **Securitatea datelor:** Bazele de date oferă mecanisme avansate de control al accesului și securitate a datelor, în comparație cu fișierele tradiționale.
* **Accesul concurent:** Bazele de date permit accesul simultan al mai multor utilizatori la date, în timp ce fișierele tradiționale pot întâmpina probleme de blocare a fișierelor.
* **Scalabilitate:** Bazele de date sunt proiectate pentru a gestiona volume mari de date și pentru a se adapta creșterii, în timp ce fișierele tradiționale pot deveni greu de gestionat odată cu creșterea volumului de informații.

Prin urmare, fără aceste informații suplimentare din curs, nu putem oferi un răspuns complet la întrebarea despre avantajele bazelor de date față de fișierele tradiționale. 
","Care sunt avantajele bazelor de date față de fișierele tradiționale, conform cursului?","['copyright@www.adrian.runceanu.ro\nOrice firmă utilizează baze de date pentru păstrarea \nşi gestionarea informaţiilor. Câteva astfel de aplicaţii sunt \nuzuale:\n1.bazele de date ale liniilor aeriene care sunt accesate \nsimultan din sute de agenţii pentru a realiza rezervări şi \nvânzări de locuri pentru date şi zboruri diferite\n2.bazele de date ale băncilor care permit realizarea a mii \nde tranzacţii zilnic\n3.bazele de date ale supermagazinelor care sunt accesate \natât de la casele de marcaj cât şi de la echipamentele de \ninventariere\n4.bazele de date ale bibliotecilor care păstrează milioane \nde titluri şi permit localizarea unei lucrări folosind diferite \ncriterii (cuvinte cheie, titlu, autori, domeniu)\nCurs - Baze de date 17', 'copyright@www.adrian.runceanu.ro\nOrice firmă utilizează baze de date pentru păstrarea \nşi gestionarea informaţiilor. Câteva astfel de aplicaţii sunt \nuzuale:\n1.bazele de date ale liniilor aeriene care sunt accesate \nsimultan din sute de agenţii pentru a realiza rezervări şi \nvânzări de locuri pentru date şi zboruri diferite\n2.bazele de date ale băncilor care permit realizarea a mii \nde tranzacţii zilnic\n3.bazele de date ale supermagazinelor care sunt accesate \natât de la casele de marcaj cât şi de la echipamentele de \ninventariere\n4.bazele de date ale bibliotecilor care păstrează milioane \nde titluri şi permit localizarea unei lucrări folosind diferite \ncriterii (cuvinte cheie, titlu, autori, domeniu)\nCurs - Baze de date 17', 'copyright@www.adrian.runceanu.ro\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4']","Contextul furnizat nu oferă o comparație directă între bazele de date și fișierele tradiționale. Informațiile se concentrează pe exemple de utilizare a bazelor de date și pe tipurile de obiecte dintr-o bază de date. 

Pentru a putea răspunde la întrebarea despre avantajele bazelor de date față de fișierele tradiționale, ar fi nevoie de informații suplimentare din curs care să acopere subiecte precum:

* **Gestionarea redundanței datelor:** Bazele de date sunt concepute pentru a minimiza redundanța datelor, în timp ce fișierele tradiționale pot duce la duplicarea informațiilor.
* **Consistența și integritatea datelor:** Bazele de date impun reguli de integritate pentru a asigura coerența datelor, în timp ce fișierele tradiționale sunt mai predispuse la erori și inconsistențe.
* **Securitatea datelor:** Bazele de date oferă mecanisme avansate de control al accesului și securitate a datelor, în comparație cu fișierele tradiționale.
* **Accesul concurent:** Bazele de date permit accesul simultan al mai multor utilizatori la date, în timp ce fișierele tradiționale pot întâmpina probleme de blocare a fișierelor.
* **Scalabilitate:** Bazele de date sunt proiectate pentru a gestiona volume mari de date și pentru a se adapta creșterii, în timp ce fișierele tradiționale pot deveni greu de gestionat odată cu creșterea volumului de informații.

Prin urmare, fără aceste informații suplimentare din curs, nu putem oferi un răspuns complet la întrebarea despre avantajele bazelor de date față de fișierele tradiționale. 
","Avantajele: elimină redundanța, îmbunătățesc integritatea, oferă acces flexibil și securitate sporită.",0.0,0.0,0.0,0.5238095238095238,0.03144344638628673,0.05185185185185185,0.56
26,O3mini-high,Medium,Curs 13,,"Ce caracteristici are modelul relațional de baze de date, conform cursului?","Modelul relațional organizează datele în tabele, utilizează chei primare și străine pentru integritate și oferă independența datelor față de aplicații.",Este corect,pagina 1,"['copyright@www.adrian.runceanu.ro\n1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\nCurs - Baze de date 36', 'copyright@www.adrian.runceanu.ro\n1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\nCurs - Baze de date 36', 'copyright@www.adrian.runceanu.ro\n1.4. Modelul de date obiect-relaţional\n Modelul de date obiect-relaţional\n(Object-Relational Model) reprezintă\nextinderea modelului relaţional cu\ncaracteristici ale modelului obiect, extindere\nnecesară pentru realizarea bazelor de date\ncare definesc şi prelucrează tipuri de date\ncomplexe.\nCurs - Baze de date 58', 'copyright@www.adrian.runceanu.ro\n1.4. Modelul de date obiect-relaţional\n Modelul de date obiect-relaţional\n(Object-Relational Model) reprezintă\nextinderea modelului relaţional cu\ncaracteristici ale modelului obiect, extindere\nnecesară pentru realizarea bazelor de date\ncare definesc şi prelucrează tipuri de date\ncomplexe.\nCurs - Baze de date 58', 'copyright@www.adrian.runceanu.ro\nModele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\nCurs - Baze de date\n 34']","Conform cursului, modelul relațional de baze de date are următoarele caracteristici:

* **Reprezentarea datelor sub formă de tabele:**  Baza de date este văzută ca o colecție de tabele.
* **Legătură directă cu conceptul matematic de relație:**  Modelul se bazează pe conceptul matematic de relație.
* **Structură compusă din:**
    * **Parte structurală:** Schema bazei de date (colecție de scheme de relații) și baza de date în sine (colecție de relații).
    * **Parte de integritate:**  Chei primare și chei străine pentru asigurarea integrității datelor.
    * **Parte de manipulare:** Algebra relațională și calcul relațional pentru interogarea și manipularea datelor. 
","Ce caracteristici are modelul relațional de baze de date, conform cursului?","['copyright@www.adrian.runceanu.ro\n1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\nCurs - Baze de date 36', 'copyright@www.adrian.runceanu.ro\n1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\nCurs - Baze de date 36', 'copyright@www.adrian.runceanu.ro\n1.4. Modelul de date obiect-relaţional\n Modelul de date obiect-relaţional\n(Object-Relational Model) reprezintă\nextinderea modelului relaţional cu\ncaracteristici ale modelului obiect, extindere\nnecesară pentru realizarea bazelor de date\ncare definesc şi prelucrează tipuri de date\ncomplexe.\nCurs - Baze de date 58', 'copyright@www.adrian.runceanu.ro\n1.4. Modelul de date obiect-relaţional\n Modelul de date obiect-relaţional\n(Object-Relational Model) reprezintă\nextinderea modelului relaţional cu\ncaracteristici ale modelului obiect, extindere\nnecesară pentru realizarea bazelor de date\ncare definesc şi prelucrează tipuri de date\ncomplexe.\nCurs - Baze de date 58', 'copyright@www.adrian.runceanu.ro\nModele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\nCurs - Baze de date\n 34']","Conform cursului, modelul relațional de baze de date are următoarele caracteristici:

* **Reprezentarea datelor sub formă de tabele:**  Baza de date este văzută ca o colecție de tabele.
* **Legătură directă cu conceptul matematic de relație:**  Modelul se bazează pe conceptul matematic de relație.
* **Structură compusă din:**
    * **Parte structurală:** Schema bazei de date (colecție de scheme de relații) și baza de date în sine (colecție de relații).
    * **Parte de integritate:**  Chei primare și chei străine pentru asigurarea integrității datelor.
    * **Parte de manipulare:** Algebra relațională și calcul relațional pentru interogarea și manipularea datelor. 
","Modelul relațional organizează datele în tabele, utilizează chei primare și străine pentru integritate și oferă independența datelor față de aplicații.",0.99999999995,0.6666666666666666,0.8955906122964663,1.0,0.010346668572978324,0.20155038759689922,0.5
27,O3mini-high,Medium,Curs 14,,"Care sunt etapele proiectării bazelor de date relaționale, potrivit cursului?","Etapele sunt: 1. Identificarea cerințelor, 2. Modelarea conceptuală, 3. Modelarea logică, 4. Modelarea fizică, 5. Normalizarea.",Este corect,pagina 1,"['copyright@www.adrian.runceanu.ro\n1.4. Modelul de date obiect-relaţional\n✓ În esenţă, modelul obiect-relaţional păstrează \nstructurarea datelor în relaţii (reprezentate ca tabele), \ndar adaugă posibilitatea definirii unor noi tipuri de \ndate, pentru domeniile de valori ale atributelor. \n✓Tipurile de date definite de utilizator pot fi extinse \nprin mecanismul de moştenire şi pentru fiecare tip sau \nsubtip se pot defini metode pe care le pot executa \nobiectele de acel tip.\nCurs - Baze de date 59', 'copyright@www.adrian.runceanu.ro\n1.4. Modelul de date obiect-relaţional\n✓ În esenţă, modelul obiect-relaţional păstrează \nstructurarea datelor în relaţii (reprezentate ca tabele), \ndar adaugă posibilitatea definirii unor noi tipuri de \ndate, pentru domeniile de valori ale atributelor. \n✓Tipurile de date definite de utilizator pot fi extinse \nprin mecanismul de moştenire şi pentru fiecare tip sau \nsubtip se pot defini metode pe care le pot executa \nobiectele de acel tip.\nCurs - Baze de date 59', 'copyright@www.adrian.runceanu.ro\nConcepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\nCurs - Baze de date 54', 'copyright@www.adrian.runceanu.ro\nConcepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\nCurs - Baze de date 54', 'copyright@www.adrian.runceanu.ro\nConcepte de bază din teoria relațională a bazelor de \ndate\nPrezentăm în continuare aceste concepte:\n1. DOMENIUL reprezintă un ansamblu de valori, \ncaracterizat printr-un nume. \n➢Domeniul se poate definit explicit, prin \nenumerarea tuturor valorilor care aparţin \nacestuia, sau implicit, prin precizarea \nproprietăţilor pe care le au valorile domeniului \nrespectiv.\nCurs - Baze de date 48']","Nu există informații despre etapele proiectării bazelor de date relaționale în contextul furnizat. Textul se referă la modelul de date obiect-relațional și la concepte de bază din teoria relațională a bazelor de date, exemplificând cu o bază de date numită FACULTATE. 
","Care sunt etapele proiectării bazelor de date relaționale, potrivit cursului?","['copyright@www.adrian.runceanu.ro\n1.4. Modelul de date obiect-relaţional\n✓ În esenţă, modelul obiect-relaţional păstrează \nstructurarea datelor în relaţii (reprezentate ca tabele), \ndar adaugă posibilitatea definirii unor noi tipuri de \ndate, pentru domeniile de valori ale atributelor. \n✓Tipurile de date definite de utilizator pot fi extinse \nprin mecanismul de moştenire şi pentru fiecare tip sau \nsubtip se pot defini metode pe care le pot executa \nobiectele de acel tip.\nCurs - Baze de date 59', 'copyright@www.adrian.runceanu.ro\n1.4. Modelul de date obiect-relaţional\n✓ În esenţă, modelul obiect-relaţional păstrează \nstructurarea datelor în relaţii (reprezentate ca tabele), \ndar adaugă posibilitatea definirii unor noi tipuri de \ndate, pentru domeniile de valori ale atributelor. \n✓Tipurile de date definite de utilizator pot fi extinse \nprin mecanismul de moştenire şi pentru fiecare tip sau \nsubtip se pot defini metode pe care le pot executa \nobiectele de acel tip.\nCurs - Baze de date 59', 'copyright@www.adrian.runceanu.ro\nConcepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\nCurs - Baze de date 54', 'copyright@www.adrian.runceanu.ro\nConcepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\nCurs - Baze de date 54', 'copyright@www.adrian.runceanu.ro\nConcepte de bază din teoria relațională a bazelor de \ndate\nPrezentăm în continuare aceste concepte:\n1. DOMENIUL reprezintă un ansamblu de valori, \ncaracterizat printr-un nume. \n➢Domeniul se poate definit explicit, prin \nenumerarea tuturor valorilor care aparţin \nacestuia, sau implicit, prin precizarea \nproprietăţilor pe care le au valorile domeniului \nrespectiv.\nCurs - Baze de date 48']","Nu există informații despre etapele proiectării bazelor de date relaționale în contextul furnizat. Textul se referă la modelul de date obiect-relațional și la concepte de bază din teoria relațională a bazelor de date, exemplificând cu o bază de date numită FACULTATE. 
","Etapele sunt: 1. Identificarea cerințelor, 2. Modelarea conceptuală, 3. Modelarea logică, 4. Modelarea fizică, 5. Normalizarea.",0.0,0.0,0.0,1.0,0.0,0.03076923076923077,0.2
28,O3mini-high,High,"C1, C13",C12,"Comparați modelul relațional cu celelalte modele de baze de date, evidențiind avantajele fundamentale.","Modelul relațional organizează datele în tabele, folosind chei primare și străine pentru integritate și independența datelor” – spre deosebire de modelele ierarhice sau de rețea, care sunt mai rigide.",Partial corect,C12,"['copyright@www.adrian.runceanu.ro\nModele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\nCurs - Baze de date\n 34', 'copyright@www.adrian.runceanu.ro\nModele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\nCurs - Baze de date\n 34', 'copyright@www.adrian.runceanu.ro\nNoţiuni introductive \ndespre teoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\nCurs - Baze de date 60', 'copyright@www.adrian.runceanu.ro\nNoţiuni introductive \ndespre teoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\nCurs - Baze de date 60', 'copyright@www.adrian.runceanu.ro\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\nCurs - Baze de date 19']","Contextul oferit menționează modelul relațional și alte modele de baze de date (orientat obiect, obiect-relațional, ierarhic, rețea), dar nu oferă detalii despre avantajele modelului relațional. 

Pentru a putea compara modelul relațional cu celelalte modele și a evidenția avantajele sale fundamentale, ar fi nevoie de informații suplimentare despre:

* **Structura fiecărui model:** Cum sunt organizate datele în fiecare model (e.g., tabele în modelul relațional, obiecte în modelul orientat obiect).
* **Operații specifice fiecărui model:** Cum se realizează interogarea, adăugarea, modificarea și ștergerea datelor.
* **Avantaje și dezavantaje:**  Care sunt punctele forte și punctele slabe ale fiecărui model în diverse scenarii.

Doar având aceste informații, putem face o comparație relevantă și putem evidenția avantajele modelului relațional. 
","Comparați modelul relațional cu celelalte modele de baze de date, evidențiind avantajele fundamentale.","['copyright@www.adrian.runceanu.ro\nModele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\nCurs - Baze de date\n 34', 'copyright@www.adrian.runceanu.ro\nModele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\nCurs - Baze de date\n 34', 'copyright@www.adrian.runceanu.ro\nNoţiuni introductive \ndespre teoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\nCurs - Baze de date 60', 'copyright@www.adrian.runceanu.ro\nNoţiuni introductive \ndespre teoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\nCurs - Baze de date 60', 'copyright@www.adrian.runceanu.ro\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\nCurs - Baze de date 19']","Contextul oferit menționează modelul relațional și alte modele de baze de date (orientat obiect, obiect-relațional, ierarhic, rețea), dar nu oferă detalii despre avantajele modelului relațional. 

Pentru a putea compara modelul relațional cu celelalte modele și a evidenția avantajele sale fundamentale, ar fi nevoie de informații suplimentare despre:

* **Structura fiecărui model:** Cum sunt organizate datele în fiecare model (e.g., tabele în modelul relațional, obiecte în modelul orientat obiect).
* **Operații specifice fiecărui model:** Cum se realizează interogarea, adăugarea, modificarea și ștergerea datelor.
* **Avantaje și dezavantaje:**  Care sunt punctele forte și punctele slabe ale fiecărui model în diverse scenarii.

Doar având aceste informații, putem face o comparație relevantă și putem evidenția avantajele modelului relațional. 
","Modelul relațional organizează datele în tabele, folosind chei primare și străine pentru integritate și independența datelor” – spre deosebire de modelele ierarhice sau de rețea, care sunt mai rigide.",0.0,0.0,0.0,0.7272727272727273,0.018889056804276053,0.12195121951219512,0.53
29,O3mini-high,High,"C2, C12",C1,Explicați evoluția SGBD-ului Oracle și diferențele față de alte tipuri de baze de date moderne.,"Oracle este un SGBD complet relațional, extins, cu facilități din tehnologia orientată obiect” și a evoluat de la arhitectura client/server la NC, integrând tehnici cloud și inovații pentru performanță și flexibilitate.",Este corect,C2,"['copyright@www.adrian.runceanu.ro\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27Curs - Baze de date']","Contextul furnizat oferă informații despre arhitectura Oracle și câteva detalii despre istoria sa, dar nu detaliază evoluția SGBD-ului Oracle în comparație cu alte baze de date. 

Pentru a răspunde promptului, ar fi nevoie de informații suplimentare despre:

* **Versiunile majore Oracle:** Cum a evoluat funcționalitatea Oracle de-a lungul timpului? Ce funcționalități noi au fost introduse în versiunile cheie?
* **Comparație cu alte tipuri de baze de date:** Care sunt principalele diferențe între Oracle și alte tipuri de baze de date moderne, cum ar fi bazele de date NoSQL (MongoDB, Cassandra), bazele de date NewSQL (Spanner, CockroachDB) sau bazele de date cloud-native (AWS Aurora, Azure SQL Database)?  
    *  Exemple de diferențe pot include: modelul de date (relațional vs. non-relațional), scalabilitatea, consistența datelor, suportul pentru tranzacții, costul etc.

Cu informații adiționale, ar fi posibil să se ofere o comparație detaliată a evoluției Oracle și a poziției sale în peisajul bazelor de date moderne.
",Explicați evoluția SGBD-ului Oracle și diferențele față de alte tipuri de baze de date moderne.,"['copyright@www.adrian.runceanu.ro\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27Curs - Baze de date']","Contextul furnizat oferă informații despre arhitectura Oracle și câteva detalii despre istoria sa, dar nu detaliază evoluția SGBD-ului Oracle în comparație cu alte baze de date. 

Pentru a răspunde promptului, ar fi nevoie de informații suplimentare despre:

* **Versiunile majore Oracle:** Cum a evoluat funcționalitatea Oracle de-a lungul timpului? Ce funcționalități noi au fost introduse în versiunile cheie?
* **Comparație cu alte tipuri de baze de date:** Care sunt principalele diferențe între Oracle și alte tipuri de baze de date moderne, cum ar fi bazele de date NoSQL (MongoDB, Cassandra), bazele de date NewSQL (Spanner, CockroachDB) sau bazele de date cloud-native (AWS Aurora, Azure SQL Database)?  
    *  Exemple de diferențe pot include: modelul de date (relațional vs. non-relațional), scalabilitatea, consistența datelor, suportul pentru tranzacții, costul etc.

Cu informații adiționale, ar fi posibil să se ofere o comparație detaliată a evoluției Oracle și a poziției sale în peisajul bazelor de date moderne.
","Oracle este un SGBD complet relațional, extins, cu facilități din tehnologia orientată obiect” și a evoluat de la arhitectura client/server la NC, integrând tehnici cloud și inovații pentru performanță și flexibilitate.",0.0,0.5,0.0,1.0,0.01499757078421666,0.08612440191387559,0.58
30,O3mini-high,High,"C3, C4",C5,"Cum se combină clauzele WHERE, ORDER BY și funcțiile agregate pentru a obține rezultate sumare?","WHERE filtrează rândurile, ORDER BY sortează rezultatul, iar funcțiile de grup (ex. AVG, COUNT) calculează valori sumare pentru fiecare grup definit prin GROUP BY. Exemplu: „SELECT deptno, AVG(sal) FROM EMP GROUP BY deptno ORDER BY AVG(sal)” – rezultatul fiind o sumă statistică pe departamente.",Este corect,C5,"['copyright@www.adrian.runceanu.ro\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\nCurs - Baze de date 6', 'copyright@www.adrian.runceanu.ro\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\nCurs - Baze de date 6', 'copyright@www.adrian.runceanu.ro\nSintaxa conţine: \nO subcerere care întoarce elemente sortate şi \ncare conţine clauza ORDER BY. \nCa să avem cea mai mare valoare pe prima linie \nfolosim DESC. \nO cerere care selectează un anumit număr de \nlinii (N) ca rezultat final. Conţine: \n– ROWNUM care aloca o valoare începând de la 1 fiecărei \nlinii întoarse de subcerere.\n– WHERE care condiţionează numărul de linii întoarse\nCurs - BAZE DE DATE 51', 'copyright@www.adrian.runceanu.ro\nSintaxa conţine: \nO subcerere care întoarce elemente sortate şi \ncare conţine clauza ORDER BY. \nCa să avem cea mai mare valoare pe prima linie \nfolosim DESC. \nO cerere care selectează un anumit număr de \nlinii (N) ca rezultat final. Conţine: \n– ROWNUM care aloca o valoare începând de la 1 fiecărei \nlinii întoarse de subcerere.\n– WHERE care condiţionează numărul de linii întoarse\nCurs - BAZE DE DATE 51', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\n Clauza WHERE poate compara valori în coloană, \nvalori literale, expresii aritmetice sau funcţii.\nWHERE - restricţionează cererea la rândurile care \nîndeplinesc o condiţie;\nCondiţie este alcătuită din trei elemente:\n1. Un nume de coloană \n2. Un operator de comparaţie \n3. Un nume de coloană, constantă sau listă de valori\nCurs - Baze de date 31']","Informațiile furnizate în context nu conțin detalii despre cum se combină clauzele WHERE, ORDER BY și funcțiile agregate pentru a obține rezultate sumare. Contextul se concentrează pe:

* Efectul cuvântului cheie DISTINCT și al clauzei ORDER BY în interogările SQL.
* Sintaxa pentru selectarea unui anumit număr de linii folosind ROWNUM și WHERE.
* Funcția clauzei WHERE și componentele sale.

Pentru a obține informații despre combinarea clauzelor WHERE, ORDER BY și funcțiilor agregate, ar fi nevoie de un context diferit care să acopere aceste subiecte. 
","Cum se combină clauzele WHERE, ORDER BY și funcțiile agregate pentru a obține rezultate sumare?","['copyright@www.adrian.runceanu.ro\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\nCurs - Baze de date 6', 'copyright@www.adrian.runceanu.ro\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\nCurs - Baze de date 6', 'copyright@www.adrian.runceanu.ro\nSintaxa conţine: \nO subcerere care întoarce elemente sortate şi \ncare conţine clauza ORDER BY. \nCa să avem cea mai mare valoare pe prima linie \nfolosim DESC. \nO cerere care selectează un anumit număr de \nlinii (N) ca rezultat final. Conţine: \n– ROWNUM care aloca o valoare începând de la 1 fiecărei \nlinii întoarse de subcerere.\n– WHERE care condiţionează numărul de linii întoarse\nCurs - BAZE DE DATE 51', 'copyright@www.adrian.runceanu.ro\nSintaxa conţine: \nO subcerere care întoarce elemente sortate şi \ncare conţine clauza ORDER BY. \nCa să avem cea mai mare valoare pe prima linie \nfolosim DESC. \nO cerere care selectează un anumit număr de \nlinii (N) ca rezultat final. Conţine: \n– ROWNUM care aloca o valoare începând de la 1 fiecărei \nlinii întoarse de subcerere.\n– WHERE care condiţionează numărul de linii întoarse\nCurs - BAZE DE DATE 51', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\n Clauza WHERE poate compara valori în coloană, \nvalori literale, expresii aritmetice sau funcţii.\nWHERE - restricţionează cererea la rândurile care \nîndeplinesc o condiţie;\nCondiţie este alcătuită din trei elemente:\n1. Un nume de coloană \n2. Un operator de comparaţie \n3. Un nume de coloană, constantă sau listă de valori\nCurs - Baze de date 31']","Informațiile furnizate în context nu conțin detalii despre cum se combină clauzele WHERE, ORDER BY și funcțiile agregate pentru a obține rezultate sumare. Contextul se concentrează pe:

* Efectul cuvântului cheie DISTINCT și al clauzei ORDER BY în interogările SQL.
* Sintaxa pentru selectarea unui anumit număr de linii folosind ROWNUM și WHERE.
* Funcția clauzei WHERE și componentele sale.

Pentru a obține informații despre combinarea clauzelor WHERE, ORDER BY și funcțiilor agregate, ar fi nevoie de un context diferit care să acopere aceste subiecte. 
","WHERE filtrează rândurile, ORDER BY sortează rezultatul, iar funcțiile de grup (ex. AVG, COUNT) calculează valori sumare pentru fiecare grup definit prin GROUP BY. Exemplu: „SELECT deptno, AVG(sal) FROM EMP GROUP BY deptno ORDER BY AVG(sal)” – rezultatul fiind o sumă statistică pe departamente.",0.0,0.0,0.0,1.0,0.05637098534565783,0.1285714285714286,0.25
31,O3mini-high,High,"C4, C3",(C5),"Cum se utilizează funcțiile UPPER, LOWER și INITCAP în manipularea șirurilor și în condițiile din clauza WHERE?","Funcțiile UPPER, LOWER și INITCAP transformă șirurile pentru o comparare uniformă. De exemplu, „SELECT empno, UPPER(ename) FROM EMP WHERE INITCAP(ename) = 'Smith'” asigură că literele sunt comparate indiferent de caz, facilitând filtrarea corectă a datelor.",Este corect,"C5, slide 24","['copyright@www.adrian.runceanu.ro\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52', 'copyright@www.adrian.runceanu.ro\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52', 'copyright@www.adrian.runceanu.ro\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56', 'copyright@www.adrian.runceanu.ro\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56', 'copyright@www.adrian.runceanu.ro\nConstrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17']","Îmi pare rău, dar informațiile furnizate în context nu conțin detalii despre funcțiile UPPER, LOWER și INITCAP și utilizarea lor în manipularea șirurilor sau în clauzele WHERE. 

Contextul oferă informații despre operatorul ALL în subinterogări și despre constrângerea UNIQUE în bazele de date. 
","Cum se utilizează funcțiile UPPER, LOWER și INITCAP în manipularea șirurilor și în condițiile din clauza WHERE?","['copyright@www.adrian.runceanu.ro\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52', 'copyright@www.adrian.runceanu.ro\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52', 'copyright@www.adrian.runceanu.ro\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56', 'copyright@www.adrian.runceanu.ro\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56', 'copyright@www.adrian.runceanu.ro\nConstrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17']","Îmi pare rău, dar informațiile furnizate în context nu conțin detalii despre funcțiile UPPER, LOWER și INITCAP și utilizarea lor în manipularea șirurilor sau în clauzele WHERE. 

Contextul oferă informații despre operatorul ALL în subinterogări și despre constrângerea UNIQUE în bazele de date. 
","Funcțiile UPPER, LOWER și INITCAP transformă șirurile pentru o comparare uniformă. De exemplu, „SELECT empno, UPPER(ename) FROM EMP WHERE INITCAP(ename) = 'Smith'” asigură că literele sunt comparate indiferent de caz, facilitând filtrarea corectă a datelor.",0.0,0.0,0.0,1.0,0.11027464697628432,0.1818181818181818,0.0
32,O3mini-high,High,"C6, C3",C5,Explicați mecanismul de execuție al unei subinterogări single-row și integrarea acesteia în clauza WHERE.,"O subinterogare single-row se execută înaintea interogării principale, returnând o valoare unică folosită în condiția WHERE. Exemplu: „WHERE sal > (SELECT sal FROM EMP WHERE ename = 'SMITH')” – fiecare salariu este comparat cu valoarea unică obținută din subquery.",Este corect,"C6, slide 11","['copyright@www.adrian.runceanu.ro\nSfaturi în utilizarea subinterogarilor\n1. Includerea subinterogarilor în paranteze\n2. Plasarea subinterogarilor în partea dreapta a \noperatorului de comparare\n3. A nu se adauga clauza ORDER BY într-o \nsubinterogare\n4. Folosirea operatorilor single-row în subinterogari \nsingle-row\n5. Folosirea operatorilor multiple-row în \nsubinterogari multiple-row\nCurs 6 - BAZE DE DATE 67', 'copyright@www.adrian.runceanu.ro\nSfaturi în utilizarea subinterogarilor\n1. Includerea subinterogarilor în paranteze\n2. Plasarea subinterogarilor în partea dreapta a \noperatorului de comparare\n3. A nu se adauga clauza ORDER BY într-o \nsubinterogare\n4. Folosirea operatorilor single-row în subinterogari \nsingle-row\n5. Folosirea operatorilor multiple-row în \nsubinterogari multiple-row\nCurs 6 - BAZE DE DATE 67', 'copyright@www.adrian.runceanu.ro\nOrdinea de executie a functiilor de \ngrup\n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei. \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează. \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă. \nCurs 5 - BAZE DE DATE 50', 'copyright@www.adrian.runceanu.ro\nOrdinea de executie a functiilor de \ngrup\n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei. \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează. \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă. \nCurs 5 - BAZE DE DATE 50', 'copyright@www.adrian.runceanu.ro\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15']","O subinterogare single-row este o subinterogare care returnează **o singură valoare** (un singur rând și o singură coloană). Această valoare poate fi folosită apoi în clauza WHERE a interogării principale pentru a filtra rezultatele.

**Mecanismul de execuție este următorul:**

1. **Execuția subinterogării:**  Motorul bazei de date execută mai întâi subinterogarea.
2. **Returnarea valorii:** Subinterogarea returnează o singură valoare interogării principale.
3. **Integrarea în clauza WHERE:** Valoarea returnată de subinterogare este utilizată în clauza WHERE a interogării principale ca și cum ar fi o valoare constantă.
4. **Execuția interogării principale:**  Motorul bazei de date execută interogarea principală, utilizând valoarea returnată de subinterogare în clauza WHERE pentru a filtra rezultatele.

**Exemplu:**

Să presupunem că avem o tabelă cu angajați și dorim să găsim toți angajații care câștigă mai mult decât salariul mediu al tuturor angajaților. 

Putem face acest lucru folosind o subinterogare single-row în clauza WHERE:

```sql
SELECT *
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);
```

În acest exemplu:

1. Subinterogarea `(SELECT AVG(salary) FROM employees)` este executată prima și returnează salariul mediu al tuturor angajaților.
2. Această valoare este apoi utilizată în clauza WHERE a interogării principale pentru a selecta angajații al căror salariu este mai mare decât valoarea returnată de subinterogare.

**Important:** Pentru a utiliza o subinterogare în clauza WHERE, trebuie să vă asigurați că subinterogarea returnează o singură valoare. Dacă subinterogarea returnează mai multe valori, va trebui să utilizați un operator precum IN, ANY sau ALL.
",Explicați mecanismul de execuție al unei subinterogări single-row și integrarea acesteia în clauza WHERE.,"['copyright@www.adrian.runceanu.ro\nSfaturi în utilizarea subinterogarilor\n1. Includerea subinterogarilor în paranteze\n2. Plasarea subinterogarilor în partea dreapta a \noperatorului de comparare\n3. A nu se adauga clauza ORDER BY într-o \nsubinterogare\n4. Folosirea operatorilor single-row în subinterogari \nsingle-row\n5. Folosirea operatorilor multiple-row în \nsubinterogari multiple-row\nCurs 6 - BAZE DE DATE 67', 'copyright@www.adrian.runceanu.ro\nSfaturi în utilizarea subinterogarilor\n1. Includerea subinterogarilor în paranteze\n2. Plasarea subinterogarilor în partea dreapta a \noperatorului de comparare\n3. A nu se adauga clauza ORDER BY într-o \nsubinterogare\n4. Folosirea operatorilor single-row în subinterogari \nsingle-row\n5. Folosirea operatorilor multiple-row în \nsubinterogari multiple-row\nCurs 6 - BAZE DE DATE 67', 'copyright@www.adrian.runceanu.ro\nOrdinea de executie a functiilor de \ngrup\n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei. \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează. \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă. \nCurs 5 - BAZE DE DATE 50', 'copyright@www.adrian.runceanu.ro\nOrdinea de executie a functiilor de \ngrup\n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei. \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează. \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă. \nCurs 5 - BAZE DE DATE 50', 'copyright@www.adrian.runceanu.ro\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15']","O subinterogare single-row este o subinterogare care returnează **o singură valoare** (un singur rând și o singură coloană). Această valoare poate fi folosită apoi în clauza WHERE a interogării principale pentru a filtra rezultatele.

**Mecanismul de execuție este următorul:**

1. **Execuția subinterogării:**  Motorul bazei de date execută mai întâi subinterogarea.
2. **Returnarea valorii:** Subinterogarea returnează o singură valoare interogării principale.
3. **Integrarea în clauza WHERE:** Valoarea returnată de subinterogare este utilizată în clauza WHERE a interogării principale ca și cum ar fi o valoare constantă.
4. **Execuția interogării principale:**  Motorul bazei de date execută interogarea principală, utilizând valoarea returnată de subinterogare în clauza WHERE pentru a filtra rezultatele.

**Exemplu:**

Să presupunem că avem o tabelă cu angajați și dorim să găsim toți angajații care câștigă mai mult decât salariul mediu al tuturor angajaților. 

Putem face acest lucru folosind o subinterogare single-row în clauza WHERE:

```sql
SELECT *
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);
```

În acest exemplu:

1. Subinterogarea `(SELECT AVG(salary) FROM employees)` este executată prima și returnează salariul mediu al tuturor angajaților.
2. Această valoare este apoi utilizată în clauza WHERE a interogării principale pentru a selecta angajații al căror salariu este mai mare decât valoarea returnată de subinterogare.

**Important:** Pentru a utiliza o subinterogare în clauza WHERE, trebuie să vă asigurați că subinterogarea returnează o singură valoare. Dacă subinterogarea returnează mai multe valori, va trebui să utilizați un operator precum IN, ANY sau ALL.
","O subinterogare single-row se execută înaintea interogării principale, returnând o valoare unică folosită în condiția WHERE. Exemplu: „WHERE sal > (SELECT sal FROM EMP WHERE ename = 'SMITH')” – fiecare salariu este comparat cu valoarea unică obținută din subquery.",0.19999999998,0.5,0.8320194891547631,0.25,0.06334973751796387,0.13029315960912052,0.56
33,O3mini-high,High,C7,"C3, C6",Cum se utilizează instrucțiunea UPDATE combinată cu subinterogări pentru a actualiza date selective?,UPDATE poate folosi o subinterogare pentru a seta valori. Exemplu: „UPDATE EMP SET sal = (SELECT AVG(sal) FROM EMP) WHERE deptno = 10” actualizează salariile din departamentul 10 cu media salarială calculată prin subquery.,Este corect,C7,"['copyright@www.adrian.runceanu.ro\nDeci se pune problema cand nu sunt necesari indecsii:\n✓Cand tabela pe care se doreste adaugarea este mica.\n✓Cand coloanele pe care se adauga indecsii nu sunt \nfolosite frecvent pentru executarea de extrageri de \ninregistrari\n✓Cand cererile de tip SELECT in general extrag un numar \nmare de inregistrari (mai mare de 2-4%)\n✓Cand operatiuni de UPDATE sunt foarte des utilizate.\n✓Cand coloanele indexate sunt referentiate ca parte \nintegranta a unor expresii.\nCurs - BAZE DE DATE 34', 'copyright@www.adrian.runceanu.ro\nDeci se pune problema cand nu sunt necesari indecsii:\n✓Cand tabela pe care se doreste adaugarea este mica.\n✓Cand coloanele pe care se adauga indecsii nu sunt \nfolosite frecvent pentru executarea de extrageri de \ninregistrari\n✓Cand cererile de tip SELECT in general extrag un numar \nmare de inregistrari (mai mare de 2-4%)\n✓Cand operatiuni de UPDATE sunt foarte des utilizate.\n✓Cand coloanele indexate sunt referentiate ca parte \nintegranta a unor expresii.\nCurs - BAZE DE DATE 34', 'copyright@www.adrian.runceanu.ro\nCand nu se creaza indecsii si de ce?\n➢In general nu tot timpul este necesar si bine sa fie creati \nindexi in baza de date.\n➢O creare excesiva de indecsi in baza de date are si multe \nneajunsuri. \n➢In momentul in care sunt adaugati indecsi, baza de date \nface o repunere la zi a lor pentru fiecare operatie care \neste executata. \n➢In momentul in care sunt creati prea multi indecsi \noperatile de extragere din baza de date isi amelioreaza \nviteza doar cu un raport mic dar pentru fiecare \noperatiune de inserare sau stergere timpul necesar \ncreste simtitor precum si resursele folosite. \nCurs - BAZE DE DATE 33', 'copyright@www.adrian.runceanu.ro\nCand nu se creaza indecsii si de ce?\n➢In general nu tot timpul este necesar si bine sa fie creati \nindexi in baza de date.\n➢O creare excesiva de indecsi in baza de date are si multe \nneajunsuri. \n➢In momentul in care sunt adaugati indecsi, baza de date \nface o repunere la zi a lor pentru fiecare operatie care \neste executata. \n➢In momentul in care sunt creati prea multi indecsi \noperatile de extragere din baza de date isi amelioreaza \nviteza doar cu un raport mic dar pentru fiecare \noperatiune de inserare sau stergere timpul necesar \ncreste simtitor precum si resursele folosite. \nCurs - BAZE DE DATE 33', 'copyright@www.adrian.runceanu.ro\nCrearea indecșilor \nIndecsii sunt creati in doua feluri:\n1. Automat: In momentul in care se creaza o cheie \nprimara asupra tabelelor, in momentul in care se creaza \no restrictie ca inregistrarile din baza de date sa fie unice \nsi in alte situatii asemanatoare.\n2. Manual: Se pot defini indecsi manuali care nu trebuie \nsa contina o restrictie cum este cazul indecsilor unici.\nCurs - BAZE DE DATE 28']","Îmi pare rău, dar contextul furnizat nu conține informații despre utilizarea instrucțiunii UPDATE combinată cu subinterogări pentru a actualiza date selective. Contextul discută despre crearea și necesitatea indexării în bazele de date. 

Pentru a obține informații despre utilizarea instrucțiunii UPDATE cu subinterogări, vă recomand să căutați resurse specifice despre limbajul SQL și sintaxa sa.
",Cum se utilizează instrucțiunea UPDATE combinată cu subinterogări pentru a actualiza date selective?,"['copyright@www.adrian.runceanu.ro\nDeci se pune problema cand nu sunt necesari indecsii:\n✓Cand tabela pe care se doreste adaugarea este mica.\n✓Cand coloanele pe care se adauga indecsii nu sunt \nfolosite frecvent pentru executarea de extrageri de \ninregistrari\n✓Cand cererile de tip SELECT in general extrag un numar \nmare de inregistrari (mai mare de 2-4%)\n✓Cand operatiuni de UPDATE sunt foarte des utilizate.\n✓Cand coloanele indexate sunt referentiate ca parte \nintegranta a unor expresii.\nCurs - BAZE DE DATE 34', 'copyright@www.adrian.runceanu.ro\nDeci se pune problema cand nu sunt necesari indecsii:\n✓Cand tabela pe care se doreste adaugarea este mica.\n✓Cand coloanele pe care se adauga indecsii nu sunt \nfolosite frecvent pentru executarea de extrageri de \ninregistrari\n✓Cand cererile de tip SELECT in general extrag un numar \nmare de inregistrari (mai mare de 2-4%)\n✓Cand operatiuni de UPDATE sunt foarte des utilizate.\n✓Cand coloanele indexate sunt referentiate ca parte \nintegranta a unor expresii.\nCurs - BAZE DE DATE 34', 'copyright@www.adrian.runceanu.ro\nCand nu se creaza indecsii si de ce?\n➢In general nu tot timpul este necesar si bine sa fie creati \nindexi in baza de date.\n➢O creare excesiva de indecsi in baza de date are si multe \nneajunsuri. \n➢In momentul in care sunt adaugati indecsi, baza de date \nface o repunere la zi a lor pentru fiecare operatie care \neste executata. \n➢In momentul in care sunt creati prea multi indecsi \noperatile de extragere din baza de date isi amelioreaza \nviteza doar cu un raport mic dar pentru fiecare \noperatiune de inserare sau stergere timpul necesar \ncreste simtitor precum si resursele folosite. \nCurs - BAZE DE DATE 33', 'copyright@www.adrian.runceanu.ro\nCand nu se creaza indecsii si de ce?\n➢In general nu tot timpul este necesar si bine sa fie creati \nindexi in baza de date.\n➢O creare excesiva de indecsi in baza de date are si multe \nneajunsuri. \n➢In momentul in care sunt adaugati indecsi, baza de date \nface o repunere la zi a lor pentru fiecare operatie care \neste executata. \n➢In momentul in care sunt creati prea multi indecsi \noperatile de extragere din baza de date isi amelioreaza \nviteza doar cu un raport mic dar pentru fiecare \noperatiune de inserare sau stergere timpul necesar \ncreste simtitor precum si resursele folosite. \nCurs - BAZE DE DATE 33', 'copyright@www.adrian.runceanu.ro\nCrearea indecșilor \nIndecsii sunt creati in doua feluri:\n1. Automat: In momentul in care se creaza o cheie \nprimara asupra tabelelor, in momentul in care se creaza \no restrictie ca inregistrarile din baza de date sa fie unice \nsi in alte situatii asemanatoare.\n2. Manual: Se pot defini indecsi manuali care nu trebuie \nsa contina o restrictie cum este cazul indecsilor unici.\nCurs - BAZE DE DATE 28']","Îmi pare rău, dar contextul furnizat nu conține informații despre utilizarea instrucțiunii UPDATE combinată cu subinterogări pentru a actualiza date selective. Contextul discută despre crearea și necesitatea indexării în bazele de date. 

Pentru a obține informații despre utilizarea instrucțiunii UPDATE cu subinterogări, vă recomand să căutați resurse specifice despre limbajul SQL și sintaxa sa.
",UPDATE poate folosi o subinterogare pentru a seta valori. Exemplu: „UPDATE EMP SET sal = (SELECT AVG(sal) FROM EMP) WHERE deptno = 10” actualizează salariile din departamentul 10 cu media salarială calculată prin subquery.,0.0,0.0,0.0,0.6666666666666666,0.026075312705251753,0.10101010101010101,0.0
34,O3mini-high,High,"C8, C11",C2,"Cum se aplică constrângerile de integritate (PRIMARY KEY, FOREIGN KEY, CHECK) pentru a asigura securitatea și consistența datelor?","Constrângerile asigură integritatea: PRIMARY KEY identifică unic fiecare rând, FOREIGN KEY “REFERENCES” stabilește relații corecte între tabele, iar CHECK impune condiții (ex.: CHECK(sal > 0)). Aceste reguli „previn pătrunderea de date invalide” și susțin securitatea în medii multi-user.",Este corect,"C11, slide 4","[""2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n); \n \n "", ""2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n); \n \n "", 'copyright@www.adrian.runceanu.ro\nObservaţii\n1. Dacă se activează o constrângere, această \nconstrângere se aplică la toate datele din tabela.\n1. Dacă se activează o constrângere UNIQUE sau \nPRIMARY se creează automat un index UNIQUE sau \nPRIMARY.\n1. Clauza ENABLE se poate utiliza în ambele declaraţii \nCREATE TABLE cât şi ALTER TABLE.\nCurs 8 - BAZE DE DATE 41', 'copyright@www.adrian.runceanu.ro\nObservaţii\n1. Dacă se activează o constrângere, această \nconstrângere se aplică la toate datele din tabela.\n1. Dacă se activează o constrângere UNIQUE sau \nPRIMARY se creează automat un index UNIQUE sau \nPRIMARY.\n1. Clauza ENABLE se poate utiliza în ambele declaraţii \nCREATE TABLE cât şi ALTER TABLE.\nCurs 8 - BAZE DE DATE 41', 'copyright@www.adrian.runceanu.ro\n• După cum am observat a dispărut din sintaxa \nFOREIGN KEY.\n• O constrângere de tip FOREIGN KEY este \ndefinită într-o tabela copil, iar tabela care \nconţine coloana la care se face referinţă este \npărintele.\nCurs 8 - BAZE DE DATE 24']","## Cum se aplică constrângerile de integritate pentru a asigura securitatea și consistența datelor:

Constrângerile de integritate asigură că datele din baza de date sunt corecte și consistente în timp. Iată cum PRIMARY KEY, FOREIGN KEY și CHECK contribuie la acest lucru:

**1. Cheia primară (PRIMARY KEY):**

* **Unicitate:** Garantează că fiecare înregistrare din tabel este unică, identificând-o precis. 
* **Securitate:** Previne inserarea sau actualizarea accidentală a unor înregistrări duplicate.
* **Exemplu:** În tabelul ""Client"", coloana ""ID"" este definită ca PRIMARY KEY, asigurând că fiecare client are un ID unic.

**2. Cheia străină (FOREIGN KEY):**

* **Referențialitate:** Stabilește legături între tabele, asigurând că datele referite există. 
* **Consistență:** Previne ștergerea sau modificarea datelor care ar duce la ""orfanizarea"" informațiilor în alte tabele.
* **Exemplu:** În tabelul ""Comanda"", coloana ""ClientID"" este FOREIGN KEY, referențiind coloana ""ID"" din tabelul ""Client"". Astfel, nu se poate crea o comandă pentru un client inexistent.

**3. Constrângeri CHECK:**

* **Validare:**  Impun reguli specifice pentru valorile introduse într-o coloană.
* **Integritate:**  Asigură că datele respectă anumite condiții, menținând coerența informațiilor.
* **Exemplu:** Se poate folosi o constrângere CHECK pentru a verifica formatul adresei de email în coloana ""Email"" din tabelul ""Client"".

**Concluzie:**

Constrângerile de integritate PRIMARY KEY, FOREIGN KEY și CHECK sunt esențiale pentru a construi baze de date sigure și consistente. Ele previn erorile de inserare, actualizare sau ștergere a datelor, asigurând acuratețea și fiabilitatea informațiilor stocate. 
","Cum se aplică constrângerile de integritate (PRIMARY KEY, FOREIGN KEY, CHECK) pentru a asigura securitatea și consistența datelor?","[""2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n); \n \n "", ""2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n); \n \n "", 'copyright@www.adrian.runceanu.ro\nObservaţii\n1. Dacă se activează o constrângere, această \nconstrângere se aplică la toate datele din tabela.\n1. Dacă se activează o constrângere UNIQUE sau \nPRIMARY se creează automat un index UNIQUE sau \nPRIMARY.\n1. Clauza ENABLE se poate utiliza în ambele declaraţii \nCREATE TABLE cât şi ALTER TABLE.\nCurs 8 - BAZE DE DATE 41', 'copyright@www.adrian.runceanu.ro\nObservaţii\n1. Dacă se activează o constrângere, această \nconstrângere se aplică la toate datele din tabela.\n1. Dacă se activează o constrângere UNIQUE sau \nPRIMARY se creează automat un index UNIQUE sau \nPRIMARY.\n1. Clauza ENABLE se poate utiliza în ambele declaraţii \nCREATE TABLE cât şi ALTER TABLE.\nCurs 8 - BAZE DE DATE 41', 'copyright@www.adrian.runceanu.ro\n• După cum am observat a dispărut din sintaxa \nFOREIGN KEY.\n• O constrângere de tip FOREIGN KEY este \ndefinită într-o tabela copil, iar tabela care \nconţine coloana la care se face referinţă este \npărintele.\nCurs 8 - BAZE DE DATE 24']","## Cum se aplică constrângerile de integritate pentru a asigura securitatea și consistența datelor:

Constrângerile de integritate asigură că datele din baza de date sunt corecte și consistente în timp. Iată cum PRIMARY KEY, FOREIGN KEY și CHECK contribuie la acest lucru:

**1. Cheia primară (PRIMARY KEY):**

* **Unicitate:** Garantează că fiecare înregistrare din tabel este unică, identificând-o precis. 
* **Securitate:** Previne inserarea sau actualizarea accidentală a unor înregistrări duplicate.
* **Exemplu:** În tabelul ""Client"", coloana ""ID"" este definită ca PRIMARY KEY, asigurând că fiecare client are un ID unic.

**2. Cheia străină (FOREIGN KEY):**

* **Referențialitate:** Stabilește legături între tabele, asigurând că datele referite există. 
* **Consistență:** Previne ștergerea sau modificarea datelor care ar duce la ""orfanizarea"" informațiilor în alte tabele.
* **Exemplu:** În tabelul ""Comanda"", coloana ""ClientID"" este FOREIGN KEY, referențiind coloana ""ID"" din tabelul ""Client"". Astfel, nu se poate crea o comandă pentru un client inexistent.

**3. Constrângeri CHECK:**

* **Validare:**  Impun reguli specifice pentru valorile introduse într-o coloană.
* **Integritate:**  Asigură că datele respectă anumite condiții, menținând coerența informațiilor.
* **Exemplu:** Se poate folosi o constrângere CHECK pentru a verifica formatul adresei de email în coloana ""Email"" din tabelul ""Client"".

**Concluzie:**

Constrângerile de integritate PRIMARY KEY, FOREIGN KEY și CHECK sunt esențiale pentru a construi baze de date sigure și consistente. Ele previn erorile de inserare, actualizare sau ștergere a datelor, asigurând acuratețea și fiabilitatea informațiilor stocate. 
","Constrângerile asigură integritatea: PRIMARY KEY identifică unic fiecare rând, FOREIGN KEY “REFERENCES” stabilește relații corecte între tabele, iar CHECK impune condiții (ex.: CHECK(sal > 0)). Aceste reguli „previn pătrunderea de date invalide” și susțin securitatea în medii multi-user.",0.99999999995,1.0,0.8625737139115358,1.0,0.030765593092476264,0.14285714285714285,0.72
35,O3mini-high,High,"C9, C3",C4,Ce avantaje oferă utilizarea vederilor (views) și cum simplifică ele interogările complexe?,"Vederile sunt „tabele logice” definite printr-o instrucțiune SELECT, care nu stochează date proprii, ci le extrag din tabele. Ele oferă acces restricționat, simplifică join-urile complexe și permit reutilizarea codului SQL, facilitând astfel interogările complexe.",Este corect,"C9, slide 6","['copyright@www.adrian.runceanu.ro\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', 'copyright@www.adrian.runceanu.ro\nReguli pentru crearea vederilor\n• Subcererea care defineşte vederea poate conţine cereri \nSELECT complexe incluzând join-uri, grupuri sau alte \nsubcereri. \n• Subcererea principală a vederii nu trebuie să conţina \nclauza ORDER BY. Aceasta se utilizează când se extrag \ndate din vedere.\n• Dacă nu se specifică un nume pentru constrângerea \nWITH CHECK OPTION, sistemul atribuie în mod implicit \nun nume\n• Cu ajutorul opţiunii OR REPLACE vederea este alterată\nfără a o distruge, a o recrea şi a reacorda drepturi asupra \nei. Curs - BAZE DE DATE 17', 'copyright@www.adrian.runceanu.ro\nReguli pentru crearea vederilor\n• Subcererea care defineşte vederea poate conţine cereri \nSELECT complexe incluzând join-uri, grupuri sau alte \nsubcereri. \n• Subcererea principală a vederii nu trebuie să conţina \nclauza ORDER BY. Aceasta se utilizează când se extrag \ndate din vedere.\n• Dacă nu se specifică un nume pentru constrângerea \nWITH CHECK OPTION, sistemul atribuie în mod implicit \nun nume\n• Cu ajutorul opţiunii OR REPLACE vederea este alterată\nfără a o distruge, a o recrea şi a reacorda drepturi asupra \nei. Curs - BAZE DE DATE 17', 'copyright@www.adrian.runceanu.ro\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56', 'copyright@www.adrian.runceanu.ro\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56']","Utilizarea vederilor (views) în bazele de date oferă o serie de avantaje, simplificând în special interogările complexe:

**1. Simplificarea interogărilor:** Vederile permit ascunderea complexității interogărilor.  Pot conține `JOIN`-uri, grupări și alte subcereri, prezentând utilizatorului o tabelă virtuală ușor de interogat. Astfel, utilizatorul nu trebuie să scrie interogări complexe de fiecare dată când are nevoie de aceleași date.

**Exemplu:** În loc să scrieți o interogare complexă care unește date din mai multe tabele, puteți crea o vedere care face acest lucru. Ulterior, puteți interoga vederea ca și cum ar fi un tabel obișnuit.

**2. Securitate:** Vederile pot fi folosite pentru a restricționa accesul la date.  Se poate acorda utilizatorilor permisiunea de a accesa doar anumite coloane sau rânduri dintr-un tabel prin intermediul unei vederi.

**Exemplu:**  Puteți crea o vedere care afișează doar numele și prenumele angajaților, dar nu și salariile acestora.

**3. Claritate:** Vederile pot face codul SQL mai ușor de înțeles,  prin abstractizarea logicii complexe a interogărilor. 

**Concluzie:** Vederile sunt un instrument puternic pentru simplificarea interogărilor complexe și îmbunătățirea gestionării și securității datelor.
",Ce avantaje oferă utilizarea vederilor (views) și cum simplifică ele interogările complexe?,"['copyright@www.adrian.runceanu.ro\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', 'copyright@www.adrian.runceanu.ro\nReguli pentru crearea vederilor\n• Subcererea care defineşte vederea poate conţine cereri \nSELECT complexe incluzând join-uri, grupuri sau alte \nsubcereri. \n• Subcererea principală a vederii nu trebuie să conţina \nclauza ORDER BY. Aceasta se utilizează când se extrag \ndate din vedere.\n• Dacă nu se specifică un nume pentru constrângerea \nWITH CHECK OPTION, sistemul atribuie în mod implicit \nun nume\n• Cu ajutorul opţiunii OR REPLACE vederea este alterată\nfără a o distruge, a o recrea şi a reacorda drepturi asupra \nei. Curs - BAZE DE DATE 17', 'copyright@www.adrian.runceanu.ro\nReguli pentru crearea vederilor\n• Subcererea care defineşte vederea poate conţine cereri \nSELECT complexe incluzând join-uri, grupuri sau alte \nsubcereri. \n• Subcererea principală a vederii nu trebuie să conţina \nclauza ORDER BY. Aceasta se utilizează când se extrag \ndate din vedere.\n• Dacă nu se specifică un nume pentru constrângerea \nWITH CHECK OPTION, sistemul atribuie în mod implicit \nun nume\n• Cu ajutorul opţiunii OR REPLACE vederea este alterată\nfără a o distruge, a o recrea şi a reacorda drepturi asupra \nei. Curs - BAZE DE DATE 17', 'copyright@www.adrian.runceanu.ro\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56', 'copyright@www.adrian.runceanu.ro\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56']","Utilizarea vederilor (views) în bazele de date oferă o serie de avantaje, simplificând în special interogările complexe:

**1. Simplificarea interogărilor:** Vederile permit ascunderea complexității interogărilor.  Pot conține `JOIN`-uri, grupări și alte subcereri, prezentând utilizatorului o tabelă virtuală ușor de interogat. Astfel, utilizatorul nu trebuie să scrie interogări complexe de fiecare dată când are nevoie de aceleași date.

**Exemplu:** În loc să scrieți o interogare complexă care unește date din mai multe tabele, puteți crea o vedere care face acest lucru. Ulterior, puteți interoga vederea ca și cum ar fi un tabel obișnuit.

**2. Securitate:** Vederile pot fi folosite pentru a restricționa accesul la date.  Se poate acorda utilizatorilor permisiunea de a accesa doar anumite coloane sau rânduri dintr-un tabel prin intermediul unei vederi.

**Exemplu:**  Puteți crea o vedere care afișează doar numele și prenumele angajaților, dar nu și salariile acestora.

**3. Claritate:** Vederile pot face codul SQL mai ușor de înțeles,  prin abstractizarea logicii complexe a interogărilor. 

**Concluzie:** Vederile sunt un instrument puternic pentru simplificarea interogărilor complexe și îmbunătățirea gestionării și securității datelor.
","Vederile sunt „tabele logice” definite printr-o instrucțiune SELECT, care nu stochează date proprii, ci le extrag din tabele. Ele oferă acces restricționat, simplifică join-urile complexe și permit reutilizarea codului SQL, facilitând astfel interogările complexe.",0.0,0.0,0.8547236125345349,0.06666666666666667,0.03956623635711305,0.0979591836734694,0.73
36,O3mini-high,High,"C10, C3",C8,Cum contribuie secvențele și indicii la performanța bazelor de date?,"Secvențele generează „rapid numere întregi unice” pentru chei primare, evitând blocajele, iar indicii optimizează căutările prin reducerea operațiilor I/O. Astfel, ele îmbunătățesc semnificativ performanța bazei de date.",Este corect,C10,"['copyright@www.adrian.runceanu.ro\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6', 'copyright@www.adrian.runceanu.ro\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6', 'copyright@www.adrian.runceanu.ro\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5', 'copyright@www.adrian.runceanu.ro\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5', 'copyright@www.adrian.runceanu.ro\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7']","Informația furnizată în text se concentrează pe secvențe și pe modul în care acestea sunt utilizate pentru a genera chei primare unice în bazele de date. Nu se oferă informații despre indici sau despre impactul lor asupra performanței bazelor de date. 

Iată cum contribuie secvențele la performanța bazelor de date, pe baza informațiilor furnizate:

* **Evitarea coliziunilor de chei:** Secvențele asigură generarea de valori unice pentru cheile primare, evitând astfel coliziunile care ar putea apărea dacă aplicațiile ar calcula independent aceste valori.
* **Îmbunătățirea performanței la inserare:**  Utilizarea secvențelor este mai eficienta decât ca aplicațiile să interogheze baza de date pentru a determina următoarea valoare disponibilă pentru o cheie primară. 

Textul menționează că  ""aplicația consuma mai mult timp procesor pentru fiecare inserare şi devine mult mai lentă"" atunci când nu se folosesc secvențe, evidențiind astfel beneficiile lor pentru performanță.

**Cu toate acestea, textul nu oferă informații despre indici și impactul lor asupra performanței bazelor de date.**
",Cum contribuie secvențele și indicii la performanța bazelor de date?,"['copyright@www.adrian.runceanu.ro\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6', 'copyright@www.adrian.runceanu.ro\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6', 'copyright@www.adrian.runceanu.ro\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5', 'copyright@www.adrian.runceanu.ro\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5', 'copyright@www.adrian.runceanu.ro\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7']","Informația furnizată în text se concentrează pe secvențe și pe modul în care acestea sunt utilizate pentru a genera chei primare unice în bazele de date. Nu se oferă informații despre indici sau despre impactul lor asupra performanței bazelor de date. 

Iată cum contribuie secvențele la performanța bazelor de date, pe baza informațiilor furnizate:

* **Evitarea coliziunilor de chei:** Secvențele asigură generarea de valori unice pentru cheile primare, evitând astfel coliziunile care ar putea apărea dacă aplicațiile ar calcula independent aceste valori.
* **Îmbunătățirea performanței la inserare:**  Utilizarea secvențelor este mai eficienta decât ca aplicațiile să interogheze baza de date pentru a determina următoarea valoare disponibilă pentru o cheie primară. 

Textul menționează că  ""aplicația consuma mai mult timp procesor pentru fiecare inserare şi devine mult mai lentă"" atunci când nu se folosesc secvențe, evidențiind astfel beneficiile lor pentru performanță.

**Cu toate acestea, textul nu oferă informații despre indici și impactul lor asupra performanței bazelor de date.**
","Secvențele generează „rapid numere întregi unice” pentru chei primare, evitând blocajele, iar indicii optimizează căutările prin reducerea operațiilor I/O. Astfel, ele îmbunătățesc semnificativ performanța bazei de date.",0.0,0.3333333333333333,0.8331563420973183,0.75,0.04320304869998879,0.13023255813953488,0.4
37,O3mini-high,High,"C11, C2",C8,Cum se implementează controlul accesului și gestionarea privilegiilor în Oracle?,"Controlul accesului se realizează prin acordarea de privilegii de sistem și obiect de către DBA, folosind comenzi precum CREATE USER și GRANT. Aceste măsuri „asigură securitatea utilizării și accesării bazei de date” într-un mediu multi-user.",Este corect,"C11, slide 18","['copyright@www.adrian.runceanu.ro\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oferă facilităţi din tehnologia OO, prin care se permite \ndefinirea şi utilizarea de obiecte mari şi complexe\n• Optimizează cererile de regăsire prin reutilizarea \ncomenzilor SQL identice lansate de utilizatori diferiţi şi \nprin realizarea unui plan de execuţie a instrucţiunilor \nSQL\n• Are un grad de securitate sporit prin: \n– server de criptare\n– control trafic reţea\n– niveluri de parolare, etc.\n11Curs - Baze de date\nSGBD Oracle 8i (continuare)', 'copyright@www.adrian.runceanu.ro\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oferă facilităţi din tehnologia OO, prin care se permite \ndefinirea şi utilizarea de obiecte mari şi complexe\n• Optimizează cererile de regăsire prin reutilizarea \ncomenzilor SQL identice lansate de utilizatori diferiţi şi \nprin realizarea unui plan de execuţie a instrucţiunilor \nSQL\n• Are un grad de securitate sporit prin: \n– server de criptare\n– control trafic reţea\n– niveluri de parolare, etc.\n11Curs - Baze de date\nSGBD Oracle 8i (continuare)', 'copyright@www.adrian.runceanu.ro\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18Curs - Baze de date']","Contextul furnizat menționează că Oracle are ""un grad de securitate sporit"" prin:

* **Server de criptare:**  Criptarea datelor pentru a le proteja în timpul stocării și transmiterii.
* **Control trafic rețea:**  Limitarea accesului la baza de date la anumite adrese IP sau protocoale de rețea.
* **Niveluri de parolare:**  Utilizarea parolelor pentru a controla accesul utilizatorilor la baza de date și la anumite obiecte din baza de date.

Deși contextul nu detaliază modul specific de implementare a controlului accesului și a gestionării privilegiilor, aceste caracteristici de securitate menționate sunt componente esențiale ale unui astfel de sistem. 

Pentru o înțelegere completă a modului în care se implementează controlul accesului și gestionarea privilegiilor în Oracle, ar trebui consultată documentația oficială Oracle sau alte resurse specializate. 
",Cum se implementează controlul accesului și gestionarea privilegiilor în Oracle?,"['copyright@www.adrian.runceanu.ro\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oferă facilităţi din tehnologia OO, prin care se permite \ndefinirea şi utilizarea de obiecte mari şi complexe\n• Optimizează cererile de regăsire prin reutilizarea \ncomenzilor SQL identice lansate de utilizatori diferiţi şi \nprin realizarea unui plan de execuţie a instrucţiunilor \nSQL\n• Are un grad de securitate sporit prin: \n– server de criptare\n– control trafic reţea\n– niveluri de parolare, etc.\n11Curs - Baze de date\nSGBD Oracle 8i (continuare)', 'copyright@www.adrian.runceanu.ro\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oferă facilităţi din tehnologia OO, prin care se permite \ndefinirea şi utilizarea de obiecte mari şi complexe\n• Optimizează cererile de regăsire prin reutilizarea \ncomenzilor SQL identice lansate de utilizatori diferiţi şi \nprin realizarea unui plan de execuţie a instrucţiunilor \nSQL\n• Are un grad de securitate sporit prin: \n– server de criptare\n– control trafic reţea\n– niveluri de parolare, etc.\n11Curs - Baze de date\nSGBD Oracle 8i (continuare)', 'copyright@www.adrian.runceanu.ro\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18Curs - Baze de date']","Contextul furnizat menționează că Oracle are ""un grad de securitate sporit"" prin:

* **Server de criptare:**  Criptarea datelor pentru a le proteja în timpul stocării și transmiterii.
* **Control trafic rețea:**  Limitarea accesului la baza de date la anumite adrese IP sau protocoale de rețea.
* **Niveluri de parolare:**  Utilizarea parolelor pentru a controla accesul utilizatorilor la baza de date și la anumite obiecte din baza de date.

Deși contextul nu detaliază modul specific de implementare a controlului accesului și a gestionării privilegiilor, aceste caracteristici de securitate menționate sunt componente esențiale ale unui astfel de sistem. 

Pentru o înțelegere completă a modului în care se implementează controlul accesului și gestionarea privilegiilor în Oracle, ar trebui consultată documentația oficială Oracle sau alte resurse specializate. 
","Controlul accesului se realizează prin acordarea de privilegii de sistem și obiect de către DBA, folosind comenzi precum CREATE USER și GRANT. Aceste măsuri „asigură securitatea utilizării și accesării bazei de date” într-un mediu multi-user.",0.0,0.0,0.0,0.5714285714285714,0.009076566180443509,0.11695906432748539,0.46
38,O3mini-high,High,"C12, C1",C13,Care sunt principalele diferențe între sistemele tradiționale de fișiere și bazele de date moderne?,"Bazele de date moderne elimină redundanța, îmbunătățesc integritatea, oferă acces rapid și securitate sporită, spre deosebire de sistemele tradiționale de fișiere, unde datele sunt gestionate prin programe personalizate. „Accesul rapid și sigur la date” este un avantaj major al bazelor de date moderne.",Este corect,"C12, pagina 2","['2 \n \n1.2.2. Limitări ale sistemelor tradiționale de fișiere: \n1. Redundanță și inconsistență - Aceleași date pot fi stocate în mai multe fișiere, ducând la \ninconsistențe și consum excesiv de spațiu. \n2. Lipsa integrității  - Nu există mecanisme automate pentru a asigura corectitudinea și \nvaliditatea datelor. \n3. Dificultăți în accesul la date  - Accesul la date necesită dezvoltarea de programe \npersonalizate pentru fiecare tip de interogare. \n4. Lipsa securității  - Nu există mecanisme eficiente pentru restricționarea accesului la \nanumite date. \n5. Dificultăți în partajarea datelor - Accesul simultan la fișiere de către mai mulți utilizatori \neste dificil de gestionat. \n \n1.3. Bazele de date moderne \nBazele de date elimină majoritatea acestor probleme prin utilizarea unui sistem centralizat \nde gestionare a datelor. Acestea permit accesul eficient la informații, reduc redundanța și oferă \nmecanisme avansate de securitate și integritate. \n \n1.4.Avantajele bazelor de date față de fișierele tradiționale: \n1. Eliminarea redundanței  - Datele sunt normalizate și stocate într -un mod care \nminimizează duplicările. \n2. Îmbunătățirea integrității - Se pot defini constrângeri care asigură coerența și validitatea \ndatelor. \n3. Acces flexibil la date  - Utilizatorii pot efectua interogări complexe folosind limbaje \nprecum SQL. \n4. Securitate sporită - Se pot implementa niveluri diferite de acces pentru utilizatori. \n5. Partajare eficientă a datelor - Mai mulți utilizatori pot accesa simultan baza de date fără \na afecta integritatea informațiilor. \n \n \n1.5. Componentele unui sistem de baze de date \nUn sistem de baze de date este compus din mai multe elemente esențiale care asigură \nfuncționarea și gestionarea eficientă a datelor. Aceste componente includ hardware, software, date, \nutilizatori și proceduri.  \n \n \n1. Hardware \nHardware-ul reprezintă infrastructura fizică necesară pentru \noperarea unei baze de date. Acesta include: \n✓ Servere și stații de lucru \n✓ Dispozitive de stocare (SSD, HDD, unități cloud) \n✓ Rețele de comunicație \n✓ Procesoare și memorie RAM pentru optimizarea \nperformanței \n \n \n \n', '2 \n \n1.2.2. Limitări ale sistemelor tradiționale de fișiere: \n1. Redundanță și inconsistență - Aceleași date pot fi stocate în mai multe fișiere, ducând la \ninconsistențe și consum excesiv de spațiu. \n2. Lipsa integrității  - Nu există mecanisme automate pentru a asigura corectitudinea și \nvaliditatea datelor. \n3. Dificultăți în accesul la date  - Accesul la date necesită dezvoltarea de programe \npersonalizate pentru fiecare tip de interogare. \n4. Lipsa securității  - Nu există mecanisme eficiente pentru restricționarea accesului la \nanumite date. \n5. Dificultăți în partajarea datelor - Accesul simultan la fișiere de către mai mulți utilizatori \neste dificil de gestionat. \n \n1.3. Bazele de date moderne \nBazele de date elimină majoritatea acestor probleme prin utilizarea unui sistem centralizat \nde gestionare a datelor. Acestea permit accesul eficient la informații, reduc redundanța și oferă \nmecanisme avansate de securitate și integritate. \n \n1.4.Avantajele bazelor de date față de fișierele tradiționale: \n1. Eliminarea redundanței  - Datele sunt normalizate și stocate într -un mod care \nminimizează duplicările. \n2. Îmbunătățirea integrității - Se pot defini constrângeri care asigură coerența și validitatea \ndatelor. \n3. Acces flexibil la date  - Utilizatorii pot efectua interogări complexe folosind limbaje \nprecum SQL. \n4. Securitate sporită - Se pot implementa niveluri diferite de acces pentru utilizatori. \n5. Partajare eficientă a datelor - Mai mulți utilizatori pot accesa simultan baza de date fără \na afecta integritatea informațiilor. \n \n \n1.5. Componentele unui sistem de baze de date \nUn sistem de baze de date este compus din mai multe elemente esențiale care asigură \nfuncționarea și gestionarea eficientă a datelor. Aceste componente includ hardware, software, date, \nutilizatori și proceduri.  \n \n \n1. Hardware \nHardware-ul reprezintă infrastructura fizică necesară pentru \noperarea unei baze de date. Acesta include: \n✓ Servere și stații de lucru \n✓ Dispozitive de stocare (SSD, HDD, unități cloud) \n✓ Rețele de comunicație \n✓ Procesoare și memorie RAM pentru optimizarea \nperformanței \n \n \n \n', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', 'copyright@www.adrian.runceanu.ro\nOrice firmă utilizează baze de date pentru păstrarea \nşi gestionarea informaţiilor. Câteva astfel de aplicaţii sunt \nuzuale:\n1.bazele de date ale liniilor aeriene care sunt accesate \nsimultan din sute de agenţii pentru a realiza rezervări şi \nvânzări de locuri pentru date şi zboruri diferite\n2.bazele de date ale băncilor care permit realizarea a mii \nde tranzacţii zilnic\n3.bazele de date ale supermagazinelor care sunt accesate \natât de la casele de marcaj cât şi de la echipamentele de \ninventariere\n4.bazele de date ale bibliotecilor care păstrează milioane \nde titluri şi permit localizarea unei lucrări folosind diferite \ncriterii (cuvinte cheie, titlu, autori, domeniu)\nCurs - Baze de date 17']","Sistemele tradiționale de fișiere și bazele de date moderne prezintă diferențe majore în ceea ce privește gestionarea datelor. Iată principalele diferențe:

**Sistemele tradiționale de fișiere:**

* **Redundanță și inconsistență:** Aceleași date pot fi stocate în mai multe fișiere, ducând la  inconsistențe și consum excesiv de spațiu.
* **Lipsa integrității:**  Nu există mecanisme automate pentru a asigura corectitudinea și validitatea datelor.
* **Dificultăți în accesul la date:**  Accesul la date necesită dezvoltarea de programe personalizate pentru fiecare tip de interogare.
* **Lipsa securității:**  Nu există mecanisme eficiente pentru restricționarea accesului la anumite date.
* **Dificultăți în partajarea datelor:**  Accesul simultan la fișiere de către mai mulți utilizatori este dificil de gestionat.

**Bazele de date moderne:**

* **Eliminarea redundanței:** Datele sunt normalizate și stocate într-un mod care minimizează duplicările.
* **Îmbunătățirea integrității:** Se pot defini constrângeri care asigură coerența și validitatea datelor.
* **Acces flexibil la date:** Utilizatorii pot efectua interogări complexe folosind limbaje precum SQL.
* **Securitate sporită:** Se pot implementa niveluri diferite de acces pentru utilizatori.
* **Partajare eficientă a datelor:** Mai mulți utilizatori pot accesa simultan baza de date fără a afecta integritatea informațiilor.

În esență, bazele de date moderne oferă o gestionare centralizată, eficientă și sigură a datelor, depășind limitările sistemelor tradiționale de fișiere.
",Care sunt principalele diferențe între sistemele tradiționale de fișiere și bazele de date moderne?,"['2 \n \n1.2.2. Limitări ale sistemelor tradiționale de fișiere: \n1. Redundanță și inconsistență - Aceleași date pot fi stocate în mai multe fișiere, ducând la \ninconsistențe și consum excesiv de spațiu. \n2. Lipsa integrității  - Nu există mecanisme automate pentru a asigura corectitudinea și \nvaliditatea datelor. \n3. Dificultăți în accesul la date  - Accesul la date necesită dezvoltarea de programe \npersonalizate pentru fiecare tip de interogare. \n4. Lipsa securității  - Nu există mecanisme eficiente pentru restricționarea accesului la \nanumite date. \n5. Dificultăți în partajarea datelor - Accesul simultan la fișiere de către mai mulți utilizatori \neste dificil de gestionat. \n \n1.3. Bazele de date moderne \nBazele de date elimină majoritatea acestor probleme prin utilizarea unui sistem centralizat \nde gestionare a datelor. Acestea permit accesul eficient la informații, reduc redundanța și oferă \nmecanisme avansate de securitate și integritate. \n \n1.4.Avantajele bazelor de date față de fișierele tradiționale: \n1. Eliminarea redundanței  - Datele sunt normalizate și stocate într -un mod care \nminimizează duplicările. \n2. Îmbunătățirea integrității - Se pot defini constrângeri care asigură coerența și validitatea \ndatelor. \n3. Acces flexibil la date  - Utilizatorii pot efectua interogări complexe folosind limbaje \nprecum SQL. \n4. Securitate sporită - Se pot implementa niveluri diferite de acces pentru utilizatori. \n5. Partajare eficientă a datelor - Mai mulți utilizatori pot accesa simultan baza de date fără \na afecta integritatea informațiilor. \n \n \n1.5. Componentele unui sistem de baze de date \nUn sistem de baze de date este compus din mai multe elemente esențiale care asigură \nfuncționarea și gestionarea eficientă a datelor. Aceste componente includ hardware, software, date, \nutilizatori și proceduri.  \n \n \n1. Hardware \nHardware-ul reprezintă infrastructura fizică necesară pentru \noperarea unei baze de date. Acesta include: \n✓ Servere și stații de lucru \n✓ Dispozitive de stocare (SSD, HDD, unități cloud) \n✓ Rețele de comunicație \n✓ Procesoare și memorie RAM pentru optimizarea \nperformanței \n \n \n \n', '2 \n \n1.2.2. Limitări ale sistemelor tradiționale de fișiere: \n1. Redundanță și inconsistență - Aceleași date pot fi stocate în mai multe fișiere, ducând la \ninconsistențe și consum excesiv de spațiu. \n2. Lipsa integrității  - Nu există mecanisme automate pentru a asigura corectitudinea și \nvaliditatea datelor. \n3. Dificultăți în accesul la date  - Accesul la date necesită dezvoltarea de programe \npersonalizate pentru fiecare tip de interogare. \n4. Lipsa securității  - Nu există mecanisme eficiente pentru restricționarea accesului la \nanumite date. \n5. Dificultăți în partajarea datelor - Accesul simultan la fișiere de către mai mulți utilizatori \neste dificil de gestionat. \n \n1.3. Bazele de date moderne \nBazele de date elimină majoritatea acestor probleme prin utilizarea unui sistem centralizat \nde gestionare a datelor. Acestea permit accesul eficient la informații, reduc redundanța și oferă \nmecanisme avansate de securitate și integritate. \n \n1.4.Avantajele bazelor de date față de fișierele tradiționale: \n1. Eliminarea redundanței  - Datele sunt normalizate și stocate într -un mod care \nminimizează duplicările. \n2. Îmbunătățirea integrității - Se pot defini constrângeri care asigură coerența și validitatea \ndatelor. \n3. Acces flexibil la date  - Utilizatorii pot efectua interogări complexe folosind limbaje \nprecum SQL. \n4. Securitate sporită - Se pot implementa niveluri diferite de acces pentru utilizatori. \n5. Partajare eficientă a datelor - Mai mulți utilizatori pot accesa simultan baza de date fără \na afecta integritatea informațiilor. \n \n \n1.5. Componentele unui sistem de baze de date \nUn sistem de baze de date este compus din mai multe elemente esențiale care asigură \nfuncționarea și gestionarea eficientă a datelor. Aceste componente includ hardware, software, date, \nutilizatori și proceduri.  \n \n \n1. Hardware \nHardware-ul reprezintă infrastructura fizică necesară pentru \noperarea unei baze de date. Acesta include: \n✓ Servere și stații de lucru \n✓ Dispozitive de stocare (SSD, HDD, unități cloud) \n✓ Rețele de comunicație \n✓ Procesoare și memorie RAM pentru optimizarea \nperformanței \n \n \n \n', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', 'copyright@www.adrian.runceanu.ro\nOrice firmă utilizează baze de date pentru păstrarea \nşi gestionarea informaţiilor. Câteva astfel de aplicaţii sunt \nuzuale:\n1.bazele de date ale liniilor aeriene care sunt accesate \nsimultan din sute de agenţii pentru a realiza rezervări şi \nvânzări de locuri pentru date şi zboruri diferite\n2.bazele de date ale băncilor care permit realizarea a mii \nde tranzacţii zilnic\n3.bazele de date ale supermagazinelor care sunt accesate \natât de la casele de marcaj cât şi de la echipamentele de \ninventariere\n4.bazele de date ale bibliotecilor care păstrează milioane \nde titluri şi permit localizarea unei lucrări folosind diferite \ncriterii (cuvinte cheie, titlu, autori, domeniu)\nCurs - Baze de date 17']","Sistemele tradiționale de fișiere și bazele de date moderne prezintă diferențe majore în ceea ce privește gestionarea datelor. Iată principalele diferențe:

**Sistemele tradiționale de fișiere:**

* **Redundanță și inconsistență:** Aceleași date pot fi stocate în mai multe fișiere, ducând la  inconsistențe și consum excesiv de spațiu.
* **Lipsa integrității:**  Nu există mecanisme automate pentru a asigura corectitudinea și validitatea datelor.
* **Dificultăți în accesul la date:**  Accesul la date necesită dezvoltarea de programe personalizate pentru fiecare tip de interogare.
* **Lipsa securității:**  Nu există mecanisme eficiente pentru restricționarea accesului la anumite date.
* **Dificultăți în partajarea datelor:**  Accesul simultan la fișiere de către mai mulți utilizatori este dificil de gestionat.

**Bazele de date moderne:**

* **Eliminarea redundanței:** Datele sunt normalizate și stocate într-un mod care minimizează duplicările.
* **Îmbunătățirea integrității:** Se pot defini constrângeri care asigură coerența și validitatea datelor.
* **Acces flexibil la date:** Utilizatorii pot efectua interogări complexe folosind limbaje precum SQL.
* **Securitate sporită:** Se pot implementa niveluri diferite de acces pentru utilizatori.
* **Partajare eficientă a datelor:** Mai mulți utilizatori pot accesa simultan baza de date fără a afecta integritatea informațiilor.

În esență, bazele de date moderne oferă o gestionare centralizată, eficientă și sigură a datelor, depășind limitările sistemelor tradiționale de fișiere.
","Bazele de date moderne elimină redundanța, îmbunătățesc integritatea, oferă acces rapid și securitate sporită, spre deosebire de sistemele tradiționale de fișiere, unde datele sunt gestionate prin programe personalizate. „Accesul rapid și sigur la date” este un avantaj major al bazelor de date moderne.",0.999999999975,1.0,0.8798765456070751,1.0,0.13973536728747976,0.1357142857142857,0.33
39,O3mini-high,High,"C13, C4",C5,Cum asigură modelul relațional integritatea datelor și ce rol joacă SQL în implementarea constrângerilor?,"Modelul relațional folosește chei primare și străine pentru a asigura integritatea, iar SQL permite definirea constrângerilor (ex.: PRIMARY KEY, FOREIGN KEY, CHECK). Aceste reguli „mențin coerența și validitatea datelor” la nivel de tabelă.",Este corect,"C13, pagina 1","[""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată']","Modelul relațional asigură integritatea datelor prin intermediul cheilor primare și cheilor străine. 

**Cheile primare** garantează unicitatea fiecărei înregistrări dintr-un tabel. Aceasta înseamnă că nu pot exista două rânduri cu aceeași valoare a cheii primare. 

**Cheile străine** definesc relațiile dintre tabele, asigurând că datele din tabele diferite sunt consistente între ele. De exemplu, o cheie străină într-un tabel poate face referire la o cheie primară dintr-un alt tabel, asigurând că relația dintre înregistrările respective este validă.

**SQL (Structured Query Language)** este un limbaj de programare utilizat pentru a gestiona și a interoga bazele de date relaționale. SQL joacă un rol esențial în implementarea constrângerilor de integritate a datelor prin intermediul unor comenzi specifice, cum ar fi:

* **PRIMARY KEY**: Definește o coloană sau un set de coloane ca și cheie primară.
* **FOREIGN KEY**: Definește o coloană sau un set de coloane ca și cheie străină, specificând tabelul și coloana la care face referință.
* **UNIQUE**: Asigură unicitatea valorilor dintr-o coloană sau un set de coloane.
* **CHECK**: Definește condiții specifice pe care datele trebuie să le respecte pentru a fi valide.

Prin utilizarea acestor comenzi SQL, se pot impune reguli stricte la nivelul bazei de date, asigurând integritatea și consistența datelor.
",Cum asigură modelul relațional integritatea datelor și ce rol joacă SQL în implementarea constrângerilor?,"[""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată', 'Baze de date\nAdrian \nRunceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată']","Modelul relațional asigură integritatea datelor prin intermediul cheilor primare și cheilor străine. 

**Cheile primare** garantează unicitatea fiecărei înregistrări dintr-un tabel. Aceasta înseamnă că nu pot exista două rânduri cu aceeași valoare a cheii primare. 

**Cheile străine** definesc relațiile dintre tabele, asigurând că datele din tabele diferite sunt consistente între ele. De exemplu, o cheie străină într-un tabel poate face referire la o cheie primară dintr-un alt tabel, asigurând că relația dintre înregistrările respective este validă.

**SQL (Structured Query Language)** este un limbaj de programare utilizat pentru a gestiona și a interoga bazele de date relaționale. SQL joacă un rol esențial în implementarea constrângerilor de integritate a datelor prin intermediul unor comenzi specifice, cum ar fi:

* **PRIMARY KEY**: Definește o coloană sau un set de coloane ca și cheie primară.
* **FOREIGN KEY**: Definește o coloană sau un set de coloane ca și cheie străină, specificând tabelul și coloana la care face referință.
* **UNIQUE**: Asigură unicitatea valorilor dintr-o coloană sau un set de coloane.
* **CHECK**: Definește condiții specifice pe care datele trebuie să le respecte pentru a fi valide.

Prin utilizarea acestor comenzi SQL, se pot impune reguli stricte la nivelul bazei de date, asigurând integritatea și consistența datelor.
","Modelul relațional folosește chei primare și străine pentru a asigura integritatea, iar SQL permite definirea constrângerilor (ex.: PRIMARY KEY, FOREIGN KEY, CHECK). Aceste reguli „mențin coerența și validitatea datelor” la nivel de tabelă.",0.99999999995,1.0,0.9426354863386562,0.4,0.10600313379512592,0.15151515151515152,0.4
40,O3mini-high,High,"C7, C6",C3,Cum se realizează o operație complexă de manipulare a datelor folosind subinterogări?,"Operația combină DML și subinterogări pentru actualizări selective. De exemplu: „UPDATE EMP SET sal = sal * 1.1 WHERE sal < (SELECT AVG(sal) FROM EMP)” actualizează salariile angajaților cu valori sub medie, folosind rezultatul unei subinterogări în clauza WHERE.",Este corect,Curs ???,"['copyright@www.adrian.runceanu.ro\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56', 'copyright@www.adrian.runceanu.ro\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56', 'copyright@www.adrian.runceanu.ro\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\nCurs - Baze de date 51', 'copyright@www.adrian.runceanu.ro\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\nCurs - Baze de date 51', 'copyright@www.adrian.runceanu.ro\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\nCurs - Baze de date 50']","Contextul furnizat descrie subinterogările corelate, nu operațiile complexe de manipulare a datelor în general. 

O **subinterogare corelată** este o subinterogare ce se execută o dată pentru fiecare linie din interogarea principală și folosește la execuție o valoare dintr-o coloană din interogarea exterioară. 

Contextul nu oferă informații despre cum se realizează **operații complexe de manipulare a datelor**. Pentru a răspunde la întrebarea utilizatorului, ar fi nevoie de mai multe detalii despre tipul de operații complexe dorite (ex: agregări, transformări, joncțiuni complexe etc.) și sistemul de gestiune a bazelor de date utilizat (ex: SQL, NoSQL).
 
Pe scurt, informația din context nu este suficientă pentru a răspunde la întrebarea utilizatorului.
",Cum se realizează o operație complexă de manipulare a datelor folosind subinterogări?,"['copyright@www.adrian.runceanu.ro\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56', 'copyright@www.adrian.runceanu.ro\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56', 'copyright@www.adrian.runceanu.ro\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\nCurs - Baze de date 51', 'copyright@www.adrian.runceanu.ro\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\nCurs - Baze de date 51', 'copyright@www.adrian.runceanu.ro\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\nCurs - Baze de date 50']","Contextul furnizat descrie subinterogările corelate, nu operațiile complexe de manipulare a datelor în general. 

O **subinterogare corelată** este o subinterogare ce se execută o dată pentru fiecare linie din interogarea principală și folosește la execuție o valoare dintr-o coloană din interogarea exterioară. 

Contextul nu oferă informații despre cum se realizează **operații complexe de manipulare a datelor**. Pentru a răspunde la întrebarea utilizatorului, ar fi nevoie de mai multe detalii despre tipul de operații complexe dorite (ex: agregări, transformări, joncțiuni complexe etc.) și sistemul de gestiune a bazelor de date utilizat (ex: SQL, NoSQL).
 
Pe scurt, informația din context nu este suficientă pentru a răspunde la întrebarea utilizatorului.
","Operația combină DML și subinterogări pentru actualizări selective. De exemplu: „UPDATE EMP SET sal = sal * 1.1 WHERE sal < (SELECT AVG(sal) FROM EMP)” actualizează salariile angajaților cu valori sub medie, folosind rezultatul unei subinterogări în clauza WHERE.",0.0,0.0,0.0,0.7777777777777778,0.031251907639724415,0.06097560975609755,0.0
41,O3mini-high,High,"C8, C9",C11,Cum pot fi utilizate constrângerile și vederile pentru implementarea politicilor de securitate în baze de date?,"Constrângerile (NOT NULL, FOREIGN KEY, CHECK) asigură „integritatea datelor”, iar vederile controlează accesul la informații sensibile. Împreună, ele permit „controlul accesului la obiecte specifice” și implementează politici stricte de securitate în mediul de baze de date.",Este corect,Curs ???,"['copyright@www.adrian.runceanu.ro\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5', 'copyright@www.adrian.runceanu.ro\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5', 'copyright@www.adrian.runceanu.ro\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\nCurs - Baze de date 54', 'copyright@www.adrian.runceanu.ro\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\nCurs - Baze de date 54', 'copyright@www.adrian.runceanu.ro\nExista unele restrictii in cazul alterarii unei secvente deja existe. \nAcestea sunt:\n1. Userul care executa actiunea de alterare trebuie sa aiba \ndrepturile necesare sau sa fie proprietarul secventei.\n2. Numai numerele care vor fi generate in viitor vor fi afectate.\n3. Secventa va trebui distrusa si recreata pentru ca valoarea de \ninceput sa poata fi modificata\n4. Anumite validari logice de genul ca valoarea maxima nou \nsetata trebuie sa nu fie mai mica decat valoarea care exista \ndeja, trebuie indeplinite.\nCurs - BAZE DE DATE 22']","Informațiile furnizate în context nu menționează utilizarea constrângerilor și a vizualizărilor pentru implementarea politicilor de securitate în bazele de date. Prin urmare, nu pot oferi un răspuns la întrebarea dumneavoastră pe baza acestui context. 

Totuși, pot să vă spun că, în general, constrângerile și vizualizările pot fi utilizate pentru a implementa politici de securitate în bazele de date. 

Iată câteva exemple:

* **Constrângeri**: 
    * **Constrângerile de integritate a datelor**: Acestea asigură validitatea și coerența datelor. De exemplu, se poate seta o constrângere care să nu permită introducerea unui salariu negativ în baza de date.
    * **Constrângeri de domeniu**: Acestea definesc tipurile de date permise pentru o anumită coloană. De exemplu, se poate seta o constrângere de domeniu care să permită doar introducerea de numere într-o coloană care stochează vârste.
* **Vizualizări**:
    * **Vizualizările restricționate**: Acestea permit utilizatorilor să vadă doar o parte a datelor dintr-un tabel, în funcție de permisiunile lor de acces. De exemplu, se poate crea o vizualizare care să permită angajaților să vadă doar propriile lor date salariale, și nu și ale colegilor.

Prin combinarea constrângerilor și a vizualizărilor, se pot implementa politici de securitate complexe în bazele de date, asigurând astfel confidențialitatea, integritatea și disponibilitatea datelor.
",Cum pot fi utilizate constrângerile și vederile pentru implementarea politicilor de securitate în baze de date?,"['copyright@www.adrian.runceanu.ro\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5', 'copyright@www.adrian.runceanu.ro\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5', 'copyright@www.adrian.runceanu.ro\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\nCurs - Baze de date 54', 'copyright@www.adrian.runceanu.ro\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\nCurs - Baze de date 54', 'copyright@www.adrian.runceanu.ro\nExista unele restrictii in cazul alterarii unei secvente deja existe. \nAcestea sunt:\n1. Userul care executa actiunea de alterare trebuie sa aiba \ndrepturile necesare sau sa fie proprietarul secventei.\n2. Numai numerele care vor fi generate in viitor vor fi afectate.\n3. Secventa va trebui distrusa si recreata pentru ca valoarea de \ninceput sa poata fi modificata\n4. Anumite validari logice de genul ca valoarea maxima nou \nsetata trebuie sa nu fie mai mica decat valoarea care exista \ndeja, trebuie indeplinite.\nCurs - BAZE DE DATE 22']","Informațiile furnizate în context nu menționează utilizarea constrângerilor și a vizualizărilor pentru implementarea politicilor de securitate în bazele de date. Prin urmare, nu pot oferi un răspuns la întrebarea dumneavoastră pe baza acestui context. 

Totuși, pot să vă spun că, în general, constrângerile și vizualizările pot fi utilizate pentru a implementa politici de securitate în bazele de date. 

Iată câteva exemple:

* **Constrângeri**: 
    * **Constrângerile de integritate a datelor**: Acestea asigură validitatea și coerența datelor. De exemplu, se poate seta o constrângere care să nu permită introducerea unui salariu negativ în baza de date.
    * **Constrângeri de domeniu**: Acestea definesc tipurile de date permise pentru o anumită coloană. De exemplu, se poate seta o constrângere de domeniu care să permită doar introducerea de numere într-o coloană care stochează vârste.
* **Vizualizări**:
    * **Vizualizările restricționate**: Acestea permit utilizatorilor să vadă doar o parte a datelor dintr-un tabel, în funcție de permisiunile lor de acces. De exemplu, se poate crea o vizualizare care să permită angajaților să vadă doar propriile lor date salariale, și nu și ale colegilor.

Prin combinarea constrângerilor și a vizualizărilor, se pot implementa politici de securitate complexe în bazele de date, asigurând astfel confidențialitatea, integritatea și disponibilitatea datelor.
","Constrângerile (NOT NULL, FOREIGN KEY, CHECK) asigură „integritatea datelor”, iar vederile controlează accesul la informații sensibile. Împreună, ele permit „controlul accesului la obiecte specifice” și implementează politici stricte de securitate în mediul de baze de date.",0.0,0.0,0.9365526623643134,0.18181818181818182,0.089221526116501,0.09230769230769233,0.57
42,Manual - Test 1,,,1,Ce înseamnă SQL?,Structured Query Language,Este corect,,"['copyright@www.adrian.runceanu.ro\nPentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22', 'copyright@www.adrian.runceanu.ro\nPentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3']","Deși textul oferă informații despre comenzile SQL și cum se utilizează acestea (de exemplu, comanda SELECT), nu definește explicit ce este SQL. 

Pentru a răspunde la întrebarea ""Ce înseamnă SQL?"", iată o definiție:

**SQL (Structured Query Language)** este un limbaj standardizat utilizat pentru a gestiona și interoga baze de date relaționale. Cu SQL, puteți să creați, să modificați și să ștergeți date, precum și să preluați și să analizați informații din baze de date.
",Ce înseamnă SQL?,"['copyright@www.adrian.runceanu.ro\nPentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22', 'copyright@www.adrian.runceanu.ro\nPentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3']","Deși textul oferă informații despre comenzile SQL și cum se utilizează acestea (de exemplu, comanda SELECT), nu definește explicit ce este SQL. 

Pentru a răspunde la întrebarea ""Ce înseamnă SQL?"", iată o definiție:

**SQL (Structured Query Language)** este un limbaj standardizat utilizat pentru a gestiona și interoga baze de date relaționale. Cu SQL, puteți să creați, să modificați și să ștergeți date, precum și să preluați și să analizați informații din baze de date.
",Structured Query Language,0.0,0.0,0.9301472086082749,0.0,0.0,0.06666666666666667,0.5
43,Manual - Test 1,,,2,Ce instrucțiune SQL se folosește pentru extragerea datelor dintr-o bază de date?,SELECT,Este corect,,"['copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'copyright@www.adrian.runceanu.ro\nConţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\nCurs - Baze de date\n 14\n']","Contextul furnizat nu oferă informații despre instrucțiunea SQL specifică utilizată pentru extragerea datelor dintr-o bază de date. 

Totuși, instrucțiunea SQL folosită pentru extragerea datelor este **SELECT**. 

Sintaxa generală a instrucțiunii SELECT este:

```sql
SELECT coloana1, coloana2, ...
FROM tabel
WHERE conditie;
```

Unde:

* **SELECT** specifică coloanele pe care doriți să le extrageți.
* **FROM**  specifică tabelul din care doriți să extrageți datele.
* **WHERE** este opțională și specifică o condiție care trebuie îndeplinită pentru ca o înregistrare să fie inclusă în rezultate.

De exemplu, pentru a extrage toate coloanele din tabelul ""Angajati"":

```sql
SELECT *
FROM Angajati;
``` 
",Ce instrucțiune SQL se folosește pentru extragerea datelor dintr-o bază de date?,"['copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'copyright@www.adrian.runceanu.ro\nConţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\nCurs - Baze de date\n 14\n']","Contextul furnizat nu oferă informații despre instrucțiunea SQL specifică utilizată pentru extragerea datelor dintr-o bază de date. 

Totuși, instrucțiunea SQL folosită pentru extragerea datelor este **SELECT**. 

Sintaxa generală a instrucțiunii SELECT este:

```sql
SELECT coloana1, coloana2, ...
FROM tabel
WHERE conditie;
```

Unde:

* **SELECT** specifică coloanele pe care doriți să le extrageți.
* **FROM**  specifică tabelul din care doriți să extrageți datele.
* **WHERE** este opțională și specifică o condiție care trebuie îndeplinită pentru ca o înregistrare să fie inclusă în rezultate.

De exemplu, pentru a extrage toate coloanele din tabelul ""Angajati"":

```sql
SELECT *
FROM Angajati;
``` 
",SELECT,0.0,0.0,0.873193420956802,0.14285714285714285,0.0,0.01904761904761905,0.25
44,Manual - Test 1,,,3,Ce instrucțiune SQL se folosește pentru actualizarea datelor dintr-o bază de date?,UPDATE,Este corect,,"['2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73Curs - Baze de date', '2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\nConţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\nCurs - Baze de date\n 14\n']","Informațiile furnizate în context nu menționează instrucțiunea SQL folosită pentru actualizarea datelor dintr-o bază de date. 

Totuși, instrucțiunea SQL folosită pentru actualizarea datelor este **UPDATE**. 

Sintaxa generală a instrucțiunii UPDATE este:

```sql
UPDATE nume_tabel
SET nume_coloana1 = valoare1, nume_coloana2 = valoare2, ...
WHERE conditie;
```

Unde:

* **nume_tabel** este numele tabelului care conține datele pe care doriți să le actualizați.
* **nume_coloana1**, **nume_coloana2**, ... sunt numele coloanelor pe care doriți să le actualizați.
* **valoare1**, **valoare2**, ... sunt noile valori pe care doriți să le atribuiți coloanelor specificate.
* **conditie** este o clauză opțională care specifică ce înregistrări din tabel ar trebui actualizate. Dacă nu este specificată nicio condiție, toate înregistrările din tabel vor fi actualizate.
",Ce instrucțiune SQL se folosește pentru actualizarea datelor dintr-o bază de date?,"['2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73Curs - Baze de date', '2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\nConţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\nCurs - Baze de date\n 14\n']","Informațiile furnizate în context nu menționează instrucțiunea SQL folosită pentru actualizarea datelor dintr-o bază de date. 

Totuși, instrucțiunea SQL folosită pentru actualizarea datelor este **UPDATE**. 

Sintaxa generală a instrucțiunii UPDATE este:

```sql
UPDATE nume_tabel
SET nume_coloana1 = valoare1, nume_coloana2 = valoare2, ...
WHERE conditie;
```

Unde:

* **nume_tabel** este numele tabelului care conține datele pe care doriți să le actualizați.
* **nume_coloana1**, **nume_coloana2**, ... sunt numele coloanelor pe care doriți să le actualizați.
* **valoare1**, **valoare2**, ... sunt noile valori pe care doriți să le atribuiți coloanelor specificate.
* **conditie** este o clauză opțională care specifică ce înregistrări din tabel ar trebui actualizate. Dacă nu este specificată nicio condiție, toate înregistrările din tabel vor fi actualizate.
",UPDATE,0.0,0.0,0.8726657713162371,0.125,0.0,0.015267175572519085,0.22
45,Manual - Test 1,,,4,Ce instrucțiune SQL se folosește pentru ștergerea datelor dintr-o bază de date?,DELETE,Este corect,,"['copyright@www.adrian.runceanu.ro\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', '2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73Curs - Baze de date']","Contextul furnizat nu conține informații despre instrucțiunea SQL folosită pentru ștergerea datelor dintr-o bază de date. 

Instrucțiunea SQL pentru ștergerea datelor dintr-o tabelă este **DELETE**. 

Iată un exemplu de utilizare a instrucțiunii DELETE:

```sql
DELETE FROM nume_tabelă
WHERE condiție;
```

* **nume_tabelă**: Este numele tabelului din care doriți să ștergeți datele.
* **condiție**:  Este o clauză opțională care specifică ce rânduri să fie șterse. Dacă nu este specificată nicio condiție, toate rândurile din tabel vor fi șterse. 

**Atenție:** Instrucțiunea DELETE este o operațiune permanentă. Odată ce datele sunt șterse, acestea nu mai pot fi recuperate. Asigurați-vă că aveți o copie de rezervă a datelor înainte de a utiliza această instrucțiune. 
",Ce instrucțiune SQL se folosește pentru ștergerea datelor dintr-o bază de date?,"['copyright@www.adrian.runceanu.ro\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', '2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73Curs - Baze de date']","Contextul furnizat nu conține informații despre instrucțiunea SQL folosită pentru ștergerea datelor dintr-o bază de date. 

Instrucțiunea SQL pentru ștergerea datelor dintr-o tabelă este **DELETE**. 

Iată un exemplu de utilizare a instrucțiunii DELETE:

```sql
DELETE FROM nume_tabelă
WHERE condiție;
```

* **nume_tabelă**: Este numele tabelului din care doriți să ștergeți datele.
* **condiție**:  Este o clauză opțională care specifică ce rânduri să fie șterse. Dacă nu este specificată nicio condiție, toate rândurile din tabel vor fi șterse. 

**Atenție:** Instrucțiunea DELETE este o operațiune permanentă. Odată ce datele sunt șterse, acestea nu mai pot fi recuperate. Asigurați-vă că aveți o copie de rezervă a datelor înainte de a utiliza această instrucțiune. 
",DELETE,0.0,0.0,0.8467165160649945,0.1111111111111111,0.0,0.015151515151515152,0.2
46,Manual - Test 1,,,5,Ce instrucțiune SQL se folosește pentru inserarea de date noi într-o bază de date?,INSERT INTO,Este corect,,"['copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\nConţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\nCurs - Baze de date\n 14\n', 'copyright@www.adrian.runceanu.ro\nConţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\nCurs - Baze de date\n 14\n', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3']","Deși textul menționează că exemplificările vor fi în SQL (Structured Query Language), acesta nu oferă informații despre instrucțiunea specifică pentru inserarea datelor.

Pentru a insera date noi într-o bază de date folosind SQL, se folosește instrucțiunea **INSERT INTO**. 

Sintaxa generală este:

```sql
INSERT INTO nume_tabel (coloana1, coloana2, ...) VALUES (valoare1, valoare2, ...);
```

Unde:

* **nume_tabel** este numele tabelului în care vrei să inserezi datele.
* **(coloana1, coloana2, ... )** este o listă opțională cu numele coloanelor în care vrei să inserezi date. Dacă este omisă, se consideră că inserezi valori în toate coloanele, în ordinea în care au fost definite în tabel.
* **(valoare1, valoare2, ... )**  este o listă cu valorile pe care vrei să le inserezi, în ordinea corespunzătoare coloanelor specificate.
 
 
 De exemplu:

 ```sql
 INSERT INTO Angajati (Nume, Prenume, Salariu) VALUES ('Popescu', 'Ion', 3000); 
 ```

 Această instrucțiune va insera o nouă înregistrare în tabelul ""Angajati"", cu valorile ""Popescu"", ""Ion"" și 3000 pentru coloanele ""Nume"", ""Prenume"" și respectiv ""Salariu"". 
",Ce instrucțiune SQL se folosește pentru inserarea de date noi într-o bază de date?,"['copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\nConţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\nCurs - Baze de date\n 14\n', 'copyright@www.adrian.runceanu.ro\nConţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\nCurs - Baze de date\n 14\n', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3']","Deși textul menționează că exemplificările vor fi în SQL (Structured Query Language), acesta nu oferă informații despre instrucțiunea specifică pentru inserarea datelor.

Pentru a insera date noi într-o bază de date folosind SQL, se folosește instrucțiunea **INSERT INTO**. 

Sintaxa generală este:

```sql
INSERT INTO nume_tabel (coloana1, coloana2, ...) VALUES (valoare1, valoare2, ...);
```

Unde:

* **nume_tabel** este numele tabelului în care vrei să inserezi datele.
* **(coloana1, coloana2, ... )** este o listă opțională cu numele coloanelor în care vrei să inserezi date. Dacă este omisă, se consideră că inserezi valori în toate coloanele, în ordinea în care au fost definite în tabel.
* **(valoare1, valoare2, ... )**  este o listă cu valorile pe care vrei să le inserezi, în ordinea corespunzătoare coloanelor specificate.
 
 
 De exemplu:

 ```sql
 INSERT INTO Angajati (Nume, Prenume, Salariu) VALUES ('Popescu', 'Ion', 3000); 
 ```

 Această instrucțiune va insera o nouă înregistrare în tabelul ""Angajati"", cu valorile ""Popescu"", ""Ion"" și 3000 pentru coloanele ""Nume"", ""Prenume"" și respectiv ""Salariu"". 
",INSERT INTO,0.0,0.0,0.8657388510787372,0.2,0.015545503117706427,0.024242424242424246,0.33
47,Manual - Test 1,,,6,"Folosind SQL, cum se selectează coloana ""FirstName"" din tabelul ""Persons"" ?",SELECT FirstName FROM Persons,Este corect,,"[""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere"", ""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere"", 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48']","```sql
SELECT FirstName
FROM Persons;
``` 
","Folosind SQL, cum se selectează coloana ""FirstName"" din tabelul ""Persons"" ?","[""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere"", ""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere"", 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48']","```sql
SELECT FirstName
FROM Persons;
``` 
",SELECT FirstName FROM Persons,0.0,0.0,0.8730131150549707,0.0,0.21200626759025185,0.888888888888889,
48,Manual - Test 1,,,7,"Folosind SQL, cum se selectează toate coloanele din tabelul ""Persons""?",SELECT * FROM Persons,Este corect,,"['copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 30']","Contextul furnizat descrie un curs despre SQL, dar nu oferă informații specifice despre cum se selectează toate coloanele dintr-un tabel. 

Pentru a selecta toate coloanele din tabelul ""Persons"" folosind SQL, se utilizează următoarea sintaxă:

```sql
SELECT *
FROM Persons;
```

Explicație:

* `SELECT`: specifică ce coloane dorim să selectăm.
* `*`:  caracterul wildcard ce indică selectarea tuturor coloanelor.
* `FROM`: specifică din ce tabel se face selecția.
* `Persons`: numele tabelului din care dorim să extragem date.

Această interogare va returna toate coloanele și toate rândurile din tabelul ""Persons"". 
","Folosind SQL, cum se selectează toate coloanele din tabelul ""Persons""?","['copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 30']","Contextul furnizat descrie un curs despre SQL, dar nu oferă informații specifice despre cum se selectează toate coloanele dintr-un tabel. 

Pentru a selecta toate coloanele din tabelul ""Persons"" folosind SQL, se utilizează următoarea sintaxă:

```sql
SELECT *
FROM Persons;
```

Explicație:

* `SELECT`: specifică ce coloane dorim să selectăm.
* `*`:  caracterul wildcard ce indică selectarea tuturor coloanelor.
* `FROM`: specifică din ce tabel se face selecția.
* `Persons`: numele tabelului din care dorim să extragem date.

Această interogare va returna toate coloanele și toate rândurile din tabelul ""Persons"". 
",SELECT * FROM Persons,0.0,0.0,0.8907230867079434,0.25,0.0,0.06521739130434782,0.86
49,Manual - Test 1,,,8,"Folosind SQL, cum se selectează toate înregistrările din tabelul ""Persons"" unde valoarea coloanei ""FirstName"" este ""Peter""?",SELECT * FROM Persons WHERE FirstName='Peter',Este corect,,"[""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere"", ""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere"", 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40']","```sql
SELECT *
FROM Persons
WHERE FirstName = 'Peter';
```
","Folosind SQL, cum se selectează toate înregistrările din tabelul ""Persons"" unde valoarea coloanei ""FirstName"" este ""Peter""?","[""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere"", ""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere"", 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40']","```sql
SELECT *
FROM Persons
WHERE FirstName = 'Peter';
```
",SELECT * FROM Persons WHERE FirstName='Peter',0.0,0.0,0.9066067147206214,0.0,0.4428500142691474,0.923076923076923,1.0
50,Manual - Test 1,,,9,"Folosind SQL, cum selectezi toate înregistrările dintr-un tabel numit ""Persons"" unde valoarea coloanei ""FirstName"" începe cu litera ""a""?",SELECT * FROM Persons WHERE FirstName LIKE 'a%',Este corect,,"[""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere"", ""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere"", ""copyright@www.adrian.runceanu.ro\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46"", ""copyright@www.adrian.runceanu.ro\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46"", 'copyright@www.adrian.runceanu.ro\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43']","```sql
SELECT *
FROM Persons
WHERE SUBSTR(FirstName, 1, 1) = 'a';
```

Explicație:

* **SELECT *:** Aceasta selectează toate coloanele din tabelul ""Persons"".
* **FROM Persons:** Aceasta specifică faptul că dorim să extragem date din tabelul ""Persons"".
* **WHERE SUBSTR(FirstName, 1, 1) = 'a':** Aceasta este clauza WHERE care filtrează rezultatele. 
    * **SUBSTR(FirstName, 1, 1)**: Această funcție extrage primul caracter (poziția 1, lungimea 1) din coloana ""FirstName"". 
    * **= 'a'**: Aceasta verifică dacă primul caracter extras este egal cu ""a"".

Astfel, vor fi selectate doar înregistrările unde valoarea coloanei ""FirstName"" începe cu litera ""a"". 
","Folosind SQL, cum selectezi toate înregistrările dintr-un tabel numit ""Persons"" unde valoarea coloanei ""FirstName"" începe cu litera ""a""?","[""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere"", ""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere"", ""copyright@www.adrian.runceanu.ro\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46"", ""copyright@www.adrian.runceanu.ro\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46"", 'copyright@www.adrian.runceanu.ro\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43']","```sql
SELECT *
FROM Persons
WHERE SUBSTR(FirstName, 1, 1) = 'a';
```

Explicație:

* **SELECT *:** Aceasta selectează toate coloanele din tabelul ""Persons"".
* **FROM Persons:** Aceasta specifică faptul că dorim să extragem date din tabelul ""Persons"".
* **WHERE SUBSTR(FirstName, 1, 1) = 'a':** Aceasta este clauza WHERE care filtrează rezultatele. 
    * **SUBSTR(FirstName, 1, 1)**: Această funcție extrage primul caracter (poziția 1, lungimea 1) din coloana ""FirstName"". 
    * **= 'a'**: Aceasta verifică dacă primul caracter extras este egal cu ""a"".

Astfel, vor fi selectate doar înregistrările unde valoarea coloanei ""FirstName"" începe cu litera ""a"". 
",SELECT * FROM Persons WHERE FirstName LIKE 'a%',0.0,0.0,0.7924149281650917,0.0,0.03959296512405046,0.12371134020618557,0.8
51,Manual - Test 1,,,10,Operatorul OR afișează o înregistrare dacă oricare condiție este adevărată; operatorul AND afișează o înregistrare doar dacă toate condițiile sunt adevărate.,Adevărat,Este corect,,"['copyright@www.adrian.runceanu.ro\n7.1.4. Instrucţiunea Merge\nInstrucţiunea efectuează:\nUPDATE dacă înregistrarea există deja în tabel \nINSERT dacă înregistrarea este nouă. \nObs: DEFAULT reprezintă valoarea implicită a unei \ncoloane, dacă a fost definită la crearea tabelului. \nAltfel este null.\nCurs 7 - BAZE DE DATE 36', 'copyright@www.adrian.runceanu.ro\n7.1.4. Instrucţiunea Merge\nInstrucţiunea efectuează:\nUPDATE dacă înregistrarea există deja în tabel \nINSERT dacă înregistrarea este nouă. \nObs: DEFAULT reprezintă valoarea implicită a unei \ncoloane, dacă a fost definită la crearea tabelului. \nAltfel este null.\nCurs 7 - BAZE DE DATE 36', 'copyright@www.adrian.runceanu.ro\nAcordarea privilegiilor de obiect\n➢Diferite privilegii de obiect sunt disponibile \npentru diferite tipuri de obiecte de schema. \n➢Un utilizator are automat privilegii de obiect \nasupra obiectelor de schema continute în \nschema sa. \n➢Un utilizator poate acorda orice privilegiu de \nobiect asupra oricarei scheme de obiect pe \ncare o detine unui alt utilizator sau unui rol. \nCurs - BAZE DE DATE 29', 'copyright@www.adrian.runceanu.ro\nAcordarea privilegiilor de obiect\n➢Diferite privilegii de obiect sunt disponibile \npentru diferite tipuri de obiecte de schema. \n➢Un utilizator are automat privilegii de obiect \nasupra obiectelor de schema continute în \nschema sa. \n➢Un utilizator poate acorda orice privilegiu de \nobiect asupra oricarei scheme de obiect pe \ncare o detine unui alt utilizator sau unui rol. \nCurs - BAZE DE DATE 29', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \nCurs - Baze de date 68\n']","The provided text discusses database concepts like the ""MERGE"" instruction and object privileges but does not contain information about the logical operators ""OR"" and ""AND"" in the context of retrieving records. Therefore, I cannot answer your question using the given text. 
",Operatorul OR afișează o înregistrare dacă oricare condiție este adevărată; operatorul AND afișează o înregistrare doar dacă toate condițiile sunt adevărate.,"['copyright@www.adrian.runceanu.ro\n7.1.4. Instrucţiunea Merge\nInstrucţiunea efectuează:\nUPDATE dacă înregistrarea există deja în tabel \nINSERT dacă înregistrarea este nouă. \nObs: DEFAULT reprezintă valoarea implicită a unei \ncoloane, dacă a fost definită la crearea tabelului. \nAltfel este null.\nCurs 7 - BAZE DE DATE 36', 'copyright@www.adrian.runceanu.ro\n7.1.4. Instrucţiunea Merge\nInstrucţiunea efectuează:\nUPDATE dacă înregistrarea există deja în tabel \nINSERT dacă înregistrarea este nouă. \nObs: DEFAULT reprezintă valoarea implicită a unei \ncoloane, dacă a fost definită la crearea tabelului. \nAltfel este null.\nCurs 7 - BAZE DE DATE 36', 'copyright@www.adrian.runceanu.ro\nAcordarea privilegiilor de obiect\n➢Diferite privilegii de obiect sunt disponibile \npentru diferite tipuri de obiecte de schema. \n➢Un utilizator are automat privilegii de obiect \nasupra obiectelor de schema continute în \nschema sa. \n➢Un utilizator poate acorda orice privilegiu de \nobiect asupra oricarei scheme de obiect pe \ncare o detine unui alt utilizator sau unui rol. \nCurs - BAZE DE DATE 29', 'copyright@www.adrian.runceanu.ro\nAcordarea privilegiilor de obiect\n➢Diferite privilegii de obiect sunt disponibile \npentru diferite tipuri de obiecte de schema. \n➢Un utilizator are automat privilegii de obiect \nasupra obiectelor de schema continute în \nschema sa. \n➢Un utilizator poate acorda orice privilegiu de \nobiect asupra oricarei scheme de obiect pe \ncare o detine unui alt utilizator sau unui rol. \nCurs - BAZE DE DATE 29', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \nCurs - Baze de date 68\n']","The provided text discusses database concepts like the ""MERGE"" instruction and object privileges but does not contain information about the logical operators ""OR"" and ""AND"" in the context of retrieving records. Therefore, I cannot answer your question using the given text. 
",Adevărat,0.0,0.0,0.0,0.6666666666666666,0.0,0.0,0.4
52,Manual - Test 1,,,11,"Folosind SQL, cum selectezi toate înregistrările dintr-un tabel numit ""Persons"" unde valoarea coloanei ""FirstName"" este ""Peter"" și valoarea coloanei ""LastName"" este ""Jackson""?",SELECT * FROM Persons WHERE FirstName='Peter' AND LastName='Jackson',Este corect,,"[""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere"", ""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere"", ""copyright@www.adrian.runceanu.ro\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46"", ""copyright@www.adrian.runceanu.ro\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46"", 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48']","```sql
SELECT *
FROM Persons
WHERE FirstName = 'Peter' AND LastName = 'Jackson';
``` 
","Folosind SQL, cum selectezi toate înregistrările dintr-un tabel numit ""Persons"" unde valoarea coloanei ""FirstName"" este ""Peter"" și valoarea coloanei ""LastName"" este ""Jackson""?","[""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere"", ""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere"", ""copyright@www.adrian.runceanu.ro\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46"", ""copyright@www.adrian.runceanu.ro\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46"", 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48']","```sql
SELECT *
FROM Persons
WHERE FirstName = 'Peter' AND LastName = 'Jackson';
``` 
",SELECT * FROM Persons WHERE FirstName='Peter' AND LastName='Jackson',0.0,0.0,0.890844669725118,0.0,0.5653636138834067,0.9473684210526316,1.0
53,Manual - Test 1,,,12,"Folosing SQL, cum se selectează toate înregistrările din tabelul ""Persons"" unde valoarea coloanei ""LastName"" este între ""Hansen"" și ""Pettersen"" (inclusiv)?",SELECT * FROM Persons WHERE LastName BETWEEN 'Hansen' AND 'Pettersen',Este corect,,"['copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 30']","Nu pot răspunde la această întrebare. Contextul furnizat nu oferă informații despre cum se selectează înregistrări din baza de date utilizând comenzi SQL. 
","Folosing SQL, cum se selectează toate înregistrările din tabelul ""Persons"" unde valoarea coloanei ""LastName"" este între ""Hansen"" și ""Pettersen"" (inclusiv)?","['copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 30']","Nu pot răspunde la această întrebare. Contextul furnizat nu oferă informații despre cum se selectează înregistrări din baza de date utilizând comenzi SQL. 
",SELECT * FROM Persons WHERE LastName BETWEEN 'Hansen' AND 'Pettersen',0.0,0.0,0.0,0.0,0.0,0.0,
54,Manual - Test 2,,,1,Care instrucțiune SQL este utilizată pentru a returna doar valori diferite?,SELECT DISTINCT,Este corect,,"['copyright@www.adrian.runceanu.ro\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', 'copyright@www.adrian.runceanu.ro\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', 'copyright@www.adrian.runceanu.ro\nOrdinea de executie a functiilor de \ngrup\n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei. \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează. \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă. \nCurs 5 - BAZE DE DATE 50']","Contextul furnizat nu conține informații despre instrucțiuni SQL. Pentru a afla ce instrucțiune SQL se utilizează pentru a returna doar valori unice, ai nevoie de un context care să includă informații despre limbajul SQL.

Instrucțiunea SQL utilizată pentru a returna doar valori distincte este **DISTINCT**.  

Iată un exemplu:

```sql
SELECT DISTINCT column_name
FROM table_name;
```

Această interogare va returna toate valorile unice din coloana ""column_name"" din tabelul ""table_name"". 
",Care instrucțiune SQL este utilizată pentru a returna doar valori diferite?,"['copyright@www.adrian.runceanu.ro\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', 'copyright@www.adrian.runceanu.ro\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', 'copyright@www.adrian.runceanu.ro\nOrdinea de executie a functiilor de \ngrup\n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei. \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează. \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă. \nCurs 5 - BAZE DE DATE 50']","Contextul furnizat nu conține informații despre instrucțiuni SQL. Pentru a afla ce instrucțiune SQL se utilizează pentru a returna doar valori unice, ai nevoie de un context care să includă informații despre limbajul SQL.

Instrucțiunea SQL utilizată pentru a returna doar valori distincte este **DISTINCT**.  

Iată un exemplu:

```sql
SELECT DISTINCT column_name
FROM table_name;
```

Această interogare va returna toate valorile unice din coloana ""column_name"" din tabelul ""table_name"". 
",SELECT DISTINCT,0.0,0.0,0.8408774352610476,0.0,0.0,0.05063291139240507,0.75
55,Manual - Test 2,,,2,Ce cuvânt cheie SQL este folosit pentru a sorta multimea de rezultate?,ORDER BY,Este corect,,"['copyright@www.adrian.runceanu.ro\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', 'copyright@www.adrian.runceanu.ro\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', 'copyright@www.adrian.runceanu.ro\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nPentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22']","Din păcate, contextul oferit nu conține informații despre cuvântul cheie SQL folosit pentru a sorta mulțimea de rezultate. 

Totuși, cuvântul cheie pe care îl cauți este **ORDER BY**. 
",Ce cuvânt cheie SQL este folosit pentru a sorta multimea de rezultate?,"['copyright@www.adrian.runceanu.ro\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', 'copyright@www.adrian.runceanu.ro\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', 'copyright@www.adrian.runceanu.ro\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro\nPentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22']","Din păcate, contextul oferit nu conține informații despre cuvântul cheie SQL folosit pentru a sorta mulțimea de rezultate. 

Totuși, cuvântul cheie pe care îl cauți este **ORDER BY**. 
",ORDER BY,0.0,0.0,0.889437303972121,0.5,0.0,0.10526315789473684,0.67
56,Manual - Test 2,,,3,"Folosind SQL, cum se pot returna toate înregistrările dintr-un tabel numit ""Persons"" sortate descrescător după ""FirstName""?",SELECT * FROM Persons ORDER BY FirstName DESC,Este corect,,"[""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere"", ""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere"", ""copyright@www.adrian.runceanu.ro\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46"", ""copyright@www.adrian.runceanu.ro\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46"", 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\nCurs - Baze de date 69']","Informațiile furnizate în context nu sunt suficiente pentru a răspunde la întrebarea utilizatorului. Contextul oferă exemple de interogări SQL care se concentrează pe clauzele WHERE și pe utilizarea funcțiilor pentru șiruri de caractere, dar nu oferă informații despre cum să se sorteze rezultatele în ordine descrescătoare utilizând clauza ORDER BY. 

Pentru a răspunde la întrebarea utilizatorului, iată cum se pot returna toate înregistrările dintr-un tabel numit ""Persons"" sortate descrescător după ""FirstName"" în SQL:

```sql
SELECT *
FROM Persons
ORDER BY FirstName DESC;
```

Explicație:

* `SELECT *`: Această clauză selectează toate coloanele din tabelul ""Persons"".
* `FROM Persons`: Această clauză specifică tabelul din care se vor extrage datele.
* `ORDER BY FirstName DESC`: Această clauză sortează rezultatele în ordine descrescătoare pe baza valorilor din coloana ""FirstName"". Cuvântul cheie `DESC` este folosit pentru a specifica ordinea descrescătoare. 
","Folosind SQL, cum se pot returna toate înregistrările dintr-un tabel numit ""Persons"" sortate descrescător după ""FirstName""?","[""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere"", ""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere"", ""copyright@www.adrian.runceanu.ro\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46"", ""copyright@www.adrian.runceanu.ro\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46"", 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\nCurs - Baze de date 69']","Informațiile furnizate în context nu sunt suficiente pentru a răspunde la întrebarea utilizatorului. Contextul oferă exemple de interogări SQL care se concentrează pe clauzele WHERE și pe utilizarea funcțiilor pentru șiruri de caractere, dar nu oferă informații despre cum să se sorteze rezultatele în ordine descrescătoare utilizând clauza ORDER BY. 

Pentru a răspunde la întrebarea utilizatorului, iată cum se pot returna toate înregistrările dintr-un tabel numit ""Persons"" sortate descrescător după ""FirstName"" în SQL:

```sql
SELECT *
FROM Persons
ORDER BY FirstName DESC;
```

Explicație:

* `SELECT *`: Această clauză selectează toate coloanele din tabelul ""Persons"".
* `FROM Persons`: Această clauză specifică tabelul din care se vor extrage datele.
* `ORDER BY FirstName DESC`: Această clauză sortează rezultatele în ordine descrescătoare pe baza valorilor din coloana ""FirstName"". Cuvântul cheie `DESC` este folosit pentru a specifica ordinea descrescătoare. 
",SELECT * FROM Persons ORDER BY FirstName DESC,0.0,0.0,0.8423270720475117,0.375,0.0,0.09210526315789473,0.77
57,Manual - Test 2,,,4,"Folosind SQL, cum se inserează o înregistrare nouă în tabelul ""Persons""?","INSERT INTO Persons VALUES ('Jimmy', 'Jackson')",Este corect,,"['copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 30']","Contextul furnizat nu conține informații despre cum se inserează o înregistrare nouă într-un tabel folosind SQL. 

Pentru a insera o înregistrare nouă în tabelul ""Persons"", se folosește comanda `INSERT INTO`. 

Iată un exemplu:

```sql
INSERT INTO Persons (FirstName, LastName, Age)
VALUES ('John', 'Doe', 30);
```

Această comandă va insera o nouă persoană în tabelul ""Persons"" cu următoarele valori:

* FirstName: John
* LastName: Doe
* Age: 30

Pentru a adapta comanda la propriul tabel ""Persons"", trebuie să înlocuiți:

* **Persons** cu numele tabelului dumneavoastră.
* **(FirstName, LastName, Age)** cu numele coloanelor din tabelul dumneavoastră.
* **('John', 'Doe', 30)** cu valorile pe care doriți să le inserați în fiecare coloană. 

Asigurați-vă că valorile introduse respectă tipul de date al fiecărei coloane.
","Folosind SQL, cum se inserează o înregistrare nouă în tabelul ""Persons""?","['copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 30']","Contextul furnizat nu conține informații despre cum se inserează o înregistrare nouă într-un tabel folosind SQL. 

Pentru a insera o înregistrare nouă în tabelul ""Persons"", se folosește comanda `INSERT INTO`. 

Iată un exemplu:

```sql
INSERT INTO Persons (FirstName, LastName, Age)
VALUES ('John', 'Doe', 30);
```

Această comandă va insera o nouă persoană în tabelul ""Persons"" cu următoarele valori:

* FirstName: John
* LastName: Doe
* Age: 30

Pentru a adapta comanda la propriul tabel ""Persons"", trebuie să înlocuiți:

* **Persons** cu numele tabelului dumneavoastră.
* **(FirstName, LastName, Age)** cu numele coloanelor din tabelul dumneavoastră.
* **('John', 'Doe', 30)** cu valorile pe care doriți să le inserați în fiecare coloană. 

Asigurați-vă că valorile introduse respectă tipul de date al fiecărei coloane.
","INSERT INTO Persons VALUES ('Jimmy', 'Jackson')",0.0,0.0,0.881267635599829,0.125,0.0,0.06153846153846154,0.22
58,Manual - Test 2,,,5,"Folosind SQL, cum se inserează ""Olsen"" ca ""LastName"" în tabelul ""Persons""?",INSERT INTO Persons (LastName) VALUES ('Olsen'),Este corect,,"['copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', ""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere""]","Îmi pare rău, dar contextul oferit nu conține informații despre cum se inserează date în tabele SQL. Contextul se referă la funcții SQL pentru șiruri de caractere și clauza WHERE. 

Pentru a insera ""Olsen"" ca ""LastName"" în tabelul ""Persons"", ai nevoie de o comandă SQL INSERT. Iată un exemplu:

```sql
INSERT INTO Persons (LastName) VALUES ('Olsen');
```

Această comandă presupune că tabelul ""Persons"" există și că are o coloană numită ""LastName"". 

Pentru mai multe informații despre comenzile SQL INSERT, poți căuta tutoriale online sau documentația specifică bazei de date pe care o folosești. 
","Folosind SQL, cum se inserează ""Olsen"" ca ""LastName"" în tabelul ""Persons""?","['copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', ""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere""]","Îmi pare rău, dar contextul oferit nu conține informații despre cum se inserează date în tabele SQL. Contextul se referă la funcții SQL pentru șiruri de caractere și clauza WHERE. 

Pentru a insera ""Olsen"" ca ""LastName"" în tabelul ""Persons"", ai nevoie de o comandă SQL INSERT. Iată un exemplu:

```sql
INSERT INTO Persons (LastName) VALUES ('Olsen');
```

Această comandă presupune că tabelul ""Persons"" există și că are o coloană numită ""LastName"". 

Pentru mai multe informații despre comenzile SQL INSERT, poți căuta tutoriale online sau documentația specifică bazei de date pe care o folosești. 
",INSERT INTO Persons (LastName) VALUES ('Olsen'),0.0,0.0,0.8183608004715838,0.25,0.0,0.11214953271028036,0.67
59,Manual - Test 2,,,6,"Cum se poate schimba ""Hansen"" în ""Nilsen"" în coloana ""LastName"" din tabelul ""Persons""?",UPDATE Persons SET LastName='Nilsen' WHERE LastName='Hansen',Este corect,,"[""copyright@www.adrian.runceanu.ro\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista 'ALLEN', 'WARD', 'FORD'. \nCurs - Baze de date 51\n"", ""copyright@www.adrian.runceanu.ro\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista 'ALLEN', 'WARD', 'FORD'. \nCurs - Baze de date 51\n"", 'copyright@www.adrian.runceanu.ro\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981. \nCurs - Baze de date 39\n', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981. \nCurs - Baze de date 39\n', 'copyright@www.adrian.runceanu.ro\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10']","Conținutul furnizat nu oferă informații despre cum să schimbați numele ""Hansen"" în ""Nilsen"" într-o coloană ""LastName"" a unui tabel ""Persons"".  

Pentru a realiza această modificare, aveți nevoie de o comandă SQL de tip UPDATE. 

Iată un exemplu de comandă SQL care ar putea funcționa:

```sql
UPDATE Persons
SET LastName = 'Nilsen'
WHERE LastName = 'Hansen';
```

Această comandă va actualiza toate intrările din tabelul ""Persons"" unde ""LastName"" este ""Hansen"" și va schimba valoarea în ""Nilsen"". 

**Atenție:** 

* Asigurați-vă că aveți o copie de rezervă a bazei de date înainte de a rula orice comandă SQL UPDATE. 
* Exemplul de mai sus presupune că tabelul se numește ""Persons"" și coloana se numește ""LastName"".  Asigurați-vă că utilizați numele corecte pentru tabelul și coloana dvs. 
","Cum se poate schimba ""Hansen"" în ""Nilsen"" în coloana ""LastName"" din tabelul ""Persons""?","[""copyright@www.adrian.runceanu.ro\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista 'ALLEN', 'WARD', 'FORD'. \nCurs - Baze de date 51\n"", ""copyright@www.adrian.runceanu.ro\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista 'ALLEN', 'WARD', 'FORD'. \nCurs - Baze de date 51\n"", 'copyright@www.adrian.runceanu.ro\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981. \nCurs - Baze de date 39\n', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981. \nCurs - Baze de date 39\n', 'copyright@www.adrian.runceanu.ro\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10']","Conținutul furnizat nu oferă informații despre cum să schimbați numele ""Hansen"" în ""Nilsen"" într-o coloană ""LastName"" a unui tabel ""Persons"".  

Pentru a realiza această modificare, aveți nevoie de o comandă SQL de tip UPDATE. 

Iată un exemplu de comandă SQL care ar putea funcționa:

```sql
UPDATE Persons
SET LastName = 'Nilsen'
WHERE LastName = 'Hansen';
```

Această comandă va actualiza toate intrările din tabelul ""Persons"" unde ""LastName"" este ""Hansen"" și va schimba valoarea în ""Nilsen"". 

**Atenție:** 

* Asigurați-vă că aveți o copie de rezervă a bazei de date înainte de a rula orice comandă SQL UPDATE. 
* Exemplul de mai sus presupune că tabelul se numește ""Persons"" și coloana se numește ""LastName"".  Asigurați-vă că utilizați numele corecte pentru tabelul și coloana dvs. 
",UPDATE Persons SET LastName='Nilsen' WHERE LastName='Hansen',0.0,0.0,0.8998943569198358,0.14285714285714285,0.01588011771404737,0.11347517730496454,0.73
60,Manual - Test 2,,,7,"Folosind SQL, cum se șterg înregistrările din tabelul ""Persons"" unde ""FirstName"" este ""Peter""?",DELETE FROM Persons WHERE FirstName = 'Peter',Este corect,,"[""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere"", ""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere"", 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40']",None,"Folosind SQL, cum se șterg înregistrările din tabelul ""Persons"" unde ""FirstName"" este ""Peter""?","[""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere"", ""copyright@www.adrian.runceanu.ro\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere"", 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40']",None,DELETE FROM Persons WHERE FirstName = 'Peter',0.0,0.0,0.0,,0.0,0.0,
61,Manual - Test 2,,,8,"Folosind SQL, cum se returnează numărul de înregistrări din tabelul ""Persons""?",SELECT COUNT(*) FROM Persons,Este corect,,"['copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 30']","Contextul furnizat nu conține informații despre cum să se returneze numărul de înregistrări dintr-un tabel folosind SQL. 

Totuși, pot răspunde la întrebarea ta. Pentru a returna numărul de înregistrări din tabelul ""Persons"" folosind SQL, poți utiliza funcția `COUNT(*)`  împreună cu o clauză `FROM`:

```sql
SELECT COUNT(*) 
FROM Persons;
```

Această interogare va returna un singur rând cu o singură coloană, conținând numărul total de înregistrări din tabelul ""Persons"".
","Folosind SQL, cum se returnează numărul de înregistrări din tabelul ""Persons""?","['copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 30']","Contextul furnizat nu conține informații despre cum să se returneze numărul de înregistrări dintr-un tabel folosind SQL. 

Totuși, pot răspunde la întrebarea ta. Pentru a returna numărul de înregistrări din tabelul ""Persons"" folosind SQL, poți utiliza funcția `COUNT(*)`  împreună cu o clauză `FROM`:

```sql
SELECT COUNT(*) 
FROM Persons;
```

Această interogare va returna un singur rând cu o singură coloană, conținând numărul total de înregistrări din tabelul ""Persons"".
",SELECT COUNT(*) FROM Persons,0.0,0.0,0.8703525782159222,0.16666666666666666,0.0,0.09195402298850576,0.8
62,Manual - Test 2,,,9,Care este cel mai cunoscut tip de join?,INNER JOIN,Este corect,,"['copyright@www.adrian.runceanu.ro\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13', 'copyright@www.adrian.runceanu.ro\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13', 'copyright@www.adrian.runceanu.ro\nCereri Top N \nCererile Top N căuta cele mai mari n sau \ncele mai mici valori dintr-o coloană. \nFolosind cereri Top N putem afla de \nexemplu: \n–primii 3 salariaţi dintr-o companie\n–cele mai bine vândute 3 produse ale unei \ncompanii\nCurs - BAZE DE DATE 49', 'copyright@www.adrian.runceanu.ro\nCereri Top N \nCererile Top N căuta cele mai mari n sau \ncele mai mici valori dintr-o coloană. \nFolosind cereri Top N putem afla de \nexemplu: \n–primii 3 salariaţi dintr-o companie\n–cele mai bine vândute 3 produse ale unei \ncompanii\nCurs - BAZE DE DATE 49', '7\nResurse Baze de date\n1. Suport curs - varianta electronică disponibilă\npe: https://www.runceanu.ro/adrian/   \nNotă: Actualizarea site-ului se face saptamanal.\n2. curs pe Teams (FI-AIA-2-Baze de date-2024-2025)\n3. laborator pe Teams (FI-AIA-2-Baze de date-2024-\n2025)']","Îmi pare rău, nu există informații despre tipurile de join în textul furnizat. Textul se referă la constrângeri în baze de date și la cereri Top N. 
",Care este cel mai cunoscut tip de join?,"['copyright@www.adrian.runceanu.ro\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13', 'copyright@www.adrian.runceanu.ro\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13', 'copyright@www.adrian.runceanu.ro\nCereri Top N \nCererile Top N căuta cele mai mari n sau \ncele mai mici valori dintr-o coloană. \nFolosind cereri Top N putem afla de \nexemplu: \n–primii 3 salariaţi dintr-o companie\n–cele mai bine vândute 3 produse ale unei \ncompanii\nCurs - BAZE DE DATE 49', 'copyright@www.adrian.runceanu.ro\nCereri Top N \nCererile Top N căuta cele mai mari n sau \ncele mai mici valori dintr-o coloană. \nFolosind cereri Top N putem afla de \nexemplu: \n–primii 3 salariaţi dintr-o companie\n–cele mai bine vândute 3 produse ale unei \ncompanii\nCurs - BAZE DE DATE 49', '7\nResurse Baze de date\n1. Suport curs - varianta electronică disponibilă\npe: https://www.runceanu.ro/adrian/   \nNotă: Actualizarea site-ului se face saptamanal.\n2. curs pe Teams (FI-AIA-2-Baze de date-2024-2025)\n3. laborator pe Teams (FI-AIA-2-Baze de date-2024-\n2025)']","Îmi pare rău, nu există informații despre tipurile de join în textul furnizat. Textul se referă la constrângeri în baze de date și la cereri Top N. 
",INNER JOIN,0.0,0.0,0.0,1.0,0.0,0.0625,0.0
63,Manual - Test 2,,,10,Ce operator este folosit pentru a selecta valori dintr-un interval?,BETWEEN,Este corect,,"['copyright@www.adrian.runceanu.ro\nClauza WHERE\n1. BETWEEN...AND... \nCondiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie).\nIntervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată\ntrebuie să fie limita inferioară. \nCurs - Baze de date 44', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\n1. BETWEEN...AND... \nCondiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie).\nIntervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată\ntrebuie să fie limita inferioară. \nCurs - Baze de date 44', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\n Clauza WHERE poate compara valori în coloană, \nvalori literale, expresii aritmetice sau funcţii.\nWHERE - restricţionează cererea la rândurile care \nîndeplinesc o condiţie;\nCondiţie este alcătuită din trei elemente:\n1. Un nume de coloană \n2. Un operator de comparaţie \n3. Un nume de coloană, constantă sau listă de valori\nCurs - Baze de date 31', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\n Clauza WHERE poate compara valori în coloană, \nvalori literale, expresii aritmetice sau funcţii.\nWHERE - restricţionează cererea la rândurile care \nîndeplinesc o condiţie;\nCondiţie este alcătuită din trei elemente:\n1. Un nume de coloană \n2. Un operator de comparaţie \n3. Un nume de coloană, constantă sau listă de valori\nCurs - Baze de date 31', 'Clauza WHERE\nC. Condiţii de comparare \n  În SQL sunt 4 operatori care pot fi folosiţi pentru \ntoate tipurile de date: \nOperator Semnificaţie\nBETWEEN...AND... între 2 valori (inclusiv)\nIN (lista) compară cu o listă de valori\nLIKE compară cu un model de tip caracter\nIS NULL este o valoare nulă\nCurs - Baze de date 43']","Operatorul folosit pentru a selecta valori dintr-un interval este **BETWEEN...AND...**. 

Conform contextului:

* ""Condiţia BETWEEN poate fi folosită pentru a selecta rânduri pe baza unui interval de valori"" 
* ""Intervalul este inclusiv, are o limită inferioară şi o limită superioară..."" 
 
 Deci, operatorul BETWEEN...AND... se folosește pentru a selecta valori care se încadrează între o limită inferioară și una superioară, inclusiv limitele.
",Ce operator este folosit pentru a selecta valori dintr-un interval?,"['copyright@www.adrian.runceanu.ro\nClauza WHERE\n1. BETWEEN...AND... \nCondiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie).\nIntervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată\ntrebuie să fie limita inferioară. \nCurs - Baze de date 44', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\n1. BETWEEN...AND... \nCondiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie).\nIntervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată\ntrebuie să fie limita inferioară. \nCurs - Baze de date 44', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\n Clauza WHERE poate compara valori în coloană, \nvalori literale, expresii aritmetice sau funcţii.\nWHERE - restricţionează cererea la rândurile care \nîndeplinesc o condiţie;\nCondiţie este alcătuită din trei elemente:\n1. Un nume de coloană \n2. Un operator de comparaţie \n3. Un nume de coloană, constantă sau listă de valori\nCurs - Baze de date 31', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\n Clauza WHERE poate compara valori în coloană, \nvalori literale, expresii aritmetice sau funcţii.\nWHERE - restricţionează cererea la rândurile care \nîndeplinesc o condiţie;\nCondiţie este alcătuită din trei elemente:\n1. Un nume de coloană \n2. Un operator de comparaţie \n3. Un nume de coloană, constantă sau listă de valori\nCurs - Baze de date 31', 'Clauza WHERE\nC. Condiţii de comparare \n  În SQL sunt 4 operatori care pot fi folosiţi pentru \ntoate tipurile de date: \nOperator Semnificaţie\nBETWEEN...AND... între 2 valori (inclusiv)\nIN (lista) compară cu o listă de valori\nLIKE compară cu un model de tip caracter\nIS NULL este o valoare nulă\nCurs - Baze de date 43']","Operatorul folosit pentru a selecta valori dintr-un interval este **BETWEEN...AND...**. 

Conform contextului:

* ""Condiţia BETWEEN poate fi folosită pentru a selecta rânduri pe baza unui interval de valori"" 
* ""Intervalul este inclusiv, are o limită inferioară şi o limită superioară..."" 
 
 Deci, operatorul BETWEEN...AND... se folosește pentru a selecta valori care se încadrează între o limită inferioară și una superioară, inclusiv limitele.
",BETWEEN,0.8666666666377778,1.0,0.8898804149195035,1.0,0.018160849415439308,0.030303030303030307,1.0
64,Manual - Test 2,,,11,Constrângerea NOT NULL impune ca o coloană să nu accepte valori NULL.,Adevărat,Este corect,,"['copyright@www.adrian.runceanu.ro\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13', 'copyright@www.adrian.runceanu.ro\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\n4. Conditia IS NULL \n  Pentru a verifica valorile de tip NULL există condiţia IS \nNULL sau negarea acesteia IS NOT NULL. \nO valoare nulă este o valoare care este sau incorectă, sau \nnecunoscută, sau inaplicabilă de aceea nu poate fi testată cu \n""="". \nO valoare nulă nu este la fel cu ""zero"" care este un \nnumăr.\nDacă valoarea NULL este utilizată într-o comparaţie, \natunci operatorul de comparaţie trebuie să fie IS NULL sau IS \nNOT NULL altfel rezultatul este întotdeauna FALSE. \nCurs - Baze de date 60', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\n4. Conditia IS NULL \n  Pentru a verifica valorile de tip NULL există condiţia IS \nNULL sau negarea acesteia IS NOT NULL. \nO valoare nulă este o valoare care este sau incorectă, sau \nnecunoscută, sau inaplicabilă de aceea nu poate fi testată cu \n""="". \nO valoare nulă nu este la fel cu ""zero"" care este un \nnumăr.\nDacă valoarea NULL este utilizată într-o comparaţie, \natunci operatorul de comparaţie trebuie să fie IS NULL sau IS \nNOT NULL altfel rezultatul este întotdeauna FALSE. \nCurs - Baze de date 60', 'copyright@www.adrian.runceanu.ro\nConstrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17']","Afirmația ""Constrângerea NOT NULL impune ca o coloană să nu accepte valori NULL."" este **adevărată**. 

Contextul menționează clar că ""Constrângerea de tip NOT NULL asigură faptul că o coloană să nu conțină valoarea nulă."" 
",Constrângerea NOT NULL impune ca o coloană să nu accepte valori NULL.,"['copyright@www.adrian.runceanu.ro\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13', 'copyright@www.adrian.runceanu.ro\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\n4. Conditia IS NULL \n  Pentru a verifica valorile de tip NULL există condiţia IS \nNULL sau negarea acesteia IS NOT NULL. \nO valoare nulă este o valoare care este sau incorectă, sau \nnecunoscută, sau inaplicabilă de aceea nu poate fi testată cu \n""="". \nO valoare nulă nu este la fel cu ""zero"" care este un \nnumăr.\nDacă valoarea NULL este utilizată într-o comparaţie, \natunci operatorul de comparaţie trebuie să fie IS NULL sau IS \nNOT NULL altfel rezultatul este întotdeauna FALSE. \nCurs - Baze de date 60', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\n4. Conditia IS NULL \n  Pentru a verifica valorile de tip NULL există condiţia IS \nNULL sau negarea acesteia IS NOT NULL. \nO valoare nulă este o valoare care este sau incorectă, sau \nnecunoscută, sau inaplicabilă de aceea nu poate fi testată cu \n""="". \nO valoare nulă nu este la fel cu ""zero"" care este un \nnumăr.\nDacă valoarea NULL este utilizată într-o comparaţie, \natunci operatorul de comparaţie trebuie să fie IS NULL sau IS \nNOT NULL altfel rezultatul este întotdeauna FALSE. \nCurs - Baze de date 60', 'copyright@www.adrian.runceanu.ro\nConstrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17']","Afirmația ""Constrângerea NOT NULL impune ca o coloană să nu accepte valori NULL."" este **adevărată**. 

Contextul menționează clar că ""Constrângerea de tip NOT NULL asigură faptul că o coloană să nu conțină valoarea nulă."" 
",Adevărat,0.99999999995,1.0,0.8416799451147753,1.0,0.0,0.09523809523809523,0.0
65,Manual - Test 2,,,12,Ce operator este folosit pentru a căuta un model specificat într-o coloană?,LIKE,Este corect,,"['copyright@www.adrian.runceanu.ro\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56', 'copyright@www.adrian.runceanu.ro\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56', 'copyright@www.adrian.runceanu.ro\nClasificare\n Vederile se clasifică în: \n1.vederi simple\n2.vederi complexe\n  Pentru început prezentăm vederile \nsimple. \nCurs - BAZE DE DATE 7', 'copyright@www.adrian.runceanu.ro\nClasificare\n Vederile se clasifică în: \n1.vederi simple\n2.vederi complexe\n  Pentru început prezentăm vederile \nsimple. \nCurs - BAZE DE DATE 7', 'copyright@www.adrian.runceanu.ro\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu \nInserează în tabela Angajati datele personale, \nprecum şi data când acestea au fost introduse, prin \nutilizarea comenzii SYSDATE, care reprezintă data \nsistemului. \nCurs 7 - BAZE DE DATE 14']","Contextul furnizat nu conține informații despre operatorii utilizați pentru căutarea unui model specificat într-o coloană. Pentru a căuta un model specificat într-o coloană, se folosesc de obicei operatori precum:

* **LIKE**: permite căutarea unor șabloane folosind wildcard-uri.
   * `%`: înlocuiește orice număr de caractere.
   * `_`: înlocuiește un singur caracter.
* **REGEXP**: permite căutarea folosind expresii regulate.

Pentru a oferi un răspuns mai precis, vă rugăm să furnizați mai multe detalii despre:

* **Sistemul de gestionare a bazelor de date (DBMS)** pe care îl utilizați (ex: MySQL, PostgreSQL, SQL Server etc.).
* **Tipul de date** din coloana în care doriți să căutați.

De exemplu, pentru a căuta toate numele care încep cu ""A"" într-o coloană numită ""Nume"" dintr-o tabelă ""Angajati"" folosind MySQL, ați putea utiliza următoarea interogare:

```sql
SELECT * FROM Angajati WHERE Nume LIKE 'A%'; 
``` 
",Ce operator este folosit pentru a căuta un model specificat într-o coloană?,"['copyright@www.adrian.runceanu.ro\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56', 'copyright@www.adrian.runceanu.ro\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56', 'copyright@www.adrian.runceanu.ro\nClasificare\n Vederile se clasifică în: \n1.vederi simple\n2.vederi complexe\n  Pentru început prezentăm vederile \nsimple. \nCurs - BAZE DE DATE 7', 'copyright@www.adrian.runceanu.ro\nClasificare\n Vederile se clasifică în: \n1.vederi simple\n2.vederi complexe\n  Pentru început prezentăm vederile \nsimple. \nCurs - BAZE DE DATE 7', 'copyright@www.adrian.runceanu.ro\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu \nInserează în tabela Angajati datele personale, \nprecum şi data când acestea au fost introduse, prin \nutilizarea comenzii SYSDATE, care reprezintă data \nsistemului. \nCurs 7 - BAZE DE DATE 14']","Contextul furnizat nu conține informații despre operatorii utilizați pentru căutarea unui model specificat într-o coloană. Pentru a căuta un model specificat într-o coloană, se folosesc de obicei operatori precum:

* **LIKE**: permite căutarea unor șabloane folosind wildcard-uri.
   * `%`: înlocuiește orice număr de caractere.
   * `_`: înlocuiește un singur caracter.
* **REGEXP**: permite căutarea folosind expresii regulate.

Pentru a oferi un răspuns mai precis, vă rugăm să furnizați mai multe detalii despre:

* **Sistemul de gestionare a bazelor de date (DBMS)** pe care îl utilizați (ex: MySQL, PostgreSQL, SQL Server etc.).
* **Tipul de date** din coloana în care doriți să căutați.

De exemplu, pentru a căuta toate numele care încep cu ""A"" într-o coloană numită ""Nume"" dintr-o tabelă ""Angajati"" folosind MySQL, ați putea utiliza următoarea interogare:

```sql
SELECT * FROM Angajati WHERE Nume LIKE 'A%'; 
``` 
",LIKE,0.0,0.0,0.0,0.1,0.0,0.013071895424836602,0.2
66,Manual - Test 2,,,13,"Ce instrucțiune SQL este folosită pentru a crea un tabel de bază de date numit ""Customers""?",CREATE TABLE Customers,Este corect,,"['copyright@www.adrian.runceanu.ro\nAvantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6', 'copyright@www.adrian.runceanu.ro\nAvantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 15']","Deși textul oferă informații despre bazele de date și SQL, nu prezintă sintaxa exactă pentru crearea unui tabel. 

Pentru a crea un tabel ""Customers"" în SQL, ai folosi instrucțiunea `CREATE TABLE`:

```sql
CREATE TABLE Customers (
   -- Aici definiți coloanele tabelului și tipurile lor de date
   CustomerID INT PRIMARY KEY,
   CustomerName VARCHAR(255),
   ContactName VARCHAR(255),
   Address VARCHAR(255),
   City VARCHAR(255),
   PostalCode VARCHAR(10),
   Country VARCHAR(255) 
);
```

Această instrucțiune creează un tabel numit ""Customers"" cu coloane precum CustomerID, CustomerName, etc.  

**Important:**  

*  Tipurile de date și lungimea lor (ex: VARCHAR(255)) pot varia în funcție de sistemul de gestionare a bazelor de date (DBMS) utilizat.
*  Este recomandat să consultați documentația specifică DBMS-ului  pentru sintaxa exactă și opțiunile disponibile. 
","Ce instrucțiune SQL este folosită pentru a crea un tabel de bază de date numit ""Customers""?","['copyright@www.adrian.runceanu.ro\nAvantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6', 'copyright@www.adrian.runceanu.ro\nAvantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67Curs - Baze de date', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 15']","Deși textul oferă informații despre bazele de date și SQL, nu prezintă sintaxa exactă pentru crearea unui tabel. 

Pentru a crea un tabel ""Customers"" în SQL, ai folosi instrucțiunea `CREATE TABLE`:

```sql
CREATE TABLE Customers (
   -- Aici definiți coloanele tabelului și tipurile lor de date
   CustomerID INT PRIMARY KEY,
   CustomerName VARCHAR(255),
   ContactName VARCHAR(255),
   Address VARCHAR(255),
   City VARCHAR(255),
   PostalCode VARCHAR(10),
   Country VARCHAR(255) 
);
```

Această instrucțiune creează un tabel numit ""Customers"" cu coloane precum CustomerID, CustomerName, etc.  

**Important:**  

*  Tipurile de date și lungimea lor (ex: VARCHAR(255)) pot varia în funcție de sistemul de gestionare a bazelor de date (DBMS) utilizat.
*  Este recomandat să consultați documentația specifică DBMS-ului  pentru sintaxa exactă și opțiunile disponibile. 
",CREATE TABLE Customers,0.0,0.0,0.8807247883798975,0.2857142857142857,0.0,0.046511627906976744,0.67
67,Manual - Test 3,Hard,,1,Care interogare actualizează salariul tuturor angajaților din departamentul 10 astfel încât să fie mărit cu 10% din salariul mediu al companiei?,UPDATE EMP SET SAL = SAL + 0.10 * (SELECT AVG(SAL) FROM EMP) WHERE DEPTNO = 10;,Este corect,,"['copyright@www.adrian.runceanu.ro\nExemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45', 'copyright@www.adrian.runceanu.ro\nExemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\nCurs - Baze de date 49\n', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\nCurs - Baze de date 49\n', 'copyright@www.adrian.runceanu.ro\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nRezultatul obtinut - Salariul total pe fiecare funcţie, fără a lua în \ncalcul MANAGERII, excluzând funcţiile cu suma salariilor sub \n6000$ cu ordonare după total.\nCurs 5 - BAZE DE DATE 47\n']","Informația necesară pentru a formula interogarea SQL lipsește din contextul furnizat. Contextul se referă la selectarea angajaților cu salarii specifice sau maxime pe departamente, dar nu oferă detalii despre actualizarea salariilor. 

Pentru a formula interogarea corectă, am avea nevoie de informații despre:

* **Numele tabelei** care conține informații despre angajați (ex: `Angajati`).
* **Numele coloanei** pentru salariu (ex: `Salariu`).

O posibilă interogare SQL (presupunând că avem tabela `Angajati` cu coloana `Salariu`) ar fi:

```sql
UPDATE Angajati
SET Salariu = Salariu + (SELECT AVG(Salariu) FROM Angajati) * 0.10
WHERE Deptno = 10;
```

Această interogare ar urma următorii pași:

1. **Calculează salariul mediu** al tuturor angajaților.
2. **Adaugă 10% din salariul mediu** la salariul curent al fiecărui angajat.
3. **Aplică actualizarea** doar angajaților din departamentul 10.

Vă rugăm să furnizați mai multe informații despre structura bazei de date pentru a putea oferi o interogare mai precisă.
",Care interogare actualizează salariul tuturor angajaților din departamentul 10 astfel încât să fie mărit cu 10% din salariul mediu al companiei?,"['copyright@www.adrian.runceanu.ro\nExemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45', 'copyright@www.adrian.runceanu.ro\nExemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\nCurs - Baze de date 49\n', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\nCurs - Baze de date 49\n', 'copyright@www.adrian.runceanu.ro\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nRezultatul obtinut - Salariul total pe fiecare funcţie, fără a lua în \ncalcul MANAGERII, excluzând funcţiile cu suma salariilor sub \n6000$ cu ordonare după total.\nCurs 5 - BAZE DE DATE 47\n']","Informația necesară pentru a formula interogarea SQL lipsește din contextul furnizat. Contextul se referă la selectarea angajaților cu salarii specifice sau maxime pe departamente, dar nu oferă detalii despre actualizarea salariilor. 

Pentru a formula interogarea corectă, am avea nevoie de informații despre:

* **Numele tabelei** care conține informații despre angajați (ex: `Angajati`).
* **Numele coloanei** pentru salariu (ex: `Salariu`).

O posibilă interogare SQL (presupunând că avem tabela `Angajati` cu coloana `Salariu`) ar fi:

```sql
UPDATE Angajati
SET Salariu = Salariu + (SELECT AVG(Salariu) FROM Angajati) * 0.10
WHERE Deptno = 10;
```

Această interogare ar urma următorii pași:

1. **Calculează salariul mediu** al tuturor angajaților.
2. **Adaugă 10% din salariul mediu** la salariul curent al fiecărui angajat.
3. **Aplică actualizarea** doar angajaților din departamentul 10.

Vă rugăm să furnizați mai multe informații despre structura bazei de date pentru a putea oferi o interogare mai precisă.
",UPDATE EMP SET SAL = SAL + 0.10 * (SELECT AVG(SAL) FROM EMP) WHERE DEPTNO = 10;,0.0,0.0,0.0,0.6,0.0,0.0935672514619883,0.5
68,Manual - Test 3,Hard,,,Care interogare șterge angajații al căror salariu este mai mic decât salariul mediu al departamentului lor și returnează numărul de rânduri afectate?,DELETE FROM EMP WHERE SAL < (SELECT AVG(SAL) FROM EMP WHERE DEPTNO = EMP.DEPTNO);,Este corect,,"['copyright@www.adrian.runceanu.ro\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n', 'copyright@www.adrian.runceanu.ro\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n', 'copyright@www.adrian.runceanu.ro\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47', 'copyright@www.adrian.runceanu.ro\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47', 'copyright@www.adrian.runceanu.ro\nExercitii\n1. Listaţi toţi angajaţii care au salariul între 1500 \nşi 3000. \n2. Listaţi numele angajaţilor ordonându-i în \nordine alfabetică.\n3. Listaţi toţi angajaţii ai căror nume conţin LL sau \nTT în interior. \n4. Listaţi toţi angajaţii care nu au manager. \nCurs - Baze de date 83']","Din păcate, nu pot răspunde la această întrebare. Informațiile furnizate conțin exemple de interogări SQL, dar nu includ o interogare care șterge angajați cu salarii sub media departamentului lor și returnează numărul de rânduri afectate. 
",Care interogare șterge angajații al căror salariu este mai mic decât salariul mediu al departamentului lor și returnează numărul de rânduri afectate?,"['copyright@www.adrian.runceanu.ro\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n', 'copyright@www.adrian.runceanu.ro\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n', 'copyright@www.adrian.runceanu.ro\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47', 'copyright@www.adrian.runceanu.ro\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47', 'copyright@www.adrian.runceanu.ro\nExercitii\n1. Listaţi toţi angajaţii care au salariul între 1500 \nşi 3000. \n2. Listaţi numele angajaţilor ordonându-i în \nordine alfabetică.\n3. Listaţi toţi angajaţii ai căror nume conţin LL sau \nTT în interior. \n4. Listaţi toţi angajaţii care nu au manager. \nCurs - Baze de date 83']","Din păcate, nu pot răspunde la această întrebare. Informațiile furnizate conțin exemple de interogări SQL, dar nu includ o interogare care șterge angajați cu salarii sub media departamentului lor și returnează numărul de rânduri afectate. 
",DELETE FROM EMP WHERE SAL < (SELECT AVG(SAL) FROM EMP WHERE DEPTNO = EMP.DEPTNO);,0.0,0.0,0.0,0.75,0.0,0.0,0.5
69,Manual - Test 3,Hard,,,"Scrie o interogare care actualizează salariul fiecărui angajat din departamentul 30, mărindu-l cu 5% din salariul mediu al departamentului său.","UPDATE EMP 
SET SAL = SAL + 0.05 * (SELECT AVG(SAL) FROM EMP WHERE DEPTNO = 30) 
WHERE DEPTNO = 30;
",Este corect,,"['copyright@www.adrian.runceanu.ro\nExemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45', 'copyright@www.adrian.runceanu.ro\nExemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\nCurs - Baze de date 49\n', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\nCurs - Baze de date 49\n', 'copyright@www.adrian.runceanu.ro\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47']","```sql
UPDATE EMP
SET SAL = SAL + (0.05 * (SELECT AVG(SAL) FROM EMP WHERE DEPTNO = 30))
WHERE DEPTNO = 30;
``` 

Explicație:

1. **`UPDATE EMP`**: Această clauză specifică faptul că vom actualiza tabela `EMP`.
2. **`SET SAL = SAL + (0.05 * (SELECT ...))`**: Această clauză actualizează coloana `SAL` (salariul) pentru fiecare angajat. Noul salariu va fi egal cu vechiul salariu plus 5% din salariul mediu al departamentului 30.
   - `0.05` reprezintă 5%.
   - `(SELECT AVG(SAL) FROM EMP WHERE DEPTNO = 30)` este o subinterogare care calculează salariul mediu (`AVG(SAL)`) pentru toți angajații din departamentul 30 (`WHERE DEPTNO = 30`).
3. **`WHERE DEPTNO = 30`**: Această clauză specifică faptul că actualizarea se va aplica doar angajaților din departamentul 30. 
","Scrie o interogare care actualizează salariul fiecărui angajat din departamentul 30, mărindu-l cu 5% din salariul mediu al departamentului său.","['copyright@www.adrian.runceanu.ro\nExemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45', 'copyright@www.adrian.runceanu.ro\nExemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\nCurs - Baze de date 49\n', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\nCurs - Baze de date 49\n', 'copyright@www.adrian.runceanu.ro\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47']","```sql
UPDATE EMP
SET SAL = SAL + (0.05 * (SELECT AVG(SAL) FROM EMP WHERE DEPTNO = 30))
WHERE DEPTNO = 30;
``` 

Explicație:

1. **`UPDATE EMP`**: Această clauză specifică faptul că vom actualiza tabela `EMP`.
2. **`SET SAL = SAL + (0.05 * (SELECT ...))`**: Această clauză actualizează coloana `SAL` (salariul) pentru fiecare angajat. Noul salariu va fi egal cu vechiul salariu plus 5% din salariul mediu al departamentului 30.
   - `0.05` reprezintă 5%.
   - `(SELECT AVG(SAL) FROM EMP WHERE DEPTNO = 30)` este o subinterogare care calculează salariul mediu (`AVG(SAL)`) pentru toți angajații din departamentul 30 (`WHERE DEPTNO = 30`).
3. **`WHERE DEPTNO = 30`**: Această clauză specifică faptul că actualizarea se va aplica doar angajaților din departamentul 30. 
","UPDATE EMP 
SET SAL = SAL + 0.05 * (SELECT AVG(SAL) FROM EMP WHERE DEPTNO = 30) 
WHERE DEPTNO = 30;
",0.0,0.0,0.7399010926596555,0.0,0.6148680215015627,0.26865671641791045,1.0
70,Manual - Test 3,Hard,,,Scrie o interogare care modifică funcția (JOB) angajaților care au fost angajați înainte de anul 2000 și le schimbă funcția în 'SENIOR'.,"UPDATE EMP 
SET JOB = 'SENIOR' 
WHERE EXTRACT(YEAR FROM HIREDATE) < 2000;",Este corect,,"['copyright@www.adrian.runceanu.ro\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\nCurs - Baze de date 49\n', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\nCurs - Baze de date 49\n', 'copyright@www.adrian.runceanu.ro\nExercitii\n1. Listaţi toţi angajaţii care au salariul între 1500 \nşi 3000. \n2. Listaţi numele angajaţilor ordonându-i în \nordine alfabetică.\n3. Listaţi toţi angajaţii ai căror nume conţin LL sau \nTT în interior. \n4. Listaţi toţi angajaţii care nu au manager. \nCurs - Baze de date 83', 'copyright@www.adrian.runceanu.ro\nExercitii\n1. Listaţi toţi angajaţii care au salariul între 1500 \nşi 3000. \n2. Listaţi numele angajaţilor ordonându-i în \nordine alfabetică.\n3. Listaţi toţi angajaţii ai căror nume conţin LL sau \nTT în interior. \n4. Listaţi toţi angajaţii care nu au manager. \nCurs - Baze de date 83', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul mai mic sau egal cu 3000:\nCurs - Baze de date 34\n']","Contextul furnizat nu conține informații despre sintaxa specifică pentru interogările SQL sau despre structura bazei de date la care se face referire. Prin urmare, nu pot furniza o interogare SQL validă. 

Totuși, pot oferi un șablon general pentru o astfel de interogare, presupunând că baza de date conține un tabel numit `Angajati` cu coloanele `Data_Angajarii` și `Functie`:

```sql
UPDATE Angajati
SET Functie = 'SENIOR'
WHERE YEAR(Data_Angajarii) < 2000;
```

Această interogare va actualiza tabelul `Angajati` și va seta valoarea coloanei `Functie` la 'SENIOR' pentru toți angajații a căror dată de angajare este înainte de anul 2000. 

**Notă:** Sintaxa exactă poate varia în funcție de sistemul de gestionare a bazelor de date utilizat (ex: MySQL, PostgreSQL, Oracle etc.).
",Scrie o interogare care modifică funcția (JOB) angajaților care au fost angajați înainte de anul 2000 și le schimbă funcția în 'SENIOR'.,"['copyright@www.adrian.runceanu.ro\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\nCurs - Baze de date 49\n', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\nCurs - Baze de date 49\n', 'copyright@www.adrian.runceanu.ro\nExercitii\n1. Listaţi toţi angajaţii care au salariul între 1500 \nşi 3000. \n2. Listaţi numele angajaţilor ordonându-i în \nordine alfabetică.\n3. Listaţi toţi angajaţii ai căror nume conţin LL sau \nTT în interior. \n4. Listaţi toţi angajaţii care nu au manager. \nCurs - Baze de date 83', 'copyright@www.adrian.runceanu.ro\nExercitii\n1. Listaţi toţi angajaţii care au salariul între 1500 \nşi 3000. \n2. Listaţi numele angajaţilor ordonându-i în \nordine alfabetică.\n3. Listaţi toţi angajaţii ai căror nume conţin LL sau \nTT în interior. \n4. Listaţi toţi angajaţii care nu au manager. \nCurs - Baze de date 83', 'copyright@www.adrian.runceanu.ro\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul mai mic sau egal cu 3000:\nCurs - Baze de date 34\n']","Contextul furnizat nu conține informații despre sintaxa specifică pentru interogările SQL sau despre structura bazei de date la care se face referire. Prin urmare, nu pot furniza o interogare SQL validă. 

Totuși, pot oferi un șablon general pentru o astfel de interogare, presupunând că baza de date conține un tabel numit `Angajati` cu coloanele `Data_Angajarii` și `Functie`:

```sql
UPDATE Angajati
SET Functie = 'SENIOR'
WHERE YEAR(Data_Angajarii) < 2000;
```

Această interogare va actualiza tabelul `Angajati` și va seta valoarea coloanei `Functie` la 'SENIOR' pentru toți angajații a căror dată de angajare este înainte de anul 2000. 

**Notă:** Sintaxa exactă poate varia în funcție de sistemul de gestionare a bazelor de date utilizat (ex: MySQL, PostgreSQL, Oracle etc.).
","UPDATE EMP 
SET JOB = 'SENIOR' 
WHERE EXTRACT(YEAR FROM HIREDATE) < 2000;",0.0,0.0,0.0,0.4,0.0,0.08695652173913043,0.4
71,Manual - Test 4,Negativ,,,Cum e vremea la galati ?,Nu am gasit informatii in curs despre intrebarea ta,,,"['copyright@www.adrian.runceanu.ro\nNOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n', 'copyright@www.adrian.runceanu.ro\nNOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n', 'copyright@www.adrian.runceanu.ro\nClauza WITH CHECK OPTION\n  Se foloseşte pentru a ne asigura că \noperaţia care se efectuează pe o vedere \nrespectă domeniul vederii, adică nu va \nintroduce modificări care vor determina ca \nliniile inserate să nu mai fie văzute de vedere. \nCurs - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\nClauza WITH CHECK OPTION\n  Se foloseşte pentru a ne asigura că \noperaţia care se efectuează pe o vedere \nrespectă domeniul vederii, adică nu va \nintroduce modificări care vor determina ca \nliniile inserate să nu mai fie văzute de vedere. \nCurs - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n']","I apologize, but the text you provided does not contain the answer to what the weather is like in Galati. It seems to be about database management. 
",Cum e vremea la galati ?,"['copyright@www.adrian.runceanu.ro\nNOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n', 'copyright@www.adrian.runceanu.ro\nNOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n', 'copyright@www.adrian.runceanu.ro\nClauza WITH CHECK OPTION\n  Se foloseşte pentru a ne asigura că \noperaţia care se efectuează pe o vedere \nrespectă domeniul vederii, adică nu va \nintroduce modificări care vor determina ca \nliniile inserate să nu mai fie văzute de vedere. \nCurs - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\nClauza WITH CHECK OPTION\n  Se foloseşte pentru a ne asigura că \noperaţia care se efectuează pe o vedere \nrespectă domeniul vederii, adică nu va \nintroduce modificări care vor determina ca \nliniile inserate să nu mai fie văzute de vedere. \nCurs - BAZE DE DATE 40', 'copyright@www.adrian.runceanu.ro\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n']","I apologize, but the text you provided does not contain the answer to what the weather is like in Galati. It seems to be about database management. 
",Nu am gasit informatii in curs despre intrebarea ta,0.0,0.0,0.0,1.0,0.018160849415439308,0.05555555555555555,0.67
72,Manual - Test 4,Negativ,,,Cati ani a trait Michael Jackson ?,Nu am gasit informatii in curs despre intrebarea ta,,,"['copyright@www.adrian.runceanu.ro\nConstrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17', 'copyright@www.adrian.runceanu.ro\nConstrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17', 'copyright@www.adrian.runceanu.ro\nProbleme propuse\n1. Sa se mareasca cu 3% salariul angajatului cu \nprenumele ""ADAMS"". \n(2 solutii: una cu Select si una cu Update)  \nCurs 7 - BAZE DE DATE 59', 'copyright@www.adrian.runceanu.ro\nProbleme propuse\n1. Sa se mareasca cu 3% salariul angajatului cu \nprenumele ""ADAMS"". \n(2 solutii: una cu Select si una cu Update)  \nCurs 7 - BAZE DE DATE 59', 'copyright@www.adrian.runceanu.ro\ntt\nExemplu:\nALTER USER scott\nIDENTIFIED BY lion;\n➢Desi aceasta declaratie poate fi folosita pentru \nschimbarea parolei, exista multe alte optiuni. \n➢Pentru a putea schimba oricare alta optiune \ntrebuie sa avem privilegiul ALTER USER.\nCurs - BAZE DE DATE 25']","I'm sorry, I cannot answer that question based on the context provided. The text pertains to database management and does not contain information about Michael Jackson's age. 
",Cati ani a trait Michael Jackson ?,"['copyright@www.adrian.runceanu.ro\nConstrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17', 'copyright@www.adrian.runceanu.ro\nConstrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17', 'copyright@www.adrian.runceanu.ro\nProbleme propuse\n1. Sa se mareasca cu 3% salariul angajatului cu \nprenumele ""ADAMS"". \n(2 solutii: una cu Select si una cu Update)  \nCurs 7 - BAZE DE DATE 59', 'copyright@www.adrian.runceanu.ro\nProbleme propuse\n1. Sa se mareasca cu 3% salariul angajatului cu \nprenumele ""ADAMS"". \n(2 solutii: una cu Select si una cu Update)  \nCurs 7 - BAZE DE DATE 59', 'copyright@www.adrian.runceanu.ro\ntt\nExemplu:\nALTER USER scott\nIDENTIFIED BY lion;\n➢Desi aceasta declaratie poate fi folosita pentru \nschimbarea parolei, exista multe alte optiuni. \n➢Pentru a putea schimba oricare alta optiune \ntrebuie sa avem privilegiul ALTER USER.\nCurs - BAZE DE DATE 25']","I'm sorry, I cannot answer that question based on the context provided. The text pertains to database management and does not contain information about Michael Jackson's age. 
",Nu am gasit informatii in curs despre intrebarea ta,0.0,1.0,0.0,1.0,0.0,0.0,0.67
73,Manual - Test 4,Negativ,,,Ce o carte ?,Nu am gasit informatii in curs despre intrebarea ta,,,"['copyright@www.adrian.runceanu.ro\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n', 'copyright@www.adrian.runceanu.ro\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n', 'copyright@www.adrian.runceanu.ro\nCereri Top N \nCererile Top N căuta cele mai mari n sau \ncele mai mici valori dintr-o coloană. \nFolosind cereri Top N putem afla de \nexemplu: \n–primii 3 salariaţi dintr-o companie\n–cele mai bine vândute 3 produse ale unei \ncompanii\nCurs - BAZE DE DATE 49', 'copyright@www.adrian.runceanu.ro\nCereri Top N \nCererile Top N căuta cele mai mari n sau \ncele mai mici valori dintr-o coloană. \nFolosind cereri Top N putem afla de \nexemplu: \n–primii 3 salariaţi dintr-o companie\n–cele mai bine vândute 3 produse ale unei \ncompanii\nCurs - BAZE DE DATE 49', 'copyright@www.adrian.runceanu.ro\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5']","I'm sorry, I cannot answer your question using the context provided. The text discusses databases and SQL queries, which are not related to your question in Romanian. 
",Ce o carte ?,"['copyright@www.adrian.runceanu.ro\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n', 'copyright@www.adrian.runceanu.ro\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n', 'copyright@www.adrian.runceanu.ro\nCereri Top N \nCererile Top N căuta cele mai mari n sau \ncele mai mici valori dintr-o coloană. \nFolosind cereri Top N putem afla de \nexemplu: \n–primii 3 salariaţi dintr-o companie\n–cele mai bine vândute 3 produse ale unei \ncompanii\nCurs - BAZE DE DATE 49', 'copyright@www.adrian.runceanu.ro\nCereri Top N \nCererile Top N căuta cele mai mari n sau \ncele mai mici valori dintr-o coloană. \nFolosind cereri Top N putem afla de \nexemplu: \n–primii 3 salariaţi dintr-o companie\n–cele mai bine vândute 3 produse ale unei \ncompanii\nCurs - BAZE DE DATE 49', 'copyright@www.adrian.runceanu.ro\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5']","I'm sorry, I cannot answer your question using the context provided. The text discusses databases and SQL queries, which are not related to your question in Romanian. 
",Nu am gasit informatii in curs despre intrebarea ta,0.0,1.0,0.0,0.6666666666666666,0.0,0.05405405405405406,0.67
74,Manual - Test 4,Negativ,,,Cat face 2 + 2 ?,Nu am gasit informatii in curs despre intrebarea ta,,,"['copyright@www.adrian.runceanu.ro\n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN. \n• De fapt operatorul NOT IN este echivalent cu <> ALL.\n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL). \nCurs 6 - BAZE DE DATE 62', 'copyright@www.adrian.runceanu.ro\n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN. \n• De fapt operatorul NOT IN este echivalent cu <> ALL.\n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL). \nCurs 6 - BAZE DE DATE 62', 'copyright@www.adrian.runceanu.ro\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n', 'copyright@www.adrian.runceanu.ro\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n', 'copyright@www.adrian.runceanu.ro\nConstrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17']","This document does not contain the answer to 2 + 2. However, I can tell you that 2 + 2 = 4. 
",Cat face 2 + 2 ?,"['copyright@www.adrian.runceanu.ro\n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN. \n• De fapt operatorul NOT IN este echivalent cu <> ALL.\n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL). \nCurs 6 - BAZE DE DATE 62', 'copyright@www.adrian.runceanu.ro\n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN. \n• De fapt operatorul NOT IN este echivalent cu <> ALL.\n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL). \nCurs 6 - BAZE DE DATE 62', 'copyright@www.adrian.runceanu.ro\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n', 'copyright@www.adrian.runceanu.ro\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n', 'copyright@www.adrian.runceanu.ro\nConstrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17']","This document does not contain the answer to 2 + 2. However, I can tell you that 2 + 2 = 4. 
",Nu am gasit informatii in curs despre intrebarea ta,0.0,1.0,0.8882559037166161,0.5,0.0,0.0,0.67
75,Manual - Test 4,Negativ,,,Care dintre următoarele afirmații este corectă cu privire la diferențele dintre bazele de date distribuite și NoSQL?,Nu am gasit informatii in curs despre intrebarea ta,,,"['7 \n \n✓ Flexibilitate în modelarea datelor \n✓ Performanță ridicată pentru date mari și distribuție geografică \nDezavantaje: \n✓ Lipsa standardizării interogărilor \n✓ Unele implementări nu oferă suport pentru tranzacții complexe \n \n \n2.5. Compararea tipurilor de baze de date \n \nTip de bază de \ndate Structură Scalabilitate Flexibilitate Cazuri de utilizare \nIerarhică Arbore Redusă Scăzută Sistemele bancare vechi \nRețea Grafic Medie Medie Aplicații complexe \nRelațională Tabelară Scalabilitate \nlimitată Medie CRM, ERP, eCommerce \nNoSQL Diversă Mare Mare Big Data, IoT, social \nmedia \n \n \n3. Baze de date NoSQL \nBazele de date NoSQL sunt o categorie modernă de sisteme de gestionare a bazelor de date \ncare elimină limitările sistemelor relaționale pentru a permite o stocare și o interogare mai eficiente \na datelor nestructurate și semi-structurate. \n \n3.1. Utilizări comune \n✓ Big Data: MongoDB, Cassandra \n✓ Caching și sesiuni web: Redis, Memcached \n✓ Aplicații distribuite: DynamoDB, CouchDB \n✓ Rețele sociale și grafică de date: Neo4j, ArangoDB \n \n \n3.2. Avantajele bazelor de date NoSQL \n✓ Scalabilitate orizontală: Pot gestiona volume mari de date prin distribuire pe mai multe \nservere. \n✓ Flexibilitate: Nu impun o schemă strictă a datelor, ceea ce permite schimbări rapide. \n✓ Performanță ridicată: Se adaptează bine la cerințele aplicațiilor moderne, unde latența \nredusă este esențială. \n \n1.3.3 Dezavantajele bazelor de date NoSQL \n✓ Lipsa unui standard unificat:  Fiecare sistem are propriul model de interogare și \nadministrare. \n✓ Consistența datelor:  Majoritatea bazelor NoSQL sacrifică consistența în favoarea \ndisponibilității și performanței (modelul CAP). \n \n \n ', '7 \n \n✓ Flexibilitate în modelarea datelor \n✓ Performanță ridicată pentru date mari și distribuție geografică \nDezavantaje: \n✓ Lipsa standardizării interogărilor \n✓ Unele implementări nu oferă suport pentru tranzacții complexe \n \n \n2.5. Compararea tipurilor de baze de date \n \nTip de bază de \ndate Structură Scalabilitate Flexibilitate Cazuri de utilizare \nIerarhică Arbore Redusă Scăzută Sistemele bancare vechi \nRețea Grafic Medie Medie Aplicații complexe \nRelațională Tabelară Scalabilitate \nlimitată Medie CRM, ERP, eCommerce \nNoSQL Diversă Mare Mare Big Data, IoT, social \nmedia \n \n \n3. Baze de date NoSQL \nBazele de date NoSQL sunt o categorie modernă de sisteme de gestionare a bazelor de date \ncare elimină limitările sistemelor relaționale pentru a permite o stocare și o interogare mai eficiente \na datelor nestructurate și semi-structurate. \n \n3.1. Utilizări comune \n✓ Big Data: MongoDB, Cassandra \n✓ Caching și sesiuni web: Redis, Memcached \n✓ Aplicații distribuite: DynamoDB, CouchDB \n✓ Rețele sociale și grafică de date: Neo4j, ArangoDB \n \n \n3.2. Avantajele bazelor de date NoSQL \n✓ Scalabilitate orizontală: Pot gestiona volume mari de date prin distribuire pe mai multe \nservere. \n✓ Flexibilitate: Nu impun o schemă strictă a datelor, ceea ce permite schimbări rapide. \n✓ Performanță ridicată: Se adaptează bine la cerințele aplicațiilor moderne, unde latența \nredusă este esențială. \n \n1.3.3 Dezavantajele bazelor de date NoSQL \n✓ Lipsa unui standard unificat:  Fiecare sistem are propriul model de interogare și \nadministrare. \n✓ Consistența datelor:  Majoritatea bazelor NoSQL sacrifică consistența în favoarea \ndisponibilității și performanței (modelul CAP). \n \n \n ', 'copyright@www.adrian.runceanu.ro\n2. Clasificare după numărul de staţii\npe care este stocată baza de date\n✓Există două categorii de sisteme de baze de date:\n1. centralizate \n2. distribuite\n1. Un sistem de baze de date centralizat (Centralized \nDatabase System) este un sistem de baze de date în \ncare datele şi sistemul de gestiune sunt stocate pe un \nsingur calculator.\n2. Un sistem de baze de date distribuit (Distributed \nDatabase System) poate avea atât datele, cât şi sistemul \nde gestiune, distribuite pe mai multe calculatoare \ninterconectate printr-o reţea de comunicaţie.\nCurs - Baze de date 68', 'copyright@www.adrian.runceanu.ro\n2. Clasificare după numărul de staţii\npe care este stocată baza de date\n✓Există două categorii de sisteme de baze de date:\n1. centralizate \n2. distribuite\n1. Un sistem de baze de date centralizat (Centralized \nDatabase System) este un sistem de baze de date în \ncare datele şi sistemul de gestiune sunt stocate pe un \nsingur calculator.\n2. Un sistem de baze de date distribuit (Distributed \nDatabase System) poate avea atât datele, cât şi sistemul \nde gestiune, distribuite pe mai multe calculatoare \ninterconectate printr-o reţea de comunicaţie.\nCurs - Baze de date 68', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul. \n']","Bazele de date distribuite și bazele de date NoSQL sunt concepte distincte. Iată diferența:

**Bazele de date distribuite** se referă la **modul de stocare** a datelor: informația este distribuită pe mai multe calculatoare interconectate. Acest lucru poate fi implementat pentru diverse tipuri de baze de date, inclusiv cele relaționale (SQL) și cele NoSQL.

**Bazele de date NoSQL** reprezintă o **categorie de sisteme de gestionare a bazelor de date** care se diferențiază de modelul tradițional relațional (SQL). Acestea oferă flexibilitate în modelarea datelor și sunt potrivite pentru date nestructurate sau semi-structurate. 

Deci, afirmația corectă este că bazele de date NoSQL și bazele de date distribuite sunt concepte diferite, care pot coexista: o bază de date NoSQL poate fi sau nu distribuită, la fel cum o bază de date distribuită poate fi relațională (SQL) sau NoSQL.
",Care dintre următoarele afirmații este corectă cu privire la diferențele dintre bazele de date distribuite și NoSQL?,"['7 \n \n✓ Flexibilitate în modelarea datelor \n✓ Performanță ridicată pentru date mari și distribuție geografică \nDezavantaje: \n✓ Lipsa standardizării interogărilor \n✓ Unele implementări nu oferă suport pentru tranzacții complexe \n \n \n2.5. Compararea tipurilor de baze de date \n \nTip de bază de \ndate Structură Scalabilitate Flexibilitate Cazuri de utilizare \nIerarhică Arbore Redusă Scăzută Sistemele bancare vechi \nRețea Grafic Medie Medie Aplicații complexe \nRelațională Tabelară Scalabilitate \nlimitată Medie CRM, ERP, eCommerce \nNoSQL Diversă Mare Mare Big Data, IoT, social \nmedia \n \n \n3. Baze de date NoSQL \nBazele de date NoSQL sunt o categorie modernă de sisteme de gestionare a bazelor de date \ncare elimină limitările sistemelor relaționale pentru a permite o stocare și o interogare mai eficiente \na datelor nestructurate și semi-structurate. \n \n3.1. Utilizări comune \n✓ Big Data: MongoDB, Cassandra \n✓ Caching și sesiuni web: Redis, Memcached \n✓ Aplicații distribuite: DynamoDB, CouchDB \n✓ Rețele sociale și grafică de date: Neo4j, ArangoDB \n \n \n3.2. Avantajele bazelor de date NoSQL \n✓ Scalabilitate orizontală: Pot gestiona volume mari de date prin distribuire pe mai multe \nservere. \n✓ Flexibilitate: Nu impun o schemă strictă a datelor, ceea ce permite schimbări rapide. \n✓ Performanță ridicată: Se adaptează bine la cerințele aplicațiilor moderne, unde latența \nredusă este esențială. \n \n1.3.3 Dezavantajele bazelor de date NoSQL \n✓ Lipsa unui standard unificat:  Fiecare sistem are propriul model de interogare și \nadministrare. \n✓ Consistența datelor:  Majoritatea bazelor NoSQL sacrifică consistența în favoarea \ndisponibilității și performanței (modelul CAP). \n \n \n ', '7 \n \n✓ Flexibilitate în modelarea datelor \n✓ Performanță ridicată pentru date mari și distribuție geografică \nDezavantaje: \n✓ Lipsa standardizării interogărilor \n✓ Unele implementări nu oferă suport pentru tranzacții complexe \n \n \n2.5. Compararea tipurilor de baze de date \n \nTip de bază de \ndate Structură Scalabilitate Flexibilitate Cazuri de utilizare \nIerarhică Arbore Redusă Scăzută Sistemele bancare vechi \nRețea Grafic Medie Medie Aplicații complexe \nRelațională Tabelară Scalabilitate \nlimitată Medie CRM, ERP, eCommerce \nNoSQL Diversă Mare Mare Big Data, IoT, social \nmedia \n \n \n3. Baze de date NoSQL \nBazele de date NoSQL sunt o categorie modernă de sisteme de gestionare a bazelor de date \ncare elimină limitările sistemelor relaționale pentru a permite o stocare și o interogare mai eficiente \na datelor nestructurate și semi-structurate. \n \n3.1. Utilizări comune \n✓ Big Data: MongoDB, Cassandra \n✓ Caching și sesiuni web: Redis, Memcached \n✓ Aplicații distribuite: DynamoDB, CouchDB \n✓ Rețele sociale și grafică de date: Neo4j, ArangoDB \n \n \n3.2. Avantajele bazelor de date NoSQL \n✓ Scalabilitate orizontală: Pot gestiona volume mari de date prin distribuire pe mai multe \nservere. \n✓ Flexibilitate: Nu impun o schemă strictă a datelor, ceea ce permite schimbări rapide. \n✓ Performanță ridicată: Se adaptează bine la cerințele aplicațiilor moderne, unde latența \nredusă este esențială. \n \n1.3.3 Dezavantajele bazelor de date NoSQL \n✓ Lipsa unui standard unificat:  Fiecare sistem are propriul model de interogare și \nadministrare. \n✓ Consistența datelor:  Majoritatea bazelor NoSQL sacrifică consistența în favoarea \ndisponibilității și performanței (modelul CAP). \n \n \n ', 'copyright@www.adrian.runceanu.ro\n2. Clasificare după numărul de staţii\npe care este stocată baza de date\n✓Există două categorii de sisteme de baze de date:\n1. centralizate \n2. distribuite\n1. Un sistem de baze de date centralizat (Centralized \nDatabase System) este un sistem de baze de date în \ncare datele şi sistemul de gestiune sunt stocate pe un \nsingur calculator.\n2. Un sistem de baze de date distribuit (Distributed \nDatabase System) poate avea atât datele, cât şi sistemul \nde gestiune, distribuite pe mai multe calculatoare \ninterconectate printr-o reţea de comunicaţie.\nCurs - Baze de date 68', 'copyright@www.adrian.runceanu.ro\n2. Clasificare după numărul de staţii\npe care este stocată baza de date\n✓Există două categorii de sisteme de baze de date:\n1. centralizate \n2. distribuite\n1. Un sistem de baze de date centralizat (Centralized \nDatabase System) este un sistem de baze de date în \ncare datele şi sistemul de gestiune sunt stocate pe un \nsingur calculator.\n2. Un sistem de baze de date distribuit (Distributed \nDatabase System) poate avea atât datele, cât şi sistemul \nde gestiune, distribuite pe mai multe calculatoare \ninterconectate printr-o reţea de comunicaţie.\nCurs - Baze de date 68', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul. \n']","Bazele de date distribuite și bazele de date NoSQL sunt concepte distincte. Iată diferența:

**Bazele de date distribuite** se referă la **modul de stocare** a datelor: informația este distribuită pe mai multe calculatoare interconectate. Acest lucru poate fi implementat pentru diverse tipuri de baze de date, inclusiv cele relaționale (SQL) și cele NoSQL.

**Bazele de date NoSQL** reprezintă o **categorie de sisteme de gestionare a bazelor de date** care se diferențiază de modelul tradițional relațional (SQL). Acestea oferă flexibilitate în modelarea datelor și sunt potrivite pentru date nestructurate sau semi-structurate. 

Deci, afirmația corectă este că bazele de date NoSQL și bazele de date distribuite sunt concepte diferite, care pot coexista: o bază de date NoSQL poate fi sau nu distribuită, la fel cum o bază de date distribuită poate fi relațională (SQL) sau NoSQL.
",Nu am gasit informatii in curs despre intrebarea ta,0.0,0.0,0.8568270153906722,0.7272727272727273,0.0,0.013157894736842106,0.0
76,Manual - Test 4,Negativ,,,Ce avantaj major oferă bazele de date NoSQL față de bazele de date distribuite tradiționale?,Nu am gasit informatii in curs despre intrebarea ta,,,"['copyright@www.adrian.runceanu.ro\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', '7 \n \n✓ Flexibilitate în modelarea datelor \n✓ Performanță ridicată pentru date mari și distribuție geografică \nDezavantaje: \n✓ Lipsa standardizării interogărilor \n✓ Unele implementări nu oferă suport pentru tranzacții complexe \n \n \n2.5. Compararea tipurilor de baze de date \n \nTip de bază de \ndate Structură Scalabilitate Flexibilitate Cazuri de utilizare \nIerarhică Arbore Redusă Scăzută Sistemele bancare vechi \nRețea Grafic Medie Medie Aplicații complexe \nRelațională Tabelară Scalabilitate \nlimitată Medie CRM, ERP, eCommerce \nNoSQL Diversă Mare Mare Big Data, IoT, social \nmedia \n \n \n3. Baze de date NoSQL \nBazele de date NoSQL sunt o categorie modernă de sisteme de gestionare a bazelor de date \ncare elimină limitările sistemelor relaționale pentru a permite o stocare și o interogare mai eficiente \na datelor nestructurate și semi-structurate. \n \n3.1. Utilizări comune \n✓ Big Data: MongoDB, Cassandra \n✓ Caching și sesiuni web: Redis, Memcached \n✓ Aplicații distribuite: DynamoDB, CouchDB \n✓ Rețele sociale și grafică de date: Neo4j, ArangoDB \n \n \n3.2. Avantajele bazelor de date NoSQL \n✓ Scalabilitate orizontală: Pot gestiona volume mari de date prin distribuire pe mai multe \nservere. \n✓ Flexibilitate: Nu impun o schemă strictă a datelor, ceea ce permite schimbări rapide. \n✓ Performanță ridicată: Se adaptează bine la cerințele aplicațiilor moderne, unde latența \nredusă este esențială. \n \n1.3.3 Dezavantajele bazelor de date NoSQL \n✓ Lipsa unui standard unificat:  Fiecare sistem are propriul model de interogare și \nadministrare. \n✓ Consistența datelor:  Majoritatea bazelor NoSQL sacrifică consistența în favoarea \ndisponibilității și performanței (modelul CAP). \n \n \n ', '7 \n \n✓ Flexibilitate în modelarea datelor \n✓ Performanță ridicată pentru date mari și distribuție geografică \nDezavantaje: \n✓ Lipsa standardizării interogărilor \n✓ Unele implementări nu oferă suport pentru tranzacții complexe \n \n \n2.5. Compararea tipurilor de baze de date \n \nTip de bază de \ndate Structură Scalabilitate Flexibilitate Cazuri de utilizare \nIerarhică Arbore Redusă Scăzută Sistemele bancare vechi \nRețea Grafic Medie Medie Aplicații complexe \nRelațională Tabelară Scalabilitate \nlimitată Medie CRM, ERP, eCommerce \nNoSQL Diversă Mare Mare Big Data, IoT, social \nmedia \n \n \n3. Baze de date NoSQL \nBazele de date NoSQL sunt o categorie modernă de sisteme de gestionare a bazelor de date \ncare elimină limitările sistemelor relaționale pentru a permite o stocare și o interogare mai eficiente \na datelor nestructurate și semi-structurate. \n \n3.1. Utilizări comune \n✓ Big Data: MongoDB, Cassandra \n✓ Caching și sesiuni web: Redis, Memcached \n✓ Aplicații distribuite: DynamoDB, CouchDB \n✓ Rețele sociale și grafică de date: Neo4j, ArangoDB \n \n \n3.2. Avantajele bazelor de date NoSQL \n✓ Scalabilitate orizontală: Pot gestiona volume mari de date prin distribuire pe mai multe \nservere. \n✓ Flexibilitate: Nu impun o schemă strictă a datelor, ceea ce permite schimbări rapide. \n✓ Performanță ridicată: Se adaptează bine la cerințele aplicațiilor moderne, unde latența \nredusă este esențială. \n \n1.3.3 Dezavantajele bazelor de date NoSQL \n✓ Lipsa unui standard unificat:  Fiecare sistem are propriul model de interogare și \nadministrare. \n✓ Consistența datelor:  Majoritatea bazelor NoSQL sacrifică consistența în favoarea \ndisponibilității și performanței (modelul CAP). \n \n \n ', 'copyright@www.adrian.runceanu.ro\nConţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\nCurs - Baze de date\n 14\n']","Contextul oferit menționează câteva avantaje majore ale bazelor de date NoSQL față de bazele de date tradiționale, în special în comparație cu cele relaționale:

* **Scalabilitate orizontală:** Bazele de date NoSQL pot gestiona volume mult mai mari de date prin distribuirea lor pe mai multe servere.  Bazele de date relaționale tradiționale au o scalabilitate verticală limitată. 
* **Flexibilitate:**  Spre deosebire de bazele de date relaționale care necesită o schemă rigidă, bazele NoSQL permit flexibilitate în modelarea datelor, adaptându-se ușor la schimbări.
* **Performanță ridicată:**  NoSQL excelează la latență redusă, fiind ideale pentru aplicații moderne ce necesită viteză mare de răspuns, cum ar fi cele de Big Data, IoT sau social media.

Pe scurt, bazele de date NoSQL oferă un avantaj major în ceea ce privește **scalabilitatea, flexibilitatea și performanța** pentru gestionarea datelor nestructurate și semi-structurate, în special în contextul aplicațiilor moderne care procesează volume mari de informații. 
",Ce avantaj major oferă bazele de date NoSQL față de bazele de date distribuite tradiționale?,"['copyright@www.adrian.runceanu.ro\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'copyright@www.adrian.runceanu.ro\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', '7 \n \n✓ Flexibilitate în modelarea datelor \n✓ Performanță ridicată pentru date mari și distribuție geografică \nDezavantaje: \n✓ Lipsa standardizării interogărilor \n✓ Unele implementări nu oferă suport pentru tranzacții complexe \n \n \n2.5. Compararea tipurilor de baze de date \n \nTip de bază de \ndate Structură Scalabilitate Flexibilitate Cazuri de utilizare \nIerarhică Arbore Redusă Scăzută Sistemele bancare vechi \nRețea Grafic Medie Medie Aplicații complexe \nRelațională Tabelară Scalabilitate \nlimitată Medie CRM, ERP, eCommerce \nNoSQL Diversă Mare Mare Big Data, IoT, social \nmedia \n \n \n3. Baze de date NoSQL \nBazele de date NoSQL sunt o categorie modernă de sisteme de gestionare a bazelor de date \ncare elimină limitările sistemelor relaționale pentru a permite o stocare și o interogare mai eficiente \na datelor nestructurate și semi-structurate. \n \n3.1. Utilizări comune \n✓ Big Data: MongoDB, Cassandra \n✓ Caching și sesiuni web: Redis, Memcached \n✓ Aplicații distribuite: DynamoDB, CouchDB \n✓ Rețele sociale și grafică de date: Neo4j, ArangoDB \n \n \n3.2. Avantajele bazelor de date NoSQL \n✓ Scalabilitate orizontală: Pot gestiona volume mari de date prin distribuire pe mai multe \nservere. \n✓ Flexibilitate: Nu impun o schemă strictă a datelor, ceea ce permite schimbări rapide. \n✓ Performanță ridicată: Se adaptează bine la cerințele aplicațiilor moderne, unde latența \nredusă este esențială. \n \n1.3.3 Dezavantajele bazelor de date NoSQL \n✓ Lipsa unui standard unificat:  Fiecare sistem are propriul model de interogare și \nadministrare. \n✓ Consistența datelor:  Majoritatea bazelor NoSQL sacrifică consistența în favoarea \ndisponibilității și performanței (modelul CAP). \n \n \n ', '7 \n \n✓ Flexibilitate în modelarea datelor \n✓ Performanță ridicată pentru date mari și distribuție geografică \nDezavantaje: \n✓ Lipsa standardizării interogărilor \n✓ Unele implementări nu oferă suport pentru tranzacții complexe \n \n \n2.5. Compararea tipurilor de baze de date \n \nTip de bază de \ndate Structură Scalabilitate Flexibilitate Cazuri de utilizare \nIerarhică Arbore Redusă Scăzută Sistemele bancare vechi \nRețea Grafic Medie Medie Aplicații complexe \nRelațională Tabelară Scalabilitate \nlimitată Medie CRM, ERP, eCommerce \nNoSQL Diversă Mare Mare Big Data, IoT, social \nmedia \n \n \n3. Baze de date NoSQL \nBazele de date NoSQL sunt o categorie modernă de sisteme de gestionare a bazelor de date \ncare elimină limitările sistemelor relaționale pentru a permite o stocare și o interogare mai eficiente \na datelor nestructurate și semi-structurate. \n \n3.1. Utilizări comune \n✓ Big Data: MongoDB, Cassandra \n✓ Caching și sesiuni web: Redis, Memcached \n✓ Aplicații distribuite: DynamoDB, CouchDB \n✓ Rețele sociale și grafică de date: Neo4j, ArangoDB \n \n \n3.2. Avantajele bazelor de date NoSQL \n✓ Scalabilitate orizontală: Pot gestiona volume mari de date prin distribuire pe mai multe \nservere. \n✓ Flexibilitate: Nu impun o schemă strictă a datelor, ceea ce permite schimbări rapide. \n✓ Performanță ridicată: Se adaptează bine la cerințele aplicațiilor moderne, unde latența \nredusă este esențială. \n \n1.3.3 Dezavantajele bazelor de date NoSQL \n✓ Lipsa unui standard unificat:  Fiecare sistem are propriul model de interogare și \nadministrare. \n✓ Consistența datelor:  Majoritatea bazelor NoSQL sacrifică consistența în favoarea \ndisponibilității și performanței (modelul CAP). \n \n \n ', 'copyright@www.adrian.runceanu.ro\nConţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\nCurs - Baze de date\n 14\n']","Contextul oferit menționează câteva avantaje majore ale bazelor de date NoSQL față de bazele de date tradiționale, în special în comparație cu cele relaționale:

* **Scalabilitate orizontală:** Bazele de date NoSQL pot gestiona volume mult mai mari de date prin distribuirea lor pe mai multe servere.  Bazele de date relaționale tradiționale au o scalabilitate verticală limitată. 
* **Flexibilitate:**  Spre deosebire de bazele de date relaționale care necesită o schemă rigidă, bazele NoSQL permit flexibilitate în modelarea datelor, adaptându-se ușor la schimbări.
* **Performanță ridicată:**  NoSQL excelează la latență redusă, fiind ideale pentru aplicații moderne ce necesită viteză mare de răspuns, cum ar fi cele de Big Data, IoT sau social media.

Pe scurt, bazele de date NoSQL oferă un avantaj major în ceea ce privește **scalabilitatea, flexibilitatea și performanța** pentru gestionarea datelor nestructurate și semi-structurate, în special în contextul aplicațiilor moderne care procesează volume mari de informații. 
",Nu am gasit informatii in curs despre intrebarea ta,0.4166666666458333,0.0,0.8583456966231914,0.8461538461538461,0.0,0.0,0.0
77,Manual - Test 4,Negativ,,,Descrie scenariile în care o bază de date distribuită ar fi mai potrivită decât o bază de date NoSQL.,Nu am gasit informatii in curs despre intrebarea ta,,,"['copyright@www.adrian.runceanu.ro\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4', 'copyright@www.adrian.runceanu.ro\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4', '7 \n \n✓ Flexibilitate în modelarea datelor \n✓ Performanță ridicată pentru date mari și distribuție geografică \nDezavantaje: \n✓ Lipsa standardizării interogărilor \n✓ Unele implementări nu oferă suport pentru tranzacții complexe \n \n \n2.5. Compararea tipurilor de baze de date \n \nTip de bază de \ndate Structură Scalabilitate Flexibilitate Cazuri de utilizare \nIerarhică Arbore Redusă Scăzută Sistemele bancare vechi \nRețea Grafic Medie Medie Aplicații complexe \nRelațională Tabelară Scalabilitate \nlimitată Medie CRM, ERP, eCommerce \nNoSQL Diversă Mare Mare Big Data, IoT, social \nmedia \n \n \n3. Baze de date NoSQL \nBazele de date NoSQL sunt o categorie modernă de sisteme de gestionare a bazelor de date \ncare elimină limitările sistemelor relaționale pentru a permite o stocare și o interogare mai eficiente \na datelor nestructurate și semi-structurate. \n \n3.1. Utilizări comune \n✓ Big Data: MongoDB, Cassandra \n✓ Caching și sesiuni web: Redis, Memcached \n✓ Aplicații distribuite: DynamoDB, CouchDB \n✓ Rețele sociale și grafică de date: Neo4j, ArangoDB \n \n \n3.2. Avantajele bazelor de date NoSQL \n✓ Scalabilitate orizontală: Pot gestiona volume mari de date prin distribuire pe mai multe \nservere. \n✓ Flexibilitate: Nu impun o schemă strictă a datelor, ceea ce permite schimbări rapide. \n✓ Performanță ridicată: Se adaptează bine la cerințele aplicațiilor moderne, unde latența \nredusă este esențială. \n \n1.3.3 Dezavantajele bazelor de date NoSQL \n✓ Lipsa unui standard unificat:  Fiecare sistem are propriul model de interogare și \nadministrare. \n✓ Consistența datelor:  Majoritatea bazelor NoSQL sacrifică consistența în favoarea \ndisponibilității și performanței (modelul CAP). \n \n \n ', '7 \n \n✓ Flexibilitate în modelarea datelor \n✓ Performanță ridicată pentru date mari și distribuție geografică \nDezavantaje: \n✓ Lipsa standardizării interogărilor \n✓ Unele implementări nu oferă suport pentru tranzacții complexe \n \n \n2.5. Compararea tipurilor de baze de date \n \nTip de bază de \ndate Structură Scalabilitate Flexibilitate Cazuri de utilizare \nIerarhică Arbore Redusă Scăzută Sistemele bancare vechi \nRețea Grafic Medie Medie Aplicații complexe \nRelațională Tabelară Scalabilitate \nlimitată Medie CRM, ERP, eCommerce \nNoSQL Diversă Mare Mare Big Data, IoT, social \nmedia \n \n \n3. Baze de date NoSQL \nBazele de date NoSQL sunt o categorie modernă de sisteme de gestionare a bazelor de date \ncare elimină limitările sistemelor relaționale pentru a permite o stocare și o interogare mai eficiente \na datelor nestructurate și semi-structurate. \n \n3.1. Utilizări comune \n✓ Big Data: MongoDB, Cassandra \n✓ Caching și sesiuni web: Redis, Memcached \n✓ Aplicații distribuite: DynamoDB, CouchDB \n✓ Rețele sociale și grafică de date: Neo4j, ArangoDB \n \n \n3.2. Avantajele bazelor de date NoSQL \n✓ Scalabilitate orizontală: Pot gestiona volume mari de date prin distribuire pe mai multe \nservere. \n✓ Flexibilitate: Nu impun o schemă strictă a datelor, ceea ce permite schimbări rapide. \n✓ Performanță ridicată: Se adaptează bine la cerințele aplicațiilor moderne, unde latența \nredusă este esențială. \n \n1.3.3 Dezavantajele bazelor de date NoSQL \n✓ Lipsa unui standard unificat:  Fiecare sistem are propriul model de interogare și \nadministrare. \n✓ Consistența datelor:  Majoritatea bazelor NoSQL sacrifică consistența în favoarea \ndisponibilității și performanței (modelul CAP). \n \n \n ', 'copyright@www.adrian.runceanu.ro\nConţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\nCurs - Baze de date\n 14\n']","Din păcate, contextul oferit nu conține informații despre bazele de date distribuite, ci doar despre tipurile de obiecte dintr-o bază de date și despre bazele de date NoSQL. 

Pentru a putea răspunde la întrebarea ta, ar fi nevoie de informații despre:

* **Ce sunt bazele de date distribuite:** Definiția și caracteristicile lor principale.
* **Scenarii specifice:** Exemple concrete unde avantajele bazelor de date distribuite (scalabilitate, disponibilitate, etc.) sunt esențiale și unde bazele de date NoSQL ar putea fi depășite.

Cu mai multe informații, aș putea oferi o comparație mai detaliată și o analiză a scenariilor în care o bază de date distribuită ar fi mai potrivită decât o bază de date NoSQL. 
",Descrie scenariile în care o bază de date distribuită ar fi mai potrivită decât o bază de date NoSQL.,"['copyright@www.adrian.runceanu.ro\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4', 'copyright@www.adrian.runceanu.ro\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4', '7 \n \n✓ Flexibilitate în modelarea datelor \n✓ Performanță ridicată pentru date mari și distribuție geografică \nDezavantaje: \n✓ Lipsa standardizării interogărilor \n✓ Unele implementări nu oferă suport pentru tranzacții complexe \n \n \n2.5. Compararea tipurilor de baze de date \n \nTip de bază de \ndate Structură Scalabilitate Flexibilitate Cazuri de utilizare \nIerarhică Arbore Redusă Scăzută Sistemele bancare vechi \nRețea Grafic Medie Medie Aplicații complexe \nRelațională Tabelară Scalabilitate \nlimitată Medie CRM, ERP, eCommerce \nNoSQL Diversă Mare Mare Big Data, IoT, social \nmedia \n \n \n3. Baze de date NoSQL \nBazele de date NoSQL sunt o categorie modernă de sisteme de gestionare a bazelor de date \ncare elimină limitările sistemelor relaționale pentru a permite o stocare și o interogare mai eficiente \na datelor nestructurate și semi-structurate. \n \n3.1. Utilizări comune \n✓ Big Data: MongoDB, Cassandra \n✓ Caching și sesiuni web: Redis, Memcached \n✓ Aplicații distribuite: DynamoDB, CouchDB \n✓ Rețele sociale și grafică de date: Neo4j, ArangoDB \n \n \n3.2. Avantajele bazelor de date NoSQL \n✓ Scalabilitate orizontală: Pot gestiona volume mari de date prin distribuire pe mai multe \nservere. \n✓ Flexibilitate: Nu impun o schemă strictă a datelor, ceea ce permite schimbări rapide. \n✓ Performanță ridicată: Se adaptează bine la cerințele aplicațiilor moderne, unde latența \nredusă este esențială. \n \n1.3.3 Dezavantajele bazelor de date NoSQL \n✓ Lipsa unui standard unificat:  Fiecare sistem are propriul model de interogare și \nadministrare. \n✓ Consistența datelor:  Majoritatea bazelor NoSQL sacrifică consistența în favoarea \ndisponibilității și performanței (modelul CAP). \n \n \n ', '7 \n \n✓ Flexibilitate în modelarea datelor \n✓ Performanță ridicată pentru date mari și distribuție geografică \nDezavantaje: \n✓ Lipsa standardizării interogărilor \n✓ Unele implementări nu oferă suport pentru tranzacții complexe \n \n \n2.5. Compararea tipurilor de baze de date \n \nTip de bază de \ndate Structură Scalabilitate Flexibilitate Cazuri de utilizare \nIerarhică Arbore Redusă Scăzută Sistemele bancare vechi \nRețea Grafic Medie Medie Aplicații complexe \nRelațională Tabelară Scalabilitate \nlimitată Medie CRM, ERP, eCommerce \nNoSQL Diversă Mare Mare Big Data, IoT, social \nmedia \n \n \n3. Baze de date NoSQL \nBazele de date NoSQL sunt o categorie modernă de sisteme de gestionare a bazelor de date \ncare elimină limitările sistemelor relaționale pentru a permite o stocare și o interogare mai eficiente \na datelor nestructurate și semi-structurate. \n \n3.1. Utilizări comune \n✓ Big Data: MongoDB, Cassandra \n✓ Caching și sesiuni web: Redis, Memcached \n✓ Aplicații distribuite: DynamoDB, CouchDB \n✓ Rețele sociale și grafică de date: Neo4j, ArangoDB \n \n \n3.2. Avantajele bazelor de date NoSQL \n✓ Scalabilitate orizontală: Pot gestiona volume mari de date prin distribuire pe mai multe \nservere. \n✓ Flexibilitate: Nu impun o schemă strictă a datelor, ceea ce permite schimbări rapide. \n✓ Performanță ridicată: Se adaptează bine la cerințele aplicațiilor moderne, unde latența \nredusă este esențială. \n \n1.3.3 Dezavantajele bazelor de date NoSQL \n✓ Lipsa unui standard unificat:  Fiecare sistem are propriul model de interogare și \nadministrare. \n✓ Consistența datelor:  Majoritatea bazelor NoSQL sacrifică consistența în favoarea \ndisponibilității și performanței (modelul CAP). \n \n \n ', 'copyright@www.adrian.runceanu.ro\nConţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\nCurs - Baze de date\n 14\n']","Din păcate, contextul oferit nu conține informații despre bazele de date distribuite, ci doar despre tipurile de obiecte dintr-o bază de date și despre bazele de date NoSQL. 

Pentru a putea răspunde la întrebarea ta, ar fi nevoie de informații despre:

* **Ce sunt bazele de date distribuite:** Definiția și caracteristicile lor principale.
* **Scenarii specifice:** Exemple concrete unde avantajele bazelor de date distribuite (scalabilitate, disponibilitate, etc.) sunt esențiale și unde bazele de date NoSQL ar putea fi depășite.

Cu mai multe informații, aș putea oferi o comparație mai detaliată și o analiză a scenariilor în care o bază de date distribuită ar fi mai potrivită decât o bază de date NoSQL. 
",Nu am gasit informatii in curs despre intrebarea ta,0.0,0.0,0.0,0.9,0.012414943415352929,0.04580152671755725,0.2
78,Manual - Test 4,Negativ,,,Care sunt principalele provocări ale utilizării bazelor de date NoSQL într-un sistem distribuit?,Nu am gasit informatii in curs despre intrebarea ta,,,"['7 \n \n✓ Flexibilitate în modelarea datelor \n✓ Performanță ridicată pentru date mari și distribuție geografică \nDezavantaje: \n✓ Lipsa standardizării interogărilor \n✓ Unele implementări nu oferă suport pentru tranzacții complexe \n \n \n2.5. Compararea tipurilor de baze de date \n \nTip de bază de \ndate Structură Scalabilitate Flexibilitate Cazuri de utilizare \nIerarhică Arbore Redusă Scăzută Sistemele bancare vechi \nRețea Grafic Medie Medie Aplicații complexe \nRelațională Tabelară Scalabilitate \nlimitată Medie CRM, ERP, eCommerce \nNoSQL Diversă Mare Mare Big Data, IoT, social \nmedia \n \n \n3. Baze de date NoSQL \nBazele de date NoSQL sunt o categorie modernă de sisteme de gestionare a bazelor de date \ncare elimină limitările sistemelor relaționale pentru a permite o stocare și o interogare mai eficiente \na datelor nestructurate și semi-structurate. \n \n3.1. Utilizări comune \n✓ Big Data: MongoDB, Cassandra \n✓ Caching și sesiuni web: Redis, Memcached \n✓ Aplicații distribuite: DynamoDB, CouchDB \n✓ Rețele sociale și grafică de date: Neo4j, ArangoDB \n \n \n3.2. Avantajele bazelor de date NoSQL \n✓ Scalabilitate orizontală: Pot gestiona volume mari de date prin distribuire pe mai multe \nservere. \n✓ Flexibilitate: Nu impun o schemă strictă a datelor, ceea ce permite schimbări rapide. \n✓ Performanță ridicată: Se adaptează bine la cerințele aplicațiilor moderne, unde latența \nredusă este esențială. \n \n1.3.3 Dezavantajele bazelor de date NoSQL \n✓ Lipsa unui standard unificat:  Fiecare sistem are propriul model de interogare și \nadministrare. \n✓ Consistența datelor:  Majoritatea bazelor NoSQL sacrifică consistența în favoarea \ndisponibilității și performanței (modelul CAP). \n \n \n ', '7 \n \n✓ Flexibilitate în modelarea datelor \n✓ Performanță ridicată pentru date mari și distribuție geografică \nDezavantaje: \n✓ Lipsa standardizării interogărilor \n✓ Unele implementări nu oferă suport pentru tranzacții complexe \n \n \n2.5. Compararea tipurilor de baze de date \n \nTip de bază de \ndate Structură Scalabilitate Flexibilitate Cazuri de utilizare \nIerarhică Arbore Redusă Scăzută Sistemele bancare vechi \nRețea Grafic Medie Medie Aplicații complexe \nRelațională Tabelară Scalabilitate \nlimitată Medie CRM, ERP, eCommerce \nNoSQL Diversă Mare Mare Big Data, IoT, social \nmedia \n \n \n3. Baze de date NoSQL \nBazele de date NoSQL sunt o categorie modernă de sisteme de gestionare a bazelor de date \ncare elimină limitările sistemelor relaționale pentru a permite o stocare și o interogare mai eficiente \na datelor nestructurate și semi-structurate. \n \n3.1. Utilizări comune \n✓ Big Data: MongoDB, Cassandra \n✓ Caching și sesiuni web: Redis, Memcached \n✓ Aplicații distribuite: DynamoDB, CouchDB \n✓ Rețele sociale și grafică de date: Neo4j, ArangoDB \n \n \n3.2. Avantajele bazelor de date NoSQL \n✓ Scalabilitate orizontală: Pot gestiona volume mari de date prin distribuire pe mai multe \nservere. \n✓ Flexibilitate: Nu impun o schemă strictă a datelor, ceea ce permite schimbări rapide. \n✓ Performanță ridicată: Se adaptează bine la cerințele aplicațiilor moderne, unde latența \nredusă este esențială. \n \n1.3.3 Dezavantajele bazelor de date NoSQL \n✓ Lipsa unui standard unificat:  Fiecare sistem are propriul model de interogare și \nadministrare. \n✓ Consistența datelor:  Majoritatea bazelor NoSQL sacrifică consistența în favoarea \ndisponibilității și performanței (modelul CAP). \n \n \n ', 'copyright@www.adrian.runceanu.ro\ntt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/', 'copyright@www.adrian.runceanu.ro\ntt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/', 'copyright@www.adrian.runceanu.ro\nConţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\nCurs - Baze de date\n 14\n']","Principalele provocări ale utilizării bazelor de date NoSQL într-un sistem distribuit includ:

* **Lipsa unui standard unificat:** Fiecare sistem NoSQL are propriul model de interogare și administrare. Această lipsă de standardizare poate face dificilă migrarea datelor între diferite sisteme NoSQL și poate necesita o curbă de învățare abruptă pentru dezvoltatori. 
* **Consistența datelor:** Majoritatea bazelor de date NoSQL sacrifică consistența în favoarea disponibilității și performanței (modelul CAP). Aceasta înseamnă că, în anumite situații, este posibil ca datele să nu fie consistente pe toate nodurile unui sistem distribuit. 

Deși contextul menționează scalabilitatea ca un avantaj al bazelor de date NoSQL,  gestionarea consistenței și a integrității datelor  în sistemele distribuite poate deveni o provocare semnificativă. 
",Care sunt principalele provocări ale utilizării bazelor de date NoSQL într-un sistem distribuit?,"['7 \n \n✓ Flexibilitate în modelarea datelor \n✓ Performanță ridicată pentru date mari și distribuție geografică \nDezavantaje: \n✓ Lipsa standardizării interogărilor \n✓ Unele implementări nu oferă suport pentru tranzacții complexe \n \n \n2.5. Compararea tipurilor de baze de date \n \nTip de bază de \ndate Structură Scalabilitate Flexibilitate Cazuri de utilizare \nIerarhică Arbore Redusă Scăzută Sistemele bancare vechi \nRețea Grafic Medie Medie Aplicații complexe \nRelațională Tabelară Scalabilitate \nlimitată Medie CRM, ERP, eCommerce \nNoSQL Diversă Mare Mare Big Data, IoT, social \nmedia \n \n \n3. Baze de date NoSQL \nBazele de date NoSQL sunt o categorie modernă de sisteme de gestionare a bazelor de date \ncare elimină limitările sistemelor relaționale pentru a permite o stocare și o interogare mai eficiente \na datelor nestructurate și semi-structurate. \n \n3.1. Utilizări comune \n✓ Big Data: MongoDB, Cassandra \n✓ Caching și sesiuni web: Redis, Memcached \n✓ Aplicații distribuite: DynamoDB, CouchDB \n✓ Rețele sociale și grafică de date: Neo4j, ArangoDB \n \n \n3.2. Avantajele bazelor de date NoSQL \n✓ Scalabilitate orizontală: Pot gestiona volume mari de date prin distribuire pe mai multe \nservere. \n✓ Flexibilitate: Nu impun o schemă strictă a datelor, ceea ce permite schimbări rapide. \n✓ Performanță ridicată: Se adaptează bine la cerințele aplicațiilor moderne, unde latența \nredusă este esențială. \n \n1.3.3 Dezavantajele bazelor de date NoSQL \n✓ Lipsa unui standard unificat:  Fiecare sistem are propriul model de interogare și \nadministrare. \n✓ Consistența datelor:  Majoritatea bazelor NoSQL sacrifică consistența în favoarea \ndisponibilității și performanței (modelul CAP). \n \n \n ', '7 \n \n✓ Flexibilitate în modelarea datelor \n✓ Performanță ridicată pentru date mari și distribuție geografică \nDezavantaje: \n✓ Lipsa standardizării interogărilor \n✓ Unele implementări nu oferă suport pentru tranzacții complexe \n \n \n2.5. Compararea tipurilor de baze de date \n \nTip de bază de \ndate Structură Scalabilitate Flexibilitate Cazuri de utilizare \nIerarhică Arbore Redusă Scăzută Sistemele bancare vechi \nRețea Grafic Medie Medie Aplicații complexe \nRelațională Tabelară Scalabilitate \nlimitată Medie CRM, ERP, eCommerce \nNoSQL Diversă Mare Mare Big Data, IoT, social \nmedia \n \n \n3. Baze de date NoSQL \nBazele de date NoSQL sunt o categorie modernă de sisteme de gestionare a bazelor de date \ncare elimină limitările sistemelor relaționale pentru a permite o stocare și o interogare mai eficiente \na datelor nestructurate și semi-structurate. \n \n3.1. Utilizări comune \n✓ Big Data: MongoDB, Cassandra \n✓ Caching și sesiuni web: Redis, Memcached \n✓ Aplicații distribuite: DynamoDB, CouchDB \n✓ Rețele sociale și grafică de date: Neo4j, ArangoDB \n \n \n3.2. Avantajele bazelor de date NoSQL \n✓ Scalabilitate orizontală: Pot gestiona volume mari de date prin distribuire pe mai multe \nservere. \n✓ Flexibilitate: Nu impun o schemă strictă a datelor, ceea ce permite schimbări rapide. \n✓ Performanță ridicată: Se adaptează bine la cerințele aplicațiilor moderne, unde latența \nredusă este esențială. \n \n1.3.3 Dezavantajele bazelor de date NoSQL \n✓ Lipsa unui standard unificat:  Fiecare sistem are propriul model de interogare și \nadministrare. \n✓ Consistența datelor:  Majoritatea bazelor NoSQL sacrifică consistența în favoarea \ndisponibilității și performanței (modelul CAP). \n \n \n ', 'copyright@www.adrian.runceanu.ro\ntt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/', 'copyright@www.adrian.runceanu.ro\ntt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/', 'copyright@www.adrian.runceanu.ro\nConţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\nCurs - Baze de date\n 14\n']","Principalele provocări ale utilizării bazelor de date NoSQL într-un sistem distribuit includ:

* **Lipsa unui standard unificat:** Fiecare sistem NoSQL are propriul model de interogare și administrare. Această lipsă de standardizare poate face dificilă migrarea datelor între diferite sisteme NoSQL și poate necesita o curbă de învățare abruptă pentru dezvoltatori. 
* **Consistența datelor:** Majoritatea bazelor de date NoSQL sacrifică consistența în favoarea disponibilității și performanței (modelul CAP). Aceasta înseamnă că, în anumite situații, este posibil ca datele să nu fie consistente pe toate nodurile unui sistem distribuit. 

Deși contextul menționează scalabilitatea ca un avantaj al bazelor de date NoSQL,  gestionarea consistenței și a integrității datelor  în sistemele distribuite poate deveni o provocare semnificativă. 
",Nu am gasit informatii in curs despre intrebarea ta,0.99999999995,0.0,0.9293348481346865,0.5714285714285714,0.0,0.015037593984962405,0.0
