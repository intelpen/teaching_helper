,user_input,retrieved_contexts,response,reference,context_precision,context_recall,answer_relevancy,faithfulness,bleu_score,rouge_score,factual_correctness
0,Ce este SQL?,"['operaţiile ce urmează.  \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă.  \nCurs 5 - BAZE DE DATE 50', 'copyright@www.adrian.runceanu.ro \nFuncţii \n  O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null.  \n  Singurele funcţii care nu respectă această regulă \nsunt:  \n– CONCAT', 'copyright@www.adrian.runceanu.ro \nFuncţii \n  O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null.  \n  Singurele funcţii care nu respectă această regulă \nsunt:  \n– CONCAT', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.1. Funcţii \n4.2. Funcţii referitoare la o singură înregistrare \n \nCurs 4 - BAZE DE DATE 3']","Contextul furnizat nu conține o definiție a SQL. 
",SQL este un limbaj de interogare a bazelor de date.,0.0,1.0,0.0,1.0,0.04513617516969122,0.10000000000000002,0.0
1,Care este sintaxa de bază a unei interogări SELECT?,"['copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.', 'copyright@www.adrian.runceanu.ro \nFuncţii referitoare la o singură înregistrare \nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în: \n \na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule, \netc.', 'copyright@www.adrian.runceanu.ro \nConcluzii \n1. O subinterogare este o instructiune SELECT \ninclusa într-o clauza a altei instructiuni SQL.  \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute. \n3. Subinterogarile au urmatoarele caracteristici:', '• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', 'operaţiile ce urmează.  \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă.  \nCurs 5 - BAZE DE DATE 50', 'copyright@www.adrian.runceanu.ro \n6. SUBQUERIES (Subinterogari) \n\uf0d8Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale. \n \n\uf0d8Un subquery nu poate avea propria clauză ORDER BY.', 'copyright@www.adrian.runceanu.ro \n6. SUBQUERIES (Subinterogari) \n  În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem. \n \n\uf0d8O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte', 'De asemenea se pot face interogări din \ntabele diferite. \nCurs 6 - BAZE DE DATE 13', 'copyright@www.adrian.runceanu.ro \n6.1. SINGLE ROW SUBQUERIES \n• Subinterogările pot fi plasate şi în clauza HAVING.  \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup. \nCurs 6 - BAZE DE DATE 22', 'În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii. \n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT. \nCurs - Baze de date 5']","Contextul furnizat nu oferă informații specifice despre sintaxa de bază a unei interogări SELECT. 
",SELECT [DISTINCT] lista_de_expresii FROM nume_tabela WHERE conditie_linie ORDER BY criterii_sortare_rezultat;,,0.0,0.0,,0.015392876926132885,0.0625,0.0
2,Ce face clauza WHERE într-o interogare SQL?,"['operaţiile ce urmează.  \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă.  \nCurs 5 - BAZE DE DATE 50', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă \n \n3.1. SELECT. Sintaxa. Efect. Rezultat \n3.2. Lista SELECT \n3.3. Clauza WHERE \n3.4. Clauza ORDER BY \nCurs - Baze de date 3', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \n \nCereri SELECT pe o tabelă \n \n3.1. SELECT. Sintaxa. Efect. Rezultat \n3.2. Lista SELECT \n3.3. Clauza WHERE \n3.4. Clauza ORDER BY \nCurs - Baze de date 20', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \n \nCereri SELECT pe o tabelă \n \n3.1. SELECT. Sintaxa. Efect. Rezultat \n3.2. Lista SELECT \n3.3. Clauza WHERE \n3.4. Clauza ORDER BY \nCurs - Baze de date 69', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \n \nCereri SELECT pe o tabelă \n \n3.1. SELECT. Sintaxa. Efect. Rezultat \n3.2. Lista SELECT \n3.3. Clauza WHERE \n3.4. Clauza ORDER BY \nCurs - Baze de date 9', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.1. Funcţii \n4.2. Funcţii referitoare la o singură înregistrare \n \nCurs 4 - BAZE DE DATE 3', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră']","Clauza WHERE în SQL este folosită pentru a filtra datele din tabelă. Aceasta specifică condițiile care trebuie îndeplinite de datele din tabelă pentru a fi incluse în rezultatul interogării. 
",Clauza WHERE restricționează rândurile returnate la cele care îndeplinesc condiția specificată.,0.0,0.0,0.8397988256941692,1.0,0.06772997136689071,0.13333333333333333,1.0
3,Care este efectul utilizării DISTINCT într-o interogare?,"['• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.', 'rezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela. \nCurs - Baze de date 7', 'exterioară va returna liniile care se potrivesc cu valorile \nnon-null. \n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic. \nCurs 6 - BAZE DE DATE 35', 'copyright@www.adrian.runceanu.ro \nExercitii \nSe considera tabela EMP avand urmatoarea structura: \n \n \n \n \nsi avand urmatoarele valori introduse:  \nCurs - Baze de date 82', '\uf0d8Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare. \n \n\uf0d8Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic. \nCurs 6 - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro \nREZULTAT \n  Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT.  \n  Aceste expresii dau si numele coloanelor din \nrezultat. \n  În lipsa clauzei DISTINCT, numarul de linii din', 'copyright@www.adrian.runceanu.ro \n Operatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare. \n \nAstfel,  \n < ANY inseamna mai mic decat maximul  \n ANY inseamna mai mare decat minimul \n = ANY este echivalent cu IN \nCurs 6 - BAZE DE DATE 49', 'este egala cu valoarei_1, atunci va returna valoarei_2. \nDaca nici una din valorile valoare1_1, valoare2_1, …, \nvaloaren_1 nu este egala cu expresie, atunci va \nreturna valoare. \nCurs 4 - BAZE DE DATE 107', 'copyright@www.adrian.runceanu.ro \nValori de NULL intr-o subinterogare  \n \n• In cazul in care subinterogarea returneaza \nvreuna din valori NULL si interogarea \nprincipala are operator NOT IN, atunci \ninterogarea principala nu va returna niciun \nrand.']","Contextul furnizat nu oferă informații despre efectul utilizării DISTINCT într-o interogare. 
",DISTINCT elimină rândurile duplicat din rezultatul interogării.,0.0,0.0,0.0,,0.03747776736677921,0.08695652173913043,0.0
4,Ce face clauza ORDER BY?,"['copyright@www.adrian.runceanu.ro \nEFECT \n  Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat. \n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY. \n  În cazul în care ORDER BY lipseste, liniile din', 'copyright@www.adrian.runceanu.ro \nClauza ORDER BY \n\uf0d8 Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare, salariu şi comision (în ordine crescătoare).  \nCurs - Baze de date 79', 'copyright@www.adrian.runceanu.ro \nClauza ORDER BY \n\uf0d8În clauza ORDER BY se pot folosi coloane care nu sunt \nconţinute în SELECT. \n  \nExemplu:  \n  Listaţi toţi angajaţii ordonându-i după salariu (în \nordine crescătoare). \n \nSELECT ename, job \nFROM EMP \nORDER BY sal;   \nCurs - Baze de date 80', 'ORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii. \nCurs - Baze de date 8', 'b) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile)  \n \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare \nCurs 4 - BAZE DE DATE 14', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \n \nCereri SELECT pe o tabelă \n \n3.1. SELECT. Sintaxa. Efect. Rezultat \n3.2. Lista SELECT \n3.3. Clauza WHERE \n3.4. Clauza ORDER BY \nCurs - Baze de date 69', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \n \nCereri SELECT pe o tabelă \n \n3.1. SELECT. Sintaxa. Efect. Rezultat \n3.2. Lista SELECT \n3.3. Clauza WHERE \n3.4. Clauza ORDER BY \nCurs - Baze de date 20', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \n \nCereri SELECT pe o tabelă \n \n3.1. SELECT. Sintaxa. Efect. Rezultat \n3.2. Lista SELECT \n3.3. Clauza WHERE \n3.4. Clauza ORDER BY \nCurs - Baze de date 9', 'copyright@www.adrian.runceanu.ro \n6. SUBQUERIES (Subinterogari) \n\uf0d8Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale. \n \n\uf0d8Un subquery nu poate avea propria clauză ORDER BY.', 'copyright@www.adrian.runceanu.ro \nClauza ORDER BY \n\uf0d8 Rândurile mai pot fi ordonate şi după mai multe coloane.  \n\uf0d8 Numărul de coloane după care se pot ordona rândurile \nîntoarse este numărul maxim de coloane existente în tabelă.  \nExemplu  \n Listaţi toţi angajaţii ordonându-i după data de angajare,']","Clauza `ORDER BY` este folosită pentru a sorta rezultatele unei interogări SQL în funcție de una sau mai multe coloane. 
",Clauza ORDER BY sortează rezultatele în funcție de coloanele specificate.,,,0.8538957069831764,1.0,0.0879409052211872,0.4848484848484849,1.0
5,Ce este o funcție în SQL?,"['copyright@www.adrian.runceanu.ro \nFuncţii \n  O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null.  \n  Singurele funcţii care nu respectă această regulă \nsunt:  \n– CONCAT', 'copyright@www.adrian.runceanu.ro \nFuncţii \n  O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null.  \n  Singurele funcţii care nu respectă această regulă \nsunt:  \n– CONCAT', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră', 'operaţiile ce urmează.  \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă.  \nCurs 5 - BAZE DE DATE 50', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.1. Funcţii \n4.2. Funcţii referitoare la o singură înregistrare \n \nCurs 4 - BAZE DE DATE 3']","Funcțiile în SQL sunt operații predefinite care efectuează anumite calcule sau manipulează date. Ele pot fi folosite pentru a efectua o varietate de sarcini, cum ar fi:

* **Conversia datelor:** Funcții precum `CAST` și `CONVERT` pot fi folosite pentru a converti un tip de date într-un altul.
* **Calcularea valorilor:** Funcții precum `SUM`, `AVG`, `MAX` și `MIN` pot fi folosite pentru a calcula valorile agregate pentru un set de date.
* **Manipularea șirurilor de caractere:** Funcții precum `LEN`, `SUBSTRING`, `REPLACE` și `UPPER` pot fi folosite pentru a manipula șiruri de caractere.
* **Manipularea datelor calendaristice și a orelor:** Funcții precum `DATEADD`, `DATEDIFF`, `GETDATE` și `CONVERT` pot fi folosite pentru a lucra cu date calendaristice și cu ore.

Este important de menționat că, de obicei, dacă o funcție SQL primește un argument `NULL`, rezultatul va fi și el `NULL`. Există însă și funcții care nu se supun acestei reguli, cum ar fi funcția `CONCAT`.

Pentru a afla mai multe despre funcțiile SQL, puteți consulta documentația specifică pentru motorul dumneavoastră de baze de date.
","Funcțiile sunt utilizate pentru a realiza calcule asupra datelor, a modifica date și a manipula grupuri de înregistrări.",,,0.843338736225366,,0.02549704254217688,0.1182266009852217,
6,Ce tipuri de funcții există în SQL?,"['copyright@www.adrian.runceanu.ro \nFuncţii \n  O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null.  \n  Singurele funcţii care nu respectă această regulă \nsunt:  \n– CONCAT', 'copyright@www.adrian.runceanu.ro \nFuncţii \n  O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null.  \n  Singurele funcţii care nu respectă această regulă \nsunt:  \n– CONCAT', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră', 'copyright@www.adrian.runceanu.ro \nLimbajul SQL \nInterogări SELECT pe o singură tabelă (partea II) \n \n4.2. Funcţii referitoare la o singură înregistrare \n 4.2.1. Funcţii pentru şiruri de caractere \n 4.2.2. Funcţii de tip numeric \n 4.2.3. Funcţii de tip dată calendaristică şi oră', 'copyright@www.adrian.runceanu.ro \nFuncţii \n  Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru: \n \n\uf0fca realiza calcule asupra datelor \n\uf0fca modifica date \n\uf0fca manipula grupuri de înregistrări  \n\uf0fca schimba formatul datelor  \n\uf0fcsau pentru a converti diferite tipuri de date', 'copyright@www.adrian.runceanu.ro \n4.2.5. Funcţii generale \n\uf0d8SGBD-ul ORACLE pune la dispozitia \nprogramatorilor, in cadrul limbajului SQL, o \nfunctie si o expresie conditionala.  \n \n\uf0d8Acestea sunt alternative foarte bune la \nstructurile de tip IF-THEN-ELSE.  \n\uf0d8Functia se numeste DECODE, iar expresia']","Conform contextului furnizat, în SQL există mai multe tipuri de funcții, inclusiv:

* **Funcții pentru şiruri de caractere**
* **Funcții de tip numeric**
* **Funcții de tip dată calendaristică şi oră**
* **Funcții generale** (exemplu: DECODE) 

De asemenea, contextul menționează că funcțiile SQL pot fi folosite pentru:

* **A realiza calcule asupra datelor**
* **A modifica date**
* **A manipula grupuri de înregistrări**
* **A schimba formatul datelor**
* **A converti diferite tipuri de date**

Pentru a obține informații mai detaliate despre tipurile de funcții și exemple concrete de utilizare, te sfătuiesc să cauți resurse dedicate limbajului SQL.
",Există funcții pentru o singură înregistrare și funcții pentru mai multe înregistrări (funcții de grup).,0.0,,0.0,,0.007766427959130701,0.21487603305785125,0.29
7,Care sunt principalele funcții pentru șiruri de caractere?,"['4.2.1. Funcţii pentru şiruri de caractere', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.', 'copyright@www.adrian.runceanu.ro \n\uf0d8Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime.  \n\uf0d8Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior.  \n \n\uf0d8Pentru a determina, de exemplu, de câte ori', 'copyright@www.adrian.runceanu.ro \nRezultat obtinut:  \n \nCurs 4 - BAZE DE DATE 23 \n4.2.1. Funcţii pentru şiruri de caractere', '• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare.  \nCurs 6 - BAZE DE DATE 56', ""înlocui cu primul caracter (adică tot cu caracterul 'D') din cel de-al \ntreilea argument al funcţiei (şirul de caractere 'D'), apoi va căuta \ncel de-al doilea caracter, adică caracterul 'A', şi îl va şterge din \ncâmpul nume deoarece acesta nu are caracter corespondent în"", '4. Listaţi toţi angajaţii care nu au manager.  \nCurs - Baze de date 83', 'copyright@www.adrian.runceanu.ro \nRezultat obtinut:  \nCurs 4 - BAZE DE DATE 21 \n4.2.1. Funcţii pentru şiruri de caractere', 'copyright@www.adrian.runceanu.ro \nRezultatul obtinut: \nCurs 4 - BAZE DE DATE 25 \n4.2.1. Funcţii pentru şiruri de caractere', 'copyright@www.adrian.runceanu.ro \nRezultatul obtinut: \nCurs 4 - BAZE DE DATE 27 \n4.2.1. Funcţii pentru şiruri de caractere']","Din păcate, contextul furnizat nu oferă informații specifice despre principalele funcții pentru șiruri de caractere. Contextul se concentrează pe subiecte legate de baze de date, subinterogări corelate și funcții imbricate, dar nu oferă o listă de funcții pentru șiruri de caractere. 
","LOWER, UPPER, INITCAP, CONCAT, SUBSTR, LENGTH, INSTR, REPLACE.",0.0,0.0,0.0,1.0,0.024455939372403628,0.0,0.0
8,Ce face funcția LENGTH?,"['copyright@www.adrian.runceanu.ro \nExemplu de utilizare a \nfuncţiei LENGTH: \n \n \nSELECT LENGTH(ename)  \nFROM EMP;  \nCurs 4 - BAZE DE DATE 18 \n4.2.1. Funcţii pentru şiruri de caractere', 'copyright@www.adrian.runceanu.ro \nExemplu de utilizare a funcţiei LENGTH – rezultatul \nobtinut:  \nCurs 4 - BAZE DE DATE 19 \n4.2.1. Funcţii pentru şiruri de caractere', 'copyright@www.adrian.runceanu.ro \n4.3. Funcții de grup \nExemplul 7 - Comisionul mediu în departamentul 30 \n(ignorând sau nu valorile nule):  \nSELECT AVG(comm), AVG(NVL(comm, 0)) \nFROM EMP \nWHERE deptno = 30; \nCurs 5 - BAZE DE DATE 29', ""copyright@www.adrian.runceanu.ro \nSELECT ename, LENGTH (ename) - LENGTH (TRANSLATE(ename, 'DA', \n'D'))  \nFROM EMP; \nCurs 4 - BAZE DE DATE 29 \n4.2.1. Funcţii pentru şiruri de caractere"", 'copyright@www.adrian.runceanu.ro \nLISTA SELECT \n Alias de coloana: \n  Nu poate fi mai lung de 30 de caractere. \n  Începe cu o litera, contine numai litere, cifre, _, # si \n$ sau e pus intre ghilimele (tot max. 30 caractere intre \nghilimele).', 'copyright@www.adrian.runceanu.ro \n4.3.2. Excluderea grupurilor  \n(clauza HAVING) \nRezultatul obtinut - Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$.  \nCurs 5 - BAZE DE DATE 43', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n 3. LIKE  \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere.  \n \n  Operaţia de căutare după un model poate fi asemănată', 'copyright@www.adrian.runceanu.ro \n4.3.1. Clauza GROUP BY \nRezultatul obtinut - Salariul mediu pe fiecare departament, iar \nrezultatele ordonate după salariul mediu pe departament.  \nCurs 5 - BAZE DE DATE 36', 'copyright@www.adrian.runceanu.ro \n4.3.1. Clauza GROUP BY \nRezultatul obtinut - Salariul total pe fiecare departament si pe \nfiecare functie, iar rezultatele ordonate după salariul mediu pe \ndepartament.  \n \nCurs 5 - BAZE DE DATE 39', 'copyright@www.adrian.runceanu.ro \nExemplu: \n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER. \n \nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename) \nFROM EMP;  \nCurs 4 - BAZE DE DATE 26 \n4.2.1. Funcţii pentru şiruri de caractere']","Funcția LENGTH în SQL returnează lungimea unui șir de caractere. De exemplu, LENGTH('Ana') va returna 3, deoarece șirul 'Ana' are 3 caractere.
",Funcția LENGTH returnează numărul de caractere dintr-un șir de caractere.,0.9999999999,0.0,0.8404120381339188,0.3333333333333333,0.1860045401920258,0.43243243243243246,1.0
9,Cum se utilizează funcția CONCAT?,"['copyright@www.adrian.runceanu.ro \nFuncţii referitoare la o singură înregistrare \nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în: \n \na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule, \netc.', ""copyright@www.adrian.runceanu.ro \nLISTA SELECT \nExpresii concatenate: \n \nExemplu 5: \nSELECT 'Specializarea '|| NUME ||' are codul ', CODS \nFROM SPECIALIZARE; \n \n \nExemplu 6: \nCu valori nule: \nSELECT TIP , ' are valoarea ' || SUMA || '.Lei' \nFROM BURSA; \nCurs - Baze de date 16"", 'copyright@www.adrian.runceanu.ro \nFuncţii \nFuncţiile se pot clasifica în două categorii: \n \n1. Funcţii referitoare la o singură înregistrare \n(single-row functions) \n \n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions) \nCurs 4 - BAZE DE DATE 8', ""cel de-al treilea argument al funcţiei.  \n  Am folosit acest artificiu deoarece şirul de caractere vid este \nechivalent cu valoarea Null, deci funcţia TRANSLATE (nume, 'A', ' \n') ar fi înlocuit toate valorile câmpului “nume” cu valoarea Null. \nCurs 4 - BAZE DE DATE 31"", 'copyright@www.adrian.runceanu.ro \nFuncţii \nFuncţiile se clasifică în două tipuri: \n \n1. Funcţii referitoare la o singură înregistrare \n(single-row functions) \n \n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions) \nCurs 5 - BAZE DE DATE 8', 'copyright@www.adrian.runceanu.ro \nClauza WHERE \n  Clauza WHERE poate compara valori în coloană, \nvalori literale, expresii aritmetice sau funcţii. \nWHERE - restricţionează cererea la rândurile care \nîndeplinesc o condiţie; \n \nCondiţie este alcătuită din trei elemente: \n1. Un nume de coloană', 'Al doilea argument poate fi o valoare negativă, rotunjirea \nfăcându-se la stânga punctului zecimal.  \nCifra a |b|+1 din faţa punctului zecimal (numărând de la punctul \nzecimal spre stânga începând cu 1) va fi rotunjită în funcţie \ncifra aflată imediat la dreapta ei.', 'copyright@www.adrian.runceanu.ro \nSubcereri corelate  \n \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.', 'INITCAP(column|expression) \nconverteste prima litera a fiecarui cuvant in \ncaractere mari si restul cuvantului in caractere \nmici  \nCONCAT(column1|expression1, \ncolumn2|expression2) \nfunctia este echivalentul operatorului de \nconcantenare (||)', 'copyright@www.adrian.runceanu.ro \nFuncţii \n  O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null.  \n  Singurele funcţii care nu respectă această regulă \nsunt:  \n– CONCAT']","Funcția CONCAT este echivalentul operatorului de concatenare (||). Aceasta se folosește pentru a uni două coloane sau expresii. De exemplu:

```sql
SELECT CONCAT(column1, column2) FROM table;
```

Acest cod va uni conținutul coloanei `column1` cu conținutul coloanei `column2` pentru fiecare rând din tabelul `table`.
",Funcția CONCAT concatenează două sau mai multe șiruri de caractere într-unul singur.,0.11111111109999999,0.0,0.8694496937668549,0.6666666666666666,0.06916141792551135,0.19354838709677416,0.8
