,initial_Generator,initial_Dificultate,initial_Capitole Principale,initial_Capitole Asociate,initial_user_input,initial_reference,initial_Evaluare Professor,initial_Unde se afla raspunsul,initial_retrieved_contexts,initial_response,user_input,retrieved_contexts,response,reference,context_precision,context_recall,answer_relevancy,faithfulness,bleu_score,rouge_score,factual_correctness
0,O3mini-high,LOW,C1,,"În contextul noțiunilor introductive, ce model de organizare a datelor este prezentat ca predominant în curs?",relațional,Este corect,,"['1. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '2. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '3. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '4. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '5. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '6. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '7. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '8. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '9. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '10. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n']","modelul relațional este abordarea predominantă pentru organizarea datelor, bazată pe tabele (relații). Fiecare tabel conține atribute și înregistrări, iar relațiile sunt definite prin chei primare și chei străine.
","În contextul noțiunilor introductive, ce model de organizare a datelor este prezentat ca predominant în curs?","['1. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '2. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '3. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '4. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '5. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '6. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '7. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '8. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '9. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '10. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n']","modelul relațional este abordarea predominantă pentru organizarea datelor, bazată pe tabele (relații). Fiecare tabel conține atribute și înregistrări, iar relațiile sunt definite prin chei primare și chei străine.
",relațional,0.3532327586118588,1.0,0.844411229158817,0.75,0.02627961710408444,0.1111111111111111,0.0
1,O3mini-high,LOW,C2,,Ce limbaj integrat în Oracle este utilizat pentru scrierea procedurilor stocate?,PL/SQL,Este corect,,"['1. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '2. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '3. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '4. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n', '5. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n', '6. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n', '7. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nOracle 9i REAL APPLICATION CLUSTERS (RAC) se bazează pe \no nouă arhitectură de BD numită îmbinare ascunsă (Cache \nFusion). \n✓Aceasta este o nouă generaţie de tehnologie de clustere. \n✓Conform acestei arhitecturi la adăugarea unui calculator \nîntr-o reţea cu BD Oracle, clusterele se adaptează automat \nla noile resurse, fără să fie necesară redistribuirea datelor \nsau rescrierea aplicaţiei.\n✓Posibilitatea apariţiei unei erori la o configuraţie cu 12 \ncalculatoare sub Oracle 9i RAC este foarte mică, estimată \nca durată în timp la cca 100.000 de ani. \n17\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oracle 9i DEVELOPER SUITE este un mediu \ncomplet pentru dezvoltarea aplicaţiilor tip \nafaceri electronice (e-business) şi tip Web. \nEl se bazează pe tehnologiile Java şi XML şi permite \npersonalizarea (Oracle Personalization). \n• În anul 2003 a fost lansată versiunea Oracle 10g \ncare adaugă noi facilităţi sistemului Oracle 9i. \n19\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În anul 2007 a fost lansată versiunea Oracle \n11g care are cateva facilitati in plus:\n– Gestioneaza datele mai eficient prin compresii \navansate si partitionari \n– Simplifica sistemele prin stocarea tuturor datelor in \nOracle Database cu Oracle SecureFiles\n• În anul 2013 a fost lansată versiunea Oracle \n12c\n20\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle Database 12c prezintă o arhitectură nouă, cu \nmai multe entităţi găzduite, care permite unificarea \nrapidă a mai multor baze de date şi gestionarea \nacestora ca serviciu cloud. \n➢Oracle Database 12c include, de asemenea, capacităţi \nde procesare a datelor în memorie, care oferă o \nperformanţă analitică inovatoare. \n➢Inovaţiile suplimentare pentru baze de date oferă noi \nnivele de eficienţă, performanţă, securitate şi \ndisponibilitate.[*]\n21[*] https://www.oracle.com/ro/database/index.html\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', '\n', '8. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nOracle 9i REAL APPLICATION CLUSTERS (RAC) se bazează pe \no nouă arhitectură de BD numită îmbinare ascunsă (Cache \nFusion). \n✓Aceasta este o nouă generaţie de tehnologie de clustere. \n✓Conform acestei arhitecturi la adăugarea unui calculator \nîntr-o reţea cu BD Oracle, clusterele se adaptează automat \nla noile resurse, fără să fie necesară redistribuirea datelor \nsau rescrierea aplicaţiei.\n✓Posibilitatea apariţiei unei erori la o configuraţie cu 12 \ncalculatoare sub Oracle 9i RAC este foarte mică, estimată \nca durată în timp la cca 100.000 de ani. \n17\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oracle 9i DEVELOPER SUITE este un mediu \ncomplet pentru dezvoltarea aplicaţiilor tip \nafaceri electronice (e-business) şi tip Web. \nEl se bazează pe tehnologiile Java şi XML şi permite \npersonalizarea (Oracle Personalization). \n• În anul 2003 a fost lansată versiunea Oracle 10g \ncare adaugă noi facilităţi sistemului Oracle 9i. \n19\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În anul 2007 a fost lansată versiunea Oracle \n11g care are cateva facilitati in plus:\n– Gestioneaza datele mai eficient prin compresii \navansate si partitionari \n– Simplifica sistemele prin stocarea tuturor datelor in \nOracle Database cu Oracle SecureFiles\n• În anul 2013 a fost lansată versiunea Oracle \n12c\n20\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle Database 12c prezintă o arhitectură nouă, cu \nmai multe entităţi găzduite, care permite unificarea \nrapidă a mai multor baze de date şi gestionarea \nacestora ca serviciu cloud. \n➢Oracle Database 12c include, de asemenea, capacităţi \nde procesare a datelor în memorie, care oferă o \nperformanţă analitică inovatoare. \n➢Inovaţiile suplimentare pentru baze de date oferă noi \nnivele de eficienţă, performanţă, securitate şi \ndisponibilitate.[*]\n21[*] https://www.oracle.com/ro/database/index.html\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', '\n', '9. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nOracle 9i REAL APPLICATION CLUSTERS (RAC) se bazează pe \no nouă arhitectură de BD numită îmbinare ascunsă (Cache \nFusion). \n✓Aceasta este o nouă generaţie de tehnologie de clustere. \n✓Conform acestei arhitecturi la adăugarea unui calculator \nîntr-o reţea cu BD Oracle, clusterele se adaptează automat \nla noile resurse, fără să fie necesară redistribuirea datelor \nsau rescrierea aplicaţiei.\n✓Posibilitatea apariţiei unei erori la o configuraţie cu 12 \ncalculatoare sub Oracle 9i RAC este foarte mică, estimată \nca durată în timp la cca 100.000 de ani. \n17\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oracle 9i DEVELOPER SUITE este un mediu \ncomplet pentru dezvoltarea aplicaţiilor tip \nafaceri electronice (e-business) şi tip Web. \nEl se bazează pe tehnologiile Java şi XML şi permite \npersonalizarea (Oracle Personalization). \n• În anul 2003 a fost lansată versiunea Oracle 10g \ncare adaugă noi facilităţi sistemului Oracle 9i. \n19\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În anul 2007 a fost lansată versiunea Oracle \n11g care are cateva facilitati in plus:\n– Gestioneaza datele mai eficient prin compresii \navansate si partitionari \n– Simplifica sistemele prin stocarea tuturor datelor in \nOracle Database cu Oracle SecureFiles\n• În anul 2013 a fost lansată versiunea Oracle \n12c\n20\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle Database 12c prezintă o arhitectură nouă, cu \nmai multe entităţi găzduite, care permite unificarea \nrapidă a mai multor baze de date şi gestionarea \nacestora ca serviciu cloud. \n➢Oracle Database 12c include, de asemenea, capacităţi \nde procesare a datelor în memorie, care oferă o \nperformanţă analitică inovatoare. \n➢Inovaţiile suplimentare pentru baze de date oferă noi \nnivele de eficienţă, performanţă, securitate şi \ndisponibilitate.[*]\n21[*] https://www.oracle.com/ro/database/index.html\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', '\n', '10. ', '2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43\n\n2.4. ORACLE Database 11g Expres Edition\nInstalarea aplicatiei\n 44\n\n2.4. ORACLE Database 11g Expres Edition\nPagina principala a aplicatiei Oracle Database 11g Express \nEdition\n45\n\nConcepte de bază din teoria relațională a \nbazelor de date\n46\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n➢Înainte de a începe să realizăm o aplicaţie cu \nbaze de date relaţionale trebuie să cunoaştem \nprincipalele concepte din teoria relaţională.\n➢Acestea sunt absolut necesare, atât pentru \nanaliza şi proiectarea bazei de date \nrelaţionale, cât şi pentru elaborarea \nprogramelor de aplicaţie într-un SGBD \nrelaţional ales.\n 47\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nPrezentăm în continuare aceste concepte:\n1. DOMENIUL reprezintă un ansamblu de valori, \ncaracterizat printr-un nume. \n➢Domeniul se poate definit explicit, prin \nenumerarea tuturor valorilor care aparţin \nacestuia, sau implicit, prin precizarea \nproprietăţilor pe care le au valorile domeniului \nrespectiv.\n 48\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n2. RELAŢIA (tabela) reprezintă un subansamblu al \nprodusului cartezian dintre mai multe domenii,\ncaracterizat printr-un nume.\n3. ATRIBUTUL este coloana unei relaţii \ncaracterizate printr-un nume. \n➢Fiecare atribut îşi ia valorile dintr-un domeniu. \n➢Mai multe atribute pot lua valori din acelaşi \ndomeniu.\n 49\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n4. TUPLUL este o linie dintr-o relaţie şi nu are \nnume. \nValorile dintr-un tuplu aparţin produsului \ncartezian dintre domeniile relaţiei.\n 50\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n5. SCHEMA RELAŢIEI este un ansamblu format \ndin numele relaţiei (R) urmat între paranteze \nrotunde de lista atributelor (Ai), pentru fiecare \natribut precizându-se domeniul asociat (Di):\nR (A1: D1, A2: D2, . . ., An: Dn ),\nunde n\uf0b3m sunt numere întregi.\n 51\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n6. CHEIA este un atribut sau un ansamblu de \natribute cu ajutorul căruia se poate identifica un \ntuplu dîntr-o relaţie.\n 52\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n➢Numim cheie primară (primary key) a unei \nrelaţii, un atribut (sau un grup de atribute) \ncare identifică fără ambiguitate fiecare linie a \nrelaţiei. \n➢Numim cheie straină (foreign key) a unei \nrelaţii un grup de atribute care pune în \nlegătură linii din două tabele (relaţii).\n 53', '\n']","limbajul procedural propriu integrat în Oracle pentru scrierea procedurilor stocate este PL/SQL.
",Ce limbaj integrat în Oracle este utilizat pentru scrierea procedurilor stocate?,"['1. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '2. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '3. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '4. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n', '5. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n', '6. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n', '7. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nOracle 9i REAL APPLICATION CLUSTERS (RAC) se bazează pe \no nouă arhitectură de BD numită îmbinare ascunsă (Cache \nFusion). \n✓Aceasta este o nouă generaţie de tehnologie de clustere. \n✓Conform acestei arhitecturi la adăugarea unui calculator \nîntr-o reţea cu BD Oracle, clusterele se adaptează automat \nla noile resurse, fără să fie necesară redistribuirea datelor \nsau rescrierea aplicaţiei.\n✓Posibilitatea apariţiei unei erori la o configuraţie cu 12 \ncalculatoare sub Oracle 9i RAC este foarte mică, estimată \nca durată în timp la cca 100.000 de ani. \n17\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oracle 9i DEVELOPER SUITE este un mediu \ncomplet pentru dezvoltarea aplicaţiilor tip \nafaceri electronice (e-business) şi tip Web. \nEl se bazează pe tehnologiile Java şi XML şi permite \npersonalizarea (Oracle Personalization). \n• În anul 2003 a fost lansată versiunea Oracle 10g \ncare adaugă noi facilităţi sistemului Oracle 9i. \n19\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În anul 2007 a fost lansată versiunea Oracle \n11g care are cateva facilitati in plus:\n– Gestioneaza datele mai eficient prin compresii \navansate si partitionari \n– Simplifica sistemele prin stocarea tuturor datelor in \nOracle Database cu Oracle SecureFiles\n• În anul 2013 a fost lansată versiunea Oracle \n12c\n20\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle Database 12c prezintă o arhitectură nouă, cu \nmai multe entităţi găzduite, care permite unificarea \nrapidă a mai multor baze de date şi gestionarea \nacestora ca serviciu cloud. \n➢Oracle Database 12c include, de asemenea, capacităţi \nde procesare a datelor în memorie, care oferă o \nperformanţă analitică inovatoare. \n➢Inovaţiile suplimentare pentru baze de date oferă noi \nnivele de eficienţă, performanţă, securitate şi \ndisponibilitate.[*]\n21[*] https://www.oracle.com/ro/database/index.html\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', '\n', '8. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nOracle 9i REAL APPLICATION CLUSTERS (RAC) se bazează pe \no nouă arhitectură de BD numită îmbinare ascunsă (Cache \nFusion). \n✓Aceasta este o nouă generaţie de tehnologie de clustere. \n✓Conform acestei arhitecturi la adăugarea unui calculator \nîntr-o reţea cu BD Oracle, clusterele se adaptează automat \nla noile resurse, fără să fie necesară redistribuirea datelor \nsau rescrierea aplicaţiei.\n✓Posibilitatea apariţiei unei erori la o configuraţie cu 12 \ncalculatoare sub Oracle 9i RAC este foarte mică, estimată \nca durată în timp la cca 100.000 de ani. \n17\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oracle 9i DEVELOPER SUITE este un mediu \ncomplet pentru dezvoltarea aplicaţiilor tip \nafaceri electronice (e-business) şi tip Web. \nEl se bazează pe tehnologiile Java şi XML şi permite \npersonalizarea (Oracle Personalization). \n• În anul 2003 a fost lansată versiunea Oracle 10g \ncare adaugă noi facilităţi sistemului Oracle 9i. \n19\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În anul 2007 a fost lansată versiunea Oracle \n11g care are cateva facilitati in plus:\n– Gestioneaza datele mai eficient prin compresii \navansate si partitionari \n– Simplifica sistemele prin stocarea tuturor datelor in \nOracle Database cu Oracle SecureFiles\n• În anul 2013 a fost lansată versiunea Oracle \n12c\n20\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle Database 12c prezintă o arhitectură nouă, cu \nmai multe entităţi găzduite, care permite unificarea \nrapidă a mai multor baze de date şi gestionarea \nacestora ca serviciu cloud. \n➢Oracle Database 12c include, de asemenea, capacităţi \nde procesare a datelor în memorie, care oferă o \nperformanţă analitică inovatoare. \n➢Inovaţiile suplimentare pentru baze de date oferă noi \nnivele de eficienţă, performanţă, securitate şi \ndisponibilitate.[*]\n21[*] https://www.oracle.com/ro/database/index.html\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', '\n', '9. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nOracle 9i REAL APPLICATION CLUSTERS (RAC) se bazează pe \no nouă arhitectură de BD numită îmbinare ascunsă (Cache \nFusion). \n✓Aceasta este o nouă generaţie de tehnologie de clustere. \n✓Conform acestei arhitecturi la adăugarea unui calculator \nîntr-o reţea cu BD Oracle, clusterele se adaptează automat \nla noile resurse, fără să fie necesară redistribuirea datelor \nsau rescrierea aplicaţiei.\n✓Posibilitatea apariţiei unei erori la o configuraţie cu 12 \ncalculatoare sub Oracle 9i RAC este foarte mică, estimată \nca durată în timp la cca 100.000 de ani. \n17\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oracle 9i DEVELOPER SUITE este un mediu \ncomplet pentru dezvoltarea aplicaţiilor tip \nafaceri electronice (e-business) şi tip Web. \nEl se bazează pe tehnologiile Java şi XML şi permite \npersonalizarea (Oracle Personalization). \n• În anul 2003 a fost lansată versiunea Oracle 10g \ncare adaugă noi facilităţi sistemului Oracle 9i. \n19\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În anul 2007 a fost lansată versiunea Oracle \n11g care are cateva facilitati in plus:\n– Gestioneaza datele mai eficient prin compresii \navansate si partitionari \n– Simplifica sistemele prin stocarea tuturor datelor in \nOracle Database cu Oracle SecureFiles\n• În anul 2013 a fost lansată versiunea Oracle \n12c\n20\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle Database 12c prezintă o arhitectură nouă, cu \nmai multe entităţi găzduite, care permite unificarea \nrapidă a mai multor baze de date şi gestionarea \nacestora ca serviciu cloud. \n➢Oracle Database 12c include, de asemenea, capacităţi \nde procesare a datelor în memorie, care oferă o \nperformanţă analitică inovatoare. \n➢Inovaţiile suplimentare pentru baze de date oferă noi \nnivele de eficienţă, performanţă, securitate şi \ndisponibilitate.[*]\n21[*] https://www.oracle.com/ro/database/index.html\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', '\n', '10. ', '2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43\n\n2.4. ORACLE Database 11g Expres Edition\nInstalarea aplicatiei\n 44\n\n2.4. ORACLE Database 11g Expres Edition\nPagina principala a aplicatiei Oracle Database 11g Express \nEdition\n45\n\nConcepte de bază din teoria relațională a \nbazelor de date\n46\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n➢Înainte de a începe să realizăm o aplicaţie cu \nbaze de date relaţionale trebuie să cunoaştem \nprincipalele concepte din teoria relaţională.\n➢Acestea sunt absolut necesare, atât pentru \nanaliza şi proiectarea bazei de date \nrelaţionale, cât şi pentru elaborarea \nprogramelor de aplicaţie într-un SGBD \nrelaţional ales.\n 47\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nPrezentăm în continuare aceste concepte:\n1. DOMENIUL reprezintă un ansamblu de valori, \ncaracterizat printr-un nume. \n➢Domeniul se poate definit explicit, prin \nenumerarea tuturor valorilor care aparţin \nacestuia, sau implicit, prin precizarea \nproprietăţilor pe care le au valorile domeniului \nrespectiv.\n 48\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n2. RELAŢIA (tabela) reprezintă un subansamblu al \nprodusului cartezian dintre mai multe domenii,\ncaracterizat printr-un nume.\n3. ATRIBUTUL este coloana unei relaţii \ncaracterizate printr-un nume. \n➢Fiecare atribut îşi ia valorile dintr-un domeniu. \n➢Mai multe atribute pot lua valori din acelaşi \ndomeniu.\n 49\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n4. TUPLUL este o linie dintr-o relaţie şi nu are \nnume. \nValorile dintr-un tuplu aparţin produsului \ncartezian dintre domeniile relaţiei.\n 50\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n5. SCHEMA RELAŢIEI este un ansamblu format \ndin numele relaţiei (R) urmat între paranteze \nrotunde de lista atributelor (Ai), pentru fiecare \natribut precizându-se domeniul asociat (Di):\nR (A1: D1, A2: D2, . . ., An: Dn ),\nunde n\uf0b3m sunt numere întregi.\n 51\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n6. CHEIA este un atribut sau un ansamblu de \natribute cu ajutorul căruia se poate identifica un \ntuplu dîntr-o relaţie.\n 52\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n➢Numim cheie primară (primary key) a unei \nrelaţii, un atribut (sau un grup de atribute) \ncare identifică fără ambiguitate fiecare linie a \nrelaţiei. \n➢Numim cheie straină (foreign key) a unei \nrelaţii un grup de atribute care pune în \nlegătură linii din două tabele (relaţii).\n 53', '\n']","limbajul procedural propriu integrat în Oracle pentru scrierea procedurilor stocate este PL/SQL.
",PL/SQL,0.39145339953511066,1.0,0.8873698153002886,1.0,0.0978237574896145,0.2666666666666667,0.0
2,O3mini-high,LOW,C3,,Cu ce clauză SQL se filtrează rândurile dintr-o interogare?,WHERE,Este corect,,"['1. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '2. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '3. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '4. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '5. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '6. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '7. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '8. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '9. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '10. ', ""4.2.5. Funcţii generale\nExemplu 2:\nselect CASE 'C++' \n  WHEN 'PLSQL' THEN 'Limbajul PLSQL'\n  WHEN 'SQL' THEN 'Limbajul de interogare SQL'\n  ELSE 'Limbaj de programare'\n  END\nfrom dual\nCurs 4 - BAZE DE DATE 113\n\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm\n3) https://www.w3resource.com/sql-exercises/\nCurs 4 - BAZE DE DATE 114\n\nÎntrebări?\nCurs 4 - BAZE DE DATE 115"", '\n']","clauzele SQL care filtrează rândurile dintr-o interogare sunt WHERE și HAVING. Aceste clauze sunt folosite pentru a specifica condițiile pe care trebuie să le îndeplinească rândurile pentru a fi incluse în rezultatul interogării.
",Cu ce clauză SQL se filtrează rândurile dintr-o interogare?,"['1. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '2. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '3. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '4. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '5. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '6. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '7. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '8. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '9. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '10. ', ""4.2.5. Funcţii generale\nExemplu 2:\nselect CASE 'C++' \n  WHEN 'PLSQL' THEN 'Limbajul PLSQL'\n  WHEN 'SQL' THEN 'Limbajul de interogare SQL'\n  ELSE 'Limbaj de programare'\n  END\nfrom dual\nCurs 4 - BAZE DE DATE 113\n\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm\n3) https://www.w3resource.com/sql-exercises/\nCurs 4 - BAZE DE DATE 114\n\nÎntrebări?\nCurs 4 - BAZE DE DATE 115"", '\n']","clauzele SQL care filtrează rândurile dintr-o interogare sunt WHERE și HAVING. Aceste clauze sunt folosite pentru a specifica condițiile pe care trebuie să le îndeplinească rândurile pentru a fi incluse în rezultatul interogării.
",WHERE,0.230214049739442,1.0,0.8762166452748518,1.0,0.03747776736677921,0.05128205128205127,0.0
3,O3mini-high,LOW,C4,,Ce funcție SQL transformă șirurile de caractere în majuscule?,UPPER,Este corect,,"['1. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '2. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '3. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '4. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '5. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '6. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '7. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '8. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '9. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '10. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n']","nu există informații despre funcții SQL care transformă șirurile de caractere în majuscule. Informațiile oferite descriu elemente de bază ale limbajului SQL, cum ar fi variabile, expresii, operatori, comenzile SELECT, CREATE SEQUENCE, și pseudocoloanele NEXTVAL și CURRVAL, dar nu menționează nicio funcție specifică pentru manipularea șirurilor de caractere.
",Ce funcție SQL transformă șirurile de caractere în majuscule?,"['1. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '2. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '3. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '4. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '5. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '6. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '7. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '8. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '9. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '10. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n']","nu există informații despre funcții SQL care transformă șirurile de caractere în majuscule. Informațiile oferite descriu elemente de bază ale limbajului SQL, cum ar fi variabile, expresii, operatori, comenzile SELECT, CREATE SEQUENCE, și pseudocoloanele NEXTVAL și CURRVAL, dar nu menționează nicio funcție specifică pentru manipularea șirurilor de caractere.
",UPPER,0.0,0.0,0.0,1.0,0.0,0.0,0.0
4,O3mini-high,LOW,C5,,Cu ce clauză se grupează înregistrările pentru a calcula valori agregate folosind funcțiile de grup?,GROUP BY,Este corect,,"['1. ', '4.3. Funcții de grup\n• În contrast, funcţia COUNT(expr) întoarce numărul \nde valori nenule din coloana specificată de expr.\n• COUNT(DISTINCT expr) returnează numărul de valori \ndistincte, nenule din coloana specificată de expr.\nCurs 5 - BAZE DE DATE 23\n\n4.3. Funcții de grup\nExemplul 4 \nNumărul angajaţilor din departamentul cu id-ul 30. \nSELECT COUNT(*)\nFROM EMP\nWHERE deptno = 30;\nCurs 5 - BAZE DE DATE 24\n\n\n4.3. Funcții de grup\nRezultatul obtinut - Numărul angajaţilor din departamentul cu id-\nul 30. \nCurs 5 - BAZE DE DATE 25\n\n\n4.3. Funcții de grup\nExemplul 5 \nNumărul angajaţilor care iau comision din \ndepartamentul 30.\nSELECT COUNT(comm)\nFROM EMP\nWHERE deptno = 30; \nCurs 5 - BAZE DE DATE 26\n\n4.3. Funcții de grup\nRezultatul obtinut - Numărul angajaţilor care iau comision din \ndepartamentul 30:\n \nCurs 5 - BAZE DE DATE 27\n\n\n4.3. Funcții de grup\nExemplul 6 - Numărul de departamente din firma \n(varianta incorectă şi varianta corectă). \nSELECT COUNT(deptno), COUNT(DISTINCT deptno)\nFROM EMP;\nCurs 5 - BAZE DE DATE 28\n\n\n4.3. Funcții de grup\nExemplul 7 - Comisionul mediu în departamentul 30 \n(ignorând sau nu valorile nule): \nSELECT AVG(comm), AVG(NVL(comm, 0))\nFROM EMP\nWHERE deptno = 30;\nCurs 5 - BAZE DE DATE 29\n\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 30\n\n4.3.1. Clauza GROUP BY\n➢Până acum toate funcţiile de grup au fost aplicate \nîntregii tabele. \n \n➢Pentru a putea împărţi tabela în grupuri mai mici se \nfoloseşte clauza GROUP BY. \n➢Folosirea acesteia returnează informaţii sumare despre \nfiecare grup. \nCurs 5 - BAZE DE DATE 31\n\n4.3.1. Clauza GROUP BY\n➢Folosind GROUP BY nu se pot extrage şi coloane \nindividuale, ci doar coloane ce rămân identice în tot \ngrupul.\n➢Folosind WHERE se pot exclude rânduri, înaintea \nîmpărţirii lor în grupuri.\n➢Nu pot fi folosite aliasuri de coloane în clauza GROUP \nBY.\n➢Implicit, rândurile sunt sortate crescător după coloana \n(coloanele) specificate în GROUP BY. \n➢Acest lucru poate fi schimbat folosind ORDER BY.\nCurs 5 - BAZE DE DATE 32\n\n4.3.1. Clauza GROUP BY\nExemplul 8 - Salariul mediu pe fiecare department:\nSELECT deptno, AVG(sal)\nFROM EMP\nGROUP BY deptno; \nCurs 5 - BAZE DE DATE 33\n\n\n4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul mediu pe fiecare department:\nCurs 5 - BAZE DE DATE 34\n\n\n4.3.1. Clauza GROUP BY\nExemplul 9 \nSalariul mediu pe fiecare departament, iar \nrezultatele ordonate după salariul mediu pe \ndepartament. \nSELECT deptno, AVG(sal)\nFROM EMP\nGROUP BY deptno\nORDER BY AVG(sal);\nCurs 5 - BAZE DE DATE 35\n\n4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul mediu pe fiecare departament, iar \nrezultatele ordonate după salariul mediu pe departament. \nCurs 5 - BAZE DE DATE 36', '\n', '2. ', '4.3. Funcții de grup\n• În contrast, funcţia COUNT(expr) întoarce numărul \nde valori nenule din coloana specificată de expr.\n• COUNT(DISTINCT expr) returnează numărul de valori \ndistincte, nenule din coloana specificată de expr.\nCurs 5 - BAZE DE DATE 23\n\n4.3. Funcții de grup\nExemplul 4 \nNumărul angajaţilor din departamentul cu id-ul 30. \nSELECT COUNT(*)\nFROM EMP\nWHERE deptno = 30;\nCurs 5 - BAZE DE DATE 24\n\n\n4.3. Funcții de grup\nRezultatul obtinut - Numărul angajaţilor din departamentul cu id-\nul 30. \nCurs 5 - BAZE DE DATE 25\n\n\n4.3. Funcții de grup\nExemplul 5 \nNumărul angajaţilor care iau comision din \ndepartamentul 30.\nSELECT COUNT(comm)\nFROM EMP\nWHERE deptno = 30; \nCurs 5 - BAZE DE DATE 26\n\n4.3. Funcții de grup\nRezultatul obtinut - Numărul angajaţilor care iau comision din \ndepartamentul 30:\n \nCurs 5 - BAZE DE DATE 27\n\n\n4.3. Funcții de grup\nExemplul 6 - Numărul de departamente din firma \n(varianta incorectă şi varianta corectă). \nSELECT COUNT(deptno), COUNT(DISTINCT deptno)\nFROM EMP;\nCurs 5 - BAZE DE DATE 28\n\n\n4.3. Funcții de grup\nExemplul 7 - Comisionul mediu în departamentul 30 \n(ignorând sau nu valorile nule): \nSELECT AVG(comm), AVG(NVL(comm, 0))\nFROM EMP\nWHERE deptno = 30;\nCurs 5 - BAZE DE DATE 29\n\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 30\n\n4.3.1. Clauza GROUP BY\n➢Până acum toate funcţiile de grup au fost aplicate \nîntregii tabele. \n \n➢Pentru a putea împărţi tabela în grupuri mai mici se \nfoloseşte clauza GROUP BY. \n➢Folosirea acesteia returnează informaţii sumare despre \nfiecare grup. \nCurs 5 - BAZE DE DATE 31\n\n4.3.1. Clauza GROUP BY\n➢Folosind GROUP BY nu se pot extrage şi coloane \nindividuale, ci doar coloane ce rămân identice în tot \ngrupul.\n➢Folosind WHERE se pot exclude rânduri, înaintea \nîmpărţirii lor în grupuri.\n➢Nu pot fi folosite aliasuri de coloane în clauza GROUP \nBY.\n➢Implicit, rândurile sunt sortate crescător după coloana \n(coloanele) specificate în GROUP BY. \n➢Acest lucru poate fi schimbat folosind ORDER BY.\nCurs 5 - BAZE DE DATE 32\n\n4.3.1. Clauza GROUP BY\nExemplul 8 - Salariul mediu pe fiecare department:\nSELECT deptno, AVG(sal)\nFROM EMP\nGROUP BY deptno; \nCurs 5 - BAZE DE DATE 33\n\n\n4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul mediu pe fiecare department:\nCurs 5 - BAZE DE DATE 34\n\n\n4.3.1. Clauza GROUP BY\nExemplul 9 \nSalariul mediu pe fiecare departament, iar \nrezultatele ordonate după salariul mediu pe \ndepartament. \nSELECT deptno, AVG(sal)\nFROM EMP\nGROUP BY deptno\nORDER BY AVG(sal);\nCurs 5 - BAZE DE DATE 35\n\n4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul mediu pe fiecare departament, iar \nrezultatele ordonate după salariul mediu pe departament. \nCurs 5 - BAZE DE DATE 36', '\n', '3. ', '4.3. Funcții de grup\n• În contrast, funcţia COUNT(expr) întoarce numărul \nde valori nenule din coloana specificată de expr.\n• COUNT(DISTINCT expr) returnează numărul de valori \ndistincte, nenule din coloana specificată de expr.\nCurs 5 - BAZE DE DATE 23\n\n4.3. Funcții de grup\nExemplul 4 \nNumărul angajaţilor din departamentul cu id-ul 30. \nSELECT COUNT(*)\nFROM EMP\nWHERE deptno = 30;\nCurs 5 - BAZE DE DATE 24\n\n\n4.3. Funcții de grup\nRezultatul obtinut - Numărul angajaţilor din departamentul cu id-\nul 30. \nCurs 5 - BAZE DE DATE 25\n\n\n4.3. Funcții de grup\nExemplul 5 \nNumărul angajaţilor care iau comision din \ndepartamentul 30.\nSELECT COUNT(comm)\nFROM EMP\nWHERE deptno = 30; \nCurs 5 - BAZE DE DATE 26\n\n4.3. Funcții de grup\nRezultatul obtinut - Numărul angajaţilor care iau comision din \ndepartamentul 30:\n \nCurs 5 - BAZE DE DATE 27\n\n\n4.3. Funcții de grup\nExemplul 6 - Numărul de departamente din firma \n(varianta incorectă şi varianta corectă). \nSELECT COUNT(deptno), COUNT(DISTINCT deptno)\nFROM EMP;\nCurs 5 - BAZE DE DATE 28\n\n\n4.3. Funcții de grup\nExemplul 7 - Comisionul mediu în departamentul 30 \n(ignorând sau nu valorile nule): \nSELECT AVG(comm), AVG(NVL(comm, 0))\nFROM EMP\nWHERE deptno = 30;\nCurs 5 - BAZE DE DATE 29\n\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 30\n\n4.3.1. Clauza GROUP BY\n➢Până acum toate funcţiile de grup au fost aplicate \nîntregii tabele. \n \n➢Pentru a putea împărţi tabela în grupuri mai mici se \nfoloseşte clauza GROUP BY. \n➢Folosirea acesteia returnează informaţii sumare despre \nfiecare grup. \nCurs 5 - BAZE DE DATE 31\n\n4.3.1. Clauza GROUP BY\n➢Folosind GROUP BY nu se pot extrage şi coloane \nindividuale, ci doar coloane ce rămân identice în tot \ngrupul.\n➢Folosind WHERE se pot exclude rânduri, înaintea \nîmpărţirii lor în grupuri.\n➢Nu pot fi folosite aliasuri de coloane în clauza GROUP \nBY.\n➢Implicit, rândurile sunt sortate crescător după coloana \n(coloanele) specificate în GROUP BY. \n➢Acest lucru poate fi schimbat folosind ORDER BY.\nCurs 5 - BAZE DE DATE 32\n\n4.3.1. Clauza GROUP BY\nExemplul 8 - Salariul mediu pe fiecare department:\nSELECT deptno, AVG(sal)\nFROM EMP\nGROUP BY deptno; \nCurs 5 - BAZE DE DATE 33\n\n\n4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul mediu pe fiecare department:\nCurs 5 - BAZE DE DATE 34\n\n\n4.3.1. Clauza GROUP BY\nExemplul 9 \nSalariul mediu pe fiecare departament, iar \nrezultatele ordonate după salariul mediu pe \ndepartament. \nSELECT deptno, AVG(sal)\nFROM EMP\nGROUP BY deptno\nORDER BY AVG(sal);\nCurs 5 - BAZE DE DATE 35\n\n4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul mediu pe fiecare departament, iar \nrezultatele ordonate după salariul mediu pe departament. \nCurs 5 - BAZE DE DATE 36', '\n', '4. ', ""4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14\n\n4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15\n\n4.3. Funcții de grup\nDISTINCT face ca funcţia să ignore valorile duplicat. \nALL face ca funcţia să afişeze şi valorile duplicat. \nValoarea implicită este ALL, deci nu este necesar să \nfie specificată.\n  Tipul de dată returnat de funcţia expr poate fi \nCHAR, VARCHAR2, NUMBER sau DATE.\n  Toate funcţiile de grup ignoră valorile nule. \nPentru a lua în considerare şi valorile nule se \nfolosesc funcţiile NVL, NVL2 sau COALESCE.\nCurs 5 - BAZE DE DATE 16\n\n4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17\n\n4.3. Funcții de grup\nExemplul 1: Afişarea salariului mediu, maxim, minim şi \nsuma tuturor salariilor angajaţilor cu funcţie SALESMAN. \nSELECT AVG(sal), MAX(sal), MIN(sal), SUM(sal)\nFROM EMP\nWHERE job = 'SALESMAN';\nCurs 5 - BAZE DE DATE 18\n\n\n4.3. Funcții de grup\nExemplul 2 - Datele la care s-au făcut prima şi ultima \nangajare.\nSELECT MIN(hiredate), MAX(hiredate)\nFROM EMP; \nCurs 5 - BAZE DE DATE 19\n\n\n4.3. Funcții de grup\nExemplul 3 - Primul şi ultimul nume de angajat în \nordine alfabetică:\nSELECT MIN(ename), MAX(ename)\nFROM EMP;\nCurs 5 - BAZE DE DATE 20\n\n\n4.3. Funcții de grup\nFuncţia COUNT \nFuncţia COUNT are 3 formate: \nCOUNT(*) \nCOUNT(expr) \nCOUNT(DISTINCT expr)\nCurs 5 - BAZE DE DATE 21\n\n4.3. Funcții de grup\n•COUNT(*) întoarce numărul de rânduri dintr-o tabela \ncare satisface criteriul de selecţie, incluzând rândurile \nduplicat şi rândurile conţinând valori nule.\n•Dacă clauza WHERE este introdusă, atunci COUNT(*) \nreturnează numărul de rânduri care satisfac condiţia \ndin clauza WHERE.\nCurs 5 - BAZE DE DATE 22"", '\n', '5. ', ""4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14\n\n4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15\n\n4.3. Funcții de grup\nDISTINCT face ca funcţia să ignore valorile duplicat. \nALL face ca funcţia să afişeze şi valorile duplicat. \nValoarea implicită este ALL, deci nu este necesar să \nfie specificată.\n  Tipul de dată returnat de funcţia expr poate fi \nCHAR, VARCHAR2, NUMBER sau DATE.\n  Toate funcţiile de grup ignoră valorile nule. \nPentru a lua în considerare şi valorile nule se \nfolosesc funcţiile NVL, NVL2 sau COALESCE.\nCurs 5 - BAZE DE DATE 16\n\n4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17\n\n4.3. Funcții de grup\nExemplul 1: Afişarea salariului mediu, maxim, minim şi \nsuma tuturor salariilor angajaţilor cu funcţie SALESMAN. \nSELECT AVG(sal), MAX(sal), MIN(sal), SUM(sal)\nFROM EMP\nWHERE job = 'SALESMAN';\nCurs 5 - BAZE DE DATE 18\n\n\n4.3. Funcții de grup\nExemplul 2 - Datele la care s-au făcut prima şi ultima \nangajare.\nSELECT MIN(hiredate), MAX(hiredate)\nFROM EMP; \nCurs 5 - BAZE DE DATE 19\n\n\n4.3. Funcții de grup\nExemplul 3 - Primul şi ultimul nume de angajat în \nordine alfabetică:\nSELECT MIN(ename), MAX(ename)\nFROM EMP;\nCurs 5 - BAZE DE DATE 20\n\n\n4.3. Funcții de grup\nFuncţia COUNT \nFuncţia COUNT are 3 formate: \nCOUNT(*) \nCOUNT(expr) \nCOUNT(DISTINCT expr)\nCurs 5 - BAZE DE DATE 21\n\n4.3. Funcții de grup\n•COUNT(*) întoarce numărul de rânduri dintr-o tabela \ncare satisface criteriul de selecţie, incluzând rândurile \nduplicat şi rândurile conţinând valori nule.\n•Dacă clauza WHERE este introdusă, atunci COUNT(*) \nreturnează numărul de rânduri care satisfac condiţia \ndin clauza WHERE.\nCurs 5 - BAZE DE DATE 22"", '\n', '6. ', ""4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14\n\n4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15\n\n4.3. Funcții de grup\nDISTINCT face ca funcţia să ignore valorile duplicat. \nALL face ca funcţia să afişeze şi valorile duplicat. \nValoarea implicită este ALL, deci nu este necesar să \nfie specificată.\n  Tipul de dată returnat de funcţia expr poate fi \nCHAR, VARCHAR2, NUMBER sau DATE.\n  Toate funcţiile de grup ignoră valorile nule. \nPentru a lua în considerare şi valorile nule se \nfolosesc funcţiile NVL, NVL2 sau COALESCE.\nCurs 5 - BAZE DE DATE 16\n\n4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17\n\n4.3. Funcții de grup\nExemplul 1: Afişarea salariului mediu, maxim, minim şi \nsuma tuturor salariilor angajaţilor cu funcţie SALESMAN. \nSELECT AVG(sal), MAX(sal), MIN(sal), SUM(sal)\nFROM EMP\nWHERE job = 'SALESMAN';\nCurs 5 - BAZE DE DATE 18\n\n\n4.3. Funcții de grup\nExemplul 2 - Datele la care s-au făcut prima şi ultima \nangajare.\nSELECT MIN(hiredate), MAX(hiredate)\nFROM EMP; \nCurs 5 - BAZE DE DATE 19\n\n\n4.3. Funcții de grup\nExemplul 3 - Primul şi ultimul nume de angajat în \nordine alfabetică:\nSELECT MIN(ename), MAX(ename)\nFROM EMP;\nCurs 5 - BAZE DE DATE 20\n\n\n4.3. Funcții de grup\nFuncţia COUNT \nFuncţia COUNT are 3 formate: \nCOUNT(*) \nCOUNT(expr) \nCOUNT(DISTINCT expr)\nCurs 5 - BAZE DE DATE 21\n\n4.3. Funcții de grup\n•COUNT(*) întoarce numărul de rânduri dintr-o tabela \ncare satisface criteriul de selecţie, incluzând rândurile \nduplicat şi rândurile conţinând valori nule.\n•Dacă clauza WHERE este introdusă, atunci COUNT(*) \nreturnează numărul de rânduri care satisfac condiţia \ndin clauza WHERE.\nCurs 5 - BAZE DE DATE 22"", '\n', '7. ', 'Curs 5 \nLimbajul SQL \nCurs 5 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea III)\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 3\n\nTabele EMP si DEPT\nPentru exemplele din cursuri vom folosi tabela EMP:\nCurs 5 - BAZE DE DATE 4\nStructura tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 5\nPentru exemplele din cursuri vom folosi tabela EMP:\nContinutul initial al tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 6\nStructura tabelei DEPT.\nContinutul initial al tabelei DEPT.\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7\n\nFuncţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. funcţii caracter\n2. funcţii numerice\n3. funcţii pentru data calendaristică si oră\n4. funcţii de conversie\n5. funcţii diverse\nCurs 5 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• funcţii totalizatoare sau funcţii de grup\nCurs 5 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13\n\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', '\n', '8. ', 'Curs 5 \nLimbajul SQL \nCurs 5 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea III)\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 3\n\nTabele EMP si DEPT\nPentru exemplele din cursuri vom folosi tabela EMP:\nCurs 5 - BAZE DE DATE 4\nStructura tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 5\nPentru exemplele din cursuri vom folosi tabela EMP:\nContinutul initial al tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 6\nStructura tabelei DEPT.\nContinutul initial al tabelei DEPT.\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7\n\nFuncţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. funcţii caracter\n2. funcţii numerice\n3. funcţii pentru data calendaristică si oră\n4. funcţii de conversie\n5. funcţii diverse\nCurs 5 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• funcţii totalizatoare sau funcţii de grup\nCurs 5 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13\n\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', '\n', '9. ', 'Curs 5 \nLimbajul SQL \nCurs 5 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea III)\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 3\n\nTabele EMP si DEPT\nPentru exemplele din cursuri vom folosi tabela EMP:\nCurs 5 - BAZE DE DATE 4\nStructura tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 5\nPentru exemplele din cursuri vom folosi tabela EMP:\nContinutul initial al tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 6\nStructura tabelei DEPT.\nContinutul initial al tabelei DEPT.\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7\n\nFuncţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. funcţii caracter\n2. funcţii numerice\n3. funcţii pentru data calendaristică si oră\n4. funcţii de conversie\n5. funcţii diverse\nCurs 5 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• funcţii totalizatoare sau funcţii de grup\nCurs 5 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13\n\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', '\n', '10. ', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13\n\nFuncţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 15\n\nFuncţii referitoare la o singură înregistrare\n4.2.1. Funcţii pentru şiruri de caractere \nAceste funcţii au ca argumente date de tip \ncaracter şi returnează date de tip VARCHAR2, \nCHAR sau NUMBER.\nCurs 4 - BAZE DE DATE 16\n\n4.2.1. Funcţii pentru şiruri de caractere\nCele mai importante funcţii caracter sunt:\nFunctie Descriere  \nLOWER(column|expression) converteste alfa caracterele din caractere mari in \ncaractere mici  \nUPPER(column|expression) converteste alfa caracterele din caractere mici in \ncaractere mari  \nINITCAP(column|expression) \nconverteste prima litera a fiecarui cuvant in \ncaractere mari si restul cuvantului in caractere \nmici  \nCONCAT(column1|expression1, \ncolumn2|expression2) \nfunctia este echivalentul operatorului de \nconcantenare (||)  \nSUBSTR(column|expression, m [, n]) returneaza un sir de n caractere incepand cu \ncaracterul aflat pe pozitia m  \nLENGTH(column|expression) returneaza numarul de caractere dintr-o expresie  \nINSTR(column|expression, \'string\', \n[m], [n]) \nreturneaza pozitia unui anumit sir, optional se \npoate incepe cautarea cu pozitia m sau cu a n-a \naparitie a sirului. m si n sunt prin definitie 1  \nREPLACE(text, search_string, \nreplacement_ string) \ncauta un anumit text intr-un sir de caractere si \ndaca il gaseste il inlocuieste  \n \nCurs 4 - BAZE DE DATE 17\n\nExemplu de utilizare a \nfuncţiei LENGTH:\nSELECT LENGTH(ename) \nFROM EMP; \nCurs 4 - BAZE DE DATE 18\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu de utilizare a funcţiei LENGTH – rezultatul \nobtinut: \nCurs 4 - BAZE DE DATE 19\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT \'Numele functiei pentru \'||UPPER(ename)||\'este \n\'||LOWER(job) AS ""DETALII ANGAJAT""\nFROM EMP; \nCurs 4 - BAZE DE DATE 20\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = \'MARTIN\';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere', '\n']","clauza `GROUP BY` este utilizată pentru a grupa înregistrările și a calcula valori agregate folosind funcțiile de grup.
",Cu ce clauză se grupează înregistrările pentru a calcula valori agregate folosind funcțiile de grup?,"['1. ', '4.3. Funcții de grup\n• În contrast, funcţia COUNT(expr) întoarce numărul \nde valori nenule din coloana specificată de expr.\n• COUNT(DISTINCT expr) returnează numărul de valori \ndistincte, nenule din coloana specificată de expr.\nCurs 5 - BAZE DE DATE 23\n\n4.3. Funcții de grup\nExemplul 4 \nNumărul angajaţilor din departamentul cu id-ul 30. \nSELECT COUNT(*)\nFROM EMP\nWHERE deptno = 30;\nCurs 5 - BAZE DE DATE 24\n\n\n4.3. Funcții de grup\nRezultatul obtinut - Numărul angajaţilor din departamentul cu id-\nul 30. \nCurs 5 - BAZE DE DATE 25\n\n\n4.3. Funcții de grup\nExemplul 5 \nNumărul angajaţilor care iau comision din \ndepartamentul 30.\nSELECT COUNT(comm)\nFROM EMP\nWHERE deptno = 30; \nCurs 5 - BAZE DE DATE 26\n\n4.3. Funcții de grup\nRezultatul obtinut - Numărul angajaţilor care iau comision din \ndepartamentul 30:\n \nCurs 5 - BAZE DE DATE 27\n\n\n4.3. Funcții de grup\nExemplul 6 - Numărul de departamente din firma \n(varianta incorectă şi varianta corectă). \nSELECT COUNT(deptno), COUNT(DISTINCT deptno)\nFROM EMP;\nCurs 5 - BAZE DE DATE 28\n\n\n4.3. Funcții de grup\nExemplul 7 - Comisionul mediu în departamentul 30 \n(ignorând sau nu valorile nule): \nSELECT AVG(comm), AVG(NVL(comm, 0))\nFROM EMP\nWHERE deptno = 30;\nCurs 5 - BAZE DE DATE 29\n\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 30\n\n4.3.1. Clauza GROUP BY\n➢Până acum toate funcţiile de grup au fost aplicate \nîntregii tabele. \n \n➢Pentru a putea împărţi tabela în grupuri mai mici se \nfoloseşte clauza GROUP BY. \n➢Folosirea acesteia returnează informaţii sumare despre \nfiecare grup. \nCurs 5 - BAZE DE DATE 31\n\n4.3.1. Clauza GROUP BY\n➢Folosind GROUP BY nu se pot extrage şi coloane \nindividuale, ci doar coloane ce rămân identice în tot \ngrupul.\n➢Folosind WHERE se pot exclude rânduri, înaintea \nîmpărţirii lor în grupuri.\n➢Nu pot fi folosite aliasuri de coloane în clauza GROUP \nBY.\n➢Implicit, rândurile sunt sortate crescător după coloana \n(coloanele) specificate în GROUP BY. \n➢Acest lucru poate fi schimbat folosind ORDER BY.\nCurs 5 - BAZE DE DATE 32\n\n4.3.1. Clauza GROUP BY\nExemplul 8 - Salariul mediu pe fiecare department:\nSELECT deptno, AVG(sal)\nFROM EMP\nGROUP BY deptno; \nCurs 5 - BAZE DE DATE 33\n\n\n4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul mediu pe fiecare department:\nCurs 5 - BAZE DE DATE 34\n\n\n4.3.1. Clauza GROUP BY\nExemplul 9 \nSalariul mediu pe fiecare departament, iar \nrezultatele ordonate după salariul mediu pe \ndepartament. \nSELECT deptno, AVG(sal)\nFROM EMP\nGROUP BY deptno\nORDER BY AVG(sal);\nCurs 5 - BAZE DE DATE 35\n\n4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul mediu pe fiecare departament, iar \nrezultatele ordonate după salariul mediu pe departament. \nCurs 5 - BAZE DE DATE 36', '\n', '2. ', '4.3. Funcții de grup\n• În contrast, funcţia COUNT(expr) întoarce numărul \nde valori nenule din coloana specificată de expr.\n• COUNT(DISTINCT expr) returnează numărul de valori \ndistincte, nenule din coloana specificată de expr.\nCurs 5 - BAZE DE DATE 23\n\n4.3. Funcții de grup\nExemplul 4 \nNumărul angajaţilor din departamentul cu id-ul 30. \nSELECT COUNT(*)\nFROM EMP\nWHERE deptno = 30;\nCurs 5 - BAZE DE DATE 24\n\n\n4.3. Funcții de grup\nRezultatul obtinut - Numărul angajaţilor din departamentul cu id-\nul 30. \nCurs 5 - BAZE DE DATE 25\n\n\n4.3. Funcții de grup\nExemplul 5 \nNumărul angajaţilor care iau comision din \ndepartamentul 30.\nSELECT COUNT(comm)\nFROM EMP\nWHERE deptno = 30; \nCurs 5 - BAZE DE DATE 26\n\n4.3. Funcții de grup\nRezultatul obtinut - Numărul angajaţilor care iau comision din \ndepartamentul 30:\n \nCurs 5 - BAZE DE DATE 27\n\n\n4.3. Funcții de grup\nExemplul 6 - Numărul de departamente din firma \n(varianta incorectă şi varianta corectă). \nSELECT COUNT(deptno), COUNT(DISTINCT deptno)\nFROM EMP;\nCurs 5 - BAZE DE DATE 28\n\n\n4.3. Funcții de grup\nExemplul 7 - Comisionul mediu în departamentul 30 \n(ignorând sau nu valorile nule): \nSELECT AVG(comm), AVG(NVL(comm, 0))\nFROM EMP\nWHERE deptno = 30;\nCurs 5 - BAZE DE DATE 29\n\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 30\n\n4.3.1. Clauza GROUP BY\n➢Până acum toate funcţiile de grup au fost aplicate \nîntregii tabele. \n \n➢Pentru a putea împărţi tabela în grupuri mai mici se \nfoloseşte clauza GROUP BY. \n➢Folosirea acesteia returnează informaţii sumare despre \nfiecare grup. \nCurs 5 - BAZE DE DATE 31\n\n4.3.1. Clauza GROUP BY\n➢Folosind GROUP BY nu se pot extrage şi coloane \nindividuale, ci doar coloane ce rămân identice în tot \ngrupul.\n➢Folosind WHERE se pot exclude rânduri, înaintea \nîmpărţirii lor în grupuri.\n➢Nu pot fi folosite aliasuri de coloane în clauza GROUP \nBY.\n➢Implicit, rândurile sunt sortate crescător după coloana \n(coloanele) specificate în GROUP BY. \n➢Acest lucru poate fi schimbat folosind ORDER BY.\nCurs 5 - BAZE DE DATE 32\n\n4.3.1. Clauza GROUP BY\nExemplul 8 - Salariul mediu pe fiecare department:\nSELECT deptno, AVG(sal)\nFROM EMP\nGROUP BY deptno; \nCurs 5 - BAZE DE DATE 33\n\n\n4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul mediu pe fiecare department:\nCurs 5 - BAZE DE DATE 34\n\n\n4.3.1. Clauza GROUP BY\nExemplul 9 \nSalariul mediu pe fiecare departament, iar \nrezultatele ordonate după salariul mediu pe \ndepartament. \nSELECT deptno, AVG(sal)\nFROM EMP\nGROUP BY deptno\nORDER BY AVG(sal);\nCurs 5 - BAZE DE DATE 35\n\n4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul mediu pe fiecare departament, iar \nrezultatele ordonate după salariul mediu pe departament. \nCurs 5 - BAZE DE DATE 36', '\n', '3. ', '4.3. Funcții de grup\n• În contrast, funcţia COUNT(expr) întoarce numărul \nde valori nenule din coloana specificată de expr.\n• COUNT(DISTINCT expr) returnează numărul de valori \ndistincte, nenule din coloana specificată de expr.\nCurs 5 - BAZE DE DATE 23\n\n4.3. Funcții de grup\nExemplul 4 \nNumărul angajaţilor din departamentul cu id-ul 30. \nSELECT COUNT(*)\nFROM EMP\nWHERE deptno = 30;\nCurs 5 - BAZE DE DATE 24\n\n\n4.3. Funcții de grup\nRezultatul obtinut - Numărul angajaţilor din departamentul cu id-\nul 30. \nCurs 5 - BAZE DE DATE 25\n\n\n4.3. Funcții de grup\nExemplul 5 \nNumărul angajaţilor care iau comision din \ndepartamentul 30.\nSELECT COUNT(comm)\nFROM EMP\nWHERE deptno = 30; \nCurs 5 - BAZE DE DATE 26\n\n4.3. Funcții de grup\nRezultatul obtinut - Numărul angajaţilor care iau comision din \ndepartamentul 30:\n \nCurs 5 - BAZE DE DATE 27\n\n\n4.3. Funcții de grup\nExemplul 6 - Numărul de departamente din firma \n(varianta incorectă şi varianta corectă). \nSELECT COUNT(deptno), COUNT(DISTINCT deptno)\nFROM EMP;\nCurs 5 - BAZE DE DATE 28\n\n\n4.3. Funcții de grup\nExemplul 7 - Comisionul mediu în departamentul 30 \n(ignorând sau nu valorile nule): \nSELECT AVG(comm), AVG(NVL(comm, 0))\nFROM EMP\nWHERE deptno = 30;\nCurs 5 - BAZE DE DATE 29\n\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 30\n\n4.3.1. Clauza GROUP BY\n➢Până acum toate funcţiile de grup au fost aplicate \nîntregii tabele. \n \n➢Pentru a putea împărţi tabela în grupuri mai mici se \nfoloseşte clauza GROUP BY. \n➢Folosirea acesteia returnează informaţii sumare despre \nfiecare grup. \nCurs 5 - BAZE DE DATE 31\n\n4.3.1. Clauza GROUP BY\n➢Folosind GROUP BY nu se pot extrage şi coloane \nindividuale, ci doar coloane ce rămân identice în tot \ngrupul.\n➢Folosind WHERE se pot exclude rânduri, înaintea \nîmpărţirii lor în grupuri.\n➢Nu pot fi folosite aliasuri de coloane în clauza GROUP \nBY.\n➢Implicit, rândurile sunt sortate crescător după coloana \n(coloanele) specificate în GROUP BY. \n➢Acest lucru poate fi schimbat folosind ORDER BY.\nCurs 5 - BAZE DE DATE 32\n\n4.3.1. Clauza GROUP BY\nExemplul 8 - Salariul mediu pe fiecare department:\nSELECT deptno, AVG(sal)\nFROM EMP\nGROUP BY deptno; \nCurs 5 - BAZE DE DATE 33\n\n\n4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul mediu pe fiecare department:\nCurs 5 - BAZE DE DATE 34\n\n\n4.3.1. Clauza GROUP BY\nExemplul 9 \nSalariul mediu pe fiecare departament, iar \nrezultatele ordonate după salariul mediu pe \ndepartament. \nSELECT deptno, AVG(sal)\nFROM EMP\nGROUP BY deptno\nORDER BY AVG(sal);\nCurs 5 - BAZE DE DATE 35\n\n4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul mediu pe fiecare departament, iar \nrezultatele ordonate după salariul mediu pe departament. \nCurs 5 - BAZE DE DATE 36', '\n', '4. ', ""4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14\n\n4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15\n\n4.3. Funcții de grup\nDISTINCT face ca funcţia să ignore valorile duplicat. \nALL face ca funcţia să afişeze şi valorile duplicat. \nValoarea implicită este ALL, deci nu este necesar să \nfie specificată.\n  Tipul de dată returnat de funcţia expr poate fi \nCHAR, VARCHAR2, NUMBER sau DATE.\n  Toate funcţiile de grup ignoră valorile nule. \nPentru a lua în considerare şi valorile nule se \nfolosesc funcţiile NVL, NVL2 sau COALESCE.\nCurs 5 - BAZE DE DATE 16\n\n4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17\n\n4.3. Funcții de grup\nExemplul 1: Afişarea salariului mediu, maxim, minim şi \nsuma tuturor salariilor angajaţilor cu funcţie SALESMAN. \nSELECT AVG(sal), MAX(sal), MIN(sal), SUM(sal)\nFROM EMP\nWHERE job = 'SALESMAN';\nCurs 5 - BAZE DE DATE 18\n\n\n4.3. Funcții de grup\nExemplul 2 - Datele la care s-au făcut prima şi ultima \nangajare.\nSELECT MIN(hiredate), MAX(hiredate)\nFROM EMP; \nCurs 5 - BAZE DE DATE 19\n\n\n4.3. Funcții de grup\nExemplul 3 - Primul şi ultimul nume de angajat în \nordine alfabetică:\nSELECT MIN(ename), MAX(ename)\nFROM EMP;\nCurs 5 - BAZE DE DATE 20\n\n\n4.3. Funcții de grup\nFuncţia COUNT \nFuncţia COUNT are 3 formate: \nCOUNT(*) \nCOUNT(expr) \nCOUNT(DISTINCT expr)\nCurs 5 - BAZE DE DATE 21\n\n4.3. Funcții de grup\n•COUNT(*) întoarce numărul de rânduri dintr-o tabela \ncare satisface criteriul de selecţie, incluzând rândurile \nduplicat şi rândurile conţinând valori nule.\n•Dacă clauza WHERE este introdusă, atunci COUNT(*) \nreturnează numărul de rânduri care satisfac condiţia \ndin clauza WHERE.\nCurs 5 - BAZE DE DATE 22"", '\n', '5. ', ""4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14\n\n4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15\n\n4.3. Funcții de grup\nDISTINCT face ca funcţia să ignore valorile duplicat. \nALL face ca funcţia să afişeze şi valorile duplicat. \nValoarea implicită este ALL, deci nu este necesar să \nfie specificată.\n  Tipul de dată returnat de funcţia expr poate fi \nCHAR, VARCHAR2, NUMBER sau DATE.\n  Toate funcţiile de grup ignoră valorile nule. \nPentru a lua în considerare şi valorile nule se \nfolosesc funcţiile NVL, NVL2 sau COALESCE.\nCurs 5 - BAZE DE DATE 16\n\n4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17\n\n4.3. Funcții de grup\nExemplul 1: Afişarea salariului mediu, maxim, minim şi \nsuma tuturor salariilor angajaţilor cu funcţie SALESMAN. \nSELECT AVG(sal), MAX(sal), MIN(sal), SUM(sal)\nFROM EMP\nWHERE job = 'SALESMAN';\nCurs 5 - BAZE DE DATE 18\n\n\n4.3. Funcții de grup\nExemplul 2 - Datele la care s-au făcut prima şi ultima \nangajare.\nSELECT MIN(hiredate), MAX(hiredate)\nFROM EMP; \nCurs 5 - BAZE DE DATE 19\n\n\n4.3. Funcții de grup\nExemplul 3 - Primul şi ultimul nume de angajat în \nordine alfabetică:\nSELECT MIN(ename), MAX(ename)\nFROM EMP;\nCurs 5 - BAZE DE DATE 20\n\n\n4.3. Funcții de grup\nFuncţia COUNT \nFuncţia COUNT are 3 formate: \nCOUNT(*) \nCOUNT(expr) \nCOUNT(DISTINCT expr)\nCurs 5 - BAZE DE DATE 21\n\n4.3. Funcții de grup\n•COUNT(*) întoarce numărul de rânduri dintr-o tabela \ncare satisface criteriul de selecţie, incluzând rândurile \nduplicat şi rândurile conţinând valori nule.\n•Dacă clauza WHERE este introdusă, atunci COUNT(*) \nreturnează numărul de rânduri care satisfac condiţia \ndin clauza WHERE.\nCurs 5 - BAZE DE DATE 22"", '\n', '6. ', ""4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14\n\n4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15\n\n4.3. Funcții de grup\nDISTINCT face ca funcţia să ignore valorile duplicat. \nALL face ca funcţia să afişeze şi valorile duplicat. \nValoarea implicită este ALL, deci nu este necesar să \nfie specificată.\n  Tipul de dată returnat de funcţia expr poate fi \nCHAR, VARCHAR2, NUMBER sau DATE.\n  Toate funcţiile de grup ignoră valorile nule. \nPentru a lua în considerare şi valorile nule se \nfolosesc funcţiile NVL, NVL2 sau COALESCE.\nCurs 5 - BAZE DE DATE 16\n\n4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17\n\n4.3. Funcții de grup\nExemplul 1: Afişarea salariului mediu, maxim, minim şi \nsuma tuturor salariilor angajaţilor cu funcţie SALESMAN. \nSELECT AVG(sal), MAX(sal), MIN(sal), SUM(sal)\nFROM EMP\nWHERE job = 'SALESMAN';\nCurs 5 - BAZE DE DATE 18\n\n\n4.3. Funcții de grup\nExemplul 2 - Datele la care s-au făcut prima şi ultima \nangajare.\nSELECT MIN(hiredate), MAX(hiredate)\nFROM EMP; \nCurs 5 - BAZE DE DATE 19\n\n\n4.3. Funcții de grup\nExemplul 3 - Primul şi ultimul nume de angajat în \nordine alfabetică:\nSELECT MIN(ename), MAX(ename)\nFROM EMP;\nCurs 5 - BAZE DE DATE 20\n\n\n4.3. Funcții de grup\nFuncţia COUNT \nFuncţia COUNT are 3 formate: \nCOUNT(*) \nCOUNT(expr) \nCOUNT(DISTINCT expr)\nCurs 5 - BAZE DE DATE 21\n\n4.3. Funcții de grup\n•COUNT(*) întoarce numărul de rânduri dintr-o tabela \ncare satisface criteriul de selecţie, incluzând rândurile \nduplicat şi rândurile conţinând valori nule.\n•Dacă clauza WHERE este introdusă, atunci COUNT(*) \nreturnează numărul de rânduri care satisfac condiţia \ndin clauza WHERE.\nCurs 5 - BAZE DE DATE 22"", '\n', '7. ', 'Curs 5 \nLimbajul SQL \nCurs 5 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea III)\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 3\n\nTabele EMP si DEPT\nPentru exemplele din cursuri vom folosi tabela EMP:\nCurs 5 - BAZE DE DATE 4\nStructura tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 5\nPentru exemplele din cursuri vom folosi tabela EMP:\nContinutul initial al tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 6\nStructura tabelei DEPT.\nContinutul initial al tabelei DEPT.\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7\n\nFuncţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. funcţii caracter\n2. funcţii numerice\n3. funcţii pentru data calendaristică si oră\n4. funcţii de conversie\n5. funcţii diverse\nCurs 5 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• funcţii totalizatoare sau funcţii de grup\nCurs 5 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13\n\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', '\n', '8. ', 'Curs 5 \nLimbajul SQL \nCurs 5 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea III)\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 3\n\nTabele EMP si DEPT\nPentru exemplele din cursuri vom folosi tabela EMP:\nCurs 5 - BAZE DE DATE 4\nStructura tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 5\nPentru exemplele din cursuri vom folosi tabela EMP:\nContinutul initial al tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 6\nStructura tabelei DEPT.\nContinutul initial al tabelei DEPT.\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7\n\nFuncţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. funcţii caracter\n2. funcţii numerice\n3. funcţii pentru data calendaristică si oră\n4. funcţii de conversie\n5. funcţii diverse\nCurs 5 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• funcţii totalizatoare sau funcţii de grup\nCurs 5 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13\n\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', '\n', '9. ', 'Curs 5 \nLimbajul SQL \nCurs 5 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea III)\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 3\n\nTabele EMP si DEPT\nPentru exemplele din cursuri vom folosi tabela EMP:\nCurs 5 - BAZE DE DATE 4\nStructura tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 5\nPentru exemplele din cursuri vom folosi tabela EMP:\nContinutul initial al tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 6\nStructura tabelei DEPT.\nContinutul initial al tabelei DEPT.\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7\n\nFuncţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. funcţii caracter\n2. funcţii numerice\n3. funcţii pentru data calendaristică si oră\n4. funcţii de conversie\n5. funcţii diverse\nCurs 5 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• funcţii totalizatoare sau funcţii de grup\nCurs 5 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13\n\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', '\n', '10. ', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13\n\nFuncţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 15\n\nFuncţii referitoare la o singură înregistrare\n4.2.1. Funcţii pentru şiruri de caractere \nAceste funcţii au ca argumente date de tip \ncaracter şi returnează date de tip VARCHAR2, \nCHAR sau NUMBER.\nCurs 4 - BAZE DE DATE 16\n\n4.2.1. Funcţii pentru şiruri de caractere\nCele mai importante funcţii caracter sunt:\nFunctie Descriere  \nLOWER(column|expression) converteste alfa caracterele din caractere mari in \ncaractere mici  \nUPPER(column|expression) converteste alfa caracterele din caractere mici in \ncaractere mari  \nINITCAP(column|expression) \nconverteste prima litera a fiecarui cuvant in \ncaractere mari si restul cuvantului in caractere \nmici  \nCONCAT(column1|expression1, \ncolumn2|expression2) \nfunctia este echivalentul operatorului de \nconcantenare (||)  \nSUBSTR(column|expression, m [, n]) returneaza un sir de n caractere incepand cu \ncaracterul aflat pe pozitia m  \nLENGTH(column|expression) returneaza numarul de caractere dintr-o expresie  \nINSTR(column|expression, \'string\', \n[m], [n]) \nreturneaza pozitia unui anumit sir, optional se \npoate incepe cautarea cu pozitia m sau cu a n-a \naparitie a sirului. m si n sunt prin definitie 1  \nREPLACE(text, search_string, \nreplacement_ string) \ncauta un anumit text intr-un sir de caractere si \ndaca il gaseste il inlocuieste  \n \nCurs 4 - BAZE DE DATE 17\n\nExemplu de utilizare a \nfuncţiei LENGTH:\nSELECT LENGTH(ename) \nFROM EMP; \nCurs 4 - BAZE DE DATE 18\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu de utilizare a funcţiei LENGTH – rezultatul \nobtinut: \nCurs 4 - BAZE DE DATE 19\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT \'Numele functiei pentru \'||UPPER(ename)||\'este \n\'||LOWER(job) AS ""DETALII ANGAJAT""\nFROM EMP; \nCurs 4 - BAZE DE DATE 20\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = \'MARTIN\';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere', '\n']","clauza `GROUP BY` este utilizată pentru a grupa înregistrările și a calcula valori agregate folosind funcțiile de grup.
",GROUP BY,0.37696670336916455,1.0,0.8996075754633508,1.0,0.036321698830878615,0.18181818181818182,1.0
5,O3mini-high,LOW,C6,,Cum se numește subinterogarea care returnează o singură valoare pentru o condiție din clauza WHERE?,subinterogare single-row,Este corect,,"['1. ', '6.2. MULTIPLE ROW SUBQUERIES\nVALORI NULL\n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci:\n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null.\n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic.\nCurs 6 - BAZE DE DATE 35\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi HAVING\n- Pot fi folosite cu subinterogările de tip multiple row.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) < ANY\n          ( SELECT sal\n             FROM EMP\n             WHERE deptno IN (10,20) );\nCurs 6 - BAZE DE DATE 36\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi \nHAVING\n- Pot fi folosite cu \nsubinterogările de tip \nmultiple row.\nCurs 6 - BAZE DE DATE 37\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\n  De asemenea, se poate folosi clauza GROUP BY intr-\no subinterogare\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > ALL\n    (SELECT MIN(sal)\n     FROM EMP\n     WHERE deptno < 40\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 38\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare\nCurs 6 - BAZE DE DATE 39\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi angajaţii ale căror salarii sunt \naceleaşi cu salariul minim din oricare (any) \ndepartament. \nSELECT ename\nFROM EMP\nWHERE sal = ANY\n    (SELECT MIN(sal)\n     FROM EMP\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 40\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi \nangajaţii ale căror salarii \nsunt aceleaşi cu (any) \ndepartament. salariul \nminim din oricare \nCurs 6 - BAZE DE DATE 41\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42\n\n6.2. MULTIPLE ROW SUBQUERIES\nSoluţia corectă este următoarea:\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) <\n  ( SELECT MIN(sal)\n    FROM EMP\n    WHERE deptno = 30);\nCurs 6 - BAZE DE DATE 43\n\nSubcereri multilinie \n• Subcererile multilinie returneaza mai mult decat o \nlinie. \n• Cu astfel de subinterogari trebuie folositi operatori \nmultilinie care pot prelucra una sau mai multe valori. \nOperatorii utilizati sunt: \n1. IN - egal cu oricare dintre membrii unei liste\n2. ANY/SOME - compara o valoare cu fiecare (vreo) \nvaloare returnata de subinterogare\n3. ALL - compara o valoare cu oricare (toate) din \nvalorile returnate de subinterogare\nCurs 6 - BAZE DE DATE 44', '\n', '2. ', '6.2. MULTIPLE ROW SUBQUERIES\nVALORI NULL\n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci:\n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null.\n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic.\nCurs 6 - BAZE DE DATE 35\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi HAVING\n- Pot fi folosite cu subinterogările de tip multiple row.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) < ANY\n          ( SELECT sal\n             FROM EMP\n             WHERE deptno IN (10,20) );\nCurs 6 - BAZE DE DATE 36\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi \nHAVING\n- Pot fi folosite cu \nsubinterogările de tip \nmultiple row.\nCurs 6 - BAZE DE DATE 37\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\n  De asemenea, se poate folosi clauza GROUP BY intr-\no subinterogare\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > ALL\n    (SELECT MIN(sal)\n     FROM EMP\n     WHERE deptno < 40\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 38\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare\nCurs 6 - BAZE DE DATE 39\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi angajaţii ale căror salarii sunt \naceleaşi cu salariul minim din oricare (any) \ndepartament. \nSELECT ename\nFROM EMP\nWHERE sal = ANY\n    (SELECT MIN(sal)\n     FROM EMP\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 40\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi \nangajaţii ale căror salarii \nsunt aceleaşi cu (any) \ndepartament. salariul \nminim din oricare \nCurs 6 - BAZE DE DATE 41\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42\n\n6.2. MULTIPLE ROW SUBQUERIES\nSoluţia corectă este următoarea:\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) <\n  ( SELECT MIN(sal)\n    FROM EMP\n    WHERE deptno = 30);\nCurs 6 - BAZE DE DATE 43\n\nSubcereri multilinie \n• Subcererile multilinie returneaza mai mult decat o \nlinie. \n• Cu astfel de subinterogari trebuie folositi operatori \nmultilinie care pot prelucra una sau mai multe valori. \nOperatorii utilizati sunt: \n1. IN - egal cu oricare dintre membrii unei liste\n2. ANY/SOME - compara o valoare cu fiecare (vreo) \nvaloare returnata de subinterogare\n3. ALL - compara o valoare cu oricare (toate) din \nvalorile returnate de subinterogare\nCurs 6 - BAZE DE DATE 44', '\n', '3. ', '6.2. MULTIPLE ROW SUBQUERIES\nVALORI NULL\n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci:\n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null.\n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic.\nCurs 6 - BAZE DE DATE 35\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi HAVING\n- Pot fi folosite cu subinterogările de tip multiple row.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) < ANY\n          ( SELECT sal\n             FROM EMP\n             WHERE deptno IN (10,20) );\nCurs 6 - BAZE DE DATE 36\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi \nHAVING\n- Pot fi folosite cu \nsubinterogările de tip \nmultiple row.\nCurs 6 - BAZE DE DATE 37\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\n  De asemenea, se poate folosi clauza GROUP BY intr-\no subinterogare\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > ALL\n    (SELECT MIN(sal)\n     FROM EMP\n     WHERE deptno < 40\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 38\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare\nCurs 6 - BAZE DE DATE 39\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi angajaţii ale căror salarii sunt \naceleaşi cu salariul minim din oricare (any) \ndepartament. \nSELECT ename\nFROM EMP\nWHERE sal = ANY\n    (SELECT MIN(sal)\n     FROM EMP\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 40\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi \nangajaţii ale căror salarii \nsunt aceleaşi cu (any) \ndepartament. salariul \nminim din oricare \nCurs 6 - BAZE DE DATE 41\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42\n\n6.2. MULTIPLE ROW SUBQUERIES\nSoluţia corectă este următoarea:\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) <\n  ( SELECT MIN(sal)\n    FROM EMP\n    WHERE deptno = 30);\nCurs 6 - BAZE DE DATE 43\n\nSubcereri multilinie \n• Subcererile multilinie returneaza mai mult decat o \nlinie. \n• Cu astfel de subinterogari trebuie folositi operatori \nmultilinie care pot prelucra una sau mai multe valori. \nOperatorii utilizati sunt: \n1. IN - egal cu oricare dintre membrii unei liste\n2. ANY/SOME - compara o valoare cu fiecare (vreo) \nvaloare returnata de subinterogare\n3. ALL - compara o valoare cu oricare (toate) din \nvalorile returnate de subinterogare\nCurs 6 - BAZE DE DATE 44', '\n', '4. ', '2. Indecșii\nExemplu 1 - crearea unui index:\nO sa cream un index pentru departamente care ne va \najuta sa extragem foarte repede o inregistrare in \nfunctie de numele departamentului.\nCREATE INDEX department_name\nON dept(dname);\nCurs - BAZE DE DATE 30\n\n\nCand se creaza indecșii?\nExista mai multe situatii care necesita crearea indecsilor in \nbaza de date. \nUn index este creat daca:\n➢o singura coloana contine o varietate foarte mare de \nvalori si un numar mare de valori.\n➢campul din baza de date contine multe inregistrari de \ntip null\n➢campurile sunt folosite foarte frecvent in conditile de \nselectare a inregistrarilor sau in cazuri de JOIN\nCurs - BAZE DE DATE 31\n\nCand se creaza indecșii? (continuare)\n➢tabela pe care se creaza indexul este foarte mare si \ncererile in mod frecvent nu extrag o cantitate mare de \ndate (2-4% din cantitatea totala de informatii din tabela) \n➢in momentul in care anumite chei sunt create in tabela \nca si cheile unice si atunci Oracle genereaza automat un \nindex unic.\nCurs - BAZE DE DATE 32\n\nCand nu se creaza indecsii si de ce?\n➢In general nu tot timpul este necesar si bine sa fie creati \nindexi in baza de date.\n➢O creare excesiva de indecsi in baza de date are si multe \nneajunsuri. \n➢In momentul in care sunt adaugati indecsi, baza de date \nface o repunere la zi a lor pentru fiecare operatie care \neste executata. \n➢In momentul in care sunt creati prea multi indecsi \noperatile de extragere din baza de date isi amelioreaza \nviteza doar cu un raport mic dar pentru fiecare \noperatiune de inserare sau stergere timpul necesar \ncreste simtitor precum si resursele folosite. \nCurs - BAZE DE DATE 33\n\nDeci se pune problema cand nu sunt necesari indecsii:\n✓Cand tabela pe care se doreste adaugarea este mica.\n✓Cand coloanele pe care se adauga indecsii nu sunt \nfolosite frecvent pentru executarea de extrageri de \ninregistrari\n✓Cand cererile de tip SELECT in general extrag un numar \nmare de inregistrari (mai mare de 2-4%)\n✓Cand operatiuni de UPDATE sunt foarte des utilizate.\n✓Cand coloanele indexate sunt referentiate ca parte \nintegranta a unor expresii.\nCurs - BAZE DE DATE 34\n\n2. Indecșii\nConfirmarea indecsilor \n• O lista completa de indecsi poate fi extrasa din \nvederea USER_INDEXES care contine numele \nindexului si daca acesta are o restrictie de \nunicitate. \nCurs - BAZE DE DATE 35\n\n2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '\n', '5. ', '2. Indecșii\nExemplu 1 - crearea unui index:\nO sa cream un index pentru departamente care ne va \najuta sa extragem foarte repede o inregistrare in \nfunctie de numele departamentului.\nCREATE INDEX department_name\nON dept(dname);\nCurs - BAZE DE DATE 30\n\n\nCand se creaza indecșii?\nExista mai multe situatii care necesita crearea indecsilor in \nbaza de date. \nUn index este creat daca:\n➢o singura coloana contine o varietate foarte mare de \nvalori si un numar mare de valori.\n➢campul din baza de date contine multe inregistrari de \ntip null\n➢campurile sunt folosite foarte frecvent in conditile de \nselectare a inregistrarilor sau in cazuri de JOIN\nCurs - BAZE DE DATE 31\n\nCand se creaza indecșii? (continuare)\n➢tabela pe care se creaza indexul este foarte mare si \ncererile in mod frecvent nu extrag o cantitate mare de \ndate (2-4% din cantitatea totala de informatii din tabela) \n➢in momentul in care anumite chei sunt create in tabela \nca si cheile unice si atunci Oracle genereaza automat un \nindex unic.\nCurs - BAZE DE DATE 32\n\nCand nu se creaza indecsii si de ce?\n➢In general nu tot timpul este necesar si bine sa fie creati \nindexi in baza de date.\n➢O creare excesiva de indecsi in baza de date are si multe \nneajunsuri. \n➢In momentul in care sunt adaugati indecsi, baza de date \nface o repunere la zi a lor pentru fiecare operatie care \neste executata. \n➢In momentul in care sunt creati prea multi indecsi \noperatile de extragere din baza de date isi amelioreaza \nviteza doar cu un raport mic dar pentru fiecare \noperatiune de inserare sau stergere timpul necesar \ncreste simtitor precum si resursele folosite. \nCurs - BAZE DE DATE 33\n\nDeci se pune problema cand nu sunt necesari indecsii:\n✓Cand tabela pe care se doreste adaugarea este mica.\n✓Cand coloanele pe care se adauga indecsii nu sunt \nfolosite frecvent pentru executarea de extrageri de \ninregistrari\n✓Cand cererile de tip SELECT in general extrag un numar \nmare de inregistrari (mai mare de 2-4%)\n✓Cand operatiuni de UPDATE sunt foarte des utilizate.\n✓Cand coloanele indexate sunt referentiate ca parte \nintegranta a unor expresii.\nCurs - BAZE DE DATE 34\n\n2. Indecșii\nConfirmarea indecsilor \n• O lista completa de indecsi poate fi extrasa din \nvederea USER_INDEXES care contine numele \nindexului si daca acesta are o restrictie de \nunicitate. \nCurs - BAZE DE DATE 35\n\n2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '\n', '6. ', '2. Indecșii\nExemplu 1 - crearea unui index:\nO sa cream un index pentru departamente care ne va \najuta sa extragem foarte repede o inregistrare in \nfunctie de numele departamentului.\nCREATE INDEX department_name\nON dept(dname);\nCurs - BAZE DE DATE 30\n\n\nCand se creaza indecșii?\nExista mai multe situatii care necesita crearea indecsilor in \nbaza de date. \nUn index este creat daca:\n➢o singura coloana contine o varietate foarte mare de \nvalori si un numar mare de valori.\n➢campul din baza de date contine multe inregistrari de \ntip null\n➢campurile sunt folosite foarte frecvent in conditile de \nselectare a inregistrarilor sau in cazuri de JOIN\nCurs - BAZE DE DATE 31\n\nCand se creaza indecșii? (continuare)\n➢tabela pe care se creaza indexul este foarte mare si \ncererile in mod frecvent nu extrag o cantitate mare de \ndate (2-4% din cantitatea totala de informatii din tabela) \n➢in momentul in care anumite chei sunt create in tabela \nca si cheile unice si atunci Oracle genereaza automat un \nindex unic.\nCurs - BAZE DE DATE 32\n\nCand nu se creaza indecsii si de ce?\n➢In general nu tot timpul este necesar si bine sa fie creati \nindexi in baza de date.\n➢O creare excesiva de indecsi in baza de date are si multe \nneajunsuri. \n➢In momentul in care sunt adaugati indecsi, baza de date \nface o repunere la zi a lor pentru fiecare operatie care \neste executata. \n➢In momentul in care sunt creati prea multi indecsi \noperatile de extragere din baza de date isi amelioreaza \nviteza doar cu un raport mic dar pentru fiecare \noperatiune de inserare sau stergere timpul necesar \ncreste simtitor precum si resursele folosite. \nCurs - BAZE DE DATE 33\n\nDeci se pune problema cand nu sunt necesari indecsii:\n✓Cand tabela pe care se doreste adaugarea este mica.\n✓Cand coloanele pe care se adauga indecsii nu sunt \nfolosite frecvent pentru executarea de extrageri de \ninregistrari\n✓Cand cererile de tip SELECT in general extrag un numar \nmare de inregistrari (mai mare de 2-4%)\n✓Cand operatiuni de UPDATE sunt foarte des utilizate.\n✓Cand coloanele indexate sunt referentiate ca parte \nintegranta a unor expresii.\nCurs - BAZE DE DATE 34\n\n2. Indecșii\nConfirmarea indecsilor \n• O lista completa de indecsi poate fi extrasa din \nvederea USER_INDEXES care contine numele \nindexului si daca acesta are o restrictie de \nunicitate. \nCurs - BAZE DE DATE 35\n\n2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '\n', '7. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '8. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '9. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '10. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n']","acest tip de subinterogare se numește ""subinterogare single-row"". Ambele cereri interne returneaza valori singulare, astfel ca aceasta instructiune SQL este denumita o subinterogare single-row.
",Cum se numește subinterogarea care returnează o singură valoare pentru o condiție din clauza WHERE?,"['1. ', '6.2. MULTIPLE ROW SUBQUERIES\nVALORI NULL\n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci:\n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null.\n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic.\nCurs 6 - BAZE DE DATE 35\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi HAVING\n- Pot fi folosite cu subinterogările de tip multiple row.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) < ANY\n          ( SELECT sal\n             FROM EMP\n             WHERE deptno IN (10,20) );\nCurs 6 - BAZE DE DATE 36\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi \nHAVING\n- Pot fi folosite cu \nsubinterogările de tip \nmultiple row.\nCurs 6 - BAZE DE DATE 37\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\n  De asemenea, se poate folosi clauza GROUP BY intr-\no subinterogare\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > ALL\n    (SELECT MIN(sal)\n     FROM EMP\n     WHERE deptno < 40\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 38\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare\nCurs 6 - BAZE DE DATE 39\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi angajaţii ale căror salarii sunt \naceleaşi cu salariul minim din oricare (any) \ndepartament. \nSELECT ename\nFROM EMP\nWHERE sal = ANY\n    (SELECT MIN(sal)\n     FROM EMP\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 40\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi \nangajaţii ale căror salarii \nsunt aceleaşi cu (any) \ndepartament. salariul \nminim din oricare \nCurs 6 - BAZE DE DATE 41\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42\n\n6.2. MULTIPLE ROW SUBQUERIES\nSoluţia corectă este următoarea:\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) <\n  ( SELECT MIN(sal)\n    FROM EMP\n    WHERE deptno = 30);\nCurs 6 - BAZE DE DATE 43\n\nSubcereri multilinie \n• Subcererile multilinie returneaza mai mult decat o \nlinie. \n• Cu astfel de subinterogari trebuie folositi operatori \nmultilinie care pot prelucra una sau mai multe valori. \nOperatorii utilizati sunt: \n1. IN - egal cu oricare dintre membrii unei liste\n2. ANY/SOME - compara o valoare cu fiecare (vreo) \nvaloare returnata de subinterogare\n3. ALL - compara o valoare cu oricare (toate) din \nvalorile returnate de subinterogare\nCurs 6 - BAZE DE DATE 44', '\n', '2. ', '6.2. MULTIPLE ROW SUBQUERIES\nVALORI NULL\n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci:\n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null.\n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic.\nCurs 6 - BAZE DE DATE 35\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi HAVING\n- Pot fi folosite cu subinterogările de tip multiple row.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) < ANY\n          ( SELECT sal\n             FROM EMP\n             WHERE deptno IN (10,20) );\nCurs 6 - BAZE DE DATE 36\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi \nHAVING\n- Pot fi folosite cu \nsubinterogările de tip \nmultiple row.\nCurs 6 - BAZE DE DATE 37\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\n  De asemenea, se poate folosi clauza GROUP BY intr-\no subinterogare\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > ALL\n    (SELECT MIN(sal)\n     FROM EMP\n     WHERE deptno < 40\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 38\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare\nCurs 6 - BAZE DE DATE 39\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi angajaţii ale căror salarii sunt \naceleaşi cu salariul minim din oricare (any) \ndepartament. \nSELECT ename\nFROM EMP\nWHERE sal = ANY\n    (SELECT MIN(sal)\n     FROM EMP\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 40\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi \nangajaţii ale căror salarii \nsunt aceleaşi cu (any) \ndepartament. salariul \nminim din oricare \nCurs 6 - BAZE DE DATE 41\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42\n\n6.2. MULTIPLE ROW SUBQUERIES\nSoluţia corectă este următoarea:\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) <\n  ( SELECT MIN(sal)\n    FROM EMP\n    WHERE deptno = 30);\nCurs 6 - BAZE DE DATE 43\n\nSubcereri multilinie \n• Subcererile multilinie returneaza mai mult decat o \nlinie. \n• Cu astfel de subinterogari trebuie folositi operatori \nmultilinie care pot prelucra una sau mai multe valori. \nOperatorii utilizati sunt: \n1. IN - egal cu oricare dintre membrii unei liste\n2. ANY/SOME - compara o valoare cu fiecare (vreo) \nvaloare returnata de subinterogare\n3. ALL - compara o valoare cu oricare (toate) din \nvalorile returnate de subinterogare\nCurs 6 - BAZE DE DATE 44', '\n', '3. ', '6.2. MULTIPLE ROW SUBQUERIES\nVALORI NULL\n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci:\n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null.\n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic.\nCurs 6 - BAZE DE DATE 35\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi HAVING\n- Pot fi folosite cu subinterogările de tip multiple row.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) < ANY\n          ( SELECT sal\n             FROM EMP\n             WHERE deptno IN (10,20) );\nCurs 6 - BAZE DE DATE 36\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi \nHAVING\n- Pot fi folosite cu \nsubinterogările de tip \nmultiple row.\nCurs 6 - BAZE DE DATE 37\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\n  De asemenea, se poate folosi clauza GROUP BY intr-\no subinterogare\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > ALL\n    (SELECT MIN(sal)\n     FROM EMP\n     WHERE deptno < 40\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 38\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare\nCurs 6 - BAZE DE DATE 39\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi angajaţii ale căror salarii sunt \naceleaşi cu salariul minim din oricare (any) \ndepartament. \nSELECT ename\nFROM EMP\nWHERE sal = ANY\n    (SELECT MIN(sal)\n     FROM EMP\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 40\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi \nangajaţii ale căror salarii \nsunt aceleaşi cu (any) \ndepartament. salariul \nminim din oricare \nCurs 6 - BAZE DE DATE 41\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42\n\n6.2. MULTIPLE ROW SUBQUERIES\nSoluţia corectă este următoarea:\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) <\n  ( SELECT MIN(sal)\n    FROM EMP\n    WHERE deptno = 30);\nCurs 6 - BAZE DE DATE 43\n\nSubcereri multilinie \n• Subcererile multilinie returneaza mai mult decat o \nlinie. \n• Cu astfel de subinterogari trebuie folositi operatori \nmultilinie care pot prelucra una sau mai multe valori. \nOperatorii utilizati sunt: \n1. IN - egal cu oricare dintre membrii unei liste\n2. ANY/SOME - compara o valoare cu fiecare (vreo) \nvaloare returnata de subinterogare\n3. ALL - compara o valoare cu oricare (toate) din \nvalorile returnate de subinterogare\nCurs 6 - BAZE DE DATE 44', '\n', '4. ', '2. Indecșii\nExemplu 1 - crearea unui index:\nO sa cream un index pentru departamente care ne va \najuta sa extragem foarte repede o inregistrare in \nfunctie de numele departamentului.\nCREATE INDEX department_name\nON dept(dname);\nCurs - BAZE DE DATE 30\n\n\nCand se creaza indecșii?\nExista mai multe situatii care necesita crearea indecsilor in \nbaza de date. \nUn index este creat daca:\n➢o singura coloana contine o varietate foarte mare de \nvalori si un numar mare de valori.\n➢campul din baza de date contine multe inregistrari de \ntip null\n➢campurile sunt folosite foarte frecvent in conditile de \nselectare a inregistrarilor sau in cazuri de JOIN\nCurs - BAZE DE DATE 31\n\nCand se creaza indecșii? (continuare)\n➢tabela pe care se creaza indexul este foarte mare si \ncererile in mod frecvent nu extrag o cantitate mare de \ndate (2-4% din cantitatea totala de informatii din tabela) \n➢in momentul in care anumite chei sunt create in tabela \nca si cheile unice si atunci Oracle genereaza automat un \nindex unic.\nCurs - BAZE DE DATE 32\n\nCand nu se creaza indecsii si de ce?\n➢In general nu tot timpul este necesar si bine sa fie creati \nindexi in baza de date.\n➢O creare excesiva de indecsi in baza de date are si multe \nneajunsuri. \n➢In momentul in care sunt adaugati indecsi, baza de date \nface o repunere la zi a lor pentru fiecare operatie care \neste executata. \n➢In momentul in care sunt creati prea multi indecsi \noperatile de extragere din baza de date isi amelioreaza \nviteza doar cu un raport mic dar pentru fiecare \noperatiune de inserare sau stergere timpul necesar \ncreste simtitor precum si resursele folosite. \nCurs - BAZE DE DATE 33\n\nDeci se pune problema cand nu sunt necesari indecsii:\n✓Cand tabela pe care se doreste adaugarea este mica.\n✓Cand coloanele pe care se adauga indecsii nu sunt \nfolosite frecvent pentru executarea de extrageri de \ninregistrari\n✓Cand cererile de tip SELECT in general extrag un numar \nmare de inregistrari (mai mare de 2-4%)\n✓Cand operatiuni de UPDATE sunt foarte des utilizate.\n✓Cand coloanele indexate sunt referentiate ca parte \nintegranta a unor expresii.\nCurs - BAZE DE DATE 34\n\n2. Indecșii\nConfirmarea indecsilor \n• O lista completa de indecsi poate fi extrasa din \nvederea USER_INDEXES care contine numele \nindexului si daca acesta are o restrictie de \nunicitate. \nCurs - BAZE DE DATE 35\n\n2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '\n', '5. ', '2. Indecșii\nExemplu 1 - crearea unui index:\nO sa cream un index pentru departamente care ne va \najuta sa extragem foarte repede o inregistrare in \nfunctie de numele departamentului.\nCREATE INDEX department_name\nON dept(dname);\nCurs - BAZE DE DATE 30\n\n\nCand se creaza indecșii?\nExista mai multe situatii care necesita crearea indecsilor in \nbaza de date. \nUn index este creat daca:\n➢o singura coloana contine o varietate foarte mare de \nvalori si un numar mare de valori.\n➢campul din baza de date contine multe inregistrari de \ntip null\n➢campurile sunt folosite foarte frecvent in conditile de \nselectare a inregistrarilor sau in cazuri de JOIN\nCurs - BAZE DE DATE 31\n\nCand se creaza indecșii? (continuare)\n➢tabela pe care se creaza indexul este foarte mare si \ncererile in mod frecvent nu extrag o cantitate mare de \ndate (2-4% din cantitatea totala de informatii din tabela) \n➢in momentul in care anumite chei sunt create in tabela \nca si cheile unice si atunci Oracle genereaza automat un \nindex unic.\nCurs - BAZE DE DATE 32\n\nCand nu se creaza indecsii si de ce?\n➢In general nu tot timpul este necesar si bine sa fie creati \nindexi in baza de date.\n➢O creare excesiva de indecsi in baza de date are si multe \nneajunsuri. \n➢In momentul in care sunt adaugati indecsi, baza de date \nface o repunere la zi a lor pentru fiecare operatie care \neste executata. \n➢In momentul in care sunt creati prea multi indecsi \noperatile de extragere din baza de date isi amelioreaza \nviteza doar cu un raport mic dar pentru fiecare \noperatiune de inserare sau stergere timpul necesar \ncreste simtitor precum si resursele folosite. \nCurs - BAZE DE DATE 33\n\nDeci se pune problema cand nu sunt necesari indecsii:\n✓Cand tabela pe care se doreste adaugarea este mica.\n✓Cand coloanele pe care se adauga indecsii nu sunt \nfolosite frecvent pentru executarea de extrageri de \ninregistrari\n✓Cand cererile de tip SELECT in general extrag un numar \nmare de inregistrari (mai mare de 2-4%)\n✓Cand operatiuni de UPDATE sunt foarte des utilizate.\n✓Cand coloanele indexate sunt referentiate ca parte \nintegranta a unor expresii.\nCurs - BAZE DE DATE 34\n\n2. Indecșii\nConfirmarea indecsilor \n• O lista completa de indecsi poate fi extrasa din \nvederea USER_INDEXES care contine numele \nindexului si daca acesta are o restrictie de \nunicitate. \nCurs - BAZE DE DATE 35\n\n2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '\n', '6. ', '2. Indecșii\nExemplu 1 - crearea unui index:\nO sa cream un index pentru departamente care ne va \najuta sa extragem foarte repede o inregistrare in \nfunctie de numele departamentului.\nCREATE INDEX department_name\nON dept(dname);\nCurs - BAZE DE DATE 30\n\n\nCand se creaza indecșii?\nExista mai multe situatii care necesita crearea indecsilor in \nbaza de date. \nUn index este creat daca:\n➢o singura coloana contine o varietate foarte mare de \nvalori si un numar mare de valori.\n➢campul din baza de date contine multe inregistrari de \ntip null\n➢campurile sunt folosite foarte frecvent in conditile de \nselectare a inregistrarilor sau in cazuri de JOIN\nCurs - BAZE DE DATE 31\n\nCand se creaza indecșii? (continuare)\n➢tabela pe care se creaza indexul este foarte mare si \ncererile in mod frecvent nu extrag o cantitate mare de \ndate (2-4% din cantitatea totala de informatii din tabela) \n➢in momentul in care anumite chei sunt create in tabela \nca si cheile unice si atunci Oracle genereaza automat un \nindex unic.\nCurs - BAZE DE DATE 32\n\nCand nu se creaza indecsii si de ce?\n➢In general nu tot timpul este necesar si bine sa fie creati \nindexi in baza de date.\n➢O creare excesiva de indecsi in baza de date are si multe \nneajunsuri. \n➢In momentul in care sunt adaugati indecsi, baza de date \nface o repunere la zi a lor pentru fiecare operatie care \neste executata. \n➢In momentul in care sunt creati prea multi indecsi \noperatile de extragere din baza de date isi amelioreaza \nviteza doar cu un raport mic dar pentru fiecare \noperatiune de inserare sau stergere timpul necesar \ncreste simtitor precum si resursele folosite. \nCurs - BAZE DE DATE 33\n\nDeci se pune problema cand nu sunt necesari indecsii:\n✓Cand tabela pe care se doreste adaugarea este mica.\n✓Cand coloanele pe care se adauga indecsii nu sunt \nfolosite frecvent pentru executarea de extrageri de \ninregistrari\n✓Cand cererile de tip SELECT in general extrag un numar \nmare de inregistrari (mai mare de 2-4%)\n✓Cand operatiuni de UPDATE sunt foarte des utilizate.\n✓Cand coloanele indexate sunt referentiate ca parte \nintegranta a unor expresii.\nCurs - BAZE DE DATE 34\n\n2. Indecșii\nConfirmarea indecsilor \n• O lista completa de indecsi poate fi extrasa din \nvederea USER_INDEXES care contine numele \nindexului si daca acesta are o restrictie de \nunicitate. \nCurs - BAZE DE DATE 35\n\n2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '\n', '7. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '8. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '9. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '10. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n']","acest tip de subinterogare se numește ""subinterogare single-row"". Ambele cereri interne returneaza valori singulare, astfel ca aceasta instructiune SQL este denumita o subinterogare single-row.
",subinterogare single-row,0.09756804289918691,1.0,0.827967818261965,1.0,0.08392229812593097,0.19999999999999998,0.5
6,O3mini-high,LOW,C7,,Ce instrucțiune SQL permite inserarea sau actualizarea condiționată a datelor?,MERGE,Este corect,,"['1. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '2. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '3. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '4. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '5. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '6. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '7. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n', '8. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n', '9. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n', '10. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n']","instrucțiunea SQL care permite inserarea sau actualizarea condiționată a datelor este `MERGE`. Aceasta este menționată ca una dintre funcțiile DML (Data Manipulation Language) în Oracle 12c, alături de `INSERT`, `UPDATE` și `DELETE`.
",Ce instrucțiune SQL permite inserarea sau actualizarea condiționată a datelor?,"['1. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '2. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '3. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '4. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '5. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '6. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '7. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n', '8. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n', '9. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n', '10. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n']","instrucțiunea SQL care permite inserarea sau actualizarea condiționată a datelor este `MERGE`. Aceasta este menționată ca una dintre funcțiile DML (Data Manipulation Language) în Oracle 12c, alături de `INSERT`, `UPDATE` și `DELETE`.
",MERGE,0.14603746636629625,1.0,0.8914600926655908,1.0,0.028398387225677894,0.052631578947368425,0.0
7,O3mini-high,LOW,C8,,Ce constrângere SQL impune ca o coloană să nu accepte valori NULL?,NOT NULL,Este corect,,"['1. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '2. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '3. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '4. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '5. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '6. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '7. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '8. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '9. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '10. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n']","nu există detalii despre constrângeri SQL în documentele furnizate.
",Ce constrângere SQL impune ca o coloană să nu accepte valori NULL?,"['1. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '2. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '3. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '4. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '5. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '6. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '7. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '8. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '9. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '10. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n']","nu există detalii despre constrângeri SQL în documentele furnizate.
",NOT NULL,0.0,0.0,0.0,0.0,0.0,0.0,0.0
8,O3mini-high,LOW,C9,,"Cu ce instrucțiune SQL se creează o vedere, adică o tabelă virtuală care extrage date din tabelele reale?",CREATE VIEW,Este corect,,"['1. ', ""Curs 9\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3\n\n O vedere este o tabelă logică care extrage \ndate dintr-o tabelă propriu-zisă sau dintr-o \naltă vedere. \n  O vedere nu are date proprii, ci este ca o \nfereastră prin care datele din tabele pot fi \nactualizate sau vizualizate. \n  O vedere poate să conţină toate datele \ndintr-o tabelă (sau mai multe) sau anumite \ncoloane. \nCurs - BAZE DE DATE 4\n\nVederile se folosesc pentru că oferă: \n1. Acces restricţionat la date (vederile pot \nselecţiona anumite coloane dintr-o tabelă)\n2. Posibilitatea lucrului cu interogări complexe\n3. Independenţa datelor\n4. Posibilitatea prezentării de date identice în \nvederi diferite\nCurs - BAZE DE DATE 5\n\nAvantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6\n\nClasificare\n Vederile se clasifică în: \n1.vederi simple\n2.vederi complexe\n  Pentru început prezentăm vederile \nsimple. \nCurs - BAZE DE DATE 7\n\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8\n\nSintaxa \nCREATE [OR REPLACE] [FORCE|NOFORCE] VIEW \nview   [ (alias [, alias]...) ] \n AS subquery \n[WITH CHECK OPTION [CONSTRAINT \nconstraint] ]\n[WITH READ ONLY [CONSTRAINT constraint] ];\nCurs - BAZE DE DATE 9\n\nSemnificaţia argumentelor sintaxei: \n• OR REPLACE: determină înlocuirea vederii dacă \naceasta există deja\n• FORCE: crearea vederii indiferent dacă tabela din care \nprovin datele nu există\n• NOFORCE: crearea vederii numai dacă tabela există \n(valoarea implicită)\n• view: numele vederii\n• alias: specifică numele expresiilor selectate de către \ncererea din vedere (numele coloanelor selectate). \nNumărul alias-urilor trebuie să fie egal cu numărul \ncoloanelor selectate.\nCurs - BAZE DE DATE 10\n\n• subquery: cererea SELECT care generează \nvederea \n• WITH CHECK OPTION: numai rândurile accesibile \nvederii pot fi actualizate\n• constraint: numele constrângerii asociate cu \nWITH CHECK OPTION\n• WITH READ ONLY: asigură că nici o operaţie DML \n(INSERT, UPDATE, DELETE) nu va fi executată prin \nvedere.\nCurs - BAZE DE DATE 11\n\nExemplu \n Să cream o vedere emp20 care va conţine \npersoanele din departamentul 20. \n  Mai întâi trebuie să ne asigurăm că vederea \nemp20 nu există deja. \nCurs - BAZE DE DATE 12\n\nSELECT OBJECT_NAME, OBJECT_TYPE \nFROM USER_OBJECTS \nWHERE OBJECT_TYPE='VIEW'\nAceastă vedere nu există deci putem să o cream. \n \nCurs - BAZE DE DATE 13"", '\n', '2. ', ""Curs 9\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3\n\n O vedere este o tabelă logică care extrage \ndate dintr-o tabelă propriu-zisă sau dintr-o \naltă vedere. \n  O vedere nu are date proprii, ci este ca o \nfereastră prin care datele din tabele pot fi \nactualizate sau vizualizate. \n  O vedere poate să conţină toate datele \ndintr-o tabelă (sau mai multe) sau anumite \ncoloane. \nCurs - BAZE DE DATE 4\n\nVederile se folosesc pentru că oferă: \n1. Acces restricţionat la date (vederile pot \nselecţiona anumite coloane dintr-o tabelă)\n2. Posibilitatea lucrului cu interogări complexe\n3. Independenţa datelor\n4. Posibilitatea prezentării de date identice în \nvederi diferite\nCurs - BAZE DE DATE 5\n\nAvantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6\n\nClasificare\n Vederile se clasifică în: \n1.vederi simple\n2.vederi complexe\n  Pentru început prezentăm vederile \nsimple. \nCurs - BAZE DE DATE 7\n\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8\n\nSintaxa \nCREATE [OR REPLACE] [FORCE|NOFORCE] VIEW \nview   [ (alias [, alias]...) ] \n AS subquery \n[WITH CHECK OPTION [CONSTRAINT \nconstraint] ]\n[WITH READ ONLY [CONSTRAINT constraint] ];\nCurs - BAZE DE DATE 9\n\nSemnificaţia argumentelor sintaxei: \n• OR REPLACE: determină înlocuirea vederii dacă \naceasta există deja\n• FORCE: crearea vederii indiferent dacă tabela din care \nprovin datele nu există\n• NOFORCE: crearea vederii numai dacă tabela există \n(valoarea implicită)\n• view: numele vederii\n• alias: specifică numele expresiilor selectate de către \ncererea din vedere (numele coloanelor selectate). \nNumărul alias-urilor trebuie să fie egal cu numărul \ncoloanelor selectate.\nCurs - BAZE DE DATE 10\n\n• subquery: cererea SELECT care generează \nvederea \n• WITH CHECK OPTION: numai rândurile accesibile \nvederii pot fi actualizate\n• constraint: numele constrângerii asociate cu \nWITH CHECK OPTION\n• WITH READ ONLY: asigură că nici o operaţie DML \n(INSERT, UPDATE, DELETE) nu va fi executată prin \nvedere.\nCurs - BAZE DE DATE 11\n\nExemplu \n Să cream o vedere emp20 care va conţine \npersoanele din departamentul 20. \n  Mai întâi trebuie să ne asigurăm că vederea \nemp20 nu există deja. \nCurs - BAZE DE DATE 12\n\nSELECT OBJECT_NAME, OBJECT_TYPE \nFROM USER_OBJECTS \nWHERE OBJECT_TYPE='VIEW'\nAceastă vedere nu există deci putem să o cream. \n \nCurs - BAZE DE DATE 13"", '\n', '3. ', ""Curs 9\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3\n\n O vedere este o tabelă logică care extrage \ndate dintr-o tabelă propriu-zisă sau dintr-o \naltă vedere. \n  O vedere nu are date proprii, ci este ca o \nfereastră prin care datele din tabele pot fi \nactualizate sau vizualizate. \n  O vedere poate să conţină toate datele \ndintr-o tabelă (sau mai multe) sau anumite \ncoloane. \nCurs - BAZE DE DATE 4\n\nVederile se folosesc pentru că oferă: \n1. Acces restricţionat la date (vederile pot \nselecţiona anumite coloane dintr-o tabelă)\n2. Posibilitatea lucrului cu interogări complexe\n3. Independenţa datelor\n4. Posibilitatea prezentării de date identice în \nvederi diferite\nCurs - BAZE DE DATE 5\n\nAvantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6\n\nClasificare\n Vederile se clasifică în: \n1.vederi simple\n2.vederi complexe\n  Pentru început prezentăm vederile \nsimple. \nCurs - BAZE DE DATE 7\n\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8\n\nSintaxa \nCREATE [OR REPLACE] [FORCE|NOFORCE] VIEW \nview   [ (alias [, alias]...) ] \n AS subquery \n[WITH CHECK OPTION [CONSTRAINT \nconstraint] ]\n[WITH READ ONLY [CONSTRAINT constraint] ];\nCurs - BAZE DE DATE 9\n\nSemnificaţia argumentelor sintaxei: \n• OR REPLACE: determină înlocuirea vederii dacă \naceasta există deja\n• FORCE: crearea vederii indiferent dacă tabela din care \nprovin datele nu există\n• NOFORCE: crearea vederii numai dacă tabela există \n(valoarea implicită)\n• view: numele vederii\n• alias: specifică numele expresiilor selectate de către \ncererea din vedere (numele coloanelor selectate). \nNumărul alias-urilor trebuie să fie egal cu numărul \ncoloanelor selectate.\nCurs - BAZE DE DATE 10\n\n• subquery: cererea SELECT care generează \nvederea \n• WITH CHECK OPTION: numai rândurile accesibile \nvederii pot fi actualizate\n• constraint: numele constrângerii asociate cu \nWITH CHECK OPTION\n• WITH READ ONLY: asigură că nici o operaţie DML \n(INSERT, UPDATE, DELETE) nu va fi executată prin \nvedere.\nCurs - BAZE DE DATE 11\n\nExemplu \n Să cream o vedere emp20 care va conţine \npersoanele din departamentul 20. \n  Mai întâi trebuie să ne asigurăm că vederea \nemp20 nu există deja. \nCurs - BAZE DE DATE 12\n\nSELECT OBJECT_NAME, OBJECT_TYPE \nFROM USER_OBJECTS \nWHERE OBJECT_TYPE='VIEW'\nAceastă vedere nu există deci putem să o cream. \n \nCurs - BAZE DE DATE 13"", '\n', '4. ', 'Extragere de date dintr-o vedere\n➢Extragerea de date se face exact ca în cazul \nunei tabele. \n➢Se pot selecta anumite rânduri sau toată \nvederea. \nSELECT * FROM emp10;\nCurs - BAZE DE DATE 26\n\n\nInterogarea unei vederi\nInterogarea unei vederi de către serverul \nORACLE se face în felul următor: \n1. Extragere definiţie vedere din tabela \ndicţionarului de date USER_VIEWS\n2. Verificare drepturi acces pentru tabela vederii\n3. Convertire interogare vedere într-o interogare \nechivalentă a tabelei vederii. \nDeci datele sunt extrase, inserate din tabele \npropriu-zise. \nCurs - BAZE DE DATE 27\n\nModificarea unei vederi\nPână acum am verificat dacă vederea \nexistă sau nu şi numai în cazul în care nu exista \no cream. \nAvem posibilitatea de a crea o vedere chiar \ndacă ea există, înlocuind-o pe cea veche cu o \nnouă versiune. \nCurs - BAZE DE DATE 28\n\nÎn acest scop se foloseşte clauza OR REPLACE. \nVom înlocui vederea emp20 cu alta.\nCREATE OR REPLACE VIEW emp20 (COD, NUME, \nSAL_ANUAL)\n AS SELECT  empno, ename, sal * 12 \n     FROM   emp\n     WHERE  deptno = 20;\nCurs - BAZE DE DATE 29\n\n\nExerciţiu \nVizualizaţi conţinutul vederii cu o cerere SELECT. \nCurs - BAZE DE DATE 30\n\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCREATE OR REPLACE VIEW dept_sal(Denumire_dept, \nSAL_MIN, SAL_MAX, SAL_MEDIU)\n AS SELECT  d.dname, MIN(e.sal), MAX(e.sal), \nAVG(e.sal) \n     FROM   emp e, dept d\n     WHERE  d.deptno = e.deptno\n     GROUP BY d.dname;\nCurs - BAZE DE DATE 31\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n\n\nNOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n\n\nEfectuarea operaţiilor DML asupra vederilor\nSe pot efectua operaţii DML asupra \nvederilor, dar numai în anumite condiţii. \na) Nu se poate şterge un rând dintr-o \nvedere care conţine: \n1. funcţii de grup\n2. GROUP BY\n3. DISTINCT\n4. ROWNUM\nCurs - BAZE DE DATE 34\n\nb) De asemenea nu se pot modifica date printr-o vedere \ndacă aceasta verifică condiţiile de mai sus şi dacă există \ncoloane definite prin expresii cum ar fi SALARIU*12. \nc) Adăugarea de date printr-o vedere este imposibilădacă\nvederea conţine elementele enumerate mai sus şi dacă\nexistă coloane NOT NULL în tabela neselectate de către\nvedere.\nPrin adăugare de date se modifică de fapt tabela propriu-\nzisă deci în coloanele neselectate se va adăuga NULL\nceea ce încalcă constrângerea.\nCurs - BAZE DE DATE 35\n\nExemplu - Crearea vederii dept_sal utilizând clauza OR \nREPLACE. \nCREATE OR REPLACE VIEW dept_sal (COD, SAL_MEDIU)\n  AS SELECT deptno, AVG(sal)\n    FROM     emp\n    GROUP BY deptno;\n \nCurs - BAZE DE DATE 36', '\n', '5. ', 'Extragere de date dintr-o vedere\n➢Extragerea de date se face exact ca în cazul \nunei tabele. \n➢Se pot selecta anumite rânduri sau toată \nvederea. \nSELECT * FROM emp10;\nCurs - BAZE DE DATE 26\n\n\nInterogarea unei vederi\nInterogarea unei vederi de către serverul \nORACLE se face în felul următor: \n1. Extragere definiţie vedere din tabela \ndicţionarului de date USER_VIEWS\n2. Verificare drepturi acces pentru tabela vederii\n3. Convertire interogare vedere într-o interogare \nechivalentă a tabelei vederii. \nDeci datele sunt extrase, inserate din tabele \npropriu-zise. \nCurs - BAZE DE DATE 27\n\nModificarea unei vederi\nPână acum am verificat dacă vederea \nexistă sau nu şi numai în cazul în care nu exista \no cream. \nAvem posibilitatea de a crea o vedere chiar \ndacă ea există, înlocuind-o pe cea veche cu o \nnouă versiune. \nCurs - BAZE DE DATE 28\n\nÎn acest scop se foloseşte clauza OR REPLACE. \nVom înlocui vederea emp20 cu alta.\nCREATE OR REPLACE VIEW emp20 (COD, NUME, \nSAL_ANUAL)\n AS SELECT  empno, ename, sal * 12 \n     FROM   emp\n     WHERE  deptno = 20;\nCurs - BAZE DE DATE 29\n\n\nExerciţiu \nVizualizaţi conţinutul vederii cu o cerere SELECT. \nCurs - BAZE DE DATE 30\n\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCREATE OR REPLACE VIEW dept_sal(Denumire_dept, \nSAL_MIN, SAL_MAX, SAL_MEDIU)\n AS SELECT  d.dname, MIN(e.sal), MAX(e.sal), \nAVG(e.sal) \n     FROM   emp e, dept d\n     WHERE  d.deptno = e.deptno\n     GROUP BY d.dname;\nCurs - BAZE DE DATE 31\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n\n\nNOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n\n\nEfectuarea operaţiilor DML asupra vederilor\nSe pot efectua operaţii DML asupra \nvederilor, dar numai în anumite condiţii. \na) Nu se poate şterge un rând dintr-o \nvedere care conţine: \n1. funcţii de grup\n2. GROUP BY\n3. DISTINCT\n4. ROWNUM\nCurs - BAZE DE DATE 34\n\nb) De asemenea nu se pot modifica date printr-o vedere \ndacă aceasta verifică condiţiile de mai sus şi dacă există \ncoloane definite prin expresii cum ar fi SALARIU*12. \nc) Adăugarea de date printr-o vedere este imposibilădacă\nvederea conţine elementele enumerate mai sus şi dacă\nexistă coloane NOT NULL în tabela neselectate de către\nvedere.\nPrin adăugare de date se modifică de fapt tabela propriu-\nzisă deci în coloanele neselectate se va adăuga NULL\nceea ce încalcă constrângerea.\nCurs - BAZE DE DATE 35\n\nExemplu - Crearea vederii dept_sal utilizând clauza OR \nREPLACE. \nCREATE OR REPLACE VIEW dept_sal (COD, SAL_MEDIU)\n  AS SELECT deptno, AVG(sal)\n    FROM     emp\n    GROUP BY deptno;\n \nCurs - BAZE DE DATE 36', '\n', '6. ', 'Extragere de date dintr-o vedere\n➢Extragerea de date se face exact ca în cazul \nunei tabele. \n➢Se pot selecta anumite rânduri sau toată \nvederea. \nSELECT * FROM emp10;\nCurs - BAZE DE DATE 26\n\n\nInterogarea unei vederi\nInterogarea unei vederi de către serverul \nORACLE se face în felul următor: \n1. Extragere definiţie vedere din tabela \ndicţionarului de date USER_VIEWS\n2. Verificare drepturi acces pentru tabela vederii\n3. Convertire interogare vedere într-o interogare \nechivalentă a tabelei vederii. \nDeci datele sunt extrase, inserate din tabele \npropriu-zise. \nCurs - BAZE DE DATE 27\n\nModificarea unei vederi\nPână acum am verificat dacă vederea \nexistă sau nu şi numai în cazul în care nu exista \no cream. \nAvem posibilitatea de a crea o vedere chiar \ndacă ea există, înlocuind-o pe cea veche cu o \nnouă versiune. \nCurs - BAZE DE DATE 28\n\nÎn acest scop se foloseşte clauza OR REPLACE. \nVom înlocui vederea emp20 cu alta.\nCREATE OR REPLACE VIEW emp20 (COD, NUME, \nSAL_ANUAL)\n AS SELECT  empno, ename, sal * 12 \n     FROM   emp\n     WHERE  deptno = 20;\nCurs - BAZE DE DATE 29\n\n\nExerciţiu \nVizualizaţi conţinutul vederii cu o cerere SELECT. \nCurs - BAZE DE DATE 30\n\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCREATE OR REPLACE VIEW dept_sal(Denumire_dept, \nSAL_MIN, SAL_MAX, SAL_MEDIU)\n AS SELECT  d.dname, MIN(e.sal), MAX(e.sal), \nAVG(e.sal) \n     FROM   emp e, dept d\n     WHERE  d.deptno = e.deptno\n     GROUP BY d.dname;\nCurs - BAZE DE DATE 31\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n\n\nNOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n\n\nEfectuarea operaţiilor DML asupra vederilor\nSe pot efectua operaţii DML asupra \nvederilor, dar numai în anumite condiţii. \na) Nu se poate şterge un rând dintr-o \nvedere care conţine: \n1. funcţii de grup\n2. GROUP BY\n3. DISTINCT\n4. ROWNUM\nCurs - BAZE DE DATE 34\n\nb) De asemenea nu se pot modifica date printr-o vedere \ndacă aceasta verifică condiţiile de mai sus şi dacă există \ncoloane definite prin expresii cum ar fi SALARIU*12. \nc) Adăugarea de date printr-o vedere este imposibilădacă\nvederea conţine elementele enumerate mai sus şi dacă\nexistă coloane NOT NULL în tabela neselectate de către\nvedere.\nPrin adăugare de date se modifică de fapt tabela propriu-\nzisă deci în coloanele neselectate se va adăuga NULL\nceea ce încalcă constrângerea.\nCurs - BAZE DE DATE 35\n\nExemplu - Crearea vederii dept_sal utilizând clauza OR \nREPLACE. \nCREATE OR REPLACE VIEW dept_sal (COD, SAL_MEDIU)\n  AS SELECT deptno, AVG(sal)\n    FROM     emp\n    GROUP BY deptno;\n \nCurs - BAZE DE DATE 36', '\n', '7. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '8. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '9. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '10. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n']","instrucțiunea SQL pentru a crea o vedere este: `CREATE VIEW view AS subquery`.
","Cu ce instrucțiune SQL se creează o vedere, adică o tabelă virtuală care extrage date din tabelele reale?","['1. ', ""Curs 9\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3\n\n O vedere este o tabelă logică care extrage \ndate dintr-o tabelă propriu-zisă sau dintr-o \naltă vedere. \n  O vedere nu are date proprii, ci este ca o \nfereastră prin care datele din tabele pot fi \nactualizate sau vizualizate. \n  O vedere poate să conţină toate datele \ndintr-o tabelă (sau mai multe) sau anumite \ncoloane. \nCurs - BAZE DE DATE 4\n\nVederile se folosesc pentru că oferă: \n1. Acces restricţionat la date (vederile pot \nselecţiona anumite coloane dintr-o tabelă)\n2. Posibilitatea lucrului cu interogări complexe\n3. Independenţa datelor\n4. Posibilitatea prezentării de date identice în \nvederi diferite\nCurs - BAZE DE DATE 5\n\nAvantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6\n\nClasificare\n Vederile se clasifică în: \n1.vederi simple\n2.vederi complexe\n  Pentru început prezentăm vederile \nsimple. \nCurs - BAZE DE DATE 7\n\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8\n\nSintaxa \nCREATE [OR REPLACE] [FORCE|NOFORCE] VIEW \nview   [ (alias [, alias]...) ] \n AS subquery \n[WITH CHECK OPTION [CONSTRAINT \nconstraint] ]\n[WITH READ ONLY [CONSTRAINT constraint] ];\nCurs - BAZE DE DATE 9\n\nSemnificaţia argumentelor sintaxei: \n• OR REPLACE: determină înlocuirea vederii dacă \naceasta există deja\n• FORCE: crearea vederii indiferent dacă tabela din care \nprovin datele nu există\n• NOFORCE: crearea vederii numai dacă tabela există \n(valoarea implicită)\n• view: numele vederii\n• alias: specifică numele expresiilor selectate de către \ncererea din vedere (numele coloanelor selectate). \nNumărul alias-urilor trebuie să fie egal cu numărul \ncoloanelor selectate.\nCurs - BAZE DE DATE 10\n\n• subquery: cererea SELECT care generează \nvederea \n• WITH CHECK OPTION: numai rândurile accesibile \nvederii pot fi actualizate\n• constraint: numele constrângerii asociate cu \nWITH CHECK OPTION\n• WITH READ ONLY: asigură că nici o operaţie DML \n(INSERT, UPDATE, DELETE) nu va fi executată prin \nvedere.\nCurs - BAZE DE DATE 11\n\nExemplu \n Să cream o vedere emp20 care va conţine \npersoanele din departamentul 20. \n  Mai întâi trebuie să ne asigurăm că vederea \nemp20 nu există deja. \nCurs - BAZE DE DATE 12\n\nSELECT OBJECT_NAME, OBJECT_TYPE \nFROM USER_OBJECTS \nWHERE OBJECT_TYPE='VIEW'\nAceastă vedere nu există deci putem să o cream. \n \nCurs - BAZE DE DATE 13"", '\n', '2. ', ""Curs 9\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3\n\n O vedere este o tabelă logică care extrage \ndate dintr-o tabelă propriu-zisă sau dintr-o \naltă vedere. \n  O vedere nu are date proprii, ci este ca o \nfereastră prin care datele din tabele pot fi \nactualizate sau vizualizate. \n  O vedere poate să conţină toate datele \ndintr-o tabelă (sau mai multe) sau anumite \ncoloane. \nCurs - BAZE DE DATE 4\n\nVederile se folosesc pentru că oferă: \n1. Acces restricţionat la date (vederile pot \nselecţiona anumite coloane dintr-o tabelă)\n2. Posibilitatea lucrului cu interogări complexe\n3. Independenţa datelor\n4. Posibilitatea prezentării de date identice în \nvederi diferite\nCurs - BAZE DE DATE 5\n\nAvantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6\n\nClasificare\n Vederile se clasifică în: \n1.vederi simple\n2.vederi complexe\n  Pentru început prezentăm vederile \nsimple. \nCurs - BAZE DE DATE 7\n\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8\n\nSintaxa \nCREATE [OR REPLACE] [FORCE|NOFORCE] VIEW \nview   [ (alias [, alias]...) ] \n AS subquery \n[WITH CHECK OPTION [CONSTRAINT \nconstraint] ]\n[WITH READ ONLY [CONSTRAINT constraint] ];\nCurs - BAZE DE DATE 9\n\nSemnificaţia argumentelor sintaxei: \n• OR REPLACE: determină înlocuirea vederii dacă \naceasta există deja\n• FORCE: crearea vederii indiferent dacă tabela din care \nprovin datele nu există\n• NOFORCE: crearea vederii numai dacă tabela există \n(valoarea implicită)\n• view: numele vederii\n• alias: specifică numele expresiilor selectate de către \ncererea din vedere (numele coloanelor selectate). \nNumărul alias-urilor trebuie să fie egal cu numărul \ncoloanelor selectate.\nCurs - BAZE DE DATE 10\n\n• subquery: cererea SELECT care generează \nvederea \n• WITH CHECK OPTION: numai rândurile accesibile \nvederii pot fi actualizate\n• constraint: numele constrângerii asociate cu \nWITH CHECK OPTION\n• WITH READ ONLY: asigură că nici o operaţie DML \n(INSERT, UPDATE, DELETE) nu va fi executată prin \nvedere.\nCurs - BAZE DE DATE 11\n\nExemplu \n Să cream o vedere emp20 care va conţine \npersoanele din departamentul 20. \n  Mai întâi trebuie să ne asigurăm că vederea \nemp20 nu există deja. \nCurs - BAZE DE DATE 12\n\nSELECT OBJECT_NAME, OBJECT_TYPE \nFROM USER_OBJECTS \nWHERE OBJECT_TYPE='VIEW'\nAceastă vedere nu există deci putem să o cream. \n \nCurs - BAZE DE DATE 13"", '\n', '3. ', ""Curs 9\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3\n\n O vedere este o tabelă logică care extrage \ndate dintr-o tabelă propriu-zisă sau dintr-o \naltă vedere. \n  O vedere nu are date proprii, ci este ca o \nfereastră prin care datele din tabele pot fi \nactualizate sau vizualizate. \n  O vedere poate să conţină toate datele \ndintr-o tabelă (sau mai multe) sau anumite \ncoloane. \nCurs - BAZE DE DATE 4\n\nVederile se folosesc pentru că oferă: \n1. Acces restricţionat la date (vederile pot \nselecţiona anumite coloane dintr-o tabelă)\n2. Posibilitatea lucrului cu interogări complexe\n3. Independenţa datelor\n4. Posibilitatea prezentării de date identice în \nvederi diferite\nCurs - BAZE DE DATE 5\n\nAvantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6\n\nClasificare\n Vederile se clasifică în: \n1.vederi simple\n2.vederi complexe\n  Pentru început prezentăm vederile \nsimple. \nCurs - BAZE DE DATE 7\n\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8\n\nSintaxa \nCREATE [OR REPLACE] [FORCE|NOFORCE] VIEW \nview   [ (alias [, alias]...) ] \n AS subquery \n[WITH CHECK OPTION [CONSTRAINT \nconstraint] ]\n[WITH READ ONLY [CONSTRAINT constraint] ];\nCurs - BAZE DE DATE 9\n\nSemnificaţia argumentelor sintaxei: \n• OR REPLACE: determină înlocuirea vederii dacă \naceasta există deja\n• FORCE: crearea vederii indiferent dacă tabela din care \nprovin datele nu există\n• NOFORCE: crearea vederii numai dacă tabela există \n(valoarea implicită)\n• view: numele vederii\n• alias: specifică numele expresiilor selectate de către \ncererea din vedere (numele coloanelor selectate). \nNumărul alias-urilor trebuie să fie egal cu numărul \ncoloanelor selectate.\nCurs - BAZE DE DATE 10\n\n• subquery: cererea SELECT care generează \nvederea \n• WITH CHECK OPTION: numai rândurile accesibile \nvederii pot fi actualizate\n• constraint: numele constrângerii asociate cu \nWITH CHECK OPTION\n• WITH READ ONLY: asigură că nici o operaţie DML \n(INSERT, UPDATE, DELETE) nu va fi executată prin \nvedere.\nCurs - BAZE DE DATE 11\n\nExemplu \n Să cream o vedere emp20 care va conţine \npersoanele din departamentul 20. \n  Mai întâi trebuie să ne asigurăm că vederea \nemp20 nu există deja. \nCurs - BAZE DE DATE 12\n\nSELECT OBJECT_NAME, OBJECT_TYPE \nFROM USER_OBJECTS \nWHERE OBJECT_TYPE='VIEW'\nAceastă vedere nu există deci putem să o cream. \n \nCurs - BAZE DE DATE 13"", '\n', '4. ', 'Extragere de date dintr-o vedere\n➢Extragerea de date se face exact ca în cazul \nunei tabele. \n➢Se pot selecta anumite rânduri sau toată \nvederea. \nSELECT * FROM emp10;\nCurs - BAZE DE DATE 26\n\n\nInterogarea unei vederi\nInterogarea unei vederi de către serverul \nORACLE se face în felul următor: \n1. Extragere definiţie vedere din tabela \ndicţionarului de date USER_VIEWS\n2. Verificare drepturi acces pentru tabela vederii\n3. Convertire interogare vedere într-o interogare \nechivalentă a tabelei vederii. \nDeci datele sunt extrase, inserate din tabele \npropriu-zise. \nCurs - BAZE DE DATE 27\n\nModificarea unei vederi\nPână acum am verificat dacă vederea \nexistă sau nu şi numai în cazul în care nu exista \no cream. \nAvem posibilitatea de a crea o vedere chiar \ndacă ea există, înlocuind-o pe cea veche cu o \nnouă versiune. \nCurs - BAZE DE DATE 28\n\nÎn acest scop se foloseşte clauza OR REPLACE. \nVom înlocui vederea emp20 cu alta.\nCREATE OR REPLACE VIEW emp20 (COD, NUME, \nSAL_ANUAL)\n AS SELECT  empno, ename, sal * 12 \n     FROM   emp\n     WHERE  deptno = 20;\nCurs - BAZE DE DATE 29\n\n\nExerciţiu \nVizualizaţi conţinutul vederii cu o cerere SELECT. \nCurs - BAZE DE DATE 30\n\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCREATE OR REPLACE VIEW dept_sal(Denumire_dept, \nSAL_MIN, SAL_MAX, SAL_MEDIU)\n AS SELECT  d.dname, MIN(e.sal), MAX(e.sal), \nAVG(e.sal) \n     FROM   emp e, dept d\n     WHERE  d.deptno = e.deptno\n     GROUP BY d.dname;\nCurs - BAZE DE DATE 31\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n\n\nNOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n\n\nEfectuarea operaţiilor DML asupra vederilor\nSe pot efectua operaţii DML asupra \nvederilor, dar numai în anumite condiţii. \na) Nu se poate şterge un rând dintr-o \nvedere care conţine: \n1. funcţii de grup\n2. GROUP BY\n3. DISTINCT\n4. ROWNUM\nCurs - BAZE DE DATE 34\n\nb) De asemenea nu se pot modifica date printr-o vedere \ndacă aceasta verifică condiţiile de mai sus şi dacă există \ncoloane definite prin expresii cum ar fi SALARIU*12. \nc) Adăugarea de date printr-o vedere este imposibilădacă\nvederea conţine elementele enumerate mai sus şi dacă\nexistă coloane NOT NULL în tabela neselectate de către\nvedere.\nPrin adăugare de date se modifică de fapt tabela propriu-\nzisă deci în coloanele neselectate se va adăuga NULL\nceea ce încalcă constrângerea.\nCurs - BAZE DE DATE 35\n\nExemplu - Crearea vederii dept_sal utilizând clauza OR \nREPLACE. \nCREATE OR REPLACE VIEW dept_sal (COD, SAL_MEDIU)\n  AS SELECT deptno, AVG(sal)\n    FROM     emp\n    GROUP BY deptno;\n \nCurs - BAZE DE DATE 36', '\n', '5. ', 'Extragere de date dintr-o vedere\n➢Extragerea de date se face exact ca în cazul \nunei tabele. \n➢Se pot selecta anumite rânduri sau toată \nvederea. \nSELECT * FROM emp10;\nCurs - BAZE DE DATE 26\n\n\nInterogarea unei vederi\nInterogarea unei vederi de către serverul \nORACLE se face în felul următor: \n1. Extragere definiţie vedere din tabela \ndicţionarului de date USER_VIEWS\n2. Verificare drepturi acces pentru tabela vederii\n3. Convertire interogare vedere într-o interogare \nechivalentă a tabelei vederii. \nDeci datele sunt extrase, inserate din tabele \npropriu-zise. \nCurs - BAZE DE DATE 27\n\nModificarea unei vederi\nPână acum am verificat dacă vederea \nexistă sau nu şi numai în cazul în care nu exista \no cream. \nAvem posibilitatea de a crea o vedere chiar \ndacă ea există, înlocuind-o pe cea veche cu o \nnouă versiune. \nCurs - BAZE DE DATE 28\n\nÎn acest scop se foloseşte clauza OR REPLACE. \nVom înlocui vederea emp20 cu alta.\nCREATE OR REPLACE VIEW emp20 (COD, NUME, \nSAL_ANUAL)\n AS SELECT  empno, ename, sal * 12 \n     FROM   emp\n     WHERE  deptno = 20;\nCurs - BAZE DE DATE 29\n\n\nExerciţiu \nVizualizaţi conţinutul vederii cu o cerere SELECT. \nCurs - BAZE DE DATE 30\n\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCREATE OR REPLACE VIEW dept_sal(Denumire_dept, \nSAL_MIN, SAL_MAX, SAL_MEDIU)\n AS SELECT  d.dname, MIN(e.sal), MAX(e.sal), \nAVG(e.sal) \n     FROM   emp e, dept d\n     WHERE  d.deptno = e.deptno\n     GROUP BY d.dname;\nCurs - BAZE DE DATE 31\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n\n\nNOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n\n\nEfectuarea operaţiilor DML asupra vederilor\nSe pot efectua operaţii DML asupra \nvederilor, dar numai în anumite condiţii. \na) Nu se poate şterge un rând dintr-o \nvedere care conţine: \n1. funcţii de grup\n2. GROUP BY\n3. DISTINCT\n4. ROWNUM\nCurs - BAZE DE DATE 34\n\nb) De asemenea nu se pot modifica date printr-o vedere \ndacă aceasta verifică condiţiile de mai sus şi dacă există \ncoloane definite prin expresii cum ar fi SALARIU*12. \nc) Adăugarea de date printr-o vedere este imposibilădacă\nvederea conţine elementele enumerate mai sus şi dacă\nexistă coloane NOT NULL în tabela neselectate de către\nvedere.\nPrin adăugare de date se modifică de fapt tabela propriu-\nzisă deci în coloanele neselectate se va adăuga NULL\nceea ce încalcă constrângerea.\nCurs - BAZE DE DATE 35\n\nExemplu - Crearea vederii dept_sal utilizând clauza OR \nREPLACE. \nCREATE OR REPLACE VIEW dept_sal (COD, SAL_MEDIU)\n  AS SELECT deptno, AVG(sal)\n    FROM     emp\n    GROUP BY deptno;\n \nCurs - BAZE DE DATE 36', '\n', '6. ', 'Extragere de date dintr-o vedere\n➢Extragerea de date se face exact ca în cazul \nunei tabele. \n➢Se pot selecta anumite rânduri sau toată \nvederea. \nSELECT * FROM emp10;\nCurs - BAZE DE DATE 26\n\n\nInterogarea unei vederi\nInterogarea unei vederi de către serverul \nORACLE se face în felul următor: \n1. Extragere definiţie vedere din tabela \ndicţionarului de date USER_VIEWS\n2. Verificare drepturi acces pentru tabela vederii\n3. Convertire interogare vedere într-o interogare \nechivalentă a tabelei vederii. \nDeci datele sunt extrase, inserate din tabele \npropriu-zise. \nCurs - BAZE DE DATE 27\n\nModificarea unei vederi\nPână acum am verificat dacă vederea \nexistă sau nu şi numai în cazul în care nu exista \no cream. \nAvem posibilitatea de a crea o vedere chiar \ndacă ea există, înlocuind-o pe cea veche cu o \nnouă versiune. \nCurs - BAZE DE DATE 28\n\nÎn acest scop se foloseşte clauza OR REPLACE. \nVom înlocui vederea emp20 cu alta.\nCREATE OR REPLACE VIEW emp20 (COD, NUME, \nSAL_ANUAL)\n AS SELECT  empno, ename, sal * 12 \n     FROM   emp\n     WHERE  deptno = 20;\nCurs - BAZE DE DATE 29\n\n\nExerciţiu \nVizualizaţi conţinutul vederii cu o cerere SELECT. \nCurs - BAZE DE DATE 30\n\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCREATE OR REPLACE VIEW dept_sal(Denumire_dept, \nSAL_MIN, SAL_MAX, SAL_MEDIU)\n AS SELECT  d.dname, MIN(e.sal), MAX(e.sal), \nAVG(e.sal) \n     FROM   emp e, dept d\n     WHERE  d.deptno = e.deptno\n     GROUP BY d.dname;\nCurs - BAZE DE DATE 31\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n\n\nNOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n\n\nEfectuarea operaţiilor DML asupra vederilor\nSe pot efectua operaţii DML asupra \nvederilor, dar numai în anumite condiţii. \na) Nu se poate şterge un rând dintr-o \nvedere care conţine: \n1. funcţii de grup\n2. GROUP BY\n3. DISTINCT\n4. ROWNUM\nCurs - BAZE DE DATE 34\n\nb) De asemenea nu se pot modifica date printr-o vedere \ndacă aceasta verifică condiţiile de mai sus şi dacă există \ncoloane definite prin expresii cum ar fi SALARIU*12. \nc) Adăugarea de date printr-o vedere este imposibilădacă\nvederea conţine elementele enumerate mai sus şi dacă\nexistă coloane NOT NULL în tabela neselectate de către\nvedere.\nPrin adăugare de date se modifică de fapt tabela propriu-\nzisă deci în coloanele neselectate se va adăuga NULL\nceea ce încalcă constrângerea.\nCurs - BAZE DE DATE 35\n\nExemplu - Crearea vederii dept_sal utilizând clauza OR \nREPLACE. \nCREATE OR REPLACE VIEW dept_sal (COD, SAL_MEDIU)\n  AS SELECT deptno, AVG(sal)\n    FROM     emp\n    GROUP BY deptno;\n \nCurs - BAZE DE DATE 36', '\n', '7. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '8. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '9. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '10. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n']","instrucțiunea SQL pentru a crea o vedere este: `CREATE VIEW view AS subquery`.
",CREATE VIEW,0.39145339953511066,1.0,0.8678390620767824,1.0,0.04573913556123801,0.25,0.0
9,O3mini-high,LOW,C10,,"Ce obiect SQL este folosit pentru a genera automat valori unice, utile de obicei pentru identificatori?",SEQUENCE,Este corect,,"['1. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '2. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '3. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '4. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '5. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '6. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '7. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '8. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '9. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '10. ', ""3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43\n\n3. Sinonime\nPentru crearea sinonimelor este necesara o cerere SQL \ncare are urmatorul format:\nCurs - BAZE DE DATE 44\nCREATE [PUBLIC] SYNONYM nume_sinonim\nFOR nume_obiect;\nPUBLIC\nDefineste faptul ca acest sinonim este accesibil de catre toti \nutilizatorii. Daca nu este precizat atunci sinonimul este disponibil \ndoar pentru utilizatorul curent. Sinonimele publice pot fi create doar \nde catre utilizatorii care au drepturi administrative.\nnume_sinonim Numele sinonimului care va fi creat.\nnume_obiect Identifica obiectul pentru care se doreste crearea sinonimului \n\n3. Sinonime\n➢Daca dorim sa accesam o tabela pe care un alt utilizator \na creat-o in prealabil si careia ii dorim asignarea unui \nsinonim suntem obligati sa introducem inaintea numelui \ntabelei si numele utilizatorului care a creat tabela, in \nfata numelui tabelei, despartite de un punct.\nExemplu 1 - In acest exemplu vom incerca sa cream un \nsinonim pentru tabela departamente care are un nume \ndestul de lung.\nCREATE PUBLIC SYNONYM dep\nFOR dept;\nCurs - BAZE DE DATE 45\n\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46\n\n3. Sinonime\nExista unele restrictii in folosirea sinonimelor:\n➢obiectele respective nu pot sa fie continute intr-un \npachet.\n➢numele sinonimului privat trebuie sa fie unic in cadrul \ngrupului de obiecte pentru care acel user este \nproprietar.\nCurs - BAZE DE DATE 47\n\n3. Sinonime\n➢Un sinonim nu poate fi schimbat odata creat. \n➢El poate sa fie doar distrus. \n➢Distrugerea unui sinonim nu implica si distrugerea \nobiectului de care aliasul este atasat. \n➢Distrugerea unui sinonim este facuta folosind o \ninterogare SQL de tipul urmator:\nDROP [PUBLIC] SYNONYM nume_sinonim\nunde nume_sinonim este numele sinonimului care sa fie \ndistrus.\nCurs - BAZE DE DATE 48\n\n3. Sinonime\n➢Un sinonim de tip public poate sa fie sa fie distrus doar \nde catre un utilizator administrativ. \n➢Sinonimele private trebuie distruse de utilizatorul care \nle-a creat acestea nefiind disponibile in cadrul listei \nnumelor de obiecte a celorlalti utilizatori.\nCurs - BAZE DE DATE 49\n\nBibliografie\nFlorin Rădulescu: Oracle SQL, PL/SQL, Editura \nPrintech, ISBN 973-718-203-02005\nCurs - BAZE DE DATE 50\n\nÎntrebări?\nCurs - BAZE DE DATE 51"", '\n']","obiectul SQL folosit pentru a genera automat valori unice este o **secvență**. Aceasta poate fi creată utilizând sintaxa `CREATE SEQUENCE`. Pseudocoloanele `NEXTVAL` și `CURRVAL` sunt folosite pentru a accesa valorile unei secvențe.
","Ce obiect SQL este folosit pentru a genera automat valori unice, utile de obicei pentru identificatori?","['1. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '2. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '3. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '4. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '5. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '6. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '7. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '8. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '9. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '10. ', ""3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43\n\n3. Sinonime\nPentru crearea sinonimelor este necesara o cerere SQL \ncare are urmatorul format:\nCurs - BAZE DE DATE 44\nCREATE [PUBLIC] SYNONYM nume_sinonim\nFOR nume_obiect;\nPUBLIC\nDefineste faptul ca acest sinonim este accesibil de catre toti \nutilizatorii. Daca nu este precizat atunci sinonimul este disponibil \ndoar pentru utilizatorul curent. Sinonimele publice pot fi create doar \nde catre utilizatorii care au drepturi administrative.\nnume_sinonim Numele sinonimului care va fi creat.\nnume_obiect Identifica obiectul pentru care se doreste crearea sinonimului \n\n3. Sinonime\n➢Daca dorim sa accesam o tabela pe care un alt utilizator \na creat-o in prealabil si careia ii dorim asignarea unui \nsinonim suntem obligati sa introducem inaintea numelui \ntabelei si numele utilizatorului care a creat tabela, in \nfata numelui tabelei, despartite de un punct.\nExemplu 1 - In acest exemplu vom incerca sa cream un \nsinonim pentru tabela departamente care are un nume \ndestul de lung.\nCREATE PUBLIC SYNONYM dep\nFOR dept;\nCurs - BAZE DE DATE 45\n\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46\n\n3. Sinonime\nExista unele restrictii in folosirea sinonimelor:\n➢obiectele respective nu pot sa fie continute intr-un \npachet.\n➢numele sinonimului privat trebuie sa fie unic in cadrul \ngrupului de obiecte pentru care acel user este \nproprietar.\nCurs - BAZE DE DATE 47\n\n3. Sinonime\n➢Un sinonim nu poate fi schimbat odata creat. \n➢El poate sa fie doar distrus. \n➢Distrugerea unui sinonim nu implica si distrugerea \nobiectului de care aliasul este atasat. \n➢Distrugerea unui sinonim este facuta folosind o \ninterogare SQL de tipul urmator:\nDROP [PUBLIC] SYNONYM nume_sinonim\nunde nume_sinonim este numele sinonimului care sa fie \ndistrus.\nCurs - BAZE DE DATE 48\n\n3. Sinonime\n➢Un sinonim de tip public poate sa fie sa fie distrus doar \nde catre un utilizator administrativ. \n➢Sinonimele private trebuie distruse de utilizatorul care \nle-a creat acestea nefiind disponibile in cadrul listei \nnumelor de obiecte a celorlalti utilizatori.\nCurs - BAZE DE DATE 49\n\nBibliografie\nFlorin Rădulescu: Oracle SQL, PL/SQL, Editura \nPrintech, ISBN 973-718-203-02005\nCurs - BAZE DE DATE 50\n\nÎntrebări?\nCurs - BAZE DE DATE 51"", '\n']","obiectul SQL folosit pentru a genera automat valori unice este o **secvență**. Aceasta poate fi creată utilizând sintaxa `CREATE SEQUENCE`. Pseudocoloanele `NEXTVAL` și `CURRVAL` sunt folosite pentru a accesa valorile unei secvențe.
",SEQUENCE,0.3205267558475007,1.0,0.8784497948569525,1.0,0.0,0.05714285714285715,1.0
10,O3mini-high,LOW,C11,,"Cu ce instrucțiune SQL se creează un utilizator nou în Oracle, conform politicilor de control al accesului?",CREATE USER,Este corect,,"['1. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32\n\n2.3. ORACLE Server\n ORACLE Server (OS) permite \nmanagementul informaţiilor organizate în baze \nde date, astfel încât se asigură accesul mai \nmultor utilizatori în mod concurenţial la acelaşi \ndate, oferind facilităţi de prevenire a accesului \nneautorizat şi de restaurare a datelor după \nproducerea unor erori. \n33\n\n2.3. ORACLE Server\nORACLE Server este un sistem relaţional-\nobiectual de management a bazelor de date, \ncare permite o abordare deschisă, integrată şi \ncuprinzătoare a managementului \ninformaţiilor. \nOS constă dintr-un cuplu format dintr-o \nbază de date şi o instanţă Oracle.\n34\n\n2.3. ORACLE Server\nA. O bază de date Oracle este o colecţie \nunitară de date, având o structură logică şi \nuna fizică putând avea două stări: \n1. open (accesibilă) \n2. close (inaccesibilă)\n35\n\n2.3. ORACLE Server\n1) Structura logică a unei baze de date este \nformată din:\n✓tabelele spaţiu (tablespaces)\n✓schema de obiectelor bazei de date\n✓blocurile de date\n✓extensiile\n✓segmentele\n36\n\n2.3. ORACLE Server\n2) Structura fizică este definită de un set de \nfişiere specifice sistemului de operare pe care \nrezidă SGBD Oracle, folosite pentru memorarea \nstructurilor logice ale bazei de date şi pentru \npăstrarea unor informaţii tehnice de control. \nAceste fişiere sunt: \n- fişiere de date (Data files)\n- fişiere Redo log (Redo Log files) \n- fişiere de control (Control files)\n37\n\n2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n39\n\n2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40\n\n2.4. ORACLE Database 11g Expres Edition\n Pe calculatorul personal este ideal sa se \ninstaleze fisierul: \nOracle Database 11g Express Edition \n(Universal)  OracleXE112_Win32.zip\n41\n\n2.4. ORACLE Database 11g Expres Edition\nPas 1: Se porneste instalarea fisierului executabil si se vor \nurma pasii indicati de catre programul de instalare.\n42\n\n2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43\n\n2.4. ORACLE Database 11g Expres Edition\nInstalarea aplicatiei\n 44', '\n', '2. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32\n\n2.3. ORACLE Server\n ORACLE Server (OS) permite \nmanagementul informaţiilor organizate în baze \nde date, astfel încât se asigură accesul mai \nmultor utilizatori în mod concurenţial la acelaşi \ndate, oferind facilităţi de prevenire a accesului \nneautorizat şi de restaurare a datelor după \nproducerea unor erori. \n33\n\n2.3. ORACLE Server\nORACLE Server este un sistem relaţional-\nobiectual de management a bazelor de date, \ncare permite o abordare deschisă, integrată şi \ncuprinzătoare a managementului \ninformaţiilor. \nOS constă dintr-un cuplu format dintr-o \nbază de date şi o instanţă Oracle.\n34\n\n2.3. ORACLE Server\nA. O bază de date Oracle este o colecţie \nunitară de date, având o structură logică şi \nuna fizică putând avea două stări: \n1. open (accesibilă) \n2. close (inaccesibilă)\n35\n\n2.3. ORACLE Server\n1) Structura logică a unei baze de date este \nformată din:\n✓tabelele spaţiu (tablespaces)\n✓schema de obiectelor bazei de date\n✓blocurile de date\n✓extensiile\n✓segmentele\n36\n\n2.3. ORACLE Server\n2) Structura fizică este definită de un set de \nfişiere specifice sistemului de operare pe care \nrezidă SGBD Oracle, folosite pentru memorarea \nstructurilor logice ale bazei de date şi pentru \npăstrarea unor informaţii tehnice de control. \nAceste fişiere sunt: \n- fişiere de date (Data files)\n- fişiere Redo log (Redo Log files) \n- fişiere de control (Control files)\n37\n\n2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n39\n\n2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40\n\n2.4. ORACLE Database 11g Expres Edition\n Pe calculatorul personal este ideal sa se \ninstaleze fisierul: \nOracle Database 11g Express Edition \n(Universal)  OracleXE112_Win32.zip\n41\n\n2.4. ORACLE Database 11g Expres Edition\nPas 1: Se porneste instalarea fisierului executabil si se vor \nurma pasii indicati de catre programul de instalare.\n42\n\n2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43\n\n2.4. ORACLE Database 11g Expres Edition\nInstalarea aplicatiei\n 44', '\n', '3. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32\n\n2.3. ORACLE Server\n ORACLE Server (OS) permite \nmanagementul informaţiilor organizate în baze \nde date, astfel încât se asigură accesul mai \nmultor utilizatori în mod concurenţial la acelaşi \ndate, oferind facilităţi de prevenire a accesului \nneautorizat şi de restaurare a datelor după \nproducerea unor erori. \n33\n\n2.3. ORACLE Server\nORACLE Server este un sistem relaţional-\nobiectual de management a bazelor de date, \ncare permite o abordare deschisă, integrată şi \ncuprinzătoare a managementului \ninformaţiilor. \nOS constă dintr-un cuplu format dintr-o \nbază de date şi o instanţă Oracle.\n34\n\n2.3. ORACLE Server\nA. O bază de date Oracle este o colecţie \nunitară de date, având o structură logică şi \nuna fizică putând avea două stări: \n1. open (accesibilă) \n2. close (inaccesibilă)\n35\n\n2.3. ORACLE Server\n1) Structura logică a unei baze de date este \nformată din:\n✓tabelele spaţiu (tablespaces)\n✓schema de obiectelor bazei de date\n✓blocurile de date\n✓extensiile\n✓segmentele\n36\n\n2.3. ORACLE Server\n2) Structura fizică este definită de un set de \nfişiere specifice sistemului de operare pe care \nrezidă SGBD Oracle, folosite pentru memorarea \nstructurilor logice ale bazei de date şi pentru \npăstrarea unor informaţii tehnice de control. \nAceste fişiere sunt: \n- fişiere de date (Data files)\n- fişiere Redo log (Redo Log files) \n- fişiere de control (Control files)\n37\n\n2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n39\n\n2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40\n\n2.4. ORACLE Database 11g Expres Edition\n Pe calculatorul personal este ideal sa se \ninstaleze fisierul: \nOracle Database 11g Express Edition \n(Universal)  OracleXE112_Win32.zip\n41\n\n2.4. ORACLE Database 11g Expres Edition\nPas 1: Se porneste instalarea fisierului executabil si se vor \nurma pasii indicati de catre programul de instalare.\n42\n\n2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43\n\n2.4. ORACLE Database 11g Expres Edition\nInstalarea aplicatiei\n 44', '\n', '4. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '5. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '6. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '7. ', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 8\nLimbajul SQL \nCurs 8 - BAZE DE DATE 2\n\nLimbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3\n\nServerul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4\n\nTipuri de constrângeri\nCurs 8 - BAZE DE DATE 5\n\nGhidul Constrângerilor\n1. Toate constrângerile sunt cuprinse într-un dicţionar. \n2. Este uşor să se facă referinţă la constrângeri dacă li se \ndă nume sugestive. \n3. Numele unei constrângeri trebuie să urmeze un \nanumit standard. \n4. Dacă nu se denumeşte constrângerea, server-ul Oracle\ngenerează un nume de forma SYS_Cn, unde n este un \nnumăr întreg astfel încât numele constrângerii este \nunic.\n5. Constrângerile definite pentru o anumita tabela pot fi \nvizualizate în USER_CONSTRAINTS (dicţionarul tabelei).\nCurs 8 - BAZE DE DATE 6\n\nDefinirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7\n\nÎn sintaxa prezentată anterior avem:\nCurs 8 - BAZE DE DATE 8\n\nEXEMPLU - Adăugarea unei \nconstrângeri unei tabele odată cu \ncrearea lui.\nCREATE TABLE EMP1(\nempno number(6) NOT NULL,\nename varchar2(20),\nsal number(4),\nmgr number(4),\njob varchar2(20), \nPRIMARY KEY(empno));\nConstrângere \npentru tabela\nConstrângere \npentru coloană\nCurs 8 - BAZE DE DATE 9\n\n\n• De obicei constrângerile sunt create în acelaşi timp cu \ntabela.\n• Constrângerile pot fi adăugate tabelei după crearea ei.\n• Constrângerile pot fi definite pe 2 nivele: \nCurs 8 - BAZE DE DATE 10\n\nSintaxa:\n1. Constrângere la nivel de coloană\n2. Constrângere la nivel de tabela\nCurs 8 - BAZE DE DATE 11\n\n• In sintaxa avem:\nCurs 8 - BAZE DE DATE 12\n\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13\n\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14\n\nCREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15', '\n', '8. ', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 8\nLimbajul SQL \nCurs 8 - BAZE DE DATE 2\n\nLimbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3\n\nServerul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4\n\nTipuri de constrângeri\nCurs 8 - BAZE DE DATE 5\n\nGhidul Constrângerilor\n1. Toate constrângerile sunt cuprinse într-un dicţionar. \n2. Este uşor să se facă referinţă la constrângeri dacă li se \ndă nume sugestive. \n3. Numele unei constrângeri trebuie să urmeze un \nanumit standard. \n4. Dacă nu se denumeşte constrângerea, server-ul Oracle\ngenerează un nume de forma SYS_Cn, unde n este un \nnumăr întreg astfel încât numele constrângerii este \nunic.\n5. Constrângerile definite pentru o anumita tabela pot fi \nvizualizate în USER_CONSTRAINTS (dicţionarul tabelei).\nCurs 8 - BAZE DE DATE 6\n\nDefinirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7\n\nÎn sintaxa prezentată anterior avem:\nCurs 8 - BAZE DE DATE 8\n\nEXEMPLU - Adăugarea unei \nconstrângeri unei tabele odată cu \ncrearea lui.\nCREATE TABLE EMP1(\nempno number(6) NOT NULL,\nename varchar2(20),\nsal number(4),\nmgr number(4),\njob varchar2(20), \nPRIMARY KEY(empno));\nConstrângere \npentru tabela\nConstrângere \npentru coloană\nCurs 8 - BAZE DE DATE 9\n\n\n• De obicei constrângerile sunt create în acelaşi timp cu \ntabela.\n• Constrângerile pot fi adăugate tabelei după crearea ei.\n• Constrângerile pot fi definite pe 2 nivele: \nCurs 8 - BAZE DE DATE 10\n\nSintaxa:\n1. Constrângere la nivel de coloană\n2. Constrângere la nivel de tabela\nCurs 8 - BAZE DE DATE 11\n\n• In sintaxa avem:\nCurs 8 - BAZE DE DATE 12\n\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13\n\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14\n\nCREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15', '\n', '9. ', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 8\nLimbajul SQL \nCurs 8 - BAZE DE DATE 2\n\nLimbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3\n\nServerul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4\n\nTipuri de constrângeri\nCurs 8 - BAZE DE DATE 5\n\nGhidul Constrângerilor\n1. Toate constrângerile sunt cuprinse într-un dicţionar. \n2. Este uşor să se facă referinţă la constrângeri dacă li se \ndă nume sugestive. \n3. Numele unei constrângeri trebuie să urmeze un \nanumit standard. \n4. Dacă nu se denumeşte constrângerea, server-ul Oracle\ngenerează un nume de forma SYS_Cn, unde n este un \nnumăr întreg astfel încât numele constrângerii este \nunic.\n5. Constrângerile definite pentru o anumita tabela pot fi \nvizualizate în USER_CONSTRAINTS (dicţionarul tabelei).\nCurs 8 - BAZE DE DATE 6\n\nDefinirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7\n\nÎn sintaxa prezentată anterior avem:\nCurs 8 - BAZE DE DATE 8\n\nEXEMPLU - Adăugarea unei \nconstrângeri unei tabele odată cu \ncrearea lui.\nCREATE TABLE EMP1(\nempno number(6) NOT NULL,\nename varchar2(20),\nsal number(4),\nmgr number(4),\njob varchar2(20), \nPRIMARY KEY(empno));\nConstrângere \npentru tabela\nConstrângere \npentru coloană\nCurs 8 - BAZE DE DATE 9\n\n\n• De obicei constrângerile sunt create în acelaşi timp cu \ntabela.\n• Constrângerile pot fi adăugate tabelei după crearea ei.\n• Constrângerile pot fi definite pe 2 nivele: \nCurs 8 - BAZE DE DATE 10\n\nSintaxa:\n1. Constrângere la nivel de coloană\n2. Constrângere la nivel de tabela\nCurs 8 - BAZE DE DATE 11\n\n• In sintaxa avem:\nCurs 8 - BAZE DE DATE 12\n\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13\n\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14\n\nCREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15', '\n', '10. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n']","instrucțiunea SQL pentru a crea un utilizator nou nu este explicit menționată. Totuși, se menționează că Oracle Server oferă ""facilităţi de prevenire a accesului neautorizat"" și că Enterprise Manager Console conține utilitare pentru ""autorizarea accesului"". De asemenea, dicționarul de date conține informații despre ""numele utilizatorilor autorizați"" și ""drepturile de acces"".
","Cu ce instrucțiune SQL se creează un utilizator nou în Oracle, conform politicilor de control al accesului?","['1. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32\n\n2.3. ORACLE Server\n ORACLE Server (OS) permite \nmanagementul informaţiilor organizate în baze \nde date, astfel încât se asigură accesul mai \nmultor utilizatori în mod concurenţial la acelaşi \ndate, oferind facilităţi de prevenire a accesului \nneautorizat şi de restaurare a datelor după \nproducerea unor erori. \n33\n\n2.3. ORACLE Server\nORACLE Server este un sistem relaţional-\nobiectual de management a bazelor de date, \ncare permite o abordare deschisă, integrată şi \ncuprinzătoare a managementului \ninformaţiilor. \nOS constă dintr-un cuplu format dintr-o \nbază de date şi o instanţă Oracle.\n34\n\n2.3. ORACLE Server\nA. O bază de date Oracle este o colecţie \nunitară de date, având o structură logică şi \nuna fizică putând avea două stări: \n1. open (accesibilă) \n2. close (inaccesibilă)\n35\n\n2.3. ORACLE Server\n1) Structura logică a unei baze de date este \nformată din:\n✓tabelele spaţiu (tablespaces)\n✓schema de obiectelor bazei de date\n✓blocurile de date\n✓extensiile\n✓segmentele\n36\n\n2.3. ORACLE Server\n2) Structura fizică este definită de un set de \nfişiere specifice sistemului de operare pe care \nrezidă SGBD Oracle, folosite pentru memorarea \nstructurilor logice ale bazei de date şi pentru \npăstrarea unor informaţii tehnice de control. \nAceste fişiere sunt: \n- fişiere de date (Data files)\n- fişiere Redo log (Redo Log files) \n- fişiere de control (Control files)\n37\n\n2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n39\n\n2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40\n\n2.4. ORACLE Database 11g Expres Edition\n Pe calculatorul personal este ideal sa se \ninstaleze fisierul: \nOracle Database 11g Express Edition \n(Universal)  OracleXE112_Win32.zip\n41\n\n2.4. ORACLE Database 11g Expres Edition\nPas 1: Se porneste instalarea fisierului executabil si se vor \nurma pasii indicati de catre programul de instalare.\n42\n\n2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43\n\n2.4. ORACLE Database 11g Expres Edition\nInstalarea aplicatiei\n 44', '\n', '2. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32\n\n2.3. ORACLE Server\n ORACLE Server (OS) permite \nmanagementul informaţiilor organizate în baze \nde date, astfel încât se asigură accesul mai \nmultor utilizatori în mod concurenţial la acelaşi \ndate, oferind facilităţi de prevenire a accesului \nneautorizat şi de restaurare a datelor după \nproducerea unor erori. \n33\n\n2.3. ORACLE Server\nORACLE Server este un sistem relaţional-\nobiectual de management a bazelor de date, \ncare permite o abordare deschisă, integrată şi \ncuprinzătoare a managementului \ninformaţiilor. \nOS constă dintr-un cuplu format dintr-o \nbază de date şi o instanţă Oracle.\n34\n\n2.3. ORACLE Server\nA. O bază de date Oracle este o colecţie \nunitară de date, având o structură logică şi \nuna fizică putând avea două stări: \n1. open (accesibilă) \n2. close (inaccesibilă)\n35\n\n2.3. ORACLE Server\n1) Structura logică a unei baze de date este \nformată din:\n✓tabelele spaţiu (tablespaces)\n✓schema de obiectelor bazei de date\n✓blocurile de date\n✓extensiile\n✓segmentele\n36\n\n2.3. ORACLE Server\n2) Structura fizică este definită de un set de \nfişiere specifice sistemului de operare pe care \nrezidă SGBD Oracle, folosite pentru memorarea \nstructurilor logice ale bazei de date şi pentru \npăstrarea unor informaţii tehnice de control. \nAceste fişiere sunt: \n- fişiere de date (Data files)\n- fişiere Redo log (Redo Log files) \n- fişiere de control (Control files)\n37\n\n2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n39\n\n2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40\n\n2.4. ORACLE Database 11g Expres Edition\n Pe calculatorul personal este ideal sa se \ninstaleze fisierul: \nOracle Database 11g Express Edition \n(Universal)  OracleXE112_Win32.zip\n41\n\n2.4. ORACLE Database 11g Expres Edition\nPas 1: Se porneste instalarea fisierului executabil si se vor \nurma pasii indicati de catre programul de instalare.\n42\n\n2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43\n\n2.4. ORACLE Database 11g Expres Edition\nInstalarea aplicatiei\n 44', '\n', '3. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32\n\n2.3. ORACLE Server\n ORACLE Server (OS) permite \nmanagementul informaţiilor organizate în baze \nde date, astfel încât se asigură accesul mai \nmultor utilizatori în mod concurenţial la acelaşi \ndate, oferind facilităţi de prevenire a accesului \nneautorizat şi de restaurare a datelor după \nproducerea unor erori. \n33\n\n2.3. ORACLE Server\nORACLE Server este un sistem relaţional-\nobiectual de management a bazelor de date, \ncare permite o abordare deschisă, integrată şi \ncuprinzătoare a managementului \ninformaţiilor. \nOS constă dintr-un cuplu format dintr-o \nbază de date şi o instanţă Oracle.\n34\n\n2.3. ORACLE Server\nA. O bază de date Oracle este o colecţie \nunitară de date, având o structură logică şi \nuna fizică putând avea două stări: \n1. open (accesibilă) \n2. close (inaccesibilă)\n35\n\n2.3. ORACLE Server\n1) Structura logică a unei baze de date este \nformată din:\n✓tabelele spaţiu (tablespaces)\n✓schema de obiectelor bazei de date\n✓blocurile de date\n✓extensiile\n✓segmentele\n36\n\n2.3. ORACLE Server\n2) Structura fizică este definită de un set de \nfişiere specifice sistemului de operare pe care \nrezidă SGBD Oracle, folosite pentru memorarea \nstructurilor logice ale bazei de date şi pentru \npăstrarea unor informaţii tehnice de control. \nAceste fişiere sunt: \n- fişiere de date (Data files)\n- fişiere Redo log (Redo Log files) \n- fişiere de control (Control files)\n37\n\n2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n39\n\n2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40\n\n2.4. ORACLE Database 11g Expres Edition\n Pe calculatorul personal este ideal sa se \ninstaleze fisierul: \nOracle Database 11g Express Edition \n(Universal)  OracleXE112_Win32.zip\n41\n\n2.4. ORACLE Database 11g Expres Edition\nPas 1: Se porneste instalarea fisierului executabil si se vor \nurma pasii indicati de catre programul de instalare.\n42\n\n2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43\n\n2.4. ORACLE Database 11g Expres Edition\nInstalarea aplicatiei\n 44', '\n', '4. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '5. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '6. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '7. ', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 8\nLimbajul SQL \nCurs 8 - BAZE DE DATE 2\n\nLimbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3\n\nServerul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4\n\nTipuri de constrângeri\nCurs 8 - BAZE DE DATE 5\n\nGhidul Constrângerilor\n1. Toate constrângerile sunt cuprinse într-un dicţionar. \n2. Este uşor să se facă referinţă la constrângeri dacă li se \ndă nume sugestive. \n3. Numele unei constrângeri trebuie să urmeze un \nanumit standard. \n4. Dacă nu se denumeşte constrângerea, server-ul Oracle\ngenerează un nume de forma SYS_Cn, unde n este un \nnumăr întreg astfel încât numele constrângerii este \nunic.\n5. Constrângerile definite pentru o anumita tabela pot fi \nvizualizate în USER_CONSTRAINTS (dicţionarul tabelei).\nCurs 8 - BAZE DE DATE 6\n\nDefinirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7\n\nÎn sintaxa prezentată anterior avem:\nCurs 8 - BAZE DE DATE 8\n\nEXEMPLU - Adăugarea unei \nconstrângeri unei tabele odată cu \ncrearea lui.\nCREATE TABLE EMP1(\nempno number(6) NOT NULL,\nename varchar2(20),\nsal number(4),\nmgr number(4),\njob varchar2(20), \nPRIMARY KEY(empno));\nConstrângere \npentru tabela\nConstrângere \npentru coloană\nCurs 8 - BAZE DE DATE 9\n\n\n• De obicei constrângerile sunt create în acelaşi timp cu \ntabela.\n• Constrângerile pot fi adăugate tabelei după crearea ei.\n• Constrângerile pot fi definite pe 2 nivele: \nCurs 8 - BAZE DE DATE 10\n\nSintaxa:\n1. Constrângere la nivel de coloană\n2. Constrângere la nivel de tabela\nCurs 8 - BAZE DE DATE 11\n\n• In sintaxa avem:\nCurs 8 - BAZE DE DATE 12\n\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13\n\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14\n\nCREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15', '\n', '8. ', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 8\nLimbajul SQL \nCurs 8 - BAZE DE DATE 2\n\nLimbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3\n\nServerul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4\n\nTipuri de constrângeri\nCurs 8 - BAZE DE DATE 5\n\nGhidul Constrângerilor\n1. Toate constrângerile sunt cuprinse într-un dicţionar. \n2. Este uşor să se facă referinţă la constrângeri dacă li se \ndă nume sugestive. \n3. Numele unei constrângeri trebuie să urmeze un \nanumit standard. \n4. Dacă nu se denumeşte constrângerea, server-ul Oracle\ngenerează un nume de forma SYS_Cn, unde n este un \nnumăr întreg astfel încât numele constrângerii este \nunic.\n5. Constrângerile definite pentru o anumita tabela pot fi \nvizualizate în USER_CONSTRAINTS (dicţionarul tabelei).\nCurs 8 - BAZE DE DATE 6\n\nDefinirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7\n\nÎn sintaxa prezentată anterior avem:\nCurs 8 - BAZE DE DATE 8\n\nEXEMPLU - Adăugarea unei \nconstrângeri unei tabele odată cu \ncrearea lui.\nCREATE TABLE EMP1(\nempno number(6) NOT NULL,\nename varchar2(20),\nsal number(4),\nmgr number(4),\njob varchar2(20), \nPRIMARY KEY(empno));\nConstrângere \npentru tabela\nConstrângere \npentru coloană\nCurs 8 - BAZE DE DATE 9\n\n\n• De obicei constrângerile sunt create în acelaşi timp cu \ntabela.\n• Constrângerile pot fi adăugate tabelei după crearea ei.\n• Constrângerile pot fi definite pe 2 nivele: \nCurs 8 - BAZE DE DATE 10\n\nSintaxa:\n1. Constrângere la nivel de coloană\n2. Constrângere la nivel de tabela\nCurs 8 - BAZE DE DATE 11\n\n• In sintaxa avem:\nCurs 8 - BAZE DE DATE 12\n\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13\n\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14\n\nCREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15', '\n', '9. ', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 8\nLimbajul SQL \nCurs 8 - BAZE DE DATE 2\n\nLimbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3\n\nServerul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4\n\nTipuri de constrângeri\nCurs 8 - BAZE DE DATE 5\n\nGhidul Constrângerilor\n1. Toate constrângerile sunt cuprinse într-un dicţionar. \n2. Este uşor să se facă referinţă la constrângeri dacă li se \ndă nume sugestive. \n3. Numele unei constrângeri trebuie să urmeze un \nanumit standard. \n4. Dacă nu se denumeşte constrângerea, server-ul Oracle\ngenerează un nume de forma SYS_Cn, unde n este un \nnumăr întreg astfel încât numele constrângerii este \nunic.\n5. Constrângerile definite pentru o anumita tabela pot fi \nvizualizate în USER_CONSTRAINTS (dicţionarul tabelei).\nCurs 8 - BAZE DE DATE 6\n\nDefinirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7\n\nÎn sintaxa prezentată anterior avem:\nCurs 8 - BAZE DE DATE 8\n\nEXEMPLU - Adăugarea unei \nconstrângeri unei tabele odată cu \ncrearea lui.\nCREATE TABLE EMP1(\nempno number(6) NOT NULL,\nename varchar2(20),\nsal number(4),\nmgr number(4),\njob varchar2(20), \nPRIMARY KEY(empno));\nConstrângere \npentru tabela\nConstrângere \npentru coloană\nCurs 8 - BAZE DE DATE 9\n\n\n• De obicei constrângerile sunt create în acelaşi timp cu \ntabela.\n• Constrângerile pot fi adăugate tabelei după crearea ei.\n• Constrângerile pot fi definite pe 2 nivele: \nCurs 8 - BAZE DE DATE 10\n\nSintaxa:\n1. Constrângere la nivel de coloană\n2. Constrângere la nivel de tabela\nCurs 8 - BAZE DE DATE 11\n\n• In sintaxa avem:\nCurs 8 - BAZE DE DATE 12\n\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13\n\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14\n\nCREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15', '\n', '10. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n']","instrucțiunea SQL pentru a crea un utilizator nou nu este explicit menționată. Totuși, se menționează că Oracle Server oferă ""facilităţi de prevenire a accesului neautorizat"" și că Enterprise Manager Console conține utilitare pentru ""autorizarea accesului"". De asemenea, dicționarul de date conține informații despre ""numele utilizatorilor autorizați"" și ""drepturile de acces"".
",CREATE USER,0.0,0.0,0.0,1.0,0.0,0.0,0.0
11,O3mini-high,LOW,C12,,"Ce model de baze de date, care organizează datele în tabele interconectate, este descris în acest capitol?",relațional,Este corect,,"['1. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '2. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '3. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '4. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '5. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '6. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '7. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '8. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '9. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '10. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n']","modelul relațional este abordarea care organizează datele în tabele interconectate. Relațiile dintre tabele sunt definite prin chei primare și chei străine, asigurând integritatea datelor.
","Ce model de baze de date, care organizează datele în tabele interconectate, este descris în acest capitol?","['1. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '2. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '3. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '4. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '5. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '6. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '7. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '8. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '9. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '10. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n']","modelul relațional este abordarea care organizează datele în tabele interconectate. Relațiile dintre tabele sunt definite prin chei primare și chei străine, asigurând integritatea datelor.
",relațional,0.39145339953511066,1.0,0.8377893819296647,1.0,0.04196114906296548,0.13333333333333333,0.0
12,O3mini-high,LOW,C13,,Cu ce cuvânt cheie SQL se definește o cheie primară pentru a asigura identificarea unică a înregistrărilor în modelul relațional?,PRIMARY KEY,Este corect,,"['1. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '2. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '3. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '4. ', '1.2.Modelul de date relaţional\nCele mai importante constrângeri de integritate \nsunt: \nConstrângerea de integritate a entităţii care \nstabileşte că fiecare tuplu să fie unic identificat \nprintr-o cheie şi atributul cheie să nu poată fi null;\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\n40\n\n1.2.Modelul de date relaţional\nConstrâgerea referenţială de integritate\nstabileşte că un n-tuplu dintr-o relaţie care se \nreferă la o altă relaţie, trebuie să se refere la \nun n-tuplu care există în acea relaţie; această\ncondiţie se referă la cheile străine.\n 41\n\n1.2.Modelul de date relaţional\nO cheie candidat a unei relaţii R este o mulţime \nminimă de atribute de care toate celelalte atribute ale \nlui R sunt dependente funcţional. \nCheia primară a unei relaţii R este una din cheile \ncandidat care a fost desemnată în acest scop.\nO cheie străină a unei relaţii R este o mulţime de \natribute din schema relaţională care formează o cheie \nprimară pentru o altă relaţie. \nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00 42\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 43\n\n1.3.Modelul de  date orientate obiect\nBazele de date orientate obiect permit \ncrearea unor obiecte complexe din componente \nmai simple, fiecare având atribute proprii şi \ncomportament specific. \n  Aceste sisteme combină posibilitatea definirii \nşi manipulării structurilor complexe de date cu \nfuncţionalitatea unui limbaj de programare şi \ntehnologia de gestiune a bazelor de date.\n 44\n\n1.3.Modelul de  date orientate obiect\nModelele de date \norientate obiect (MDOO) au \nfost create pentru a modela \nlumea reală. \nDe exemplu, limbajul C++ \na fost dezvoltat pentru a crea \nmodelul unui sistem \ntelefonic. \nConceptul fundamental al \nunui MDOO este obiectul. \n 45\n\n1.3.Modelul de  date orientate obiect\nÎntr-un MDOO, orice entitate din lumea reală este \nun obiect şi reciproc, orice obiect reprezintă o entitate \na lumii reale. \nUn obiect reprezintă un grup de date stucturate, \nidentificate printr-o referinţă unică.\nUn obiect persistent este un obiect stocat în baza \nde date care are o durată de viaţă mai mare decât a \nprogramului care l-a creat. \nUn obiect tranzitoriu este un obiect depus în \nmemorie, a cărui durată de viaţă nu depăşeşte durata \nde viaţă a programului care l-a creat.\n 46', '\n', '5. ', '1.2.Modelul de date relaţional\nCele mai importante constrângeri de integritate \nsunt: \nConstrângerea de integritate a entităţii care \nstabileşte că fiecare tuplu să fie unic identificat \nprintr-o cheie şi atributul cheie să nu poată fi null;\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\n40\n\n1.2.Modelul de date relaţional\nConstrâgerea referenţială de integritate\nstabileşte că un n-tuplu dintr-o relaţie care se \nreferă la o altă relaţie, trebuie să se refere la \nun n-tuplu care există în acea relaţie; această\ncondiţie se referă la cheile străine.\n 41\n\n1.2.Modelul de date relaţional\nO cheie candidat a unei relaţii R este o mulţime \nminimă de atribute de care toate celelalte atribute ale \nlui R sunt dependente funcţional. \nCheia primară a unei relaţii R este una din cheile \ncandidat care a fost desemnată în acest scop.\nO cheie străină a unei relaţii R este o mulţime de \natribute din schema relaţională care formează o cheie \nprimară pentru o altă relaţie. \nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00 42\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 43\n\n1.3.Modelul de  date orientate obiect\nBazele de date orientate obiect permit \ncrearea unor obiecte complexe din componente \nmai simple, fiecare având atribute proprii şi \ncomportament specific. \n  Aceste sisteme combină posibilitatea definirii \nşi manipulării structurilor complexe de date cu \nfuncţionalitatea unui limbaj de programare şi \ntehnologia de gestiune a bazelor de date.\n 44\n\n1.3.Modelul de  date orientate obiect\nModelele de date \norientate obiect (MDOO) au \nfost create pentru a modela \nlumea reală. \nDe exemplu, limbajul C++ \na fost dezvoltat pentru a crea \nmodelul unui sistem \ntelefonic. \nConceptul fundamental al \nunui MDOO este obiectul. \n 45\n\n1.3.Modelul de  date orientate obiect\nÎntr-un MDOO, orice entitate din lumea reală este \nun obiect şi reciproc, orice obiect reprezintă o entitate \na lumii reale. \nUn obiect reprezintă un grup de date stucturate, \nidentificate printr-o referinţă unică.\nUn obiect persistent este un obiect stocat în baza \nde date care are o durată de viaţă mai mare decât a \nprogramului care l-a creat. \nUn obiect tranzitoriu este un obiect depus în \nmemorie, a cărui durată de viaţă nu depăşeşte durata \nde viaţă a programului care l-a creat.\n 46', '\n', '6. ', '1.2.Modelul de date relaţional\nCele mai importante constrângeri de integritate \nsunt: \nConstrângerea de integritate a entităţii care \nstabileşte că fiecare tuplu să fie unic identificat \nprintr-o cheie şi atributul cheie să nu poată fi null;\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\n40\n\n1.2.Modelul de date relaţional\nConstrâgerea referenţială de integritate\nstabileşte că un n-tuplu dintr-o relaţie care se \nreferă la o altă relaţie, trebuie să se refere la \nun n-tuplu care există în acea relaţie; această\ncondiţie se referă la cheile străine.\n 41\n\n1.2.Modelul de date relaţional\nO cheie candidat a unei relaţii R este o mulţime \nminimă de atribute de care toate celelalte atribute ale \nlui R sunt dependente funcţional. \nCheia primară a unei relaţii R este una din cheile \ncandidat care a fost desemnată în acest scop.\nO cheie străină a unei relaţii R este o mulţime de \natribute din schema relaţională care formează o cheie \nprimară pentru o altă relaţie. \nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00 42\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 43\n\n1.3.Modelul de  date orientate obiect\nBazele de date orientate obiect permit \ncrearea unor obiecte complexe din componente \nmai simple, fiecare având atribute proprii şi \ncomportament specific. \n  Aceste sisteme combină posibilitatea definirii \nşi manipulării structurilor complexe de date cu \nfuncţionalitatea unui limbaj de programare şi \ntehnologia de gestiune a bazelor de date.\n 44\n\n1.3.Modelul de  date orientate obiect\nModelele de date \norientate obiect (MDOO) au \nfost create pentru a modela \nlumea reală. \nDe exemplu, limbajul C++ \na fost dezvoltat pentru a crea \nmodelul unui sistem \ntelefonic. \nConceptul fundamental al \nunui MDOO este obiectul. \n 45\n\n1.3.Modelul de  date orientate obiect\nÎntr-un MDOO, orice entitate din lumea reală este \nun obiect şi reciproc, orice obiect reprezintă o entitate \na lumii reale. \nUn obiect reprezintă un grup de date stucturate, \nidentificate printr-o referinţă unică.\nUn obiect persistent este un obiect stocat în baza \nde date care are o durată de viaţă mai mare decât a \nprogramului care l-a creat. \nUn obiect tranzitoriu este un obiect depus în \nmemorie, a cărui durată de viaţă nu depăşeşte durata \nde viaţă a programului care l-a creat.\n 46', '\n', '7. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '8. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '9. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '10. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n']","cuvântul cheie SQL utilizat pentru a defini o cheie primară este ""Cheia primară"". Aceasta asigură identificarea unică a fiecărei înregistrări: ""Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare."".
",Cu ce cuvânt cheie SQL se definește o cheie primară pentru a asigura identificarea unică a înregistrărilor în modelul relațional?,"['1. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '2. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '3. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '4. ', '1.2.Modelul de date relaţional\nCele mai importante constrângeri de integritate \nsunt: \nConstrângerea de integritate a entităţii care \nstabileşte că fiecare tuplu să fie unic identificat \nprintr-o cheie şi atributul cheie să nu poată fi null;\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\n40\n\n1.2.Modelul de date relaţional\nConstrâgerea referenţială de integritate\nstabileşte că un n-tuplu dintr-o relaţie care se \nreferă la o altă relaţie, trebuie să se refere la \nun n-tuplu care există în acea relaţie; această\ncondiţie se referă la cheile străine.\n 41\n\n1.2.Modelul de date relaţional\nO cheie candidat a unei relaţii R este o mulţime \nminimă de atribute de care toate celelalte atribute ale \nlui R sunt dependente funcţional. \nCheia primară a unei relaţii R este una din cheile \ncandidat care a fost desemnată în acest scop.\nO cheie străină a unei relaţii R este o mulţime de \natribute din schema relaţională care formează o cheie \nprimară pentru o altă relaţie. \nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00 42\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 43\n\n1.3.Modelul de  date orientate obiect\nBazele de date orientate obiect permit \ncrearea unor obiecte complexe din componente \nmai simple, fiecare având atribute proprii şi \ncomportament specific. \n  Aceste sisteme combină posibilitatea definirii \nşi manipulării structurilor complexe de date cu \nfuncţionalitatea unui limbaj de programare şi \ntehnologia de gestiune a bazelor de date.\n 44\n\n1.3.Modelul de  date orientate obiect\nModelele de date \norientate obiect (MDOO) au \nfost create pentru a modela \nlumea reală. \nDe exemplu, limbajul C++ \na fost dezvoltat pentru a crea \nmodelul unui sistem \ntelefonic. \nConceptul fundamental al \nunui MDOO este obiectul. \n 45\n\n1.3.Modelul de  date orientate obiect\nÎntr-un MDOO, orice entitate din lumea reală este \nun obiect şi reciproc, orice obiect reprezintă o entitate \na lumii reale. \nUn obiect reprezintă un grup de date stucturate, \nidentificate printr-o referinţă unică.\nUn obiect persistent este un obiect stocat în baza \nde date care are o durată de viaţă mai mare decât a \nprogramului care l-a creat. \nUn obiect tranzitoriu este un obiect depus în \nmemorie, a cărui durată de viaţă nu depăşeşte durata \nde viaţă a programului care l-a creat.\n 46', '\n', '5. ', '1.2.Modelul de date relaţional\nCele mai importante constrângeri de integritate \nsunt: \nConstrângerea de integritate a entităţii care \nstabileşte că fiecare tuplu să fie unic identificat \nprintr-o cheie şi atributul cheie să nu poată fi null;\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\n40\n\n1.2.Modelul de date relaţional\nConstrâgerea referenţială de integritate\nstabileşte că un n-tuplu dintr-o relaţie care se \nreferă la o altă relaţie, trebuie să se refere la \nun n-tuplu care există în acea relaţie; această\ncondiţie se referă la cheile străine.\n 41\n\n1.2.Modelul de date relaţional\nO cheie candidat a unei relaţii R este o mulţime \nminimă de atribute de care toate celelalte atribute ale \nlui R sunt dependente funcţional. \nCheia primară a unei relaţii R este una din cheile \ncandidat care a fost desemnată în acest scop.\nO cheie străină a unei relaţii R este o mulţime de \natribute din schema relaţională care formează o cheie \nprimară pentru o altă relaţie. \nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00 42\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 43\n\n1.3.Modelul de  date orientate obiect\nBazele de date orientate obiect permit \ncrearea unor obiecte complexe din componente \nmai simple, fiecare având atribute proprii şi \ncomportament specific. \n  Aceste sisteme combină posibilitatea definirii \nşi manipulării structurilor complexe de date cu \nfuncţionalitatea unui limbaj de programare şi \ntehnologia de gestiune a bazelor de date.\n 44\n\n1.3.Modelul de  date orientate obiect\nModelele de date \norientate obiect (MDOO) au \nfost create pentru a modela \nlumea reală. \nDe exemplu, limbajul C++ \na fost dezvoltat pentru a crea \nmodelul unui sistem \ntelefonic. \nConceptul fundamental al \nunui MDOO este obiectul. \n 45\n\n1.3.Modelul de  date orientate obiect\nÎntr-un MDOO, orice entitate din lumea reală este \nun obiect şi reciproc, orice obiect reprezintă o entitate \na lumii reale. \nUn obiect reprezintă un grup de date stucturate, \nidentificate printr-o referinţă unică.\nUn obiect persistent este un obiect stocat în baza \nde date care are o durată de viaţă mai mare decât a \nprogramului care l-a creat. \nUn obiect tranzitoriu este un obiect depus în \nmemorie, a cărui durată de viaţă nu depăşeşte durata \nde viaţă a programului care l-a creat.\n 46', '\n', '6. ', '1.2.Modelul de date relaţional\nCele mai importante constrângeri de integritate \nsunt: \nConstrângerea de integritate a entităţii care \nstabileşte că fiecare tuplu să fie unic identificat \nprintr-o cheie şi atributul cheie să nu poată fi null;\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\n40\n\n1.2.Modelul de date relaţional\nConstrâgerea referenţială de integritate\nstabileşte că un n-tuplu dintr-o relaţie care se \nreferă la o altă relaţie, trebuie să se refere la \nun n-tuplu care există în acea relaţie; această\ncondiţie se referă la cheile străine.\n 41\n\n1.2.Modelul de date relaţional\nO cheie candidat a unei relaţii R este o mulţime \nminimă de atribute de care toate celelalte atribute ale \nlui R sunt dependente funcţional. \nCheia primară a unei relaţii R este una din cheile \ncandidat care a fost desemnată în acest scop.\nO cheie străină a unei relaţii R este o mulţime de \natribute din schema relaţională care formează o cheie \nprimară pentru o altă relaţie. \nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00 42\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 43\n\n1.3.Modelul de  date orientate obiect\nBazele de date orientate obiect permit \ncrearea unor obiecte complexe din componente \nmai simple, fiecare având atribute proprii şi \ncomportament specific. \n  Aceste sisteme combină posibilitatea definirii \nşi manipulării structurilor complexe de date cu \nfuncţionalitatea unui limbaj de programare şi \ntehnologia de gestiune a bazelor de date.\n 44\n\n1.3.Modelul de  date orientate obiect\nModelele de date \norientate obiect (MDOO) au \nfost create pentru a modela \nlumea reală. \nDe exemplu, limbajul C++ \na fost dezvoltat pentru a crea \nmodelul unui sistem \ntelefonic. \nConceptul fundamental al \nunui MDOO este obiectul. \n 45\n\n1.3.Modelul de  date orientate obiect\nÎntr-un MDOO, orice entitate din lumea reală este \nun obiect şi reciproc, orice obiect reprezintă o entitate \na lumii reale. \nUn obiect reprezintă un grup de date stucturate, \nidentificate printr-o referinţă unică.\nUn obiect persistent este un obiect stocat în baza \nde date care are o durată de viaţă mai mare decât a \nprogramului care l-a creat. \nUn obiect tranzitoriu este un obiect depus în \nmemorie, a cărui durată de viaţă nu depăşeşte durata \nde viaţă a programului care l-a creat.\n 46', '\n', '7. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '8. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '9. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '10. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n']","cuvântul cheie SQL utilizat pentru a defini o cheie primară este ""Cheia primară"". Aceasta asigură identificarea unică a fiecărei înregistrări: ""Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare."".
",PRIMARY KEY,0.39145339953511066,1.0,0.9148439174024658,0.6666666666666666,0.0,0.0,0.0
13,O3mini-high,LOW,C14,,"În proiectarea bazelor de date relaționale, ce etapă transformă modelul conceptual într-un model relațional, pregătind implementarea efectivă a structurii bazei?",modelarea logică,Este corect,,"['1. ', ""Curs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n\n2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n);"", '\n', '2. ', ""Curs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n\n2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n);"", '\n', '3. ', ""Curs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n\n2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n);"", '\n', '4. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '5. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '6. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '7. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '8. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '9. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '10. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n']","etapa care transformă modelul conceptual într-un model relațional, pregătind implementarea efectivă a structurii bazei de date, este **Modelarea logică**.
","În proiectarea bazelor de date relaționale, ce etapă transformă modelul conceptual într-un model relațional, pregătind implementarea efectivă a structurii bazei?","['1. ', ""Curs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n\n2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n);"", '\n', '2. ', ""Curs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n\n2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n);"", '\n', '3. ', ""Curs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n\n2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n);"", '\n', '4. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '5. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '6. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '7. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '8. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '9. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '10. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n']","etapa care transformă modelul conceptual într-un model relațional, pregătind implementarea efectivă a structurii bazei de date, este **Modelarea logică**.
",modelarea logică,0.4249999999858333,1.0,0.8885937927807709,0.5,0.014445809981770858,0.16666666666666669,0.0
14,O3mini-high,Medium,Curs 1,,"Ce este o bază de date, conform cursului?","O bază de date este o colecție organizată de date stocate electronic, care permite accesul, gestionarea și actualizarea eficientă a acestora.",Este corect,,"['1. ', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul.', '\n', '2. ', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul.', '\n', '3. ', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul.', '\n', '4. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '5. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '6. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '7. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '8. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '9. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '10. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n']","o bază de date este o colecție organizată de date care sunt stocate electronic și structurate într-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora.
","Ce este o bază de date, conform cursului?","['1. ', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul.', '\n', '2. ', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul.', '\n', '3. ', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul.', '\n', '4. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '5. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '6. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '7. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '8. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '9. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '10. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n']","o bază de date este o colecție organizată de date care sunt stocate electronic și structurate într-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora.
","O bază de date este o colecție organizată de date stocate electronic, care permite accesul, gestionarea și actualizarea eficientă a acestora.",0.08411371237177816,1.0,0.9090845731131859,1.0,0.6366236814398645,0.8627450980392156,1.0
15,O3mini-high,Medium,Curs 2,,Ce reprezintă Oracle în cursul prezentat?,"Oracle este un SGBD complet relațional, extins, cu facilități din tehnologia orientată obiect, operațional pe toată gama de calculatoare.",Este corect,sllde 5,"['1. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n', '2. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n', '3. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n', '4. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nOracle 9i REAL APPLICATION CLUSTERS (RAC) se bazează pe \no nouă arhitectură de BD numită îmbinare ascunsă (Cache \nFusion). \n✓Aceasta este o nouă generaţie de tehnologie de clustere. \n✓Conform acestei arhitecturi la adăugarea unui calculator \nîntr-o reţea cu BD Oracle, clusterele se adaptează automat \nla noile resurse, fără să fie necesară redistribuirea datelor \nsau rescrierea aplicaţiei.\n✓Posibilitatea apariţiei unei erori la o configuraţie cu 12 \ncalculatoare sub Oracle 9i RAC este foarte mică, estimată \nca durată în timp la cca 100.000 de ani. \n17\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oracle 9i DEVELOPER SUITE este un mediu \ncomplet pentru dezvoltarea aplicaţiilor tip \nafaceri electronice (e-business) şi tip Web. \nEl se bazează pe tehnologiile Java şi XML şi permite \npersonalizarea (Oracle Personalization). \n• În anul 2003 a fost lansată versiunea Oracle 10g \ncare adaugă noi facilităţi sistemului Oracle 9i. \n19\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În anul 2007 a fost lansată versiunea Oracle \n11g care are cateva facilitati in plus:\n– Gestioneaza datele mai eficient prin compresii \navansate si partitionari \n– Simplifica sistemele prin stocarea tuturor datelor in \nOracle Database cu Oracle SecureFiles\n• În anul 2013 a fost lansată versiunea Oracle \n12c\n20\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle Database 12c prezintă o arhitectură nouă, cu \nmai multe entităţi găzduite, care permite unificarea \nrapidă a mai multor baze de date şi gestionarea \nacestora ca serviciu cloud. \n➢Oracle Database 12c include, de asemenea, capacităţi \nde procesare a datelor în memorie, care oferă o \nperformanţă analitică inovatoare. \n➢Inovaţiile suplimentare pentru baze de date oferă noi \nnivele de eficienţă, performanţă, securitate şi \ndisponibilitate.[*]\n21[*] https://www.oracle.com/ro/database/index.html\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', '\n', '5. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nOracle 9i REAL APPLICATION CLUSTERS (RAC) se bazează pe \no nouă arhitectură de BD numită îmbinare ascunsă (Cache \nFusion). \n✓Aceasta este o nouă generaţie de tehnologie de clustere. \n✓Conform acestei arhitecturi la adăugarea unui calculator \nîntr-o reţea cu BD Oracle, clusterele se adaptează automat \nla noile resurse, fără să fie necesară redistribuirea datelor \nsau rescrierea aplicaţiei.\n✓Posibilitatea apariţiei unei erori la o configuraţie cu 12 \ncalculatoare sub Oracle 9i RAC este foarte mică, estimată \nca durată în timp la cca 100.000 de ani. \n17\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oracle 9i DEVELOPER SUITE este un mediu \ncomplet pentru dezvoltarea aplicaţiilor tip \nafaceri electronice (e-business) şi tip Web. \nEl se bazează pe tehnologiile Java şi XML şi permite \npersonalizarea (Oracle Personalization). \n• În anul 2003 a fost lansată versiunea Oracle 10g \ncare adaugă noi facilităţi sistemului Oracle 9i. \n19\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În anul 2007 a fost lansată versiunea Oracle \n11g care are cateva facilitati in plus:\n– Gestioneaza datele mai eficient prin compresii \navansate si partitionari \n– Simplifica sistemele prin stocarea tuturor datelor in \nOracle Database cu Oracle SecureFiles\n• În anul 2013 a fost lansată versiunea Oracle \n12c\n20\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle Database 12c prezintă o arhitectură nouă, cu \nmai multe entităţi găzduite, care permite unificarea \nrapidă a mai multor baze de date şi gestionarea \nacestora ca serviciu cloud. \n➢Oracle Database 12c include, de asemenea, capacităţi \nde procesare a datelor în memorie, care oferă o \nperformanţă analitică inovatoare. \n➢Inovaţiile suplimentare pentru baze de date oferă noi \nnivele de eficienţă, performanţă, securitate şi \ndisponibilitate.[*]\n21[*] https://www.oracle.com/ro/database/index.html\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', '\n', '6. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nOracle 9i REAL APPLICATION CLUSTERS (RAC) se bazează pe \no nouă arhitectură de BD numită îmbinare ascunsă (Cache \nFusion). \n✓Aceasta este o nouă generaţie de tehnologie de clustere. \n✓Conform acestei arhitecturi la adăugarea unui calculator \nîntr-o reţea cu BD Oracle, clusterele se adaptează automat \nla noile resurse, fără să fie necesară redistribuirea datelor \nsau rescrierea aplicaţiei.\n✓Posibilitatea apariţiei unei erori la o configuraţie cu 12 \ncalculatoare sub Oracle 9i RAC este foarte mică, estimată \nca durată în timp la cca 100.000 de ani. \n17\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oracle 9i DEVELOPER SUITE este un mediu \ncomplet pentru dezvoltarea aplicaţiilor tip \nafaceri electronice (e-business) şi tip Web. \nEl se bazează pe tehnologiile Java şi XML şi permite \npersonalizarea (Oracle Personalization). \n• În anul 2003 a fost lansată versiunea Oracle 10g \ncare adaugă noi facilităţi sistemului Oracle 9i. \n19\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În anul 2007 a fost lansată versiunea Oracle \n11g care are cateva facilitati in plus:\n– Gestioneaza datele mai eficient prin compresii \navansate si partitionari \n– Simplifica sistemele prin stocarea tuturor datelor in \nOracle Database cu Oracle SecureFiles\n• În anul 2013 a fost lansată versiunea Oracle \n12c\n20\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle Database 12c prezintă o arhitectură nouă, cu \nmai multe entităţi găzduite, care permite unificarea \nrapidă a mai multor baze de date şi gestionarea \nacestora ca serviciu cloud. \n➢Oracle Database 12c include, de asemenea, capacităţi \nde procesare a datelor în memorie, care oferă o \nperformanţă analitică inovatoare. \n➢Inovaţiile suplimentare pentru baze de date oferă noi \nnivele de eficienţă, performanţă, securitate şi \ndisponibilitate.[*]\n21[*] https://www.oracle.com/ro/database/index.html\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', '\n', '7. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '8. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '9. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '10. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32\n\n2.3. ORACLE Server\n ORACLE Server (OS) permite \nmanagementul informaţiilor organizate în baze \nde date, astfel încât se asigură accesul mai \nmultor utilizatori în mod concurenţial la acelaşi \ndate, oferind facilităţi de prevenire a accesului \nneautorizat şi de restaurare a datelor după \nproducerea unor erori. \n33\n\n2.3. ORACLE Server\nORACLE Server este un sistem relaţional-\nobiectual de management a bazelor de date, \ncare permite o abordare deschisă, integrată şi \ncuprinzătoare a managementului \ninformaţiilor. \nOS constă dintr-un cuplu format dintr-o \nbază de date şi o instanţă Oracle.\n34\n\n2.3. ORACLE Server\nA. O bază de date Oracle este o colecţie \nunitară de date, având o structură logică şi \nuna fizică putând avea două stări: \n1. open (accesibilă) \n2. close (inaccesibilă)\n35\n\n2.3. ORACLE Server\n1) Structura logică a unei baze de date este \nformată din:\n✓tabelele spaţiu (tablespaces)\n✓schema de obiectelor bazei de date\n✓blocurile de date\n✓extensiile\n✓segmentele\n36\n\n2.3. ORACLE Server\n2) Structura fizică este definită de un set de \nfişiere specifice sistemului de operare pe care \nrezidă SGBD Oracle, folosite pentru memorarea \nstructurilor logice ale bazei de date şi pentru \npăstrarea unor informaţii tehnice de control. \nAceste fişiere sunt: \n- fişiere de date (Data files)\n- fişiere Redo log (Redo Log files) \n- fişiere de control (Control files)\n37\n\n2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n39\n\n2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40\n\n2.4. ORACLE Database 11g Expres Edition\n Pe calculatorul personal este ideal sa se \ninstaleze fisierul: \nOracle Database 11g Express Edition \n(Universal)  OracleXE112_Win32.zip\n41\n\n2.4. ORACLE Database 11g Expres Edition\nPas 1: Se porneste instalarea fisierului executabil si se vor \nurma pasii indicati de catre programul de instalare.\n42\n\n2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43\n\n2.4. ORACLE Database 11g Expres Edition\nInstalarea aplicatiei\n 44', '\n']","Oracle este un sistem de gestiune a bazelor de date (SGBD) complet relațional, extins, cu facilități din tehnologia orientată obiect (OO). Este realizat de firma Oracle Corporation.
",Ce reprezintă Oracle în cursul prezentat?,"['1. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n', '2. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n', '3. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n', '4. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nOracle 9i REAL APPLICATION CLUSTERS (RAC) se bazează pe \no nouă arhitectură de BD numită îmbinare ascunsă (Cache \nFusion). \n✓Aceasta este o nouă generaţie de tehnologie de clustere. \n✓Conform acestei arhitecturi la adăugarea unui calculator \nîntr-o reţea cu BD Oracle, clusterele se adaptează automat \nla noile resurse, fără să fie necesară redistribuirea datelor \nsau rescrierea aplicaţiei.\n✓Posibilitatea apariţiei unei erori la o configuraţie cu 12 \ncalculatoare sub Oracle 9i RAC este foarte mică, estimată \nca durată în timp la cca 100.000 de ani. \n17\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oracle 9i DEVELOPER SUITE este un mediu \ncomplet pentru dezvoltarea aplicaţiilor tip \nafaceri electronice (e-business) şi tip Web. \nEl se bazează pe tehnologiile Java şi XML şi permite \npersonalizarea (Oracle Personalization). \n• În anul 2003 a fost lansată versiunea Oracle 10g \ncare adaugă noi facilităţi sistemului Oracle 9i. \n19\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În anul 2007 a fost lansată versiunea Oracle \n11g care are cateva facilitati in plus:\n– Gestioneaza datele mai eficient prin compresii \navansate si partitionari \n– Simplifica sistemele prin stocarea tuturor datelor in \nOracle Database cu Oracle SecureFiles\n• În anul 2013 a fost lansată versiunea Oracle \n12c\n20\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle Database 12c prezintă o arhitectură nouă, cu \nmai multe entităţi găzduite, care permite unificarea \nrapidă a mai multor baze de date şi gestionarea \nacestora ca serviciu cloud. \n➢Oracle Database 12c include, de asemenea, capacităţi \nde procesare a datelor în memorie, care oferă o \nperformanţă analitică inovatoare. \n➢Inovaţiile suplimentare pentru baze de date oferă noi \nnivele de eficienţă, performanţă, securitate şi \ndisponibilitate.[*]\n21[*] https://www.oracle.com/ro/database/index.html\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', '\n', '5. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nOracle 9i REAL APPLICATION CLUSTERS (RAC) se bazează pe \no nouă arhitectură de BD numită îmbinare ascunsă (Cache \nFusion). \n✓Aceasta este o nouă generaţie de tehnologie de clustere. \n✓Conform acestei arhitecturi la adăugarea unui calculator \nîntr-o reţea cu BD Oracle, clusterele se adaptează automat \nla noile resurse, fără să fie necesară redistribuirea datelor \nsau rescrierea aplicaţiei.\n✓Posibilitatea apariţiei unei erori la o configuraţie cu 12 \ncalculatoare sub Oracle 9i RAC este foarte mică, estimată \nca durată în timp la cca 100.000 de ani. \n17\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oracle 9i DEVELOPER SUITE este un mediu \ncomplet pentru dezvoltarea aplicaţiilor tip \nafaceri electronice (e-business) şi tip Web. \nEl se bazează pe tehnologiile Java şi XML şi permite \npersonalizarea (Oracle Personalization). \n• În anul 2003 a fost lansată versiunea Oracle 10g \ncare adaugă noi facilităţi sistemului Oracle 9i. \n19\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În anul 2007 a fost lansată versiunea Oracle \n11g care are cateva facilitati in plus:\n– Gestioneaza datele mai eficient prin compresii \navansate si partitionari \n– Simplifica sistemele prin stocarea tuturor datelor in \nOracle Database cu Oracle SecureFiles\n• În anul 2013 a fost lansată versiunea Oracle \n12c\n20\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle Database 12c prezintă o arhitectură nouă, cu \nmai multe entităţi găzduite, care permite unificarea \nrapidă a mai multor baze de date şi gestionarea \nacestora ca serviciu cloud. \n➢Oracle Database 12c include, de asemenea, capacităţi \nde procesare a datelor în memorie, care oferă o \nperformanţă analitică inovatoare. \n➢Inovaţiile suplimentare pentru baze de date oferă noi \nnivele de eficienţă, performanţă, securitate şi \ndisponibilitate.[*]\n21[*] https://www.oracle.com/ro/database/index.html\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', '\n', '6. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nOracle 9i REAL APPLICATION CLUSTERS (RAC) se bazează pe \no nouă arhitectură de BD numită îmbinare ascunsă (Cache \nFusion). \n✓Aceasta este o nouă generaţie de tehnologie de clustere. \n✓Conform acestei arhitecturi la adăugarea unui calculator \nîntr-o reţea cu BD Oracle, clusterele se adaptează automat \nla noile resurse, fără să fie necesară redistribuirea datelor \nsau rescrierea aplicaţiei.\n✓Posibilitatea apariţiei unei erori la o configuraţie cu 12 \ncalculatoare sub Oracle 9i RAC este foarte mică, estimată \nca durată în timp la cca 100.000 de ani. \n17\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oracle 9i DEVELOPER SUITE este un mediu \ncomplet pentru dezvoltarea aplicaţiilor tip \nafaceri electronice (e-business) şi tip Web. \nEl se bazează pe tehnologiile Java şi XML şi permite \npersonalizarea (Oracle Personalization). \n• În anul 2003 a fost lansată versiunea Oracle 10g \ncare adaugă noi facilităţi sistemului Oracle 9i. \n19\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În anul 2007 a fost lansată versiunea Oracle \n11g care are cateva facilitati in plus:\n– Gestioneaza datele mai eficient prin compresii \navansate si partitionari \n– Simplifica sistemele prin stocarea tuturor datelor in \nOracle Database cu Oracle SecureFiles\n• În anul 2013 a fost lansată versiunea Oracle \n12c\n20\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle Database 12c prezintă o arhitectură nouă, cu \nmai multe entităţi găzduite, care permite unificarea \nrapidă a mai multor baze de date şi gestionarea \nacestora ca serviciu cloud. \n➢Oracle Database 12c include, de asemenea, capacităţi \nde procesare a datelor în memorie, care oferă o \nperformanţă analitică inovatoare. \n➢Inovaţiile suplimentare pentru baze de date oferă noi \nnivele de eficienţă, performanţă, securitate şi \ndisponibilitate.[*]\n21[*] https://www.oracle.com/ro/database/index.html\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', '\n', '7. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '8. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '9. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '10. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32\n\n2.3. ORACLE Server\n ORACLE Server (OS) permite \nmanagementul informaţiilor organizate în baze \nde date, astfel încât se asigură accesul mai \nmultor utilizatori în mod concurenţial la acelaşi \ndate, oferind facilităţi de prevenire a accesului \nneautorizat şi de restaurare a datelor după \nproducerea unor erori. \n33\n\n2.3. ORACLE Server\nORACLE Server este un sistem relaţional-\nobiectual de management a bazelor de date, \ncare permite o abordare deschisă, integrată şi \ncuprinzătoare a managementului \ninformaţiilor. \nOS constă dintr-un cuplu format dintr-o \nbază de date şi o instanţă Oracle.\n34\n\n2.3. ORACLE Server\nA. O bază de date Oracle este o colecţie \nunitară de date, având o structură logică şi \nuna fizică putând avea două stări: \n1. open (accesibilă) \n2. close (inaccesibilă)\n35\n\n2.3. ORACLE Server\n1) Structura logică a unei baze de date este \nformată din:\n✓tabelele spaţiu (tablespaces)\n✓schema de obiectelor bazei de date\n✓blocurile de date\n✓extensiile\n✓segmentele\n36\n\n2.3. ORACLE Server\n2) Structura fizică este definită de un set de \nfişiere specifice sistemului de operare pe care \nrezidă SGBD Oracle, folosite pentru memorarea \nstructurilor logice ale bazei de date şi pentru \npăstrarea unor informaţii tehnice de control. \nAceste fişiere sunt: \n- fişiere de date (Data files)\n- fişiere Redo log (Redo Log files) \n- fişiere de control (Control files)\n37\n\n2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n39\n\n2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40\n\n2.4. ORACLE Database 11g Expres Edition\n Pe calculatorul personal este ideal sa se \ninstaleze fisierul: \nOracle Database 11g Express Edition \n(Universal)  OracleXE112_Win32.zip\n41\n\n2.4. ORACLE Database 11g Expres Edition\nPas 1: Se porneste instalarea fisierului executabil si se vor \nurma pasii indicati de catre programul de instalare.\n42\n\n2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43\n\n2.4. ORACLE Database 11g Expres Edition\nInstalarea aplicatiei\n 44', '\n']","Oracle este un sistem de gestiune a bazelor de date (SGBD) complet relațional, extins, cu facilități din tehnologia orientată obiect (OO). Este realizat de firma Oracle Corporation.
","Oracle este un SGBD complet relațional, extins, cu facilități din tehnologia orientată obiect, operațional pe toată gama de calculatoare.",0.15133894590863278,1.0,0.8583797228582304,1.0,0.4369942407063455,0.6274509803921569,0.67
16,O3mini-high,Medium,Curs 3,,Ce face clauza ORDER BY într-o interogare SELECT?,"ORDER BY sortează liniile rezultatului conform criteriilor specificate; fără aceasta, ordinea rezultatelor este independentă de ordinea inserării.",Este corect,sllde 6,"['1. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '2. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '3. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '4. ', 'Clauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \n 68\n\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 69\n\nClauza ORDER BY\n➢În mod normal (fără clauza ORDER BY) rândurile sunt \nreturnate într-o ordine convenită de Oracle însă ea \nfiind consistentă de la cerere la cerere. \n➢Cu ajutorul clauzei ORDER BY rândurile vor fi afişate în \nordinea solicitată (cu toate acestea nu se va modifica \nordinea internă a rândurilor din baza de date).\n➢Clauza ORDER BY trebuie să fie ultima clauză din cerere \n(interogare).\n 70\n\nClauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine crescătoare).\nSELECT * \nFROM EMP\nORDER BY hiredata; \n 72\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare (în ordine crescătoare).\n 73\n\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine descrescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate DESC;\n 74\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă data de angajare (în ordine descrescătoare). \n 75\n\n\nClauza ORDER BY\n➢Mai putem ordona randurile returnate cu ajutorul \nalias-urilor.\nExemplu: \nListati toti angajatii ordonandu-i dupa salariul anual: \nsal*12 salariuanual (in ordine crescatoare). \nSELECT ename, job, sal*12 SALARIU_ANUAL\nFROM EMP\nORDER BY SALARIU_ANUAL;\n 76\n\nClauza ORDER BY\nRezultatul obtinut - Listati toti angajatii ordonandu-i dupa salariul \nanual: sal*12 salariuanual (in ordine crescatoare). \n 77\n\n\nClauza ORDER BY\n➢ Rândurile mai pot fi ordonate şi după mai multe coloane. \n➢ Numărul de coloane după care se pot ordona rândurile \nîntoarse este numărul maxim de coloane existente în tabelă. \nExemplu \n Listaţi toţi angajaţii ordonându-i după data de angajare, \nsalariu şi comision (în ordine crescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate, sal, comm; \n 78\n\nClauza ORDER BY\n➢ Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare, salariu şi comision (în ordine crescătoare). \n 79\n\n\nClauza ORDER BY\n➢În clauza ORDER BY se pot folosi coloane care nu sunt \nconţinute în SELECT.\n \nExemplu: \n  Listaţi toţi angajaţii ordonându-i după salariu (în \nordine crescătoare).\nSELECT ename, job\nFROM EMP\nORDER BY sal;  \n 80\n\nClauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82', '\n', '5. ', 'Clauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \n 68\n\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 69\n\nClauza ORDER BY\n➢În mod normal (fără clauza ORDER BY) rândurile sunt \nreturnate într-o ordine convenită de Oracle însă ea \nfiind consistentă de la cerere la cerere. \n➢Cu ajutorul clauzei ORDER BY rândurile vor fi afişate în \nordinea solicitată (cu toate acestea nu se va modifica \nordinea internă a rândurilor din baza de date).\n➢Clauza ORDER BY trebuie să fie ultima clauză din cerere \n(interogare).\n 70\n\nClauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine crescătoare).\nSELECT * \nFROM EMP\nORDER BY hiredata; \n 72\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare (în ordine crescătoare).\n 73\n\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine descrescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate DESC;\n 74\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă data de angajare (în ordine descrescătoare). \n 75\n\n\nClauza ORDER BY\n➢Mai putem ordona randurile returnate cu ajutorul \nalias-urilor.\nExemplu: \nListati toti angajatii ordonandu-i dupa salariul anual: \nsal*12 salariuanual (in ordine crescatoare). \nSELECT ename, job, sal*12 SALARIU_ANUAL\nFROM EMP\nORDER BY SALARIU_ANUAL;\n 76\n\nClauza ORDER BY\nRezultatul obtinut - Listati toti angajatii ordonandu-i dupa salariul \nanual: sal*12 salariuanual (in ordine crescatoare). \n 77\n\n\nClauza ORDER BY\n➢ Rândurile mai pot fi ordonate şi după mai multe coloane. \n➢ Numărul de coloane după care se pot ordona rândurile \nîntoarse este numărul maxim de coloane existente în tabelă. \nExemplu \n Listaţi toţi angajaţii ordonându-i după data de angajare, \nsalariu şi comision (în ordine crescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate, sal, comm; \n 78\n\nClauza ORDER BY\n➢ Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare, salariu şi comision (în ordine crescătoare). \n 79\n\n\nClauza ORDER BY\n➢În clauza ORDER BY se pot folosi coloane care nu sunt \nconţinute în SELECT.\n \nExemplu: \n  Listaţi toţi angajaţii ordonându-i după salariu (în \nordine crescătoare).\nSELECT ename, job\nFROM EMP\nORDER BY sal;  \n 80\n\nClauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82', '\n', '6. ', 'Clauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \n 68\n\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 69\n\nClauza ORDER BY\n➢În mod normal (fără clauza ORDER BY) rândurile sunt \nreturnate într-o ordine convenită de Oracle însă ea \nfiind consistentă de la cerere la cerere. \n➢Cu ajutorul clauzei ORDER BY rândurile vor fi afişate în \nordinea solicitată (cu toate acestea nu se va modifica \nordinea internă a rândurilor din baza de date).\n➢Clauza ORDER BY trebuie să fie ultima clauză din cerere \n(interogare).\n 70\n\nClauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine crescătoare).\nSELECT * \nFROM EMP\nORDER BY hiredata; \n 72\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare (în ordine crescătoare).\n 73\n\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine descrescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate DESC;\n 74\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă data de angajare (în ordine descrescătoare). \n 75\n\n\nClauza ORDER BY\n➢Mai putem ordona randurile returnate cu ajutorul \nalias-urilor.\nExemplu: \nListati toti angajatii ordonandu-i dupa salariul anual: \nsal*12 salariuanual (in ordine crescatoare). \nSELECT ename, job, sal*12 SALARIU_ANUAL\nFROM EMP\nORDER BY SALARIU_ANUAL;\n 76\n\nClauza ORDER BY\nRezultatul obtinut - Listati toti angajatii ordonandu-i dupa salariul \nanual: sal*12 salariuanual (in ordine crescatoare). \n 77\n\n\nClauza ORDER BY\n➢ Rândurile mai pot fi ordonate şi după mai multe coloane. \n➢ Numărul de coloane după care se pot ordona rândurile \nîntoarse este numărul maxim de coloane existente în tabelă. \nExemplu \n Listaţi toţi angajaţii ordonându-i după data de angajare, \nsalariu şi comision (în ordine crescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate, sal, comm; \n 78\n\nClauza ORDER BY\n➢ Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare, salariu şi comision (în ordine crescătoare). \n 79\n\n\nClauza ORDER BY\n➢În clauza ORDER BY se pot folosi coloane care nu sunt \nconţinute în SELECT.\n \nExemplu: \n  Listaţi toţi angajaţii ordonându-i după salariu (în \nordine crescătoare).\nSELECT ename, job\nFROM EMP\nORDER BY sal;  \n 80\n\nClauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82', '\n', '7. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '8. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '9. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '10. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n']","clauza ORDER BY specifică ordinea în care sunt afișate rândurile dintr-o interogare SELECT. Rândurile pot fi ordonate crescător (ASC) sau descrescător (DESC) după una sau mai multe coloane sau expresii. Aceasta trebuie să fie ultima clauză din interogare.
",Ce face clauza ORDER BY într-o interogare SELECT?,"['1. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '2. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '3. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '4. ', 'Clauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \n 68\n\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 69\n\nClauza ORDER BY\n➢În mod normal (fără clauza ORDER BY) rândurile sunt \nreturnate într-o ordine convenită de Oracle însă ea \nfiind consistentă de la cerere la cerere. \n➢Cu ajutorul clauzei ORDER BY rândurile vor fi afişate în \nordinea solicitată (cu toate acestea nu se va modifica \nordinea internă a rândurilor din baza de date).\n➢Clauza ORDER BY trebuie să fie ultima clauză din cerere \n(interogare).\n 70\n\nClauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine crescătoare).\nSELECT * \nFROM EMP\nORDER BY hiredata; \n 72\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare (în ordine crescătoare).\n 73\n\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine descrescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate DESC;\n 74\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă data de angajare (în ordine descrescătoare). \n 75\n\n\nClauza ORDER BY\n➢Mai putem ordona randurile returnate cu ajutorul \nalias-urilor.\nExemplu: \nListati toti angajatii ordonandu-i dupa salariul anual: \nsal*12 salariuanual (in ordine crescatoare). \nSELECT ename, job, sal*12 SALARIU_ANUAL\nFROM EMP\nORDER BY SALARIU_ANUAL;\n 76\n\nClauza ORDER BY\nRezultatul obtinut - Listati toti angajatii ordonandu-i dupa salariul \nanual: sal*12 salariuanual (in ordine crescatoare). \n 77\n\n\nClauza ORDER BY\n➢ Rândurile mai pot fi ordonate şi după mai multe coloane. \n➢ Numărul de coloane după care se pot ordona rândurile \nîntoarse este numărul maxim de coloane existente în tabelă. \nExemplu \n Listaţi toţi angajaţii ordonându-i după data de angajare, \nsalariu şi comision (în ordine crescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate, sal, comm; \n 78\n\nClauza ORDER BY\n➢ Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare, salariu şi comision (în ordine crescătoare). \n 79\n\n\nClauza ORDER BY\n➢În clauza ORDER BY se pot folosi coloane care nu sunt \nconţinute în SELECT.\n \nExemplu: \n  Listaţi toţi angajaţii ordonându-i după salariu (în \nordine crescătoare).\nSELECT ename, job\nFROM EMP\nORDER BY sal;  \n 80\n\nClauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82', '\n', '5. ', 'Clauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \n 68\n\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 69\n\nClauza ORDER BY\n➢În mod normal (fără clauza ORDER BY) rândurile sunt \nreturnate într-o ordine convenită de Oracle însă ea \nfiind consistentă de la cerere la cerere. \n➢Cu ajutorul clauzei ORDER BY rândurile vor fi afişate în \nordinea solicitată (cu toate acestea nu se va modifica \nordinea internă a rândurilor din baza de date).\n➢Clauza ORDER BY trebuie să fie ultima clauză din cerere \n(interogare).\n 70\n\nClauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine crescătoare).\nSELECT * \nFROM EMP\nORDER BY hiredata; \n 72\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare (în ordine crescătoare).\n 73\n\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine descrescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate DESC;\n 74\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă data de angajare (în ordine descrescătoare). \n 75\n\n\nClauza ORDER BY\n➢Mai putem ordona randurile returnate cu ajutorul \nalias-urilor.\nExemplu: \nListati toti angajatii ordonandu-i dupa salariul anual: \nsal*12 salariuanual (in ordine crescatoare). \nSELECT ename, job, sal*12 SALARIU_ANUAL\nFROM EMP\nORDER BY SALARIU_ANUAL;\n 76\n\nClauza ORDER BY\nRezultatul obtinut - Listati toti angajatii ordonandu-i dupa salariul \nanual: sal*12 salariuanual (in ordine crescatoare). \n 77\n\n\nClauza ORDER BY\n➢ Rândurile mai pot fi ordonate şi după mai multe coloane. \n➢ Numărul de coloane după care se pot ordona rândurile \nîntoarse este numărul maxim de coloane existente în tabelă. \nExemplu \n Listaţi toţi angajaţii ordonându-i după data de angajare, \nsalariu şi comision (în ordine crescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate, sal, comm; \n 78\n\nClauza ORDER BY\n➢ Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare, salariu şi comision (în ordine crescătoare). \n 79\n\n\nClauza ORDER BY\n➢În clauza ORDER BY se pot folosi coloane care nu sunt \nconţinute în SELECT.\n \nExemplu: \n  Listaţi toţi angajaţii ordonându-i după salariu (în \nordine crescătoare).\nSELECT ename, job\nFROM EMP\nORDER BY sal;  \n 80\n\nClauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82', '\n', '6. ', 'Clauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \n 68\n\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 69\n\nClauza ORDER BY\n➢În mod normal (fără clauza ORDER BY) rândurile sunt \nreturnate într-o ordine convenită de Oracle însă ea \nfiind consistentă de la cerere la cerere. \n➢Cu ajutorul clauzei ORDER BY rândurile vor fi afişate în \nordinea solicitată (cu toate acestea nu se va modifica \nordinea internă a rândurilor din baza de date).\n➢Clauza ORDER BY trebuie să fie ultima clauză din cerere \n(interogare).\n 70\n\nClauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine crescătoare).\nSELECT * \nFROM EMP\nORDER BY hiredata; \n 72\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare (în ordine crescătoare).\n 73\n\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine descrescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate DESC;\n 74\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă data de angajare (în ordine descrescătoare). \n 75\n\n\nClauza ORDER BY\n➢Mai putem ordona randurile returnate cu ajutorul \nalias-urilor.\nExemplu: \nListati toti angajatii ordonandu-i dupa salariul anual: \nsal*12 salariuanual (in ordine crescatoare). \nSELECT ename, job, sal*12 SALARIU_ANUAL\nFROM EMP\nORDER BY SALARIU_ANUAL;\n 76\n\nClauza ORDER BY\nRezultatul obtinut - Listati toti angajatii ordonandu-i dupa salariul \nanual: sal*12 salariuanual (in ordine crescatoare). \n 77\n\n\nClauza ORDER BY\n➢ Rândurile mai pot fi ordonate şi după mai multe coloane. \n➢ Numărul de coloane după care se pot ordona rândurile \nîntoarse este numărul maxim de coloane existente în tabelă. \nExemplu \n Listaţi toţi angajaţii ordonându-i după data de angajare, \nsalariu şi comision (în ordine crescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate, sal, comm; \n 78\n\nClauza ORDER BY\n➢ Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare, salariu şi comision (în ordine crescătoare). \n 79\n\n\nClauza ORDER BY\n➢În clauza ORDER BY se pot folosi coloane care nu sunt \nconţinute în SELECT.\n \nExemplu: \n  Listaţi toţi angajaţii ordonându-i după salariu (în \nordine crescătoare).\nSELECT ename, job\nFROM EMP\nORDER BY sal;  \n 80\n\nClauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82', '\n', '7. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '8. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '9. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '10. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n']","clauza ORDER BY specifică ordinea în care sunt afișate rândurile dintr-o interogare SELECT. Rândurile pot fi ordonate crescător (ASC) sau descrescător (DESC) după una sau mai multe coloane sau expresii. Aceasta trebuie să fie ultima clauză din interogare.
","ORDER BY sortează liniile rezultatului conform criteriilor specificate; fără aceasta, ordinea rezultatelor este independentă de ordinea inserării.",0.17639955951682412,1.0,0.8661431064616965,1.0,0.03990502812023364,0.15873015873015872,0.4
17,O3mini-high,Medium,Curs 4,,"În ce două categorii se împart funcțiile în SQL, conform cursului?",Funcțiile se clasifică în: 1. Funcții referitoare la o singură înregistrare; 2. Funcții referitoare la mai multe înregistrări (funcții de grup).,Este corect,slide 8,"['1. ', ""4.2.5. Funcţii generale\nExemplu 2:\nselect CASE 'C++' \n  WHEN 'PLSQL' THEN 'Limbajul PLSQL'\n  WHEN 'SQL' THEN 'Limbajul de interogare SQL'\n  ELSE 'Limbaj de programare'\n  END\nfrom dual\nCurs 4 - BAZE DE DATE 113\n\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm\n3) https://www.w3resource.com/sql-exercises/\nCurs 4 - BAZE DE DATE 114\n\nÎntrebări?\nCurs 4 - BAZE DE DATE 115"", '\n', '2. ', ""4.2.5. Funcţii generale\nExemplu 2:\nselect CASE 'C++' \n  WHEN 'PLSQL' THEN 'Limbajul PLSQL'\n  WHEN 'SQL' THEN 'Limbajul de interogare SQL'\n  ELSE 'Limbaj de programare'\n  END\nfrom dual\nCurs 4 - BAZE DE DATE 113\n\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm\n3) https://www.w3resource.com/sql-exercises/\nCurs 4 - BAZE DE DATE 114\n\nÎntrebări?\nCurs 4 - BAZE DE DATE 115"", '\n', '3. ', ""4.2.5. Funcţii generale\nExemplu 2:\nselect CASE 'C++' \n  WHEN 'PLSQL' THEN 'Limbajul PLSQL'\n  WHEN 'SQL' THEN 'Limbajul de interogare SQL'\n  ELSE 'Limbaj de programare'\n  END\nfrom dual\nCurs 4 - BAZE DE DATE 113\n\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm\n3) https://www.w3resource.com/sql-exercises/\nCurs 4 - BAZE DE DATE 114\n\nÎntrebări?\nCurs 4 - BAZE DE DATE 115"", '\n', '4. ', 'Curs 5 \nLimbajul SQL \nCurs 5 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea III)\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 3\n\nTabele EMP si DEPT\nPentru exemplele din cursuri vom folosi tabela EMP:\nCurs 5 - BAZE DE DATE 4\nStructura tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 5\nPentru exemplele din cursuri vom folosi tabela EMP:\nContinutul initial al tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 6\nStructura tabelei DEPT.\nContinutul initial al tabelei DEPT.\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7\n\nFuncţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. funcţii caracter\n2. funcţii numerice\n3. funcţii pentru data calendaristică si oră\n4. funcţii de conversie\n5. funcţii diverse\nCurs 5 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• funcţii totalizatoare sau funcţii de grup\nCurs 5 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13\n\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', '\n', '5. ', 'Curs 5 \nLimbajul SQL \nCurs 5 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea III)\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 3\n\nTabele EMP si DEPT\nPentru exemplele din cursuri vom folosi tabela EMP:\nCurs 5 - BAZE DE DATE 4\nStructura tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 5\nPentru exemplele din cursuri vom folosi tabela EMP:\nContinutul initial al tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 6\nStructura tabelei DEPT.\nContinutul initial al tabelei DEPT.\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7\n\nFuncţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. funcţii caracter\n2. funcţii numerice\n3. funcţii pentru data calendaristică si oră\n4. funcţii de conversie\n5. funcţii diverse\nCurs 5 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• funcţii totalizatoare sau funcţii de grup\nCurs 5 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13\n\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', '\n', '6. ', 'Curs 5 \nLimbajul SQL \nCurs 5 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea III)\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 3\n\nTabele EMP si DEPT\nPentru exemplele din cursuri vom folosi tabela EMP:\nCurs 5 - BAZE DE DATE 4\nStructura tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 5\nPentru exemplele din cursuri vom folosi tabela EMP:\nContinutul initial al tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 6\nStructura tabelei DEPT.\nContinutul initial al tabelei DEPT.\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7\n\nFuncţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. funcţii caracter\n2. funcţii numerice\n3. funcţii pentru data calendaristică si oră\n4. funcţii de conversie\n5. funcţii diverse\nCurs 5 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• funcţii totalizatoare sau funcţii de grup\nCurs 5 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13\n\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', '\n', '7. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '8. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '9. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '10. ', ""4.2.4. Funcţii de conversie dintr-un tip în \naltul\nExemplu 1:\nselect to_number('123.45') + 18.3\nfrom dual\nCurs 4 - BAZE DE DATE 91\n\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\nExemplu 2:\nselect to_number('-$98,765.43','$99,999.99')\nfrom dual;\nCurs 4 - BAZE DE DATE 92\n\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 93\n\n4.2.5. Funcţii generale\nFuncţii generale: \n1. NVL \n2. NVL2 \n3. NULLIF\n4. COALESCE\nAceste funcţii au ca argumente date de diferite\ntipuri şi returnează date de tipuri diferite.\nAceste funcţii precizează cum sunt prelucrate\nvalorile de tip NULL.\nCurs 4 - BAZE DE DATE 94\n\n4.2.5. Funcţii generale\n1. Funcţia NVL cu formatul:\nNVL(valoare1, valoare2)\nReturneaza valoarea1, daca este nenula, sau \nreturneaza valoarea2, daca valoare1 este \nNULL.\nFuncţia prelucreaza date de tipurile caracter, \nnumeric sau data calendaristica, cu precizarea \nca ambele valori parametru sunt de acelasi \ntip. \nCurs 4 - BAZE DE DATE 95\n\n4.2.5. Funcţii generale\nExemplu:\nselect ename, comm, NVL(comm,0.8)\nfrom emp\nwhere empno between 7600 and 7800\nCurs 4 - BAZE DE DATE 96\n\n\n4.2.5. Funcţii generale\n2. Funcţia NVL2 cu formatul:\nNVL2(valoare1, valoare2, valoare3)\nreturneaza valoare2, daca valoare1 este nenula, \niar daca valoare1 este NULL, atunci returneaza \nvaloare3.\nCurs 4 - BAZE DE DATE 97\n\n4.2.5. Funcţii generale\nExemplu:\nselect ename, comm, NVL2(comm,'ARE \nCOMISION','NU ARE COMISION')\nfrom emp \nwhere empno between 7600 and 7800\nCurs 4 - BAZE DE DATE 98\n\n4.2.5. Funcţii generale\nRezultat afisat:\nCurs 4 - BAZE DE DATE 99\n\n\n4.2.5. Funcţii generale\n3. Funcţia NULLIF cu formatul:\nNULLIF(expresie1, expresie2)\nReturneaza NULL, daca cele doua expresii sunt \negale.\nDaca cele doua espresii sunt diferite (valorile \nlor), atunci returneaza valoarea primei expresii \n– expresie1.\nCurs 4 - BAZE DE DATE 100\n\n4.2.5. Funcţii generale\nExemplu:\nselect empno, ename, job, \nNULLIF(length(ename),length(job))\nfrom emp \nwhere empno between 7300 and 7700\nCurs 4 - BAZE DE DATE 101\n\n4.2.5. Funcţii generale\nRezultat afisat:\nCurs 4 - BAZE DE DATE 102\n\n\n4.2.5. Funcţii generale\n4. Funcţia COALESCE cu formatul:\nCOALESCE( expresie1, expresie2, …, expresien)\nReturneaza valoarea primei expresii nenule.\nCurs 4 - BAZE DE DATE 103\n\n4.2.5. Funcţii generale\nExemplu:\nselect coalesce(null, null, '678', 'sir de test') \nfrom dual\nCurs 4 - BAZE DE DATE 104"", '\n']","funcțiile se clasifică în două tipuri:

1.  Funcţii referitoare la o singură înregistrare (single-row functions)
2.  Funcţii referitoare la mai multe înregistrări (multiple-row functions)
","În ce două categorii se împart funcțiile în SQL, conform cursului?","['1. ', ""4.2.5. Funcţii generale\nExemplu 2:\nselect CASE 'C++' \n  WHEN 'PLSQL' THEN 'Limbajul PLSQL'\n  WHEN 'SQL' THEN 'Limbajul de interogare SQL'\n  ELSE 'Limbaj de programare'\n  END\nfrom dual\nCurs 4 - BAZE DE DATE 113\n\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm\n3) https://www.w3resource.com/sql-exercises/\nCurs 4 - BAZE DE DATE 114\n\nÎntrebări?\nCurs 4 - BAZE DE DATE 115"", '\n', '2. ', ""4.2.5. Funcţii generale\nExemplu 2:\nselect CASE 'C++' \n  WHEN 'PLSQL' THEN 'Limbajul PLSQL'\n  WHEN 'SQL' THEN 'Limbajul de interogare SQL'\n  ELSE 'Limbaj de programare'\n  END\nfrom dual\nCurs 4 - BAZE DE DATE 113\n\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm\n3) https://www.w3resource.com/sql-exercises/\nCurs 4 - BAZE DE DATE 114\n\nÎntrebări?\nCurs 4 - BAZE DE DATE 115"", '\n', '3. ', ""4.2.5. Funcţii generale\nExemplu 2:\nselect CASE 'C++' \n  WHEN 'PLSQL' THEN 'Limbajul PLSQL'\n  WHEN 'SQL' THEN 'Limbajul de interogare SQL'\n  ELSE 'Limbaj de programare'\n  END\nfrom dual\nCurs 4 - BAZE DE DATE 113\n\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm\n3) https://www.w3resource.com/sql-exercises/\nCurs 4 - BAZE DE DATE 114\n\nÎntrebări?\nCurs 4 - BAZE DE DATE 115"", '\n', '4. ', 'Curs 5 \nLimbajul SQL \nCurs 5 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea III)\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 3\n\nTabele EMP si DEPT\nPentru exemplele din cursuri vom folosi tabela EMP:\nCurs 5 - BAZE DE DATE 4\nStructura tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 5\nPentru exemplele din cursuri vom folosi tabela EMP:\nContinutul initial al tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 6\nStructura tabelei DEPT.\nContinutul initial al tabelei DEPT.\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7\n\nFuncţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. funcţii caracter\n2. funcţii numerice\n3. funcţii pentru data calendaristică si oră\n4. funcţii de conversie\n5. funcţii diverse\nCurs 5 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• funcţii totalizatoare sau funcţii de grup\nCurs 5 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13\n\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', '\n', '5. ', 'Curs 5 \nLimbajul SQL \nCurs 5 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea III)\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 3\n\nTabele EMP si DEPT\nPentru exemplele din cursuri vom folosi tabela EMP:\nCurs 5 - BAZE DE DATE 4\nStructura tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 5\nPentru exemplele din cursuri vom folosi tabela EMP:\nContinutul initial al tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 6\nStructura tabelei DEPT.\nContinutul initial al tabelei DEPT.\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7\n\nFuncţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. funcţii caracter\n2. funcţii numerice\n3. funcţii pentru data calendaristică si oră\n4. funcţii de conversie\n5. funcţii diverse\nCurs 5 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• funcţii totalizatoare sau funcţii de grup\nCurs 5 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13\n\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', '\n', '6. ', 'Curs 5 \nLimbajul SQL \nCurs 5 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea III)\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 3\n\nTabele EMP si DEPT\nPentru exemplele din cursuri vom folosi tabela EMP:\nCurs 5 - BAZE DE DATE 4\nStructura tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 5\nPentru exemplele din cursuri vom folosi tabela EMP:\nContinutul initial al tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 6\nStructura tabelei DEPT.\nContinutul initial al tabelei DEPT.\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7\n\nFuncţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. funcţii caracter\n2. funcţii numerice\n3. funcţii pentru data calendaristică si oră\n4. funcţii de conversie\n5. funcţii diverse\nCurs 5 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• funcţii totalizatoare sau funcţii de grup\nCurs 5 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13\n\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', '\n', '7. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '8. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '9. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '10. ', ""4.2.4. Funcţii de conversie dintr-un tip în \naltul\nExemplu 1:\nselect to_number('123.45') + 18.3\nfrom dual\nCurs 4 - BAZE DE DATE 91\n\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\nExemplu 2:\nselect to_number('-$98,765.43','$99,999.99')\nfrom dual;\nCurs 4 - BAZE DE DATE 92\n\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 93\n\n4.2.5. Funcţii generale\nFuncţii generale: \n1. NVL \n2. NVL2 \n3. NULLIF\n4. COALESCE\nAceste funcţii au ca argumente date de diferite\ntipuri şi returnează date de tipuri diferite.\nAceste funcţii precizează cum sunt prelucrate\nvalorile de tip NULL.\nCurs 4 - BAZE DE DATE 94\n\n4.2.5. Funcţii generale\n1. Funcţia NVL cu formatul:\nNVL(valoare1, valoare2)\nReturneaza valoarea1, daca este nenula, sau \nreturneaza valoarea2, daca valoare1 este \nNULL.\nFuncţia prelucreaza date de tipurile caracter, \nnumeric sau data calendaristica, cu precizarea \nca ambele valori parametru sunt de acelasi \ntip. \nCurs 4 - BAZE DE DATE 95\n\n4.2.5. Funcţii generale\nExemplu:\nselect ename, comm, NVL(comm,0.8)\nfrom emp\nwhere empno between 7600 and 7800\nCurs 4 - BAZE DE DATE 96\n\n\n4.2.5. Funcţii generale\n2. Funcţia NVL2 cu formatul:\nNVL2(valoare1, valoare2, valoare3)\nreturneaza valoare2, daca valoare1 este nenula, \niar daca valoare1 este NULL, atunci returneaza \nvaloare3.\nCurs 4 - BAZE DE DATE 97\n\n4.2.5. Funcţii generale\nExemplu:\nselect ename, comm, NVL2(comm,'ARE \nCOMISION','NU ARE COMISION')\nfrom emp \nwhere empno between 7600 and 7800\nCurs 4 - BAZE DE DATE 98\n\n4.2.5. Funcţii generale\nRezultat afisat:\nCurs 4 - BAZE DE DATE 99\n\n\n4.2.5. Funcţii generale\n3. Funcţia NULLIF cu formatul:\nNULLIF(expresie1, expresie2)\nReturneaza NULL, daca cele doua expresii sunt \negale.\nDaca cele doua espresii sunt diferite (valorile \nlor), atunci returneaza valoarea primei expresii \n– expresie1.\nCurs 4 - BAZE DE DATE 100\n\n4.2.5. Funcţii generale\nExemplu:\nselect empno, ename, job, \nNULLIF(length(ename),length(job))\nfrom emp \nwhere empno between 7300 and 7700\nCurs 4 - BAZE DE DATE 101\n\n4.2.5. Funcţii generale\nRezultat afisat:\nCurs 4 - BAZE DE DATE 102\n\n\n4.2.5. Funcţii generale\n4. Funcţia COALESCE cu formatul:\nCOALESCE( expresie1, expresie2, …, expresien)\nReturneaza valoarea primei expresii nenule.\nCurs 4 - BAZE DE DATE 103\n\n4.2.5. Funcţii generale\nExemplu:\nselect coalesce(null, null, '678', 'sir de test') \nfrom dual\nCurs 4 - BAZE DE DATE 104"", '\n']","funcțiile se clasifică în două tipuri:

1.  Funcţii referitoare la o singură înregistrare (single-row functions)
2.  Funcţii referitoare la mai multe înregistrări (multiple-row functions)
",Funcțiile se clasifică în: 1. Funcții referitoare la o singură înregistrare; 2. Funcții referitoare la mai multe înregistrări (funcții de grup).,0.13674560732928445,1.0,0.8199122666855015,1.0,0.25848657697858535,0.7857142857142856,1.0
18,O3mini-high,Medium,Curs 5,,"Ce sunt funcțiile de grup în SQL, conform cursului?","Funcțiile de grup operează pe un set de rânduri, returnând un singur rezultat pentru fiecare grup (ex. AVG, COUNT, SUM).",Este corect,slide 14,"['1. ', 'Curs 5 \nLimbajul SQL \nCurs 5 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea III)\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 3\n\nTabele EMP si DEPT\nPentru exemplele din cursuri vom folosi tabela EMP:\nCurs 5 - BAZE DE DATE 4\nStructura tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 5\nPentru exemplele din cursuri vom folosi tabela EMP:\nContinutul initial al tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 6\nStructura tabelei DEPT.\nContinutul initial al tabelei DEPT.\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7\n\nFuncţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. funcţii caracter\n2. funcţii numerice\n3. funcţii pentru data calendaristică si oră\n4. funcţii de conversie\n5. funcţii diverse\nCurs 5 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• funcţii totalizatoare sau funcţii de grup\nCurs 5 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13\n\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', '\n', '2. ', 'Curs 5 \nLimbajul SQL \nCurs 5 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea III)\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 3\n\nTabele EMP si DEPT\nPentru exemplele din cursuri vom folosi tabela EMP:\nCurs 5 - BAZE DE DATE 4\nStructura tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 5\nPentru exemplele din cursuri vom folosi tabela EMP:\nContinutul initial al tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 6\nStructura tabelei DEPT.\nContinutul initial al tabelei DEPT.\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7\n\nFuncţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. funcţii caracter\n2. funcţii numerice\n3. funcţii pentru data calendaristică si oră\n4. funcţii de conversie\n5. funcţii diverse\nCurs 5 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• funcţii totalizatoare sau funcţii de grup\nCurs 5 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13\n\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', '\n', '3. ', 'Curs 5 \nLimbajul SQL \nCurs 5 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea III)\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 3\n\nTabele EMP si DEPT\nPentru exemplele din cursuri vom folosi tabela EMP:\nCurs 5 - BAZE DE DATE 4\nStructura tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 5\nPentru exemplele din cursuri vom folosi tabela EMP:\nContinutul initial al tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 6\nStructura tabelei DEPT.\nContinutul initial al tabelei DEPT.\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7\n\nFuncţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. funcţii caracter\n2. funcţii numerice\n3. funcţii pentru data calendaristică si oră\n4. funcţii de conversie\n5. funcţii diverse\nCurs 5 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• funcţii totalizatoare sau funcţii de grup\nCurs 5 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13\n\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', '\n', '4. ', ""4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14\n\n4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15\n\n4.3. Funcții de grup\nDISTINCT face ca funcţia să ignore valorile duplicat. \nALL face ca funcţia să afişeze şi valorile duplicat. \nValoarea implicită este ALL, deci nu este necesar să \nfie specificată.\n  Tipul de dată returnat de funcţia expr poate fi \nCHAR, VARCHAR2, NUMBER sau DATE.\n  Toate funcţiile de grup ignoră valorile nule. \nPentru a lua în considerare şi valorile nule se \nfolosesc funcţiile NVL, NVL2 sau COALESCE.\nCurs 5 - BAZE DE DATE 16\n\n4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17\n\n4.3. Funcții de grup\nExemplul 1: Afişarea salariului mediu, maxim, minim şi \nsuma tuturor salariilor angajaţilor cu funcţie SALESMAN. \nSELECT AVG(sal), MAX(sal), MIN(sal), SUM(sal)\nFROM EMP\nWHERE job = 'SALESMAN';\nCurs 5 - BAZE DE DATE 18\n\n\n4.3. Funcții de grup\nExemplul 2 - Datele la care s-au făcut prima şi ultima \nangajare.\nSELECT MIN(hiredate), MAX(hiredate)\nFROM EMP; \nCurs 5 - BAZE DE DATE 19\n\n\n4.3. Funcții de grup\nExemplul 3 - Primul şi ultimul nume de angajat în \nordine alfabetică:\nSELECT MIN(ename), MAX(ename)\nFROM EMP;\nCurs 5 - BAZE DE DATE 20\n\n\n4.3. Funcții de grup\nFuncţia COUNT \nFuncţia COUNT are 3 formate: \nCOUNT(*) \nCOUNT(expr) \nCOUNT(DISTINCT expr)\nCurs 5 - BAZE DE DATE 21\n\n4.3. Funcții de grup\n•COUNT(*) întoarce numărul de rânduri dintr-o tabela \ncare satisface criteriul de selecţie, incluzând rândurile \nduplicat şi rândurile conţinând valori nule.\n•Dacă clauza WHERE este introdusă, atunci COUNT(*) \nreturnează numărul de rânduri care satisfac condiţia \ndin clauza WHERE.\nCurs 5 - BAZE DE DATE 22"", '\n', '5. ', ""4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14\n\n4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15\n\n4.3. Funcții de grup\nDISTINCT face ca funcţia să ignore valorile duplicat. \nALL face ca funcţia să afişeze şi valorile duplicat. \nValoarea implicită este ALL, deci nu este necesar să \nfie specificată.\n  Tipul de dată returnat de funcţia expr poate fi \nCHAR, VARCHAR2, NUMBER sau DATE.\n  Toate funcţiile de grup ignoră valorile nule. \nPentru a lua în considerare şi valorile nule se \nfolosesc funcţiile NVL, NVL2 sau COALESCE.\nCurs 5 - BAZE DE DATE 16\n\n4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17\n\n4.3. Funcții de grup\nExemplul 1: Afişarea salariului mediu, maxim, minim şi \nsuma tuturor salariilor angajaţilor cu funcţie SALESMAN. \nSELECT AVG(sal), MAX(sal), MIN(sal), SUM(sal)\nFROM EMP\nWHERE job = 'SALESMAN';\nCurs 5 - BAZE DE DATE 18\n\n\n4.3. Funcții de grup\nExemplul 2 - Datele la care s-au făcut prima şi ultima \nangajare.\nSELECT MIN(hiredate), MAX(hiredate)\nFROM EMP; \nCurs 5 - BAZE DE DATE 19\n\n\n4.3. Funcții de grup\nExemplul 3 - Primul şi ultimul nume de angajat în \nordine alfabetică:\nSELECT MIN(ename), MAX(ename)\nFROM EMP;\nCurs 5 - BAZE DE DATE 20\n\n\n4.3. Funcții de grup\nFuncţia COUNT \nFuncţia COUNT are 3 formate: \nCOUNT(*) \nCOUNT(expr) \nCOUNT(DISTINCT expr)\nCurs 5 - BAZE DE DATE 21\n\n4.3. Funcții de grup\n•COUNT(*) întoarce numărul de rânduri dintr-o tabela \ncare satisface criteriul de selecţie, incluzând rândurile \nduplicat şi rândurile conţinând valori nule.\n•Dacă clauza WHERE este introdusă, atunci COUNT(*) \nreturnează numărul de rânduri care satisfac condiţia \ndin clauza WHERE.\nCurs 5 - BAZE DE DATE 22"", '\n', '6. ', ""4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14\n\n4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15\n\n4.3. Funcții de grup\nDISTINCT face ca funcţia să ignore valorile duplicat. \nALL face ca funcţia să afişeze şi valorile duplicat. \nValoarea implicită este ALL, deci nu este necesar să \nfie specificată.\n  Tipul de dată returnat de funcţia expr poate fi \nCHAR, VARCHAR2, NUMBER sau DATE.\n  Toate funcţiile de grup ignoră valorile nule. \nPentru a lua în considerare şi valorile nule se \nfolosesc funcţiile NVL, NVL2 sau COALESCE.\nCurs 5 - BAZE DE DATE 16\n\n4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17\n\n4.3. Funcții de grup\nExemplul 1: Afişarea salariului mediu, maxim, minim şi \nsuma tuturor salariilor angajaţilor cu funcţie SALESMAN. \nSELECT AVG(sal), MAX(sal), MIN(sal), SUM(sal)\nFROM EMP\nWHERE job = 'SALESMAN';\nCurs 5 - BAZE DE DATE 18\n\n\n4.3. Funcții de grup\nExemplul 2 - Datele la care s-au făcut prima şi ultima \nangajare.\nSELECT MIN(hiredate), MAX(hiredate)\nFROM EMP; \nCurs 5 - BAZE DE DATE 19\n\n\n4.3. Funcții de grup\nExemplul 3 - Primul şi ultimul nume de angajat în \nordine alfabetică:\nSELECT MIN(ename), MAX(ename)\nFROM EMP;\nCurs 5 - BAZE DE DATE 20\n\n\n4.3. Funcții de grup\nFuncţia COUNT \nFuncţia COUNT are 3 formate: \nCOUNT(*) \nCOUNT(expr) \nCOUNT(DISTINCT expr)\nCurs 5 - BAZE DE DATE 21\n\n4.3. Funcții de grup\n•COUNT(*) întoarce numărul de rânduri dintr-o tabela \ncare satisface criteriul de selecţie, incluzând rândurile \nduplicat şi rândurile conţinând valori nule.\n•Dacă clauza WHERE este introdusă, atunci COUNT(*) \nreturnează numărul de rânduri care satisfac condiţia \ndin clauza WHERE.\nCurs 5 - BAZE DE DATE 22"", '\n', '7. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '8. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '9. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '10. ', ""4.2.5. Funcţii generale\nExemplu 2:\nselect CASE 'C++' \n  WHEN 'PLSQL' THEN 'Limbajul PLSQL'\n  WHEN 'SQL' THEN 'Limbajul de interogare SQL'\n  ELSE 'Limbaj de programare'\n  END\nfrom dual\nCurs 4 - BAZE DE DATE 113\n\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm\n3) https://www.w3resource.com/sql-exercises/\nCurs 4 - BAZE DE DATE 114\n\nÎntrebări?\nCurs 4 - BAZE DE DATE 115"", '\n']","funcțiile de grup sunt funcții care operează pe un set de rânduri pentru a da un rezultat pe întreg setul. Funcțiile de grup sunt: AVG, COUNT, MAX, MIN, STDDEV, SUM, VARIANCE.
","Ce sunt funcțiile de grup în SQL, conform cursului?","['1. ', 'Curs 5 \nLimbajul SQL \nCurs 5 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea III)\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 3\n\nTabele EMP si DEPT\nPentru exemplele din cursuri vom folosi tabela EMP:\nCurs 5 - BAZE DE DATE 4\nStructura tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 5\nPentru exemplele din cursuri vom folosi tabela EMP:\nContinutul initial al tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 6\nStructura tabelei DEPT.\nContinutul initial al tabelei DEPT.\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7\n\nFuncţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. funcţii caracter\n2. funcţii numerice\n3. funcţii pentru data calendaristică si oră\n4. funcţii de conversie\n5. funcţii diverse\nCurs 5 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• funcţii totalizatoare sau funcţii de grup\nCurs 5 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13\n\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', '\n', '2. ', 'Curs 5 \nLimbajul SQL \nCurs 5 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea III)\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 3\n\nTabele EMP si DEPT\nPentru exemplele din cursuri vom folosi tabela EMP:\nCurs 5 - BAZE DE DATE 4\nStructura tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 5\nPentru exemplele din cursuri vom folosi tabela EMP:\nContinutul initial al tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 6\nStructura tabelei DEPT.\nContinutul initial al tabelei DEPT.\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7\n\nFuncţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. funcţii caracter\n2. funcţii numerice\n3. funcţii pentru data calendaristică si oră\n4. funcţii de conversie\n5. funcţii diverse\nCurs 5 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• funcţii totalizatoare sau funcţii de grup\nCurs 5 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13\n\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', '\n', '3. ', 'Curs 5 \nLimbajul SQL \nCurs 5 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea III)\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 3\n\nTabele EMP si DEPT\nPentru exemplele din cursuri vom folosi tabela EMP:\nCurs 5 - BAZE DE DATE 4\nStructura tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 5\nPentru exemplele din cursuri vom folosi tabela EMP:\nContinutul initial al tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 6\nStructura tabelei DEPT.\nContinutul initial al tabelei DEPT.\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7\n\nFuncţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. funcţii caracter\n2. funcţii numerice\n3. funcţii pentru data calendaristică si oră\n4. funcţii de conversie\n5. funcţii diverse\nCurs 5 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• funcţii totalizatoare sau funcţii de grup\nCurs 5 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13\n\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', '\n', '4. ', ""4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14\n\n4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15\n\n4.3. Funcții de grup\nDISTINCT face ca funcţia să ignore valorile duplicat. \nALL face ca funcţia să afişeze şi valorile duplicat. \nValoarea implicită este ALL, deci nu este necesar să \nfie specificată.\n  Tipul de dată returnat de funcţia expr poate fi \nCHAR, VARCHAR2, NUMBER sau DATE.\n  Toate funcţiile de grup ignoră valorile nule. \nPentru a lua în considerare şi valorile nule se \nfolosesc funcţiile NVL, NVL2 sau COALESCE.\nCurs 5 - BAZE DE DATE 16\n\n4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17\n\n4.3. Funcții de grup\nExemplul 1: Afişarea salariului mediu, maxim, minim şi \nsuma tuturor salariilor angajaţilor cu funcţie SALESMAN. \nSELECT AVG(sal), MAX(sal), MIN(sal), SUM(sal)\nFROM EMP\nWHERE job = 'SALESMAN';\nCurs 5 - BAZE DE DATE 18\n\n\n4.3. Funcții de grup\nExemplul 2 - Datele la care s-au făcut prima şi ultima \nangajare.\nSELECT MIN(hiredate), MAX(hiredate)\nFROM EMP; \nCurs 5 - BAZE DE DATE 19\n\n\n4.3. Funcții de grup\nExemplul 3 - Primul şi ultimul nume de angajat în \nordine alfabetică:\nSELECT MIN(ename), MAX(ename)\nFROM EMP;\nCurs 5 - BAZE DE DATE 20\n\n\n4.3. Funcții de grup\nFuncţia COUNT \nFuncţia COUNT are 3 formate: \nCOUNT(*) \nCOUNT(expr) \nCOUNT(DISTINCT expr)\nCurs 5 - BAZE DE DATE 21\n\n4.3. Funcții de grup\n•COUNT(*) întoarce numărul de rânduri dintr-o tabela \ncare satisface criteriul de selecţie, incluzând rândurile \nduplicat şi rândurile conţinând valori nule.\n•Dacă clauza WHERE este introdusă, atunci COUNT(*) \nreturnează numărul de rânduri care satisfac condiţia \ndin clauza WHERE.\nCurs 5 - BAZE DE DATE 22"", '\n', '5. ', ""4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14\n\n4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15\n\n4.3. Funcții de grup\nDISTINCT face ca funcţia să ignore valorile duplicat. \nALL face ca funcţia să afişeze şi valorile duplicat. \nValoarea implicită este ALL, deci nu este necesar să \nfie specificată.\n  Tipul de dată returnat de funcţia expr poate fi \nCHAR, VARCHAR2, NUMBER sau DATE.\n  Toate funcţiile de grup ignoră valorile nule. \nPentru a lua în considerare şi valorile nule se \nfolosesc funcţiile NVL, NVL2 sau COALESCE.\nCurs 5 - BAZE DE DATE 16\n\n4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17\n\n4.3. Funcții de grup\nExemplul 1: Afişarea salariului mediu, maxim, minim şi \nsuma tuturor salariilor angajaţilor cu funcţie SALESMAN. \nSELECT AVG(sal), MAX(sal), MIN(sal), SUM(sal)\nFROM EMP\nWHERE job = 'SALESMAN';\nCurs 5 - BAZE DE DATE 18\n\n\n4.3. Funcții de grup\nExemplul 2 - Datele la care s-au făcut prima şi ultima \nangajare.\nSELECT MIN(hiredate), MAX(hiredate)\nFROM EMP; \nCurs 5 - BAZE DE DATE 19\n\n\n4.3. Funcții de grup\nExemplul 3 - Primul şi ultimul nume de angajat în \nordine alfabetică:\nSELECT MIN(ename), MAX(ename)\nFROM EMP;\nCurs 5 - BAZE DE DATE 20\n\n\n4.3. Funcții de grup\nFuncţia COUNT \nFuncţia COUNT are 3 formate: \nCOUNT(*) \nCOUNT(expr) \nCOUNT(DISTINCT expr)\nCurs 5 - BAZE DE DATE 21\n\n4.3. Funcții de grup\n•COUNT(*) întoarce numărul de rânduri dintr-o tabela \ncare satisface criteriul de selecţie, incluzând rândurile \nduplicat şi rândurile conţinând valori nule.\n•Dacă clauza WHERE este introdusă, atunci COUNT(*) \nreturnează numărul de rânduri care satisfac condiţia \ndin clauza WHERE.\nCurs 5 - BAZE DE DATE 22"", '\n', '6. ', ""4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14\n\n4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15\n\n4.3. Funcții de grup\nDISTINCT face ca funcţia să ignore valorile duplicat. \nALL face ca funcţia să afişeze şi valorile duplicat. \nValoarea implicită este ALL, deci nu este necesar să \nfie specificată.\n  Tipul de dată returnat de funcţia expr poate fi \nCHAR, VARCHAR2, NUMBER sau DATE.\n  Toate funcţiile de grup ignoră valorile nule. \nPentru a lua în considerare şi valorile nule se \nfolosesc funcţiile NVL, NVL2 sau COALESCE.\nCurs 5 - BAZE DE DATE 16\n\n4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17\n\n4.3. Funcții de grup\nExemplul 1: Afişarea salariului mediu, maxim, minim şi \nsuma tuturor salariilor angajaţilor cu funcţie SALESMAN. \nSELECT AVG(sal), MAX(sal), MIN(sal), SUM(sal)\nFROM EMP\nWHERE job = 'SALESMAN';\nCurs 5 - BAZE DE DATE 18\n\n\n4.3. Funcții de grup\nExemplul 2 - Datele la care s-au făcut prima şi ultima \nangajare.\nSELECT MIN(hiredate), MAX(hiredate)\nFROM EMP; \nCurs 5 - BAZE DE DATE 19\n\n\n4.3. Funcții de grup\nExemplul 3 - Primul şi ultimul nume de angajat în \nordine alfabetică:\nSELECT MIN(ename), MAX(ename)\nFROM EMP;\nCurs 5 - BAZE DE DATE 20\n\n\n4.3. Funcții de grup\nFuncţia COUNT \nFuncţia COUNT are 3 formate: \nCOUNT(*) \nCOUNT(expr) \nCOUNT(DISTINCT expr)\nCurs 5 - BAZE DE DATE 21\n\n4.3. Funcții de grup\n•COUNT(*) întoarce numărul de rânduri dintr-o tabela \ncare satisface criteriul de selecţie, incluzând rândurile \nduplicat şi rândurile conţinând valori nule.\n•Dacă clauza WHERE este introdusă, atunci COUNT(*) \nreturnează numărul de rânduri care satisfac condiţia \ndin clauza WHERE.\nCurs 5 - BAZE DE DATE 22"", '\n', '7. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '8. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '9. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '10. ', ""4.2.5. Funcţii generale\nExemplu 2:\nselect CASE 'C++' \n  WHEN 'PLSQL' THEN 'Limbajul PLSQL'\n  WHEN 'SQL' THEN 'Limbajul de interogare SQL'\n  ELSE 'Limbaj de programare'\n  END\nfrom dual\nCurs 4 - BAZE DE DATE 113\n\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm\n3) https://www.w3resource.com/sql-exercises/\nCurs 4 - BAZE DE DATE 114\n\nÎntrebări?\nCurs 4 - BAZE DE DATE 115"", '\n']","funcțiile de grup sunt funcții care operează pe un set de rânduri pentru a da un rezultat pe întreg setul. Funcțiile de grup sunt: AVG, COUNT, MAX, MIN, STDDEV, SUM, VARIANCE.
","Funcțiile de grup operează pe un set de rânduri, returnând un singur rezultat pentru fiecare grup (ex. AVG, COUNT, SUM).",0.39145339953511066,1.0,0.8445807201599781,1.0,0.2872797668292002,0.5862068965517241,0.67
19,O3mini-high,Medium,Curs 6,,Ce este o subinterogare (subquery) în SQL?,"O subinterogare este o instrucțiune SELECT inclusă într-o altă instrucțiune, executată prima, iar rezultatul ei este folosit de interogarea principală.",Este corect,"slide 4,5","['1. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '2. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '3. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '4. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '5. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '6. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '7. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '8. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '9. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '10. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n']","o subinterogare (subquery) este o instrucțiune SELECT care este inclusă în clauza unei alte instrucțiuni SELECT.
",Ce este o subinterogare (subquery) în SQL?,"['1. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '2. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '3. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '4. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '5. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '6. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '7. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '8. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '9. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '10. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n']","o subinterogare (subquery) este o instrucțiune SELECT care este inclusă în clauza unei alte instrucțiuni SELECT.
","O subinterogare este o instrucțiune SELECT inclusă într-o altă instrucțiune, executată prima, iar rezultatul ei este folosit de interogarea principală.",0.39145339953511066,1.0,0.9777125342132525,1.0,0.1221043509844431,0.4878048780487805,0.4
20,O3mini-high,Medium,Curs 7,,Ce permite limbajul de manipulare al datelor (DML) în SQL?,"DML permite adăugarea, modificarea și ștergerea datelor din baza de date, fiind nucleul limbajului SQL.",Este corect,slide 4,"['1. ', '1.1.Sisteme de baze de date\n- precompilatorul limbajului de manipulare\na datelor care transformă instrucţiunile\nDML de la programele de aplicaţii la\nlimbajul gazdă, şi lucrează cu procesorul de\ninterogări;\n- compilatorul limbajului de definiţie a\ndatelor care transformă instrucţiunile DDL\nîn tabele de metadate.\n 32\n\n1.1.Sisteme de baze de date\nMetadatele sunt\nmemorate în \ndicţionarul de \ndate, care \ninclude:\n➢structura bazei\nde date sau\nschema\n➢constrângerile\nde integritate\n➢constrângerile\nde securitate\n 33\n\nModele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\n 34\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 35\n\n1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36\n\n1.2.Modelul de date relaţional\nFormal, o relaţie R este o mulţime, unde D1, D2, ..., \nDn sunt domeniile a n atribute A1, A2, ..., An. \n✓ Elementele relaţiei sunt n-tuplurile (v1, v2, ..., vn) cu vi\nDi, adică valoarea celui de-al i-lea atribut trebuie să fie \nun element din mulţimea Di.  \n✓ Elementele dintr-un tuplu sunt numite câmpuri. \n✓ Când un camp nu conţine nici o valoare, vom reprezenta \nacest fapt cu o valoare specială numită valoare null, \nsemnificând că “nu este nici o intrare” în loc de “intrarea \neste necunoscută”. \n 37\n\n1.2.Modelul de date relaţional\nPrezentăm în continuare un exemplu de tabelă \npentru gestiunea studenţilor dintr-o facultate:\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\nAtributeTuplu\nCâmp\n38\n\n1.2.Modelul de date relaţional\nConstrângeri de integritate\nConstrângerile de integritate restricţionează mulţimea\ntuplu-rilor teoretice posibile la o mulţime care este în mod\npractic cu o semnificaţie. \nFie X şi Y două mulţimi cu unul sau mai multe atribute\nAi, din schema relaţională. \nSpunem că Y este dependent funcţional de X, şi notăm \nacest lucru prin X Y,dacă şi numai dacă nu este posibil să\navem două tupluri cu aceeaşi valoare pentru toate\natributele din X dar cu valoare diferită pentru toate\natributele din Y . \n→ 39', '\n', '2. ', '1.1.Sisteme de baze de date\n- precompilatorul limbajului de manipulare\na datelor care transformă instrucţiunile\nDML de la programele de aplicaţii la\nlimbajul gazdă, şi lucrează cu procesorul de\ninterogări;\n- compilatorul limbajului de definiţie a\ndatelor care transformă instrucţiunile DDL\nîn tabele de metadate.\n 32\n\n1.1.Sisteme de baze de date\nMetadatele sunt\nmemorate în \ndicţionarul de \ndate, care \ninclude:\n➢structura bazei\nde date sau\nschema\n➢constrângerile\nde integritate\n➢constrângerile\nde securitate\n 33\n\nModele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\n 34\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 35\n\n1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36\n\n1.2.Modelul de date relaţional\nFormal, o relaţie R este o mulţime, unde D1, D2, ..., \nDn sunt domeniile a n atribute A1, A2, ..., An. \n✓ Elementele relaţiei sunt n-tuplurile (v1, v2, ..., vn) cu vi\nDi, adică valoarea celui de-al i-lea atribut trebuie să fie \nun element din mulţimea Di.  \n✓ Elementele dintr-un tuplu sunt numite câmpuri. \n✓ Când un camp nu conţine nici o valoare, vom reprezenta \nacest fapt cu o valoare specială numită valoare null, \nsemnificând că “nu este nici o intrare” în loc de “intrarea \neste necunoscută”. \n 37\n\n1.2.Modelul de date relaţional\nPrezentăm în continuare un exemplu de tabelă \npentru gestiunea studenţilor dintr-o facultate:\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\nAtributeTuplu\nCâmp\n38\n\n1.2.Modelul de date relaţional\nConstrângeri de integritate\nConstrângerile de integritate restricţionează mulţimea\ntuplu-rilor teoretice posibile la o mulţime care este în mod\npractic cu o semnificaţie. \nFie X şi Y două mulţimi cu unul sau mai multe atribute\nAi, din schema relaţională. \nSpunem că Y este dependent funcţional de X, şi notăm \nacest lucru prin X Y,dacă şi numai dacă nu este posibil să\navem două tupluri cu aceeaşi valoare pentru toate\natributele din X dar cu valoare diferită pentru toate\natributele din Y . \n→ 39', '\n', '3. ', '1.1.Sisteme de baze de date\n- precompilatorul limbajului de manipulare\na datelor care transformă instrucţiunile\nDML de la programele de aplicaţii la\nlimbajul gazdă, şi lucrează cu procesorul de\ninterogări;\n- compilatorul limbajului de definiţie a\ndatelor care transformă instrucţiunile DDL\nîn tabele de metadate.\n 32\n\n1.1.Sisteme de baze de date\nMetadatele sunt\nmemorate în \ndicţionarul de \ndate, care \ninclude:\n➢structura bazei\nde date sau\nschema\n➢constrângerile\nde integritate\n➢constrângerile\nde securitate\n 33\n\nModele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\n 34\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 35\n\n1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36\n\n1.2.Modelul de date relaţional\nFormal, o relaţie R este o mulţime, unde D1, D2, ..., \nDn sunt domeniile a n atribute A1, A2, ..., An. \n✓ Elementele relaţiei sunt n-tuplurile (v1, v2, ..., vn) cu vi\nDi, adică valoarea celui de-al i-lea atribut trebuie să fie \nun element din mulţimea Di.  \n✓ Elementele dintr-un tuplu sunt numite câmpuri. \n✓ Când un camp nu conţine nici o valoare, vom reprezenta \nacest fapt cu o valoare specială numită valoare null, \nsemnificând că “nu este nici o intrare” în loc de “intrarea \neste necunoscută”. \n 37\n\n1.2.Modelul de date relaţional\nPrezentăm în continuare un exemplu de tabelă \npentru gestiunea studenţilor dintr-o facultate:\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\nAtributeTuplu\nCâmp\n38\n\n1.2.Modelul de date relaţional\nConstrângeri de integritate\nConstrângerile de integritate restricţionează mulţimea\ntuplu-rilor teoretice posibile la o mulţime care este în mod\npractic cu o semnificaţie. \nFie X şi Y două mulţimi cu unul sau mai multe atribute\nAi, din schema relaţională. \nSpunem că Y este dependent funcţional de X, şi notăm \nacest lucru prin X Y,dacă şi numai dacă nu este posibil să\navem două tupluri cu aceeaşi valoare pentru toate\natributele din X dar cu valoare diferită pentru toate\natributele din Y . \n→ 39', '\n', '4. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '5. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '6. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '7. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '8. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '9. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '10. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n']","limbajul de manipulare a datelor (DML) permite transformarea instrucțiunilor DML de la programele de aplicații la limbajul gazdă, lucrând cu procesorul de interogări. (""precompilatorul limbajului de manipulare a datelor care transformă instrucţiunile DML de la programele de aplicaţii la limbajul gazdă, şi lucrează cu procesorul de interogări"")
",Ce permite limbajul de manipulare al datelor (DML) în SQL?,"['1. ', '1.1.Sisteme de baze de date\n- precompilatorul limbajului de manipulare\na datelor care transformă instrucţiunile\nDML de la programele de aplicaţii la\nlimbajul gazdă, şi lucrează cu procesorul de\ninterogări;\n- compilatorul limbajului de definiţie a\ndatelor care transformă instrucţiunile DDL\nîn tabele de metadate.\n 32\n\n1.1.Sisteme de baze de date\nMetadatele sunt\nmemorate în \ndicţionarul de \ndate, care \ninclude:\n➢structura bazei\nde date sau\nschema\n➢constrângerile\nde integritate\n➢constrângerile\nde securitate\n 33\n\nModele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\n 34\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 35\n\n1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36\n\n1.2.Modelul de date relaţional\nFormal, o relaţie R este o mulţime, unde D1, D2, ..., \nDn sunt domeniile a n atribute A1, A2, ..., An. \n✓ Elementele relaţiei sunt n-tuplurile (v1, v2, ..., vn) cu vi\nDi, adică valoarea celui de-al i-lea atribut trebuie să fie \nun element din mulţimea Di.  \n✓ Elementele dintr-un tuplu sunt numite câmpuri. \n✓ Când un camp nu conţine nici o valoare, vom reprezenta \nacest fapt cu o valoare specială numită valoare null, \nsemnificând că “nu este nici o intrare” în loc de “intrarea \neste necunoscută”. \n 37\n\n1.2.Modelul de date relaţional\nPrezentăm în continuare un exemplu de tabelă \npentru gestiunea studenţilor dintr-o facultate:\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\nAtributeTuplu\nCâmp\n38\n\n1.2.Modelul de date relaţional\nConstrângeri de integritate\nConstrângerile de integritate restricţionează mulţimea\ntuplu-rilor teoretice posibile la o mulţime care este în mod\npractic cu o semnificaţie. \nFie X şi Y două mulţimi cu unul sau mai multe atribute\nAi, din schema relaţională. \nSpunem că Y este dependent funcţional de X, şi notăm \nacest lucru prin X Y,dacă şi numai dacă nu este posibil să\navem două tupluri cu aceeaşi valoare pentru toate\natributele din X dar cu valoare diferită pentru toate\natributele din Y . \n→ 39', '\n', '2. ', '1.1.Sisteme de baze de date\n- precompilatorul limbajului de manipulare\na datelor care transformă instrucţiunile\nDML de la programele de aplicaţii la\nlimbajul gazdă, şi lucrează cu procesorul de\ninterogări;\n- compilatorul limbajului de definiţie a\ndatelor care transformă instrucţiunile DDL\nîn tabele de metadate.\n 32\n\n1.1.Sisteme de baze de date\nMetadatele sunt\nmemorate în \ndicţionarul de \ndate, care \ninclude:\n➢structura bazei\nde date sau\nschema\n➢constrângerile\nde integritate\n➢constrângerile\nde securitate\n 33\n\nModele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\n 34\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 35\n\n1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36\n\n1.2.Modelul de date relaţional\nFormal, o relaţie R este o mulţime, unde D1, D2, ..., \nDn sunt domeniile a n atribute A1, A2, ..., An. \n✓ Elementele relaţiei sunt n-tuplurile (v1, v2, ..., vn) cu vi\nDi, adică valoarea celui de-al i-lea atribut trebuie să fie \nun element din mulţimea Di.  \n✓ Elementele dintr-un tuplu sunt numite câmpuri. \n✓ Când un camp nu conţine nici o valoare, vom reprezenta \nacest fapt cu o valoare specială numită valoare null, \nsemnificând că “nu este nici o intrare” în loc de “intrarea \neste necunoscută”. \n 37\n\n1.2.Modelul de date relaţional\nPrezentăm în continuare un exemplu de tabelă \npentru gestiunea studenţilor dintr-o facultate:\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\nAtributeTuplu\nCâmp\n38\n\n1.2.Modelul de date relaţional\nConstrângeri de integritate\nConstrângerile de integritate restricţionează mulţimea\ntuplu-rilor teoretice posibile la o mulţime care este în mod\npractic cu o semnificaţie. \nFie X şi Y două mulţimi cu unul sau mai multe atribute\nAi, din schema relaţională. \nSpunem că Y este dependent funcţional de X, şi notăm \nacest lucru prin X Y,dacă şi numai dacă nu este posibil să\navem două tupluri cu aceeaşi valoare pentru toate\natributele din X dar cu valoare diferită pentru toate\natributele din Y . \n→ 39', '\n', '3. ', '1.1.Sisteme de baze de date\n- precompilatorul limbajului de manipulare\na datelor care transformă instrucţiunile\nDML de la programele de aplicaţii la\nlimbajul gazdă, şi lucrează cu procesorul de\ninterogări;\n- compilatorul limbajului de definiţie a\ndatelor care transformă instrucţiunile DDL\nîn tabele de metadate.\n 32\n\n1.1.Sisteme de baze de date\nMetadatele sunt\nmemorate în \ndicţionarul de \ndate, care \ninclude:\n➢structura bazei\nde date sau\nschema\n➢constrângerile\nde integritate\n➢constrângerile\nde securitate\n 33\n\nModele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\n 34\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 35\n\n1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36\n\n1.2.Modelul de date relaţional\nFormal, o relaţie R este o mulţime, unde D1, D2, ..., \nDn sunt domeniile a n atribute A1, A2, ..., An. \n✓ Elementele relaţiei sunt n-tuplurile (v1, v2, ..., vn) cu vi\nDi, adică valoarea celui de-al i-lea atribut trebuie să fie \nun element din mulţimea Di.  \n✓ Elementele dintr-un tuplu sunt numite câmpuri. \n✓ Când un camp nu conţine nici o valoare, vom reprezenta \nacest fapt cu o valoare specială numită valoare null, \nsemnificând că “nu este nici o intrare” în loc de “intrarea \neste necunoscută”. \n 37\n\n1.2.Modelul de date relaţional\nPrezentăm în continuare un exemplu de tabelă \npentru gestiunea studenţilor dintr-o facultate:\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\nAtributeTuplu\nCâmp\n38\n\n1.2.Modelul de date relaţional\nConstrângeri de integritate\nConstrângerile de integritate restricţionează mulţimea\ntuplu-rilor teoretice posibile la o mulţime care este în mod\npractic cu o semnificaţie. \nFie X şi Y două mulţimi cu unul sau mai multe atribute\nAi, din schema relaţională. \nSpunem că Y este dependent funcţional de X, şi notăm \nacest lucru prin X Y,dacă şi numai dacă nu este posibil să\navem două tupluri cu aceeaşi valoare pentru toate\natributele din X dar cu valoare diferită pentru toate\natributele din Y . \n→ 39', '\n', '4. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '5. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '6. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '7. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '8. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '9. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '10. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n']","limbajul de manipulare a datelor (DML) permite transformarea instrucțiunilor DML de la programele de aplicații la limbajul gazdă, lucrând cu procesorul de interogări. (""precompilatorul limbajului de manipulare a datelor care transformă instrucţiunile DML de la programele de aplicaţii la limbajul gazdă, şi lucrează cu procesorul de interogări"")
","DML permite adăugarea, modificarea și ștergerea datelor din baza de date, fiind nucleul limbajului SQL.",0.0,1.0,0.8699720116655482,1.0,0.021601524349994395,0.11428571428571428,0.0
21,O3mini-high,Medium,Curs 8,,"Ce definește constrângerea FOREIGN KEY în SQL, conform cursului?","FOREIGN KEY stabilește o relație între coloana din tabela copil și cheia primară a tabelei părinte, asigurând integritatea referențială.",Este corect,slide 21,"['1. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '2. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '3. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '4. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '5. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '6. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '7. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '8. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '9. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '10. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n']","nu există informații despre constrângerea FOREIGN KEY în materialele furnizate.
","Ce definește constrângerea FOREIGN KEY în SQL, conform cursului?","['1. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '2. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '3. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '4. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '5. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '6. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '7. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '8. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '9. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '10. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n']","nu există informații despre constrângerea FOREIGN KEY în materialele furnizate.
","FOREIGN KEY stabilește o relație între coloana din tabela copil și cheia primară a tabelei părinte, asigurând integritatea referențială.",0.0,0.0,0.0,1.0,0.03342053179225867,0.1111111111111111,0.0
22,O3mini-high,Medium,Curs 9,,"Ce este o vedere (view) în SQL, conform cursului?","O vedere este o tabelă logică generată printr-o instrucțiune SELECT, fără a stoca date proprii, ci extrăgându-le din tabele.",Este corect,slide 4,"['1. ', ""Curs 9\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3\n\n O vedere este o tabelă logică care extrage \ndate dintr-o tabelă propriu-zisă sau dintr-o \naltă vedere. \n  O vedere nu are date proprii, ci este ca o \nfereastră prin care datele din tabele pot fi \nactualizate sau vizualizate. \n  O vedere poate să conţină toate datele \ndintr-o tabelă (sau mai multe) sau anumite \ncoloane. \nCurs - BAZE DE DATE 4\n\nVederile se folosesc pentru că oferă: \n1. Acces restricţionat la date (vederile pot \nselecţiona anumite coloane dintr-o tabelă)\n2. Posibilitatea lucrului cu interogări complexe\n3. Independenţa datelor\n4. Posibilitatea prezentării de date identice în \nvederi diferite\nCurs - BAZE DE DATE 5\n\nAvantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6\n\nClasificare\n Vederile se clasifică în: \n1.vederi simple\n2.vederi complexe\n  Pentru început prezentăm vederile \nsimple. \nCurs - BAZE DE DATE 7\n\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8\n\nSintaxa \nCREATE [OR REPLACE] [FORCE|NOFORCE] VIEW \nview   [ (alias [, alias]...) ] \n AS subquery \n[WITH CHECK OPTION [CONSTRAINT \nconstraint] ]\n[WITH READ ONLY [CONSTRAINT constraint] ];\nCurs - BAZE DE DATE 9\n\nSemnificaţia argumentelor sintaxei: \n• OR REPLACE: determină înlocuirea vederii dacă \naceasta există deja\n• FORCE: crearea vederii indiferent dacă tabela din care \nprovin datele nu există\n• NOFORCE: crearea vederii numai dacă tabela există \n(valoarea implicită)\n• view: numele vederii\n• alias: specifică numele expresiilor selectate de către \ncererea din vedere (numele coloanelor selectate). \nNumărul alias-urilor trebuie să fie egal cu numărul \ncoloanelor selectate.\nCurs - BAZE DE DATE 10\n\n• subquery: cererea SELECT care generează \nvederea \n• WITH CHECK OPTION: numai rândurile accesibile \nvederii pot fi actualizate\n• constraint: numele constrângerii asociate cu \nWITH CHECK OPTION\n• WITH READ ONLY: asigură că nici o operaţie DML \n(INSERT, UPDATE, DELETE) nu va fi executată prin \nvedere.\nCurs - BAZE DE DATE 11\n\nExemplu \n Să cream o vedere emp20 care va conţine \npersoanele din departamentul 20. \n  Mai întâi trebuie să ne asigurăm că vederea \nemp20 nu există deja. \nCurs - BAZE DE DATE 12\n\nSELECT OBJECT_NAME, OBJECT_TYPE \nFROM USER_OBJECTS \nWHERE OBJECT_TYPE='VIEW'\nAceastă vedere nu există deci putem să o cream. \n \nCurs - BAZE DE DATE 13"", '\n', '2. ', ""Curs 9\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3\n\n O vedere este o tabelă logică care extrage \ndate dintr-o tabelă propriu-zisă sau dintr-o \naltă vedere. \n  O vedere nu are date proprii, ci este ca o \nfereastră prin care datele din tabele pot fi \nactualizate sau vizualizate. \n  O vedere poate să conţină toate datele \ndintr-o tabelă (sau mai multe) sau anumite \ncoloane. \nCurs - BAZE DE DATE 4\n\nVederile se folosesc pentru că oferă: \n1. Acces restricţionat la date (vederile pot \nselecţiona anumite coloane dintr-o tabelă)\n2. Posibilitatea lucrului cu interogări complexe\n3. Independenţa datelor\n4. Posibilitatea prezentării de date identice în \nvederi diferite\nCurs - BAZE DE DATE 5\n\nAvantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6\n\nClasificare\n Vederile se clasifică în: \n1.vederi simple\n2.vederi complexe\n  Pentru început prezentăm vederile \nsimple. \nCurs - BAZE DE DATE 7\n\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8\n\nSintaxa \nCREATE [OR REPLACE] [FORCE|NOFORCE] VIEW \nview   [ (alias [, alias]...) ] \n AS subquery \n[WITH CHECK OPTION [CONSTRAINT \nconstraint] ]\n[WITH READ ONLY [CONSTRAINT constraint] ];\nCurs - BAZE DE DATE 9\n\nSemnificaţia argumentelor sintaxei: \n• OR REPLACE: determină înlocuirea vederii dacă \naceasta există deja\n• FORCE: crearea vederii indiferent dacă tabela din care \nprovin datele nu există\n• NOFORCE: crearea vederii numai dacă tabela există \n(valoarea implicită)\n• view: numele vederii\n• alias: specifică numele expresiilor selectate de către \ncererea din vedere (numele coloanelor selectate). \nNumărul alias-urilor trebuie să fie egal cu numărul \ncoloanelor selectate.\nCurs - BAZE DE DATE 10\n\n• subquery: cererea SELECT care generează \nvederea \n• WITH CHECK OPTION: numai rândurile accesibile \nvederii pot fi actualizate\n• constraint: numele constrângerii asociate cu \nWITH CHECK OPTION\n• WITH READ ONLY: asigură că nici o operaţie DML \n(INSERT, UPDATE, DELETE) nu va fi executată prin \nvedere.\nCurs - BAZE DE DATE 11\n\nExemplu \n Să cream o vedere emp20 care va conţine \npersoanele din departamentul 20. \n  Mai întâi trebuie să ne asigurăm că vederea \nemp20 nu există deja. \nCurs - BAZE DE DATE 12\n\nSELECT OBJECT_NAME, OBJECT_TYPE \nFROM USER_OBJECTS \nWHERE OBJECT_TYPE='VIEW'\nAceastă vedere nu există deci putem să o cream. \n \nCurs - BAZE DE DATE 13"", '\n', '3. ', ""Curs 9\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3\n\n O vedere este o tabelă logică care extrage \ndate dintr-o tabelă propriu-zisă sau dintr-o \naltă vedere. \n  O vedere nu are date proprii, ci este ca o \nfereastră prin care datele din tabele pot fi \nactualizate sau vizualizate. \n  O vedere poate să conţină toate datele \ndintr-o tabelă (sau mai multe) sau anumite \ncoloane. \nCurs - BAZE DE DATE 4\n\nVederile se folosesc pentru că oferă: \n1. Acces restricţionat la date (vederile pot \nselecţiona anumite coloane dintr-o tabelă)\n2. Posibilitatea lucrului cu interogări complexe\n3. Independenţa datelor\n4. Posibilitatea prezentării de date identice în \nvederi diferite\nCurs - BAZE DE DATE 5\n\nAvantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6\n\nClasificare\n Vederile se clasifică în: \n1.vederi simple\n2.vederi complexe\n  Pentru început prezentăm vederile \nsimple. \nCurs - BAZE DE DATE 7\n\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8\n\nSintaxa \nCREATE [OR REPLACE] [FORCE|NOFORCE] VIEW \nview   [ (alias [, alias]...) ] \n AS subquery \n[WITH CHECK OPTION [CONSTRAINT \nconstraint] ]\n[WITH READ ONLY [CONSTRAINT constraint] ];\nCurs - BAZE DE DATE 9\n\nSemnificaţia argumentelor sintaxei: \n• OR REPLACE: determină înlocuirea vederii dacă \naceasta există deja\n• FORCE: crearea vederii indiferent dacă tabela din care \nprovin datele nu există\n• NOFORCE: crearea vederii numai dacă tabela există \n(valoarea implicită)\n• view: numele vederii\n• alias: specifică numele expresiilor selectate de către \ncererea din vedere (numele coloanelor selectate). \nNumărul alias-urilor trebuie să fie egal cu numărul \ncoloanelor selectate.\nCurs - BAZE DE DATE 10\n\n• subquery: cererea SELECT care generează \nvederea \n• WITH CHECK OPTION: numai rândurile accesibile \nvederii pot fi actualizate\n• constraint: numele constrângerii asociate cu \nWITH CHECK OPTION\n• WITH READ ONLY: asigură că nici o operaţie DML \n(INSERT, UPDATE, DELETE) nu va fi executată prin \nvedere.\nCurs - BAZE DE DATE 11\n\nExemplu \n Să cream o vedere emp20 care va conţine \npersoanele din departamentul 20. \n  Mai întâi trebuie să ne asigurăm că vederea \nemp20 nu există deja. \nCurs - BAZE DE DATE 12\n\nSELECT OBJECT_NAME, OBJECT_TYPE \nFROM USER_OBJECTS \nWHERE OBJECT_TYPE='VIEW'\nAceastă vedere nu există deci putem să o cream. \n \nCurs - BAZE DE DATE 13"", '\n', '4. ', 'Extragere de date dintr-o vedere\n➢Extragerea de date se face exact ca în cazul \nunei tabele. \n➢Se pot selecta anumite rânduri sau toată \nvederea. \nSELECT * FROM emp10;\nCurs - BAZE DE DATE 26\n\n\nInterogarea unei vederi\nInterogarea unei vederi de către serverul \nORACLE se face în felul următor: \n1. Extragere definiţie vedere din tabela \ndicţionarului de date USER_VIEWS\n2. Verificare drepturi acces pentru tabela vederii\n3. Convertire interogare vedere într-o interogare \nechivalentă a tabelei vederii. \nDeci datele sunt extrase, inserate din tabele \npropriu-zise. \nCurs - BAZE DE DATE 27\n\nModificarea unei vederi\nPână acum am verificat dacă vederea \nexistă sau nu şi numai în cazul în care nu exista \no cream. \nAvem posibilitatea de a crea o vedere chiar \ndacă ea există, înlocuind-o pe cea veche cu o \nnouă versiune. \nCurs - BAZE DE DATE 28\n\nÎn acest scop se foloseşte clauza OR REPLACE. \nVom înlocui vederea emp20 cu alta.\nCREATE OR REPLACE VIEW emp20 (COD, NUME, \nSAL_ANUAL)\n AS SELECT  empno, ename, sal * 12 \n     FROM   emp\n     WHERE  deptno = 20;\nCurs - BAZE DE DATE 29\n\n\nExerciţiu \nVizualizaţi conţinutul vederii cu o cerere SELECT. \nCurs - BAZE DE DATE 30\n\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCREATE OR REPLACE VIEW dept_sal(Denumire_dept, \nSAL_MIN, SAL_MAX, SAL_MEDIU)\n AS SELECT  d.dname, MIN(e.sal), MAX(e.sal), \nAVG(e.sal) \n     FROM   emp e, dept d\n     WHERE  d.deptno = e.deptno\n     GROUP BY d.dname;\nCurs - BAZE DE DATE 31\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n\n\nNOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n\n\nEfectuarea operaţiilor DML asupra vederilor\nSe pot efectua operaţii DML asupra \nvederilor, dar numai în anumite condiţii. \na) Nu se poate şterge un rând dintr-o \nvedere care conţine: \n1. funcţii de grup\n2. GROUP BY\n3. DISTINCT\n4. ROWNUM\nCurs - BAZE DE DATE 34\n\nb) De asemenea nu se pot modifica date printr-o vedere \ndacă aceasta verifică condiţiile de mai sus şi dacă există \ncoloane definite prin expresii cum ar fi SALARIU*12. \nc) Adăugarea de date printr-o vedere este imposibilădacă\nvederea conţine elementele enumerate mai sus şi dacă\nexistă coloane NOT NULL în tabela neselectate de către\nvedere.\nPrin adăugare de date se modifică de fapt tabela propriu-\nzisă deci în coloanele neselectate se va adăuga NULL\nceea ce încalcă constrângerea.\nCurs - BAZE DE DATE 35\n\nExemplu - Crearea vederii dept_sal utilizând clauza OR \nREPLACE. \nCREATE OR REPLACE VIEW dept_sal (COD, SAL_MEDIU)\n  AS SELECT deptno, AVG(sal)\n    FROM     emp\n    GROUP BY deptno;\n \nCurs - BAZE DE DATE 36', '\n', '5. ', 'Extragere de date dintr-o vedere\n➢Extragerea de date se face exact ca în cazul \nunei tabele. \n➢Se pot selecta anumite rânduri sau toată \nvederea. \nSELECT * FROM emp10;\nCurs - BAZE DE DATE 26\n\n\nInterogarea unei vederi\nInterogarea unei vederi de către serverul \nORACLE se face în felul următor: \n1. Extragere definiţie vedere din tabela \ndicţionarului de date USER_VIEWS\n2. Verificare drepturi acces pentru tabela vederii\n3. Convertire interogare vedere într-o interogare \nechivalentă a tabelei vederii. \nDeci datele sunt extrase, inserate din tabele \npropriu-zise. \nCurs - BAZE DE DATE 27\n\nModificarea unei vederi\nPână acum am verificat dacă vederea \nexistă sau nu şi numai în cazul în care nu exista \no cream. \nAvem posibilitatea de a crea o vedere chiar \ndacă ea există, înlocuind-o pe cea veche cu o \nnouă versiune. \nCurs - BAZE DE DATE 28\n\nÎn acest scop se foloseşte clauza OR REPLACE. \nVom înlocui vederea emp20 cu alta.\nCREATE OR REPLACE VIEW emp20 (COD, NUME, \nSAL_ANUAL)\n AS SELECT  empno, ename, sal * 12 \n     FROM   emp\n     WHERE  deptno = 20;\nCurs - BAZE DE DATE 29\n\n\nExerciţiu \nVizualizaţi conţinutul vederii cu o cerere SELECT. \nCurs - BAZE DE DATE 30\n\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCREATE OR REPLACE VIEW dept_sal(Denumire_dept, \nSAL_MIN, SAL_MAX, SAL_MEDIU)\n AS SELECT  d.dname, MIN(e.sal), MAX(e.sal), \nAVG(e.sal) \n     FROM   emp e, dept d\n     WHERE  d.deptno = e.deptno\n     GROUP BY d.dname;\nCurs - BAZE DE DATE 31\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n\n\nNOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n\n\nEfectuarea operaţiilor DML asupra vederilor\nSe pot efectua operaţii DML asupra \nvederilor, dar numai în anumite condiţii. \na) Nu se poate şterge un rând dintr-o \nvedere care conţine: \n1. funcţii de grup\n2. GROUP BY\n3. DISTINCT\n4. ROWNUM\nCurs - BAZE DE DATE 34\n\nb) De asemenea nu se pot modifica date printr-o vedere \ndacă aceasta verifică condiţiile de mai sus şi dacă există \ncoloane definite prin expresii cum ar fi SALARIU*12. \nc) Adăugarea de date printr-o vedere este imposibilădacă\nvederea conţine elementele enumerate mai sus şi dacă\nexistă coloane NOT NULL în tabela neselectate de către\nvedere.\nPrin adăugare de date se modifică de fapt tabela propriu-\nzisă deci în coloanele neselectate se va adăuga NULL\nceea ce încalcă constrângerea.\nCurs - BAZE DE DATE 35\n\nExemplu - Crearea vederii dept_sal utilizând clauza OR \nREPLACE. \nCREATE OR REPLACE VIEW dept_sal (COD, SAL_MEDIU)\n  AS SELECT deptno, AVG(sal)\n    FROM     emp\n    GROUP BY deptno;\n \nCurs - BAZE DE DATE 36', '\n', '6. ', 'Extragere de date dintr-o vedere\n➢Extragerea de date se face exact ca în cazul \nunei tabele. \n➢Se pot selecta anumite rânduri sau toată \nvederea. \nSELECT * FROM emp10;\nCurs - BAZE DE DATE 26\n\n\nInterogarea unei vederi\nInterogarea unei vederi de către serverul \nORACLE se face în felul următor: \n1. Extragere definiţie vedere din tabela \ndicţionarului de date USER_VIEWS\n2. Verificare drepturi acces pentru tabela vederii\n3. Convertire interogare vedere într-o interogare \nechivalentă a tabelei vederii. \nDeci datele sunt extrase, inserate din tabele \npropriu-zise. \nCurs - BAZE DE DATE 27\n\nModificarea unei vederi\nPână acum am verificat dacă vederea \nexistă sau nu şi numai în cazul în care nu exista \no cream. \nAvem posibilitatea de a crea o vedere chiar \ndacă ea există, înlocuind-o pe cea veche cu o \nnouă versiune. \nCurs - BAZE DE DATE 28\n\nÎn acest scop se foloseşte clauza OR REPLACE. \nVom înlocui vederea emp20 cu alta.\nCREATE OR REPLACE VIEW emp20 (COD, NUME, \nSAL_ANUAL)\n AS SELECT  empno, ename, sal * 12 \n     FROM   emp\n     WHERE  deptno = 20;\nCurs - BAZE DE DATE 29\n\n\nExerciţiu \nVizualizaţi conţinutul vederii cu o cerere SELECT. \nCurs - BAZE DE DATE 30\n\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCREATE OR REPLACE VIEW dept_sal(Denumire_dept, \nSAL_MIN, SAL_MAX, SAL_MEDIU)\n AS SELECT  d.dname, MIN(e.sal), MAX(e.sal), \nAVG(e.sal) \n     FROM   emp e, dept d\n     WHERE  d.deptno = e.deptno\n     GROUP BY d.dname;\nCurs - BAZE DE DATE 31\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n\n\nNOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n\n\nEfectuarea operaţiilor DML asupra vederilor\nSe pot efectua operaţii DML asupra \nvederilor, dar numai în anumite condiţii. \na) Nu se poate şterge un rând dintr-o \nvedere care conţine: \n1. funcţii de grup\n2. GROUP BY\n3. DISTINCT\n4. ROWNUM\nCurs - BAZE DE DATE 34\n\nb) De asemenea nu se pot modifica date printr-o vedere \ndacă aceasta verifică condiţiile de mai sus şi dacă există \ncoloane definite prin expresii cum ar fi SALARIU*12. \nc) Adăugarea de date printr-o vedere este imposibilădacă\nvederea conţine elementele enumerate mai sus şi dacă\nexistă coloane NOT NULL în tabela neselectate de către\nvedere.\nPrin adăugare de date se modifică de fapt tabela propriu-\nzisă deci în coloanele neselectate se va adăuga NULL\nceea ce încalcă constrângerea.\nCurs - BAZE DE DATE 35\n\nExemplu - Crearea vederii dept_sal utilizând clauza OR \nREPLACE. \nCREATE OR REPLACE VIEW dept_sal (COD, SAL_MEDIU)\n  AS SELECT deptno, AVG(sal)\n    FROM     emp\n    GROUP BY deptno;\n \nCurs - BAZE DE DATE 36', '\n', '7. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '8. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '9. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '10. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n']","o vedere (view) este o tabelă logică ce extrage date dintr-o tabelă propriu-zisă sau dintr-o altă vedere. Aceasta nu conține date proprii, funcționând ca o fereastră prin care datele pot fi vizualizate sau actualizate. O vedere poate include toate sau doar o parte din coloanele unei tabele sau mai multor tabele.
","Ce este o vedere (view) în SQL, conform cursului?","['1. ', ""Curs 9\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3\n\n O vedere este o tabelă logică care extrage \ndate dintr-o tabelă propriu-zisă sau dintr-o \naltă vedere. \n  O vedere nu are date proprii, ci este ca o \nfereastră prin care datele din tabele pot fi \nactualizate sau vizualizate. \n  O vedere poate să conţină toate datele \ndintr-o tabelă (sau mai multe) sau anumite \ncoloane. \nCurs - BAZE DE DATE 4\n\nVederile se folosesc pentru că oferă: \n1. Acces restricţionat la date (vederile pot \nselecţiona anumite coloane dintr-o tabelă)\n2. Posibilitatea lucrului cu interogări complexe\n3. Independenţa datelor\n4. Posibilitatea prezentării de date identice în \nvederi diferite\nCurs - BAZE DE DATE 5\n\nAvantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6\n\nClasificare\n Vederile se clasifică în: \n1.vederi simple\n2.vederi complexe\n  Pentru început prezentăm vederile \nsimple. \nCurs - BAZE DE DATE 7\n\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8\n\nSintaxa \nCREATE [OR REPLACE] [FORCE|NOFORCE] VIEW \nview   [ (alias [, alias]...) ] \n AS subquery \n[WITH CHECK OPTION [CONSTRAINT \nconstraint] ]\n[WITH READ ONLY [CONSTRAINT constraint] ];\nCurs - BAZE DE DATE 9\n\nSemnificaţia argumentelor sintaxei: \n• OR REPLACE: determină înlocuirea vederii dacă \naceasta există deja\n• FORCE: crearea vederii indiferent dacă tabela din care \nprovin datele nu există\n• NOFORCE: crearea vederii numai dacă tabela există \n(valoarea implicită)\n• view: numele vederii\n• alias: specifică numele expresiilor selectate de către \ncererea din vedere (numele coloanelor selectate). \nNumărul alias-urilor trebuie să fie egal cu numărul \ncoloanelor selectate.\nCurs - BAZE DE DATE 10\n\n• subquery: cererea SELECT care generează \nvederea \n• WITH CHECK OPTION: numai rândurile accesibile \nvederii pot fi actualizate\n• constraint: numele constrângerii asociate cu \nWITH CHECK OPTION\n• WITH READ ONLY: asigură că nici o operaţie DML \n(INSERT, UPDATE, DELETE) nu va fi executată prin \nvedere.\nCurs - BAZE DE DATE 11\n\nExemplu \n Să cream o vedere emp20 care va conţine \npersoanele din departamentul 20. \n  Mai întâi trebuie să ne asigurăm că vederea \nemp20 nu există deja. \nCurs - BAZE DE DATE 12\n\nSELECT OBJECT_NAME, OBJECT_TYPE \nFROM USER_OBJECTS \nWHERE OBJECT_TYPE='VIEW'\nAceastă vedere nu există deci putem să o cream. \n \nCurs - BAZE DE DATE 13"", '\n', '2. ', ""Curs 9\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3\n\n O vedere este o tabelă logică care extrage \ndate dintr-o tabelă propriu-zisă sau dintr-o \naltă vedere. \n  O vedere nu are date proprii, ci este ca o \nfereastră prin care datele din tabele pot fi \nactualizate sau vizualizate. \n  O vedere poate să conţină toate datele \ndintr-o tabelă (sau mai multe) sau anumite \ncoloane. \nCurs - BAZE DE DATE 4\n\nVederile se folosesc pentru că oferă: \n1. Acces restricţionat la date (vederile pot \nselecţiona anumite coloane dintr-o tabelă)\n2. Posibilitatea lucrului cu interogări complexe\n3. Independenţa datelor\n4. Posibilitatea prezentării de date identice în \nvederi diferite\nCurs - BAZE DE DATE 5\n\nAvantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6\n\nClasificare\n Vederile se clasifică în: \n1.vederi simple\n2.vederi complexe\n  Pentru început prezentăm vederile \nsimple. \nCurs - BAZE DE DATE 7\n\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8\n\nSintaxa \nCREATE [OR REPLACE] [FORCE|NOFORCE] VIEW \nview   [ (alias [, alias]...) ] \n AS subquery \n[WITH CHECK OPTION [CONSTRAINT \nconstraint] ]\n[WITH READ ONLY [CONSTRAINT constraint] ];\nCurs - BAZE DE DATE 9\n\nSemnificaţia argumentelor sintaxei: \n• OR REPLACE: determină înlocuirea vederii dacă \naceasta există deja\n• FORCE: crearea vederii indiferent dacă tabela din care \nprovin datele nu există\n• NOFORCE: crearea vederii numai dacă tabela există \n(valoarea implicită)\n• view: numele vederii\n• alias: specifică numele expresiilor selectate de către \ncererea din vedere (numele coloanelor selectate). \nNumărul alias-urilor trebuie să fie egal cu numărul \ncoloanelor selectate.\nCurs - BAZE DE DATE 10\n\n• subquery: cererea SELECT care generează \nvederea \n• WITH CHECK OPTION: numai rândurile accesibile \nvederii pot fi actualizate\n• constraint: numele constrângerii asociate cu \nWITH CHECK OPTION\n• WITH READ ONLY: asigură că nici o operaţie DML \n(INSERT, UPDATE, DELETE) nu va fi executată prin \nvedere.\nCurs - BAZE DE DATE 11\n\nExemplu \n Să cream o vedere emp20 care va conţine \npersoanele din departamentul 20. \n  Mai întâi trebuie să ne asigurăm că vederea \nemp20 nu există deja. \nCurs - BAZE DE DATE 12\n\nSELECT OBJECT_NAME, OBJECT_TYPE \nFROM USER_OBJECTS \nWHERE OBJECT_TYPE='VIEW'\nAceastă vedere nu există deci putem să o cream. \n \nCurs - BAZE DE DATE 13"", '\n', '3. ', ""Curs 9\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3\n\n O vedere este o tabelă logică care extrage \ndate dintr-o tabelă propriu-zisă sau dintr-o \naltă vedere. \n  O vedere nu are date proprii, ci este ca o \nfereastră prin care datele din tabele pot fi \nactualizate sau vizualizate. \n  O vedere poate să conţină toate datele \ndintr-o tabelă (sau mai multe) sau anumite \ncoloane. \nCurs - BAZE DE DATE 4\n\nVederile se folosesc pentru că oferă: \n1. Acces restricţionat la date (vederile pot \nselecţiona anumite coloane dintr-o tabelă)\n2. Posibilitatea lucrului cu interogări complexe\n3. Independenţa datelor\n4. Posibilitatea prezentării de date identice în \nvederi diferite\nCurs - BAZE DE DATE 5\n\nAvantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6\n\nClasificare\n Vederile se clasifică în: \n1.vederi simple\n2.vederi complexe\n  Pentru început prezentăm vederile \nsimple. \nCurs - BAZE DE DATE 7\n\nCrearea vederilor\nVederile simple sunt acele vederi care: \n1. Interoghează o singură tabelă\n2. Nu conţin funcţii\n3. Nu conţin grupuri de date\n4. Oferă posibilitatea efectuării de operaţii DML \n(INSERT, UPDATE, DELETE)\nNOTĂ: \nO vedere are un nume şi este generată de o \ncerere SQL. \nCurs - BAZE DE DATE 8\n\nSintaxa \nCREATE [OR REPLACE] [FORCE|NOFORCE] VIEW \nview   [ (alias [, alias]...) ] \n AS subquery \n[WITH CHECK OPTION [CONSTRAINT \nconstraint] ]\n[WITH READ ONLY [CONSTRAINT constraint] ];\nCurs - BAZE DE DATE 9\n\nSemnificaţia argumentelor sintaxei: \n• OR REPLACE: determină înlocuirea vederii dacă \naceasta există deja\n• FORCE: crearea vederii indiferent dacă tabela din care \nprovin datele nu există\n• NOFORCE: crearea vederii numai dacă tabela există \n(valoarea implicită)\n• view: numele vederii\n• alias: specifică numele expresiilor selectate de către \ncererea din vedere (numele coloanelor selectate). \nNumărul alias-urilor trebuie să fie egal cu numărul \ncoloanelor selectate.\nCurs - BAZE DE DATE 10\n\n• subquery: cererea SELECT care generează \nvederea \n• WITH CHECK OPTION: numai rândurile accesibile \nvederii pot fi actualizate\n• constraint: numele constrângerii asociate cu \nWITH CHECK OPTION\n• WITH READ ONLY: asigură că nici o operaţie DML \n(INSERT, UPDATE, DELETE) nu va fi executată prin \nvedere.\nCurs - BAZE DE DATE 11\n\nExemplu \n Să cream o vedere emp20 care va conţine \npersoanele din departamentul 20. \n  Mai întâi trebuie să ne asigurăm că vederea \nemp20 nu există deja. \nCurs - BAZE DE DATE 12\n\nSELECT OBJECT_NAME, OBJECT_TYPE \nFROM USER_OBJECTS \nWHERE OBJECT_TYPE='VIEW'\nAceastă vedere nu există deci putem să o cream. \n \nCurs - BAZE DE DATE 13"", '\n', '4. ', 'Extragere de date dintr-o vedere\n➢Extragerea de date se face exact ca în cazul \nunei tabele. \n➢Se pot selecta anumite rânduri sau toată \nvederea. \nSELECT * FROM emp10;\nCurs - BAZE DE DATE 26\n\n\nInterogarea unei vederi\nInterogarea unei vederi de către serverul \nORACLE se face în felul următor: \n1. Extragere definiţie vedere din tabela \ndicţionarului de date USER_VIEWS\n2. Verificare drepturi acces pentru tabela vederii\n3. Convertire interogare vedere într-o interogare \nechivalentă a tabelei vederii. \nDeci datele sunt extrase, inserate din tabele \npropriu-zise. \nCurs - BAZE DE DATE 27\n\nModificarea unei vederi\nPână acum am verificat dacă vederea \nexistă sau nu şi numai în cazul în care nu exista \no cream. \nAvem posibilitatea de a crea o vedere chiar \ndacă ea există, înlocuind-o pe cea veche cu o \nnouă versiune. \nCurs - BAZE DE DATE 28\n\nÎn acest scop se foloseşte clauza OR REPLACE. \nVom înlocui vederea emp20 cu alta.\nCREATE OR REPLACE VIEW emp20 (COD, NUME, \nSAL_ANUAL)\n AS SELECT  empno, ename, sal * 12 \n     FROM   emp\n     WHERE  deptno = 20;\nCurs - BAZE DE DATE 29\n\n\nExerciţiu \nVizualizaţi conţinutul vederii cu o cerere SELECT. \nCurs - BAZE DE DATE 30\n\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCREATE OR REPLACE VIEW dept_sal(Denumire_dept, \nSAL_MIN, SAL_MAX, SAL_MEDIU)\n AS SELECT  d.dname, MIN(e.sal), MAX(e.sal), \nAVG(e.sal) \n     FROM   emp e, dept d\n     WHERE  d.deptno = e.deptno\n     GROUP BY d.dname;\nCurs - BAZE DE DATE 31\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n\n\nNOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n\n\nEfectuarea operaţiilor DML asupra vederilor\nSe pot efectua operaţii DML asupra \nvederilor, dar numai în anumite condiţii. \na) Nu se poate şterge un rând dintr-o \nvedere care conţine: \n1. funcţii de grup\n2. GROUP BY\n3. DISTINCT\n4. ROWNUM\nCurs - BAZE DE DATE 34\n\nb) De asemenea nu se pot modifica date printr-o vedere \ndacă aceasta verifică condiţiile de mai sus şi dacă există \ncoloane definite prin expresii cum ar fi SALARIU*12. \nc) Adăugarea de date printr-o vedere este imposibilădacă\nvederea conţine elementele enumerate mai sus şi dacă\nexistă coloane NOT NULL în tabela neselectate de către\nvedere.\nPrin adăugare de date se modifică de fapt tabela propriu-\nzisă deci în coloanele neselectate se va adăuga NULL\nceea ce încalcă constrângerea.\nCurs - BAZE DE DATE 35\n\nExemplu - Crearea vederii dept_sal utilizând clauza OR \nREPLACE. \nCREATE OR REPLACE VIEW dept_sal (COD, SAL_MEDIU)\n  AS SELECT deptno, AVG(sal)\n    FROM     emp\n    GROUP BY deptno;\n \nCurs - BAZE DE DATE 36', '\n', '5. ', 'Extragere de date dintr-o vedere\n➢Extragerea de date se face exact ca în cazul \nunei tabele. \n➢Se pot selecta anumite rânduri sau toată \nvederea. \nSELECT * FROM emp10;\nCurs - BAZE DE DATE 26\n\n\nInterogarea unei vederi\nInterogarea unei vederi de către serverul \nORACLE se face în felul următor: \n1. Extragere definiţie vedere din tabela \ndicţionarului de date USER_VIEWS\n2. Verificare drepturi acces pentru tabela vederii\n3. Convertire interogare vedere într-o interogare \nechivalentă a tabelei vederii. \nDeci datele sunt extrase, inserate din tabele \npropriu-zise. \nCurs - BAZE DE DATE 27\n\nModificarea unei vederi\nPână acum am verificat dacă vederea \nexistă sau nu şi numai în cazul în care nu exista \no cream. \nAvem posibilitatea de a crea o vedere chiar \ndacă ea există, înlocuind-o pe cea veche cu o \nnouă versiune. \nCurs - BAZE DE DATE 28\n\nÎn acest scop se foloseşte clauza OR REPLACE. \nVom înlocui vederea emp20 cu alta.\nCREATE OR REPLACE VIEW emp20 (COD, NUME, \nSAL_ANUAL)\n AS SELECT  empno, ename, sal * 12 \n     FROM   emp\n     WHERE  deptno = 20;\nCurs - BAZE DE DATE 29\n\n\nExerciţiu \nVizualizaţi conţinutul vederii cu o cerere SELECT. \nCurs - BAZE DE DATE 30\n\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCREATE OR REPLACE VIEW dept_sal(Denumire_dept, \nSAL_MIN, SAL_MAX, SAL_MEDIU)\n AS SELECT  d.dname, MIN(e.sal), MAX(e.sal), \nAVG(e.sal) \n     FROM   emp e, dept d\n     WHERE  d.deptno = e.deptno\n     GROUP BY d.dname;\nCurs - BAZE DE DATE 31\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n\n\nNOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n\n\nEfectuarea operaţiilor DML asupra vederilor\nSe pot efectua operaţii DML asupra \nvederilor, dar numai în anumite condiţii. \na) Nu se poate şterge un rând dintr-o \nvedere care conţine: \n1. funcţii de grup\n2. GROUP BY\n3. DISTINCT\n4. ROWNUM\nCurs - BAZE DE DATE 34\n\nb) De asemenea nu se pot modifica date printr-o vedere \ndacă aceasta verifică condiţiile de mai sus şi dacă există \ncoloane definite prin expresii cum ar fi SALARIU*12. \nc) Adăugarea de date printr-o vedere este imposibilădacă\nvederea conţine elementele enumerate mai sus şi dacă\nexistă coloane NOT NULL în tabela neselectate de către\nvedere.\nPrin adăugare de date se modifică de fapt tabela propriu-\nzisă deci în coloanele neselectate se va adăuga NULL\nceea ce încalcă constrângerea.\nCurs - BAZE DE DATE 35\n\nExemplu - Crearea vederii dept_sal utilizând clauza OR \nREPLACE. \nCREATE OR REPLACE VIEW dept_sal (COD, SAL_MEDIU)\n  AS SELECT deptno, AVG(sal)\n    FROM     emp\n    GROUP BY deptno;\n \nCurs - BAZE DE DATE 36', '\n', '6. ', 'Extragere de date dintr-o vedere\n➢Extragerea de date se face exact ca în cazul \nunei tabele. \n➢Se pot selecta anumite rânduri sau toată \nvederea. \nSELECT * FROM emp10;\nCurs - BAZE DE DATE 26\n\n\nInterogarea unei vederi\nInterogarea unei vederi de către serverul \nORACLE se face în felul următor: \n1. Extragere definiţie vedere din tabela \ndicţionarului de date USER_VIEWS\n2. Verificare drepturi acces pentru tabela vederii\n3. Convertire interogare vedere într-o interogare \nechivalentă a tabelei vederii. \nDeci datele sunt extrase, inserate din tabele \npropriu-zise. \nCurs - BAZE DE DATE 27\n\nModificarea unei vederi\nPână acum am verificat dacă vederea \nexistă sau nu şi numai în cazul în care nu exista \no cream. \nAvem posibilitatea de a crea o vedere chiar \ndacă ea există, înlocuind-o pe cea veche cu o \nnouă versiune. \nCurs - BAZE DE DATE 28\n\nÎn acest scop se foloseşte clauza OR REPLACE. \nVom înlocui vederea emp20 cu alta.\nCREATE OR REPLACE VIEW emp20 (COD, NUME, \nSAL_ANUAL)\n AS SELECT  empno, ename, sal * 12 \n     FROM   emp\n     WHERE  deptno = 20;\nCurs - BAZE DE DATE 29\n\n\nExerciţiu \nVizualizaţi conţinutul vederii cu o cerere SELECT. \nCurs - BAZE DE DATE 30\n\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCREATE OR REPLACE VIEW dept_sal(Denumire_dept, \nSAL_MIN, SAL_MAX, SAL_MEDIU)\n AS SELECT  d.dname, MIN(e.sal), MAX(e.sal), \nAVG(e.sal) \n     FROM   emp e, dept d\n     WHERE  d.deptno = e.deptno\n     GROUP BY d.dname;\nCurs - BAZE DE DATE 31\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n\n\nNOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n\n\nEfectuarea operaţiilor DML asupra vederilor\nSe pot efectua operaţii DML asupra \nvederilor, dar numai în anumite condiţii. \na) Nu se poate şterge un rând dintr-o \nvedere care conţine: \n1. funcţii de grup\n2. GROUP BY\n3. DISTINCT\n4. ROWNUM\nCurs - BAZE DE DATE 34\n\nb) De asemenea nu se pot modifica date printr-o vedere \ndacă aceasta verifică condiţiile de mai sus şi dacă există \ncoloane definite prin expresii cum ar fi SALARIU*12. \nc) Adăugarea de date printr-o vedere este imposibilădacă\nvederea conţine elementele enumerate mai sus şi dacă\nexistă coloane NOT NULL în tabela neselectate de către\nvedere.\nPrin adăugare de date se modifică de fapt tabela propriu-\nzisă deci în coloanele neselectate se va adăuga NULL\nceea ce încalcă constrângerea.\nCurs - BAZE DE DATE 35\n\nExemplu - Crearea vederii dept_sal utilizând clauza OR \nREPLACE. \nCREATE OR REPLACE VIEW dept_sal (COD, SAL_MEDIU)\n  AS SELECT deptno, AVG(sal)\n    FROM     emp\n    GROUP BY deptno;\n \nCurs - BAZE DE DATE 36', '\n', '7. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '8. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '9. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '10. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n']","o vedere (view) este o tabelă logică ce extrage date dintr-o tabelă propriu-zisă sau dintr-o altă vedere. Aceasta nu conține date proprii, funcționând ca o fereastră prin care datele pot fi vizualizate sau actualizate. O vedere poate include toate sau doar o parte din coloanele unei tabele sau mai multor tabele.
","O vedere este o tabelă logică generată printr-o instrucțiune SELECT, fără a stoca date proprii, ci extrăgându-le din tabele.",0.39145339953511066,1.0,0.853799177044895,1.0,0.11977165750310859,0.2682926829268293,0.57
23,O3mini-high,Medium,Curs 10,,"De ce se folosesc secvențele în SQL, potrivit cursului?","Secvențele generează automat numere întregi unice, esențiale pentru chei primare, evitând problemele de sincronizare.",Este corect,slide 8,"['1. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '2. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '3. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '4. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '5. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '6. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '7. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '8. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '9. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '10. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n']","secvențele sunt folosite pentru a genera automat valori numerice unice, incrementale. Ele sunt adesea utilizate pentru cheile primare, asigurând unicitatea și simplificând inserarea de noi înregistrări (Curs - BAZE DE DATE 10,11,12 & 13). Pseudocoloanele `NEXTVAL` și `CURRVAL` permit accesarea valorii următoare, respectiv curente, a secvenței (Curs - BAZE DE DATE 14 &15).
","De ce se folosesc secvențele în SQL, potrivit cursului?","['1. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '2. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '3. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '4. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '5. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '6. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '7. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '8. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '9. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '10. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n']","secvențele sunt folosite pentru a genera automat valori numerice unice, incrementale. Ele sunt adesea utilizate pentru cheile primare, asigurând unicitatea și simplificând inserarea de noi înregistrări (Curs - BAZE DE DATE 10,11,12 & 13). Pseudocoloanele `NEXTVAL` și `CURRVAL` permit accesarea valorii următoare, respectiv curente, a secvenței (Curs - BAZE DE DATE 14 &15).
","Secvențele generează automat numere întregi unice, esențiale pentru chei primare, evitând problemele de sincronizare.",0.4249999999858333,0.0,0.8171960085761034,0.6666666666666666,0.05309851272691558,0.21333333333333335,0.5
24,O3mini-high,Medium,Curs 11,,"Ce acoperă securitatea bazei de date, conform cursului?","Securitatea bazei de date acoperă controlul accesului, acordarea privilegiilor de sistem și obiect, protejând datele într-un mediu multi-user.",Este corect,slide 4,"['1. ', 'Curs 11\nControlul accesului utilizatorilor\nCurs - BAZE DE DATE 2\n\n\nCuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3\n\nControlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4\n\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5\n\ntt\n1) Securitatea sistemului acopera accesarea si \nutilizarea bazei de date la nivelul sistemului, cum \nar fi: numele utilizatorului si parola, spatiul pe \ndisc alocat utilizatorilor, si operatiile de sistem \npermise utilizatorilor. \nCurs - BAZE DE DATE 6\nhttps://www.scnsoft.com/blog/database-security-best-practices\n\ntt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/\n\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8\n\nScheme \nO schema este o colectie de obiecte, cum ar fi: \n✓tabele\n✓indecsi\n✓vizualizari\n✓secvente\nSchema este detinuta de un utilizator al bazei de \ndate si are acelasi nume cu utilizatorul.\nCurs - BAZE DE DATE 9\n\ntt\nPrivilegii de sistem\nSunt disponibile mai mult de 80 de privilegii de \nsistem pentru utilizatori si pentru roluri. \nPrivilegiile de sistem sunt setate  de catre  \nadministratorul bazei de date.\nCurs - BAZE DE DATE 10\n\nPrivilegiile caracteristice ale DBA\nPrivilegii de sistem Operatii autorizate\nCreare de utilizatori Permite crearea unui alt utilizator Oracle (privilegiu\ncerut pentru rolul de DBA)\nStergerea de utilizatori Permite stergerea altui utilizator\nStergerea oricarei tabele Permite stergerea unei tabele în orice schema\nRecuperarea oricarei\ntabele\nRecuperarea oricarei tabele în orice schema cu\nutilitare de export\nCurs - BAZE DE DATE 11', '\n', '2. ', 'Curs 11\nControlul accesului utilizatorilor\nCurs - BAZE DE DATE 2\n\n\nCuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3\n\nControlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4\n\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5\n\ntt\n1) Securitatea sistemului acopera accesarea si \nutilizarea bazei de date la nivelul sistemului, cum \nar fi: numele utilizatorului si parola, spatiul pe \ndisc alocat utilizatorilor, si operatiile de sistem \npermise utilizatorilor. \nCurs - BAZE DE DATE 6\nhttps://www.scnsoft.com/blog/database-security-best-practices\n\ntt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/\n\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8\n\nScheme \nO schema este o colectie de obiecte, cum ar fi: \n✓tabele\n✓indecsi\n✓vizualizari\n✓secvente\nSchema este detinuta de un utilizator al bazei de \ndate si are acelasi nume cu utilizatorul.\nCurs - BAZE DE DATE 9\n\ntt\nPrivilegii de sistem\nSunt disponibile mai mult de 80 de privilegii de \nsistem pentru utilizatori si pentru roluri. \nPrivilegiile de sistem sunt setate  de catre  \nadministratorul bazei de date.\nCurs - BAZE DE DATE 10\n\nPrivilegiile caracteristice ale DBA\nPrivilegii de sistem Operatii autorizate\nCreare de utilizatori Permite crearea unui alt utilizator Oracle (privilegiu\ncerut pentru rolul de DBA)\nStergerea de utilizatori Permite stergerea altui utilizator\nStergerea oricarei tabele Permite stergerea unei tabele în orice schema\nRecuperarea oricarei\ntabele\nRecuperarea oricarei tabele în orice schema cu\nutilitare de export\nCurs - BAZE DE DATE 11', '\n', '3. ', 'Curs 11\nControlul accesului utilizatorilor\nCurs - BAZE DE DATE 2\n\n\nCuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3\n\nControlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4\n\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5\n\ntt\n1) Securitatea sistemului acopera accesarea si \nutilizarea bazei de date la nivelul sistemului, cum \nar fi: numele utilizatorului si parola, spatiul pe \ndisc alocat utilizatorilor, si operatiile de sistem \npermise utilizatorilor. \nCurs - BAZE DE DATE 6\nhttps://www.scnsoft.com/blog/database-security-best-practices\n\ntt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/\n\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8\n\nScheme \nO schema este o colectie de obiecte, cum ar fi: \n✓tabele\n✓indecsi\n✓vizualizari\n✓secvente\nSchema este detinuta de un utilizator al bazei de \ndate si are acelasi nume cu utilizatorul.\nCurs - BAZE DE DATE 9\n\ntt\nPrivilegii de sistem\nSunt disponibile mai mult de 80 de privilegii de \nsistem pentru utilizatori si pentru roluri. \nPrivilegiile de sistem sunt setate  de catre  \nadministratorul bazei de date.\nCurs - BAZE DE DATE 10\n\nPrivilegiile caracteristice ale DBA\nPrivilegii de sistem Operatii autorizate\nCreare de utilizatori Permite crearea unui alt utilizator Oracle (privilegiu\ncerut pentru rolul de DBA)\nStergerea de utilizatori Permite stergerea altui utilizator\nStergerea oricarei tabele Permite stergerea unei tabele în orice schema\nRecuperarea oricarei\ntabele\nRecuperarea oricarei tabele în orice schema cu\nutilitare de export\nCurs - BAZE DE DATE 11', '\n', '4. ', 'Orice firmă utilizează baze de date pentru păstrarea \nşi gestionarea informaţiilor. Câteva astfel de aplicaţii sunt \nuzuale:\n1.bazele de date ale liniilor aeriene care sunt accesate \nsimultan din sute de agenţii pentru a realiza rezervări şi \nvânzări de locuri pentru date şi zboruri diferite\n2.bazele de date ale băncilor care permit realizarea a mii \nde tranzacţii zilnic\n3.bazele de date ale supermagazinelor care sunt accesate \natât de la casele de marcaj cât şi de la echipamentele de \ninventariere\n4.bazele de date ale bibliotecilor care păstrează milioane \nde titluri şi permit localizarea unei lucrări folosind diferite \ncriterii (cuvinte cheie, titlu, autori, domeniu)\n 17\n\nPentru realizarea unei aplicaţii care foloseşte baze de \ndate se poate proceda în două moduri:\na)Se creează baza de date cu ajutorul unei aplicaţii de tip server \nde baze de date şi se scriu apoi aplicaţiile care accesează baza \nde date într-un limbaj care posedă funcţiile necesare accesării \nserver-ului (frecvent se folosesc limbajele C++, Java, C# sau \nVisual Basic)\nb)Se foloseste o aplicaţie de tip sistem de gestiune de baze de \ndate (S.G.B.D. sau D.B.M.S. - DataBase Management System). \n      Un astfel de sistem oferă un ansamblu de instrumente \nsoftware cu ajutorul cărora se crează atât baza de date cât şi \naplicaţiile prin care aceasta este exploatată. \n      Pentru utilizatorii sistemului de operare Windows cele mai \ncunoscute sisteme de acest fel sunt Access şi Visual FoxPro. \n 18\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 19\n\n1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20\n\n1.1.Sisteme de baze de date\nUn sistem de baze de date poate fi \nconsiderat ca având patru părţi: \n1. date\n2. utilizatori\n3. hardware \n4. software\n 21\n\n1.1.Sisteme de baze de date\nDatele: \nSunt informaţii pe care diferiţi utilizatori (firme, \nagenţii, sau simpli utilizatori) le colectează pentru a-şi \nîndeplini scopurile sau misiunile. \nDatele individuale sunt stocate în mulţimi de date \nrelaţionate (legate) numite înregistrări. \nO colecţie de înregistrări dependente se numeşte \nbază de date.\n 22\n\n1.1.Sisteme de baze de date\nUtilizatorii: \nDiferite persoane sau grupuri de \npersoane care folosesc informaţiile sunt\ndefinite ca utilizatori.\nHardware: De obicei noţiunea de \nhardware constă din device-uri fizice, cum \nar fi harddisk-uri, imprimante, interfeţe de \nintrare/ieşire şi procesorul de date cu\nmemoria sa asociată.\n 23', '\n', '5. ', 'Orice firmă utilizează baze de date pentru păstrarea \nşi gestionarea informaţiilor. Câteva astfel de aplicaţii sunt \nuzuale:\n1.bazele de date ale liniilor aeriene care sunt accesate \nsimultan din sute de agenţii pentru a realiza rezervări şi \nvânzări de locuri pentru date şi zboruri diferite\n2.bazele de date ale băncilor care permit realizarea a mii \nde tranzacţii zilnic\n3.bazele de date ale supermagazinelor care sunt accesate \natât de la casele de marcaj cât şi de la echipamentele de \ninventariere\n4.bazele de date ale bibliotecilor care păstrează milioane \nde titluri şi permit localizarea unei lucrări folosind diferite \ncriterii (cuvinte cheie, titlu, autori, domeniu)\n 17\n\nPentru realizarea unei aplicaţii care foloseşte baze de \ndate se poate proceda în două moduri:\na)Se creează baza de date cu ajutorul unei aplicaţii de tip server \nde baze de date şi se scriu apoi aplicaţiile care accesează baza \nde date într-un limbaj care posedă funcţiile necesare accesării \nserver-ului (frecvent se folosesc limbajele C++, Java, C# sau \nVisual Basic)\nb)Se foloseste o aplicaţie de tip sistem de gestiune de baze de \ndate (S.G.B.D. sau D.B.M.S. - DataBase Management System). \n      Un astfel de sistem oferă un ansamblu de instrumente \nsoftware cu ajutorul cărora se crează atât baza de date cât şi \naplicaţiile prin care aceasta este exploatată. \n      Pentru utilizatorii sistemului de operare Windows cele mai \ncunoscute sisteme de acest fel sunt Access şi Visual FoxPro. \n 18\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 19\n\n1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20\n\n1.1.Sisteme de baze de date\nUn sistem de baze de date poate fi \nconsiderat ca având patru părţi: \n1. date\n2. utilizatori\n3. hardware \n4. software\n 21\n\n1.1.Sisteme de baze de date\nDatele: \nSunt informaţii pe care diferiţi utilizatori (firme, \nagenţii, sau simpli utilizatori) le colectează pentru a-şi \nîndeplini scopurile sau misiunile. \nDatele individuale sunt stocate în mulţimi de date \nrelaţionate (legate) numite înregistrări. \nO colecţie de înregistrări dependente se numeşte \nbază de date.\n 22\n\n1.1.Sisteme de baze de date\nUtilizatorii: \nDiferite persoane sau grupuri de \npersoane care folosesc informaţiile sunt\ndefinite ca utilizatori.\nHardware: De obicei noţiunea de \nhardware constă din device-uri fizice, cum \nar fi harddisk-uri, imprimante, interfeţe de \nintrare/ieşire şi procesorul de date cu\nmemoria sa asociată.\n 23', '\n', '6. ', 'Orice firmă utilizează baze de date pentru păstrarea \nşi gestionarea informaţiilor. Câteva astfel de aplicaţii sunt \nuzuale:\n1.bazele de date ale liniilor aeriene care sunt accesate \nsimultan din sute de agenţii pentru a realiza rezervări şi \nvânzări de locuri pentru date şi zboruri diferite\n2.bazele de date ale băncilor care permit realizarea a mii \nde tranzacţii zilnic\n3.bazele de date ale supermagazinelor care sunt accesate \natât de la casele de marcaj cât şi de la echipamentele de \ninventariere\n4.bazele de date ale bibliotecilor care păstrează milioane \nde titluri şi permit localizarea unei lucrări folosind diferite \ncriterii (cuvinte cheie, titlu, autori, domeniu)\n 17\n\nPentru realizarea unei aplicaţii care foloseşte baze de \ndate se poate proceda în două moduri:\na)Se creează baza de date cu ajutorul unei aplicaţii de tip server \nde baze de date şi se scriu apoi aplicaţiile care accesează baza \nde date într-un limbaj care posedă funcţiile necesare accesării \nserver-ului (frecvent se folosesc limbajele C++, Java, C# sau \nVisual Basic)\nb)Se foloseste o aplicaţie de tip sistem de gestiune de baze de \ndate (S.G.B.D. sau D.B.M.S. - DataBase Management System). \n      Un astfel de sistem oferă un ansamblu de instrumente \nsoftware cu ajutorul cărora se crează atât baza de date cât şi \naplicaţiile prin care aceasta este exploatată. \n      Pentru utilizatorii sistemului de operare Windows cele mai \ncunoscute sisteme de acest fel sunt Access şi Visual FoxPro. \n 18\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 19\n\n1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20\n\n1.1.Sisteme de baze de date\nUn sistem de baze de date poate fi \nconsiderat ca având patru părţi: \n1. date\n2. utilizatori\n3. hardware \n4. software\n 21\n\n1.1.Sisteme de baze de date\nDatele: \nSunt informaţii pe care diferiţi utilizatori (firme, \nagenţii, sau simpli utilizatori) le colectează pentru a-şi \nîndeplini scopurile sau misiunile. \nDatele individuale sunt stocate în mulţimi de date \nrelaţionate (legate) numite înregistrări. \nO colecţie de înregistrări dependente se numeşte \nbază de date.\n 22\n\n1.1.Sisteme de baze de date\nUtilizatorii: \nDiferite persoane sau grupuri de \npersoane care folosesc informaţiile sunt\ndefinite ca utilizatori.\nHardware: De obicei noţiunea de \nhardware constă din device-uri fizice, cum \nar fi harddisk-uri, imprimante, interfeţe de \nintrare/ieşire şi procesorul de date cu\nmemoria sa asociată.\n 23', '\n', '7. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '8. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '9. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '10. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n']","securitatea bazei de date acoperă accesarea și utilizarea obiectelor bazei de date și acțiunile pe care utilizatorii le pot efectua asupra obiectelor.
","Ce acoperă securitatea bazei de date, conform cursului?","['1. ', 'Curs 11\nControlul accesului utilizatorilor\nCurs - BAZE DE DATE 2\n\n\nCuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3\n\nControlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4\n\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5\n\ntt\n1) Securitatea sistemului acopera accesarea si \nutilizarea bazei de date la nivelul sistemului, cum \nar fi: numele utilizatorului si parola, spatiul pe \ndisc alocat utilizatorilor, si operatiile de sistem \npermise utilizatorilor. \nCurs - BAZE DE DATE 6\nhttps://www.scnsoft.com/blog/database-security-best-practices\n\ntt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/\n\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8\n\nScheme \nO schema este o colectie de obiecte, cum ar fi: \n✓tabele\n✓indecsi\n✓vizualizari\n✓secvente\nSchema este detinuta de un utilizator al bazei de \ndate si are acelasi nume cu utilizatorul.\nCurs - BAZE DE DATE 9\n\ntt\nPrivilegii de sistem\nSunt disponibile mai mult de 80 de privilegii de \nsistem pentru utilizatori si pentru roluri. \nPrivilegiile de sistem sunt setate  de catre  \nadministratorul bazei de date.\nCurs - BAZE DE DATE 10\n\nPrivilegiile caracteristice ale DBA\nPrivilegii de sistem Operatii autorizate\nCreare de utilizatori Permite crearea unui alt utilizator Oracle (privilegiu\ncerut pentru rolul de DBA)\nStergerea de utilizatori Permite stergerea altui utilizator\nStergerea oricarei tabele Permite stergerea unei tabele în orice schema\nRecuperarea oricarei\ntabele\nRecuperarea oricarei tabele în orice schema cu\nutilitare de export\nCurs - BAZE DE DATE 11', '\n', '2. ', 'Curs 11\nControlul accesului utilizatorilor\nCurs - BAZE DE DATE 2\n\n\nCuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3\n\nControlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4\n\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5\n\ntt\n1) Securitatea sistemului acopera accesarea si \nutilizarea bazei de date la nivelul sistemului, cum \nar fi: numele utilizatorului si parola, spatiul pe \ndisc alocat utilizatorilor, si operatiile de sistem \npermise utilizatorilor. \nCurs - BAZE DE DATE 6\nhttps://www.scnsoft.com/blog/database-security-best-practices\n\ntt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/\n\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8\n\nScheme \nO schema este o colectie de obiecte, cum ar fi: \n✓tabele\n✓indecsi\n✓vizualizari\n✓secvente\nSchema este detinuta de un utilizator al bazei de \ndate si are acelasi nume cu utilizatorul.\nCurs - BAZE DE DATE 9\n\ntt\nPrivilegii de sistem\nSunt disponibile mai mult de 80 de privilegii de \nsistem pentru utilizatori si pentru roluri. \nPrivilegiile de sistem sunt setate  de catre  \nadministratorul bazei de date.\nCurs - BAZE DE DATE 10\n\nPrivilegiile caracteristice ale DBA\nPrivilegii de sistem Operatii autorizate\nCreare de utilizatori Permite crearea unui alt utilizator Oracle (privilegiu\ncerut pentru rolul de DBA)\nStergerea de utilizatori Permite stergerea altui utilizator\nStergerea oricarei tabele Permite stergerea unei tabele în orice schema\nRecuperarea oricarei\ntabele\nRecuperarea oricarei tabele în orice schema cu\nutilitare de export\nCurs - BAZE DE DATE 11', '\n', '3. ', 'Curs 11\nControlul accesului utilizatorilor\nCurs - BAZE DE DATE 2\n\n\nCuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3\n\nControlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4\n\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5\n\ntt\n1) Securitatea sistemului acopera accesarea si \nutilizarea bazei de date la nivelul sistemului, cum \nar fi: numele utilizatorului si parola, spatiul pe \ndisc alocat utilizatorilor, si operatiile de sistem \npermise utilizatorilor. \nCurs - BAZE DE DATE 6\nhttps://www.scnsoft.com/blog/database-security-best-practices\n\ntt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/\n\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8\n\nScheme \nO schema este o colectie de obiecte, cum ar fi: \n✓tabele\n✓indecsi\n✓vizualizari\n✓secvente\nSchema este detinuta de un utilizator al bazei de \ndate si are acelasi nume cu utilizatorul.\nCurs - BAZE DE DATE 9\n\ntt\nPrivilegii de sistem\nSunt disponibile mai mult de 80 de privilegii de \nsistem pentru utilizatori si pentru roluri. \nPrivilegiile de sistem sunt setate  de catre  \nadministratorul bazei de date.\nCurs - BAZE DE DATE 10\n\nPrivilegiile caracteristice ale DBA\nPrivilegii de sistem Operatii autorizate\nCreare de utilizatori Permite crearea unui alt utilizator Oracle (privilegiu\ncerut pentru rolul de DBA)\nStergerea de utilizatori Permite stergerea altui utilizator\nStergerea oricarei tabele Permite stergerea unei tabele în orice schema\nRecuperarea oricarei\ntabele\nRecuperarea oricarei tabele în orice schema cu\nutilitare de export\nCurs - BAZE DE DATE 11', '\n', '4. ', 'Orice firmă utilizează baze de date pentru păstrarea \nşi gestionarea informaţiilor. Câteva astfel de aplicaţii sunt \nuzuale:\n1.bazele de date ale liniilor aeriene care sunt accesate \nsimultan din sute de agenţii pentru a realiza rezervări şi \nvânzări de locuri pentru date şi zboruri diferite\n2.bazele de date ale băncilor care permit realizarea a mii \nde tranzacţii zilnic\n3.bazele de date ale supermagazinelor care sunt accesate \natât de la casele de marcaj cât şi de la echipamentele de \ninventariere\n4.bazele de date ale bibliotecilor care păstrează milioane \nde titluri şi permit localizarea unei lucrări folosind diferite \ncriterii (cuvinte cheie, titlu, autori, domeniu)\n 17\n\nPentru realizarea unei aplicaţii care foloseşte baze de \ndate se poate proceda în două moduri:\na)Se creează baza de date cu ajutorul unei aplicaţii de tip server \nde baze de date şi se scriu apoi aplicaţiile care accesează baza \nde date într-un limbaj care posedă funcţiile necesare accesării \nserver-ului (frecvent se folosesc limbajele C++, Java, C# sau \nVisual Basic)\nb)Se foloseste o aplicaţie de tip sistem de gestiune de baze de \ndate (S.G.B.D. sau D.B.M.S. - DataBase Management System). \n      Un astfel de sistem oferă un ansamblu de instrumente \nsoftware cu ajutorul cărora se crează atât baza de date cât şi \naplicaţiile prin care aceasta este exploatată. \n      Pentru utilizatorii sistemului de operare Windows cele mai \ncunoscute sisteme de acest fel sunt Access şi Visual FoxPro. \n 18\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 19\n\n1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20\n\n1.1.Sisteme de baze de date\nUn sistem de baze de date poate fi \nconsiderat ca având patru părţi: \n1. date\n2. utilizatori\n3. hardware \n4. software\n 21\n\n1.1.Sisteme de baze de date\nDatele: \nSunt informaţii pe care diferiţi utilizatori (firme, \nagenţii, sau simpli utilizatori) le colectează pentru a-şi \nîndeplini scopurile sau misiunile. \nDatele individuale sunt stocate în mulţimi de date \nrelaţionate (legate) numite înregistrări. \nO colecţie de înregistrări dependente se numeşte \nbază de date.\n 22\n\n1.1.Sisteme de baze de date\nUtilizatorii: \nDiferite persoane sau grupuri de \npersoane care folosesc informaţiile sunt\ndefinite ca utilizatori.\nHardware: De obicei noţiunea de \nhardware constă din device-uri fizice, cum \nar fi harddisk-uri, imprimante, interfeţe de \nintrare/ieşire şi procesorul de date cu\nmemoria sa asociată.\n 23', '\n', '5. ', 'Orice firmă utilizează baze de date pentru păstrarea \nşi gestionarea informaţiilor. Câteva astfel de aplicaţii sunt \nuzuale:\n1.bazele de date ale liniilor aeriene care sunt accesate \nsimultan din sute de agenţii pentru a realiza rezervări şi \nvânzări de locuri pentru date şi zboruri diferite\n2.bazele de date ale băncilor care permit realizarea a mii \nde tranzacţii zilnic\n3.bazele de date ale supermagazinelor care sunt accesate \natât de la casele de marcaj cât şi de la echipamentele de \ninventariere\n4.bazele de date ale bibliotecilor care păstrează milioane \nde titluri şi permit localizarea unei lucrări folosind diferite \ncriterii (cuvinte cheie, titlu, autori, domeniu)\n 17\n\nPentru realizarea unei aplicaţii care foloseşte baze de \ndate se poate proceda în două moduri:\na)Se creează baza de date cu ajutorul unei aplicaţii de tip server \nde baze de date şi se scriu apoi aplicaţiile care accesează baza \nde date într-un limbaj care posedă funcţiile necesare accesării \nserver-ului (frecvent se folosesc limbajele C++, Java, C# sau \nVisual Basic)\nb)Se foloseste o aplicaţie de tip sistem de gestiune de baze de \ndate (S.G.B.D. sau D.B.M.S. - DataBase Management System). \n      Un astfel de sistem oferă un ansamblu de instrumente \nsoftware cu ajutorul cărora se crează atât baza de date cât şi \naplicaţiile prin care aceasta este exploatată. \n      Pentru utilizatorii sistemului de operare Windows cele mai \ncunoscute sisteme de acest fel sunt Access şi Visual FoxPro. \n 18\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 19\n\n1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20\n\n1.1.Sisteme de baze de date\nUn sistem de baze de date poate fi \nconsiderat ca având patru părţi: \n1. date\n2. utilizatori\n3. hardware \n4. software\n 21\n\n1.1.Sisteme de baze de date\nDatele: \nSunt informaţii pe care diferiţi utilizatori (firme, \nagenţii, sau simpli utilizatori) le colectează pentru a-şi \nîndeplini scopurile sau misiunile. \nDatele individuale sunt stocate în mulţimi de date \nrelaţionate (legate) numite înregistrări. \nO colecţie de înregistrări dependente se numeşte \nbază de date.\n 22\n\n1.1.Sisteme de baze de date\nUtilizatorii: \nDiferite persoane sau grupuri de \npersoane care folosesc informaţiile sunt\ndefinite ca utilizatori.\nHardware: De obicei noţiunea de \nhardware constă din device-uri fizice, cum \nar fi harddisk-uri, imprimante, interfeţe de \nintrare/ieşire şi procesorul de date cu\nmemoria sa asociată.\n 23', '\n', '6. ', 'Orice firmă utilizează baze de date pentru păstrarea \nşi gestionarea informaţiilor. Câteva astfel de aplicaţii sunt \nuzuale:\n1.bazele de date ale liniilor aeriene care sunt accesate \nsimultan din sute de agenţii pentru a realiza rezervări şi \nvânzări de locuri pentru date şi zboruri diferite\n2.bazele de date ale băncilor care permit realizarea a mii \nde tranzacţii zilnic\n3.bazele de date ale supermagazinelor care sunt accesate \natât de la casele de marcaj cât şi de la echipamentele de \ninventariere\n4.bazele de date ale bibliotecilor care păstrează milioane \nde titluri şi permit localizarea unei lucrări folosind diferite \ncriterii (cuvinte cheie, titlu, autori, domeniu)\n 17\n\nPentru realizarea unei aplicaţii care foloseşte baze de \ndate se poate proceda în două moduri:\na)Se creează baza de date cu ajutorul unei aplicaţii de tip server \nde baze de date şi se scriu apoi aplicaţiile care accesează baza \nde date într-un limbaj care posedă funcţiile necesare accesării \nserver-ului (frecvent se folosesc limbajele C++, Java, C# sau \nVisual Basic)\nb)Se foloseste o aplicaţie de tip sistem de gestiune de baze de \ndate (S.G.B.D. sau D.B.M.S. - DataBase Management System). \n      Un astfel de sistem oferă un ansamblu de instrumente \nsoftware cu ajutorul cărora se crează atât baza de date cât şi \naplicaţiile prin care aceasta este exploatată. \n      Pentru utilizatorii sistemului de operare Windows cele mai \ncunoscute sisteme de acest fel sunt Access şi Visual FoxPro. \n 18\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 19\n\n1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20\n\n1.1.Sisteme de baze de date\nUn sistem de baze de date poate fi \nconsiderat ca având patru părţi: \n1. date\n2. utilizatori\n3. hardware \n4. software\n 21\n\n1.1.Sisteme de baze de date\nDatele: \nSunt informaţii pe care diferiţi utilizatori (firme, \nagenţii, sau simpli utilizatori) le colectează pentru a-şi \nîndeplini scopurile sau misiunile. \nDatele individuale sunt stocate în mulţimi de date \nrelaţionate (legate) numite înregistrări. \nO colecţie de înregistrări dependente se numeşte \nbază de date.\n 22\n\n1.1.Sisteme de baze de date\nUtilizatorii: \nDiferite persoane sau grupuri de \npersoane care folosesc informaţiile sunt\ndefinite ca utilizatori.\nHardware: De obicei noţiunea de \nhardware constă din device-uri fizice, cum \nar fi harddisk-uri, imprimante, interfeţe de \nintrare/ieşire şi procesorul de date cu\nmemoria sa asociată.\n 23', '\n', '7. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '8. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '9. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '10. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n']","securitatea bazei de date acoperă accesarea și utilizarea obiectelor bazei de date și acțiunile pe care utilizatorii le pot efectua asupra obiectelor.
","Securitatea bazei de date acoperă controlul accesului, acordarea privilegiilor de sistem și obiect, protejând datele într-un mediu multi-user.",0.4249999999858333,1.0,0.8394607945240103,1.0,0.11856660123276004,0.31818181818181823,0.57
25,O3mini-high,Medium,Curs 12,,"Care sunt avantajele bazelor de date față de fișierele tradiționale, conform cursului?","Avantajele: elimină redundanța, îmbunătățesc integritatea, oferă acces flexibil și securitate sporită.",Este corect,pagina 1,"['1. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '2. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '3. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '4. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '5. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '6. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '7. ', '4. Normalizarea bazelor de date \n \n4.1. Introducere în normalizarea bazelor de date \nNormalizarea este procesul de organizare a datelor într-o bază de date pentru a minimiza \nredundanța și dependențele nedorite. Aceasta implică aplicarea mai multor forme normale (NF), \nfiecare având un set de reguli specifice care îmbunătățesc structura bazei de date. \nObiectivele normalizării: \n1. Eliminarea redundanței datelor. \n2. Îmbunătățirea integrității și consistenței bazei de date. \n3. Creșterea eficienței interogărilor și a actualizărilor datelor. \n \n \n4.2. Prima formă normală (1NF) \nReguli: \n1. Fiecare coloană trebuie să conțină doar valori atomice (nu liste sau seturi de valori). \n2. Fiecare coloană trebuie să conțină doar un singur tip de date. \n \nExemplu de tabel neconform cu 1NF: \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Telefoane V ARCHAR(100) \n); \nÎn această structură, coloana Telefoane poate conține mai multe numere de telefon pentru \nun singur student, ceea ce încalcă principiile 1NF. \n \nTabel conform cu 1NF: \nCREATE TABLE Telefon ( \n    StudentID INT, \n    Numar V ARCHAR(15), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID) \n); \n \n \n4.3. A doua formă normală (2NF) \nReguli: \n1. Baza de date trebuie să fie în 1NF. \n2. Toate atributele necheie trebuie să depindă în întregime de cheia primară. \n \nExemplu de tabel neconform cu 2NF: \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    Profesor V ARCHAR(50), \n    PRIMARY KEY (StudentID, CursCod) \n); \n\n \nÎn acest exemplu, Profesor nu depinde de cheia compusă (StudentID, CursCod), ci doar de \nCursCod. \nTabel conform cu 2NF: \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    Profesor V ARCHAR(50) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n4.4. A treia formă normală (3NF) \nReguli: \n1. Baza de date trebuie să fie în 2NF. \n2. Nicio coloană non-cheie nu trebuie să depindă tranzitiv de cheia primară. \n \nExemplu de tabel neconform cu 3NF: \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Oras V ARCHAR(50), \n    CodPostal V ARCHAR(10) \n); \nÎn această structură, CodPostal depinde de Oras, nu de ID, ceea ce încalcă regula 3NF. \nTabel conform cu 3NF: \nCREATE TABLE Oras ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    CodPostal V ARCHAR(10) \n); \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    OrasID INT, \n    FOREIGN KEY (OrasID) REFERENCES Oras(ID) \n);', '\n', '8. ', '4. Normalizarea bazelor de date \n \n4.1. Introducere în normalizarea bazelor de date \nNormalizarea este procesul de organizare a datelor într-o bază de date pentru a minimiza \nredundanța și dependențele nedorite. Aceasta implică aplicarea mai multor forme normale (NF), \nfiecare având un set de reguli specifice care îmbunătățesc structura bazei de date. \nObiectivele normalizării: \n1. Eliminarea redundanței datelor. \n2. Îmbunătățirea integrității și consistenței bazei de date. \n3. Creșterea eficienței interogărilor și a actualizărilor datelor. \n \n \n4.2. Prima formă normală (1NF) \nReguli: \n1. Fiecare coloană trebuie să conțină doar valori atomice (nu liste sau seturi de valori). \n2. Fiecare coloană trebuie să conțină doar un singur tip de date. \n \nExemplu de tabel neconform cu 1NF: \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Telefoane V ARCHAR(100) \n); \nÎn această structură, coloana Telefoane poate conține mai multe numere de telefon pentru \nun singur student, ceea ce încalcă principiile 1NF. \n \nTabel conform cu 1NF: \nCREATE TABLE Telefon ( \n    StudentID INT, \n    Numar V ARCHAR(15), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID) \n); \n \n \n4.3. A doua formă normală (2NF) \nReguli: \n1. Baza de date trebuie să fie în 1NF. \n2. Toate atributele necheie trebuie să depindă în întregime de cheia primară. \n \nExemplu de tabel neconform cu 2NF: \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    Profesor V ARCHAR(50), \n    PRIMARY KEY (StudentID, CursCod) \n); \n\n \nÎn acest exemplu, Profesor nu depinde de cheia compusă (StudentID, CursCod), ci doar de \nCursCod. \nTabel conform cu 2NF: \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    Profesor V ARCHAR(50) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n4.4. A treia formă normală (3NF) \nReguli: \n1. Baza de date trebuie să fie în 2NF. \n2. Nicio coloană non-cheie nu trebuie să depindă tranzitiv de cheia primară. \n \nExemplu de tabel neconform cu 3NF: \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Oras V ARCHAR(50), \n    CodPostal V ARCHAR(10) \n); \nÎn această structură, CodPostal depinde de Oras, nu de ID, ceea ce încalcă regula 3NF. \nTabel conform cu 3NF: \nCREATE TABLE Oras ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    CodPostal V ARCHAR(10) \n); \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    OrasID INT, \n    FOREIGN KEY (OrasID) REFERENCES Oras(ID) \n);', '\n', '9. ', '4. Normalizarea bazelor de date \n \n4.1. Introducere în normalizarea bazelor de date \nNormalizarea este procesul de organizare a datelor într-o bază de date pentru a minimiza \nredundanța și dependențele nedorite. Aceasta implică aplicarea mai multor forme normale (NF), \nfiecare având un set de reguli specifice care îmbunătățesc structura bazei de date. \nObiectivele normalizării: \n1. Eliminarea redundanței datelor. \n2. Îmbunătățirea integrității și consistenței bazei de date. \n3. Creșterea eficienței interogărilor și a actualizărilor datelor. \n \n \n4.2. Prima formă normală (1NF) \nReguli: \n1. Fiecare coloană trebuie să conțină doar valori atomice (nu liste sau seturi de valori). \n2. Fiecare coloană trebuie să conțină doar un singur tip de date. \n \nExemplu de tabel neconform cu 1NF: \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Telefoane V ARCHAR(100) \n); \nÎn această structură, coloana Telefoane poate conține mai multe numere de telefon pentru \nun singur student, ceea ce încalcă principiile 1NF. \n \nTabel conform cu 1NF: \nCREATE TABLE Telefon ( \n    StudentID INT, \n    Numar V ARCHAR(15), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID) \n); \n \n \n4.3. A doua formă normală (2NF) \nReguli: \n1. Baza de date trebuie să fie în 1NF. \n2. Toate atributele necheie trebuie să depindă în întregime de cheia primară. \n \nExemplu de tabel neconform cu 2NF: \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    Profesor V ARCHAR(50), \n    PRIMARY KEY (StudentID, CursCod) \n); \n\n \nÎn acest exemplu, Profesor nu depinde de cheia compusă (StudentID, CursCod), ci doar de \nCursCod. \nTabel conform cu 2NF: \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    Profesor V ARCHAR(50) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n4.4. A treia formă normală (3NF) \nReguli: \n1. Baza de date trebuie să fie în 2NF. \n2. Nicio coloană non-cheie nu trebuie să depindă tranzitiv de cheia primară. \n \nExemplu de tabel neconform cu 3NF: \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Oras V ARCHAR(50), \n    CodPostal V ARCHAR(10) \n); \nÎn această structură, CodPostal depinde de Oras, nu de ID, ceea ce încalcă regula 3NF. \nTabel conform cu 3NF: \nCREATE TABLE Oras ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    CodPostal V ARCHAR(10) \n); \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    OrasID INT, \n    FOREIGN KEY (OrasID) REFERENCES Oras(ID) \n);', '\n', '10. ', '2 \n \n1.2.2. Limitări ale sistemelor tradiționale de fișiere: \n1. Redundanță și inconsistență - Aceleași date pot fi stocate în mai multe fișiere, ducând la \ninconsistențe și consum excesiv de spațiu. \n2. Lipsa integrității  - Nu există mecanisme automate pentru a asigura corectitudinea și \nvaliditatea datelor. \n3. Dificultăți în accesul la date  - Accesul la date necesită dezvoltarea de programe \npersonalizate pentru fiecare tip de interogare. \n4. Lipsa securității  - Nu există mecanisme eficiente pentru restricționarea accesului la \nanumite date. \n5. Dificultăți în partajarea datelor - Accesul simultan la fișiere de către mai mulți utilizatori \neste dificil de gestionat. \n \n1.3. Bazele de date moderne \nBazele de date elimină majoritatea acestor probleme prin utilizarea unui sistem centralizat \nde gestionare a datelor. Acestea permit accesul eficient la informații, reduc redundanța și oferă \nmecanisme avansate de securitate și integritate. \n \n1.4.Avantajele bazelor de date față de fișierele tradiționale: \n1. Eliminarea redundanței  - Datele sunt normalizate și stocate într -un mod care \nminimizează duplicările. \n2. Îmbunătățirea integrității - Se pot defini constrângeri care asigură coerența și validitatea \ndatelor. \n3. Acces flexibil la date  - Utilizatorii pot efectua interogări complexe folosind limbaje \nprecum SQL. \n4. Securitate sporită - Se pot implementa niveluri diferite de acces pentru utilizatori. \n5. Partajare eficientă a datelor - Mai mulți utilizatori pot accesa simultan baza de date fără \na afecta integritatea informațiilor. \n \n \n1.5. Componentele unui sistem de baze de date \nUn sistem de baze de date este compus din mai multe elemente esențiale care asigură \nfuncționarea și gestionarea eficientă a datelor. Aceste componente includ hardware, software, date, \nutilizatori și proceduri.  \n \n \n1. Hardware \nHardware-ul reprezintă infrastructura fizică necesară pentru \noperarea unei baze de date. Acesta include: \n✓ Servere și stații de lucru \n✓ Dispozitive de stocare (SSD, HDD, unități cloud) \n✓ Rețele de comunicație \n✓ Procesoare și memorie RAM pentru optimizarea \nperformanței', '\n']","avantajele bazelor de date față de fișierele tradiționale sunt:
1.  **Eliminarea redundanței:** Datele sunt normalizate și stocate într-un mod care minimizează duplicările.
2.  **Îmbunătățirea integrității:** Se pot defini constrângeri care asigură coerența și validitatea datelor.
3.  **Acces flexibil la date:** Utilizatorii pot efectua interogări complexe folosind limbaje precum SQL.
4.  **Securitate sporită:** Se pot implementa niveluri diferite de acces pentru utilizatori.
5.  **Partajare eficientă a datelor:** Mai mulți utilizatori pot accesa simultan baza de date fără a afecta integritatea informațiilor.
","Care sunt avantajele bazelor de date față de fișierele tradiționale, conform cursului?","['1. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '2. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '3. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '4. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '5. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '6. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '7. ', '4. Normalizarea bazelor de date \n \n4.1. Introducere în normalizarea bazelor de date \nNormalizarea este procesul de organizare a datelor într-o bază de date pentru a minimiza \nredundanța și dependențele nedorite. Aceasta implică aplicarea mai multor forme normale (NF), \nfiecare având un set de reguli specifice care îmbunătățesc structura bazei de date. \nObiectivele normalizării: \n1. Eliminarea redundanței datelor. \n2. Îmbunătățirea integrității și consistenței bazei de date. \n3. Creșterea eficienței interogărilor și a actualizărilor datelor. \n \n \n4.2. Prima formă normală (1NF) \nReguli: \n1. Fiecare coloană trebuie să conțină doar valori atomice (nu liste sau seturi de valori). \n2. Fiecare coloană trebuie să conțină doar un singur tip de date. \n \nExemplu de tabel neconform cu 1NF: \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Telefoane V ARCHAR(100) \n); \nÎn această structură, coloana Telefoane poate conține mai multe numere de telefon pentru \nun singur student, ceea ce încalcă principiile 1NF. \n \nTabel conform cu 1NF: \nCREATE TABLE Telefon ( \n    StudentID INT, \n    Numar V ARCHAR(15), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID) \n); \n \n \n4.3. A doua formă normală (2NF) \nReguli: \n1. Baza de date trebuie să fie în 1NF. \n2. Toate atributele necheie trebuie să depindă în întregime de cheia primară. \n \nExemplu de tabel neconform cu 2NF: \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    Profesor V ARCHAR(50), \n    PRIMARY KEY (StudentID, CursCod) \n); \n\n \nÎn acest exemplu, Profesor nu depinde de cheia compusă (StudentID, CursCod), ci doar de \nCursCod. \nTabel conform cu 2NF: \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    Profesor V ARCHAR(50) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n4.4. A treia formă normală (3NF) \nReguli: \n1. Baza de date trebuie să fie în 2NF. \n2. Nicio coloană non-cheie nu trebuie să depindă tranzitiv de cheia primară. \n \nExemplu de tabel neconform cu 3NF: \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Oras V ARCHAR(50), \n    CodPostal V ARCHAR(10) \n); \nÎn această structură, CodPostal depinde de Oras, nu de ID, ceea ce încalcă regula 3NF. \nTabel conform cu 3NF: \nCREATE TABLE Oras ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    CodPostal V ARCHAR(10) \n); \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    OrasID INT, \n    FOREIGN KEY (OrasID) REFERENCES Oras(ID) \n);', '\n', '8. ', '4. Normalizarea bazelor de date \n \n4.1. Introducere în normalizarea bazelor de date \nNormalizarea este procesul de organizare a datelor într-o bază de date pentru a minimiza \nredundanța și dependențele nedorite. Aceasta implică aplicarea mai multor forme normale (NF), \nfiecare având un set de reguli specifice care îmbunătățesc structura bazei de date. \nObiectivele normalizării: \n1. Eliminarea redundanței datelor. \n2. Îmbunătățirea integrității și consistenței bazei de date. \n3. Creșterea eficienței interogărilor și a actualizărilor datelor. \n \n \n4.2. Prima formă normală (1NF) \nReguli: \n1. Fiecare coloană trebuie să conțină doar valori atomice (nu liste sau seturi de valori). \n2. Fiecare coloană trebuie să conțină doar un singur tip de date. \n \nExemplu de tabel neconform cu 1NF: \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Telefoane V ARCHAR(100) \n); \nÎn această structură, coloana Telefoane poate conține mai multe numere de telefon pentru \nun singur student, ceea ce încalcă principiile 1NF. \n \nTabel conform cu 1NF: \nCREATE TABLE Telefon ( \n    StudentID INT, \n    Numar V ARCHAR(15), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID) \n); \n \n \n4.3. A doua formă normală (2NF) \nReguli: \n1. Baza de date trebuie să fie în 1NF. \n2. Toate atributele necheie trebuie să depindă în întregime de cheia primară. \n \nExemplu de tabel neconform cu 2NF: \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    Profesor V ARCHAR(50), \n    PRIMARY KEY (StudentID, CursCod) \n); \n\n \nÎn acest exemplu, Profesor nu depinde de cheia compusă (StudentID, CursCod), ci doar de \nCursCod. \nTabel conform cu 2NF: \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    Profesor V ARCHAR(50) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n4.4. A treia formă normală (3NF) \nReguli: \n1. Baza de date trebuie să fie în 2NF. \n2. Nicio coloană non-cheie nu trebuie să depindă tranzitiv de cheia primară. \n \nExemplu de tabel neconform cu 3NF: \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Oras V ARCHAR(50), \n    CodPostal V ARCHAR(10) \n); \nÎn această structură, CodPostal depinde de Oras, nu de ID, ceea ce încalcă regula 3NF. \nTabel conform cu 3NF: \nCREATE TABLE Oras ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    CodPostal V ARCHAR(10) \n); \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    OrasID INT, \n    FOREIGN KEY (OrasID) REFERENCES Oras(ID) \n);', '\n', '9. ', '4. Normalizarea bazelor de date \n \n4.1. Introducere în normalizarea bazelor de date \nNormalizarea este procesul de organizare a datelor într-o bază de date pentru a minimiza \nredundanța și dependențele nedorite. Aceasta implică aplicarea mai multor forme normale (NF), \nfiecare având un set de reguli specifice care îmbunătățesc structura bazei de date. \nObiectivele normalizării: \n1. Eliminarea redundanței datelor. \n2. Îmbunătățirea integrității și consistenței bazei de date. \n3. Creșterea eficienței interogărilor și a actualizărilor datelor. \n \n \n4.2. Prima formă normală (1NF) \nReguli: \n1. Fiecare coloană trebuie să conțină doar valori atomice (nu liste sau seturi de valori). \n2. Fiecare coloană trebuie să conțină doar un singur tip de date. \n \nExemplu de tabel neconform cu 1NF: \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Telefoane V ARCHAR(100) \n); \nÎn această structură, coloana Telefoane poate conține mai multe numere de telefon pentru \nun singur student, ceea ce încalcă principiile 1NF. \n \nTabel conform cu 1NF: \nCREATE TABLE Telefon ( \n    StudentID INT, \n    Numar V ARCHAR(15), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID) \n); \n \n \n4.3. A doua formă normală (2NF) \nReguli: \n1. Baza de date trebuie să fie în 1NF. \n2. Toate atributele necheie trebuie să depindă în întregime de cheia primară. \n \nExemplu de tabel neconform cu 2NF: \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    Profesor V ARCHAR(50), \n    PRIMARY KEY (StudentID, CursCod) \n); \n\n \nÎn acest exemplu, Profesor nu depinde de cheia compusă (StudentID, CursCod), ci doar de \nCursCod. \nTabel conform cu 2NF: \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    Profesor V ARCHAR(50) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n4.4. A treia formă normală (3NF) \nReguli: \n1. Baza de date trebuie să fie în 2NF. \n2. Nicio coloană non-cheie nu trebuie să depindă tranzitiv de cheia primară. \n \nExemplu de tabel neconform cu 3NF: \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Oras V ARCHAR(50), \n    CodPostal V ARCHAR(10) \n); \nÎn această structură, CodPostal depinde de Oras, nu de ID, ceea ce încalcă regula 3NF. \nTabel conform cu 3NF: \nCREATE TABLE Oras ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    CodPostal V ARCHAR(10) \n); \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    OrasID INT, \n    FOREIGN KEY (OrasID) REFERENCES Oras(ID) \n);', '\n', '10. ', '2 \n \n1.2.2. Limitări ale sistemelor tradiționale de fișiere: \n1. Redundanță și inconsistență - Aceleași date pot fi stocate în mai multe fișiere, ducând la \ninconsistențe și consum excesiv de spațiu. \n2. Lipsa integrității  - Nu există mecanisme automate pentru a asigura corectitudinea și \nvaliditatea datelor. \n3. Dificultăți în accesul la date  - Accesul la date necesită dezvoltarea de programe \npersonalizate pentru fiecare tip de interogare. \n4. Lipsa securității  - Nu există mecanisme eficiente pentru restricționarea accesului la \nanumite date. \n5. Dificultăți în partajarea datelor - Accesul simultan la fișiere de către mai mulți utilizatori \neste dificil de gestionat. \n \n1.3. Bazele de date moderne \nBazele de date elimină majoritatea acestor probleme prin utilizarea unui sistem centralizat \nde gestionare a datelor. Acestea permit accesul eficient la informații, reduc redundanța și oferă \nmecanisme avansate de securitate și integritate. \n \n1.4.Avantajele bazelor de date față de fișierele tradiționale: \n1. Eliminarea redundanței  - Datele sunt normalizate și stocate într -un mod care \nminimizează duplicările. \n2. Îmbunătățirea integrității - Se pot defini constrângeri care asigură coerența și validitatea \ndatelor. \n3. Acces flexibil la date  - Utilizatorii pot efectua interogări complexe folosind limbaje \nprecum SQL. \n4. Securitate sporită - Se pot implementa niveluri diferite de acces pentru utilizatori. \n5. Partajare eficientă a datelor - Mai mulți utilizatori pot accesa simultan baza de date fără \na afecta integritatea informațiilor. \n \n \n1.5. Componentele unui sistem de baze de date \nUn sistem de baze de date este compus din mai multe elemente esențiale care asigură \nfuncționarea și gestionarea eficientă a datelor. Aceste componente includ hardware, software, date, \nutilizatori și proceduri.  \n \n \n1. Hardware \nHardware-ul reprezintă infrastructura fizică necesară pentru \noperarea unei baze de date. Acesta include: \n✓ Servere și stații de lucru \n✓ Dispozitive de stocare (SSD, HDD, unități cloud) \n✓ Rețele de comunicație \n✓ Procesoare și memorie RAM pentru optimizarea \nperformanței', '\n']","avantajele bazelor de date față de fișierele tradiționale sunt:
1.  **Eliminarea redundanței:** Datele sunt normalizate și stocate într-un mod care minimizează duplicările.
2.  **Îmbunătățirea integrității:** Se pot defini constrângeri care asigură coerența și validitatea datelor.
3.  **Acces flexibil la date:** Utilizatorii pot efectua interogări complexe folosind limbaje precum SQL.
4.  **Securitate sporită:** Se pot implementa niveluri diferite de acces pentru utilizatori.
5.  **Partajare eficientă a datelor:** Mai mulți utilizatori pot accesa simultan baza de date fără a afecta integritatea informațiilor.
","Avantajele: elimină redundanța, îmbunătățesc integritatea, oferă acces flexibil și securitate sporită.",0.3532327586118588,1.0,0.8853373652848862,1.0,0.026052442434962207,0.14814814814814814,0.89
26,O3mini-high,Medium,Curs 13,,"Ce caracteristici are modelul relațional de baze de date, conform cursului?","Modelul relațional organizează datele în tabele, utilizează chei primare și străine pentru integritate și oferă independența datelor față de aplicații.",Este corect,pagina 1,"['1. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '2. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '3. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '4. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '5. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '6. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '7. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '8. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '9. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '10. ', ""Curs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n\n2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n);"", '\n']","principalele caracteristici ale modelului relațional sunt:

*   Datele sunt organizate în tabele bidimensionale (relații).
*   Fiecare înregistrare (tuplă) este identificată unic printr-o cheie primară.
*   Relațiile dintre tabele sunt definite prin chei străine.
*   Datele sunt independente de aplicațiile care le folosesc.
*   Se utilizează limbajul SQL, standardizat pentru interogarea bazei de date.
","Ce caracteristici are modelul relațional de baze de date, conform cursului?","['1. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '2. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '3. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '4. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '5. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '6. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '7. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '8. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '9. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '10. ', ""Curs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n\n2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n);"", '\n']","principalele caracteristici ale modelului relațional sunt:

*   Datele sunt organizate în tabele bidimensionale (relații).
*   Fiecare înregistrare (tuplă) este identificată unic printr-o cheie primară.
*   Relațiile dintre tabele sunt definite prin chei străine.
*   Datele sunt independente de aplicațiile care le folosesc.
*   Se utilizează limbajul SQL, standardizat pentru interogarea bazei de date.
","Modelul relațional organizează datele în tabele, utilizează chei primare și străine pentru integritate și oferă independența datelor față de aplicații.",0.37001424393680504,1.0,0.9213622639437457,1.0,0.01692064801271104,0.2564102564102564,0.89
27,O3mini-high,Medium,Curs 14,,"Care sunt etapele proiectării bazelor de date relaționale, potrivit cursului?","Etapele sunt: 1. Identificarea cerințelor, 2. Modelarea conceptuală, 3. Modelarea logică, 4. Modelarea fizică, 5. Normalizarea.",Este corect,pagina 1,"['1. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '2. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '3. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '4. ', ""Curs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n\n2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n);"", '\n', '5. ', ""Curs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n\n2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n);"", '\n', '6. ', ""Curs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n\n2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n);"", '\n', '7. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '8. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '9. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '10. ', 'Introducere\nCursul de Baze de date adresează studenţilor înscrişi \nla programul de studii Automatică şi Informatică \nAplicată, organizat de facultatea de Inginerie, anul \n2, semestrul 2.\nObiectivul general al disciplinei al cursului de Baze de \ndate vizează pregătirea studenţilor în domeniul \nutilizării bazelor de date în diferite domenii tehnice.\nSe va avea in vedere insuşirea noţiunilor care stau la \nbaza analizei, proiectării şi implementării unei \naplicaţii cu baze de date. \n 10\n\n\nIntroducere\nObiectivele specifice:\nCurs: \n✓ Cunoaşterea noţiunilor privind bazele de date relaţionale\n✓ Modele de reprezentare a bazelor de date relaţionale\n✓ Arhitectura bazelor de date relaţionale\n✓ Analiza, implementarea şi prelucrarea bazelor de date cu \najutorul sistemului de gestiune a bazelor de date ORACLE \nDATABASE\nLaborator: \n✓ Se vor cunoaşte toate elementele de utilizare a unui sistem de \ngestiune a bazelor de date SQL (Structured Query Language)\n✓ Realizarea unor aplicatii de gestiune a bazelor de date in APEX\n(Application Express)\n 11\n\nIntroducere\n➢Pentru o bună înţelegere a noţiunilor teoretice şi \npractice prezentate în acest curs, este necesară \nparcurgerea anterioară a disciplinelor Programarea \ncalculatoarelor, Proiectarea algoritmilor si \nProgramare orientate pe obiecte.\n➢Cursul de Baze de date este structurat în 13 cursuri \n(capitole), fiecare dintre acestea cuprinzând câte \nun număr de 13 laboratoare (activităţi practice) la \ncare prezenţa va fi obligatorie.\n 12\n\nConţinutul cursului\nÎn cadrul acestui curs se vor studia bazele de \ndate prelucrate cu ajutorul sistemului de \ngestiune a bazelor de date\nORACLE Database 12c Express Edition\n 13\n\nConţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\n 14\n\n\nCapitolele cursului\n1. Sisteme de baze de date. Modelul de date relaţional. \nModelul de date orientate obiect.\n2. Evoluţia şi facilităţile sistemului ORACLE. Arhitectura \nsistemului ORACLE. ORACLE SERVER. Oracle Database 11g \nExpress Edition\n3. Limbajul SQL. Introducere. Prezentare generală. Cereri \nSELECT pe o tabelă\n4. Cereri SELECT pe o tabelă. Clauza WHERE. Clauza \nORDER BY\n5. Funcţii. Funcţii referitoare la o singură înregistrare\n6. Funcţii referitoare la mai multe înregistrări (Funcţii de \ngrup). Clauza GROUP BY . Excluderea grupurilor (clauza \nHAVING). Imbricarea funcţiilor de grup 15\n\nCapitolele cursului\n7. SUBQUERIES (Subinterogări). SINGLE ROW \nSUBQUERIES. MULTIPLE ROW SUBQUERIES\n8. Cereri din mai multe tabele (JOIN-uri). JOIN-urile \nproprietatea ORACLE\n9. Cereri din mai multe tabele (JOIN-uri). JOIN-urile \nANSI/ISO SQL99. Operatorii pe mulţimi\n10. Limbajul de manipulare al datelor (LMD). \nTranzacţii(Transactions)\n11. Constrângeri(Constrains)\n12. Vederi (Views)\n13. Alte obiecte din baza de date. Gestiunea \nutilizatorilor\n 16', '\n']","etapele proiectării bazelor de date relaționale sunt:

1.  **Identificarea cerințelor** - Colectarea cerințelor utilizatorilor și analiza acestora.
2.  **Modelarea conceptuală** - Crearea unui model abstract al bazei de date folosind diagrame ER (Entity-Relationship).
3.  **Modelarea logică** - Transformarea modelului conceptual într-un model relațional.
4.  **Modelarea fizică** - Optimizarea modelului logic pentru implementare în SGBD.
5.  **Normalizarea** - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea datelor.
","Care sunt etapele proiectării bazelor de date relaționale, potrivit cursului?","['1. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '2. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '3. ', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile primare(identificatorii unici) sunt:\n➢în tabela GRUPE – codgr\n➢în tabela STUDENTI – codst\n➢în tabela DISCIPLINE – codob\n➢în tabela PROFESORI - codprof\n➢în tabela INCADRARE – atributul compus –\ncodgr+codob+codprof\n 55\n\nConcepte de bază din teoria relațională a bazelor de \ndate\nCheile străine sunt:\n➢atributul GRUPE.codgr pentru tabela \nSTUDENTI (refera tabela GRUPE)\n➢atributul INCADRARE.codob pentru tabela \nINCADRARE (refera tabela DISCIPLINE)\n➢atributul INCADRARE.codgr pentru tabela \nINCADRARE (refera tabela GRUPE)\n➢atributul INCADRARE.codprof pentru tabela \nINCADRARE (refera tabela PROFESORI).\n 56\n\nConcepte de bază din teoria relațională a bazelor de \ndate\n 57\n\n\nInterogarea bazelor de date - \nLimbajul SQL \n58\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59\n\nLimbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60\n\n2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61\n\nLimbajul SQL\n2. Limbajul de manipulare a datelor (LMD) permite \nmodificarea conţinutului tabelelor. \nComenzile utilizate sunt:\n1. INSERT – pentru adăugarea de noi linii într-o tabelă\n2. UPDATE – pentru modificarea valorilor memorate \nîntr-o tabelă\n3. DELETE – pentru ştergerea liniilor dintr-o tabelă\n62', '\n', '4. ', ""Curs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n\n2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n);"", '\n', '5. ', ""Curs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n\n2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n);"", '\n', '6. ', ""Curs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n\n2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n);"", '\n', '7. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '8. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '9. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '10. ', 'Introducere\nCursul de Baze de date adresează studenţilor înscrişi \nla programul de studii Automatică şi Informatică \nAplicată, organizat de facultatea de Inginerie, anul \n2, semestrul 2.\nObiectivul general al disciplinei al cursului de Baze de \ndate vizează pregătirea studenţilor în domeniul \nutilizării bazelor de date în diferite domenii tehnice.\nSe va avea in vedere insuşirea noţiunilor care stau la \nbaza analizei, proiectării şi implementării unei \naplicaţii cu baze de date. \n 10\n\n\nIntroducere\nObiectivele specifice:\nCurs: \n✓ Cunoaşterea noţiunilor privind bazele de date relaţionale\n✓ Modele de reprezentare a bazelor de date relaţionale\n✓ Arhitectura bazelor de date relaţionale\n✓ Analiza, implementarea şi prelucrarea bazelor de date cu \najutorul sistemului de gestiune a bazelor de date ORACLE \nDATABASE\nLaborator: \n✓ Se vor cunoaşte toate elementele de utilizare a unui sistem de \ngestiune a bazelor de date SQL (Structured Query Language)\n✓ Realizarea unor aplicatii de gestiune a bazelor de date in APEX\n(Application Express)\n 11\n\nIntroducere\n➢Pentru o bună înţelegere a noţiunilor teoretice şi \npractice prezentate în acest curs, este necesară \nparcurgerea anterioară a disciplinelor Programarea \ncalculatoarelor, Proiectarea algoritmilor si \nProgramare orientate pe obiecte.\n➢Cursul de Baze de date este structurat în 13 cursuri \n(capitole), fiecare dintre acestea cuprinzând câte \nun număr de 13 laboratoare (activităţi practice) la \ncare prezenţa va fi obligatorie.\n 12\n\nConţinutul cursului\nÎn cadrul acestui curs se vor studia bazele de \ndate prelucrate cu ajutorul sistemului de \ngestiune a bazelor de date\nORACLE Database 12c Express Edition\n 13\n\nConţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\n 14\n\n\nCapitolele cursului\n1. Sisteme de baze de date. Modelul de date relaţional. \nModelul de date orientate obiect.\n2. Evoluţia şi facilităţile sistemului ORACLE. Arhitectura \nsistemului ORACLE. ORACLE SERVER. Oracle Database 11g \nExpress Edition\n3. Limbajul SQL. Introducere. Prezentare generală. Cereri \nSELECT pe o tabelă\n4. Cereri SELECT pe o tabelă. Clauza WHERE. Clauza \nORDER BY\n5. Funcţii. Funcţii referitoare la o singură înregistrare\n6. Funcţii referitoare la mai multe înregistrări (Funcţii de \ngrup). Clauza GROUP BY . Excluderea grupurilor (clauza \nHAVING). Imbricarea funcţiilor de grup 15\n\nCapitolele cursului\n7. SUBQUERIES (Subinterogări). SINGLE ROW \nSUBQUERIES. MULTIPLE ROW SUBQUERIES\n8. Cereri din mai multe tabele (JOIN-uri). JOIN-urile \nproprietatea ORACLE\n9. Cereri din mai multe tabele (JOIN-uri). JOIN-urile \nANSI/ISO SQL99. Operatorii pe mulţimi\n10. Limbajul de manipulare al datelor (LMD). \nTranzacţii(Transactions)\n11. Constrângeri(Constrains)\n12. Vederi (Views)\n13. Alte obiecte din baza de date. Gestiunea \nutilizatorilor\n 16', '\n']","etapele proiectării bazelor de date relaționale sunt:

1.  **Identificarea cerințelor** - Colectarea cerințelor utilizatorilor și analiza acestora.
2.  **Modelarea conceptuală** - Crearea unui model abstract al bazei de date folosind diagrame ER (Entity-Relationship).
3.  **Modelarea logică** - Transformarea modelului conceptual într-un model relațional.
4.  **Modelarea fizică** - Optimizarea modelului logic pentru implementare în SGBD.
5.  **Normalizarea** - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea datelor.
","Etapele sunt: 1. Identificarea cerințelor, 2. Modelarea conceptuală, 3. Modelarea logică, 4. Modelarea fizică, 5. Normalizarea.",0.13674560732928445,1.0,0.8590866576154257,1.0,0.17747405280050266,0.3908045977011494,0.67
28,O3mini-high,High,"C1, C13",C12,"Comparați modelul relațional cu celelalte modele de baze de date, evidențiind avantajele fundamentale.","Modelul relațional organizează datele în tabele, folosind chei primare și străine pentru integritate și independența datelor” – spre deosebire de modelele ierarhice sau de rețea, care sunt mai rigide.",Partial corect,C12,"['1. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '2. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '3. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '4. ', ""Curs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n\n2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n);"", '\n', '5. ', ""Curs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n\n2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n);"", '\n', '6. ', ""Curs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n\n2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n);"", '\n', '7. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '8. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '9. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '10. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n']","modelul relațional organizează datele în tabele (relații) cu atribute și tuple, utilizând chei primare și străine pentru a defini relațiile, asigurând integritatea datelor. Avantajele includ: organizarea datelor în tabele bidimensionale, utilizarea SQL ca limbaj standardizat, independența datelor față de aplicații. Alte modele, precum cel ierarhic (structură arborescentă) și cel rețea (relații multiple), sunt mai puțin flexibile și mai complexe.
","Comparați modelul relațional cu celelalte modele de baze de date, evidențiind avantajele fundamentale.","['1. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '2. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '3. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '4. ', ""Curs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n\n2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n);"", '\n', '5. ', ""Curs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n\n2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n);"", '\n', '6. ', ""Curs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n\n2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n);"", '\n', '7. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '8. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '9. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '10. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n']","modelul relațional organizează datele în tabele (relații) cu atribute și tuple, utilizând chei primare și străine pentru a defini relațiile, asigurând integritatea datelor. Avantajele includ: organizarea datelor în tabele bidimensionale, utilizarea SQL ca limbaj standardizat, independența datelor față de aplicații. Alte modele, precum cel ierarhic (structură arborescentă) și cel rețea (relații multiple), sunt mai puțin flexibile și mai complexe.
","Modelul relațional organizează datele în tabele, folosind chei primare și străine pentru integritate și independența datelor” – spre deosebire de modelele ierarhice sau de rețea, care sunt mai rigide.",0.3624431195351285,1.0,0.8279681834172177,1.0,0.23054948188696833,0.4117647058823529,0.18
29,O3mini-high,High,"C2, C12",C1,Explicați evoluția SGBD-ului Oracle și diferențele față de alte tipuri de baze de date moderne.,"Oracle este un SGBD complet relațional, extins, cu facilități din tehnologia orientată obiect” și a evoluat de la arhitectura client/server la NC, integrând tehnici cloud și inovații pentru performanță și flexibilitate.",Este corect,C2,"['1. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '2. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '3. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '4. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nOracle 9i REAL APPLICATION CLUSTERS (RAC) se bazează pe \no nouă arhitectură de BD numită îmbinare ascunsă (Cache \nFusion). \n✓Aceasta este o nouă generaţie de tehnologie de clustere. \n✓Conform acestei arhitecturi la adăugarea unui calculator \nîntr-o reţea cu BD Oracle, clusterele se adaptează automat \nla noile resurse, fără să fie necesară redistribuirea datelor \nsau rescrierea aplicaţiei.\n✓Posibilitatea apariţiei unei erori la o configuraţie cu 12 \ncalculatoare sub Oracle 9i RAC este foarte mică, estimată \nca durată în timp la cca 100.000 de ani. \n17\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oracle 9i DEVELOPER SUITE este un mediu \ncomplet pentru dezvoltarea aplicaţiilor tip \nafaceri electronice (e-business) şi tip Web. \nEl se bazează pe tehnologiile Java şi XML şi permite \npersonalizarea (Oracle Personalization). \n• În anul 2003 a fost lansată versiunea Oracle 10g \ncare adaugă noi facilităţi sistemului Oracle 9i. \n19\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În anul 2007 a fost lansată versiunea Oracle \n11g care are cateva facilitati in plus:\n– Gestioneaza datele mai eficient prin compresii \navansate si partitionari \n– Simplifica sistemele prin stocarea tuturor datelor in \nOracle Database cu Oracle SecureFiles\n• În anul 2013 a fost lansată versiunea Oracle \n12c\n20\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle Database 12c prezintă o arhitectură nouă, cu \nmai multe entităţi găzduite, care permite unificarea \nrapidă a mai multor baze de date şi gestionarea \nacestora ca serviciu cloud. \n➢Oracle Database 12c include, de asemenea, capacităţi \nde procesare a datelor în memorie, care oferă o \nperformanţă analitică inovatoare. \n➢Inovaţiile suplimentare pentru baze de date oferă noi \nnivele de eficienţă, performanţă, securitate şi \ndisponibilitate.[*]\n21[*] https://www.oracle.com/ro/database/index.html\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', '\n', '5. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nOracle 9i REAL APPLICATION CLUSTERS (RAC) se bazează pe \no nouă arhitectură de BD numită îmbinare ascunsă (Cache \nFusion). \n✓Aceasta este o nouă generaţie de tehnologie de clustere. \n✓Conform acestei arhitecturi la adăugarea unui calculator \nîntr-o reţea cu BD Oracle, clusterele se adaptează automat \nla noile resurse, fără să fie necesară redistribuirea datelor \nsau rescrierea aplicaţiei.\n✓Posibilitatea apariţiei unei erori la o configuraţie cu 12 \ncalculatoare sub Oracle 9i RAC este foarte mică, estimată \nca durată în timp la cca 100.000 de ani. \n17\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oracle 9i DEVELOPER SUITE este un mediu \ncomplet pentru dezvoltarea aplicaţiilor tip \nafaceri electronice (e-business) şi tip Web. \nEl se bazează pe tehnologiile Java şi XML şi permite \npersonalizarea (Oracle Personalization). \n• În anul 2003 a fost lansată versiunea Oracle 10g \ncare adaugă noi facilităţi sistemului Oracle 9i. \n19\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În anul 2007 a fost lansată versiunea Oracle \n11g care are cateva facilitati in plus:\n– Gestioneaza datele mai eficient prin compresii \navansate si partitionari \n– Simplifica sistemele prin stocarea tuturor datelor in \nOracle Database cu Oracle SecureFiles\n• În anul 2013 a fost lansată versiunea Oracle \n12c\n20\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle Database 12c prezintă o arhitectură nouă, cu \nmai multe entităţi găzduite, care permite unificarea \nrapidă a mai multor baze de date şi gestionarea \nacestora ca serviciu cloud. \n➢Oracle Database 12c include, de asemenea, capacităţi \nde procesare a datelor în memorie, care oferă o \nperformanţă analitică inovatoare. \n➢Inovaţiile suplimentare pentru baze de date oferă noi \nnivele de eficienţă, performanţă, securitate şi \ndisponibilitate.[*]\n21[*] https://www.oracle.com/ro/database/index.html\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', '\n', '6. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nOracle 9i REAL APPLICATION CLUSTERS (RAC) se bazează pe \no nouă arhitectură de BD numită îmbinare ascunsă (Cache \nFusion). \n✓Aceasta este o nouă generaţie de tehnologie de clustere. \n✓Conform acestei arhitecturi la adăugarea unui calculator \nîntr-o reţea cu BD Oracle, clusterele se adaptează automat \nla noile resurse, fără să fie necesară redistribuirea datelor \nsau rescrierea aplicaţiei.\n✓Posibilitatea apariţiei unei erori la o configuraţie cu 12 \ncalculatoare sub Oracle 9i RAC este foarte mică, estimată \nca durată în timp la cca 100.000 de ani. \n17\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oracle 9i DEVELOPER SUITE este un mediu \ncomplet pentru dezvoltarea aplicaţiilor tip \nafaceri electronice (e-business) şi tip Web. \nEl se bazează pe tehnologiile Java şi XML şi permite \npersonalizarea (Oracle Personalization). \n• În anul 2003 a fost lansată versiunea Oracle 10g \ncare adaugă noi facilităţi sistemului Oracle 9i. \n19\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În anul 2007 a fost lansată versiunea Oracle \n11g care are cateva facilitati in plus:\n– Gestioneaza datele mai eficient prin compresii \navansate si partitionari \n– Simplifica sistemele prin stocarea tuturor datelor in \nOracle Database cu Oracle SecureFiles\n• În anul 2013 a fost lansată versiunea Oracle \n12c\n20\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle Database 12c prezintă o arhitectură nouă, cu \nmai multe entităţi găzduite, care permite unificarea \nrapidă a mai multor baze de date şi gestionarea \nacestora ca serviciu cloud. \n➢Oracle Database 12c include, de asemenea, capacităţi \nde procesare a datelor în memorie, care oferă o \nperformanţă analitică inovatoare. \n➢Inovaţiile suplimentare pentru baze de date oferă noi \nnivele de eficienţă, performanţă, securitate şi \ndisponibilitate.[*]\n21[*] https://www.oracle.com/ro/database/index.html\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', '\n', '7. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32\n\n2.3. ORACLE Server\n ORACLE Server (OS) permite \nmanagementul informaţiilor organizate în baze \nde date, astfel încât se asigură accesul mai \nmultor utilizatori în mod concurenţial la acelaşi \ndate, oferind facilităţi de prevenire a accesului \nneautorizat şi de restaurare a datelor după \nproducerea unor erori. \n33\n\n2.3. ORACLE Server\nORACLE Server este un sistem relaţional-\nobiectual de management a bazelor de date, \ncare permite o abordare deschisă, integrată şi \ncuprinzătoare a managementului \ninformaţiilor. \nOS constă dintr-un cuplu format dintr-o \nbază de date şi o instanţă Oracle.\n34\n\n2.3. ORACLE Server\nA. O bază de date Oracle este o colecţie \nunitară de date, având o structură logică şi \nuna fizică putând avea două stări: \n1. open (accesibilă) \n2. close (inaccesibilă)\n35\n\n2.3. ORACLE Server\n1) Structura logică a unei baze de date este \nformată din:\n✓tabelele spaţiu (tablespaces)\n✓schema de obiectelor bazei de date\n✓blocurile de date\n✓extensiile\n✓segmentele\n36\n\n2.3. ORACLE Server\n2) Structura fizică este definită de un set de \nfişiere specifice sistemului de operare pe care \nrezidă SGBD Oracle, folosite pentru memorarea \nstructurilor logice ale bazei de date şi pentru \npăstrarea unor informaţii tehnice de control. \nAceste fişiere sunt: \n- fişiere de date (Data files)\n- fişiere Redo log (Redo Log files) \n- fişiere de control (Control files)\n37\n\n2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n39\n\n2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40\n\n2.4. ORACLE Database 11g Expres Edition\n Pe calculatorul personal este ideal sa se \ninstaleze fisierul: \nOracle Database 11g Express Edition \n(Universal)  OracleXE112_Win32.zip\n41\n\n2.4. ORACLE Database 11g Expres Edition\nPas 1: Se porneste instalarea fisierului executabil si se vor \nurma pasii indicati de catre programul de instalare.\n42\n\n2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43\n\n2.4. ORACLE Database 11g Expres Edition\nInstalarea aplicatiei\n 44', '\n', '8. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32\n\n2.3. ORACLE Server\n ORACLE Server (OS) permite \nmanagementul informaţiilor organizate în baze \nde date, astfel încât se asigură accesul mai \nmultor utilizatori în mod concurenţial la acelaşi \ndate, oferind facilităţi de prevenire a accesului \nneautorizat şi de restaurare a datelor după \nproducerea unor erori. \n33\n\n2.3. ORACLE Server\nORACLE Server este un sistem relaţional-\nobiectual de management a bazelor de date, \ncare permite o abordare deschisă, integrată şi \ncuprinzătoare a managementului \ninformaţiilor. \nOS constă dintr-un cuplu format dintr-o \nbază de date şi o instanţă Oracle.\n34\n\n2.3. ORACLE Server\nA. O bază de date Oracle este o colecţie \nunitară de date, având o structură logică şi \nuna fizică putând avea două stări: \n1. open (accesibilă) \n2. close (inaccesibilă)\n35\n\n2.3. ORACLE Server\n1) Structura logică a unei baze de date este \nformată din:\n✓tabelele spaţiu (tablespaces)\n✓schema de obiectelor bazei de date\n✓blocurile de date\n✓extensiile\n✓segmentele\n36\n\n2.3. ORACLE Server\n2) Structura fizică este definită de un set de \nfişiere specifice sistemului de operare pe care \nrezidă SGBD Oracle, folosite pentru memorarea \nstructurilor logice ale bazei de date şi pentru \npăstrarea unor informaţii tehnice de control. \nAceste fişiere sunt: \n- fişiere de date (Data files)\n- fişiere Redo log (Redo Log files) \n- fişiere de control (Control files)\n37\n\n2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n39\n\n2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40\n\n2.4. ORACLE Database 11g Expres Edition\n Pe calculatorul personal este ideal sa se \ninstaleze fisierul: \nOracle Database 11g Express Edition \n(Universal)  OracleXE112_Win32.zip\n41\n\n2.4. ORACLE Database 11g Expres Edition\nPas 1: Se porneste instalarea fisierului executabil si se vor \nurma pasii indicati de catre programul de instalare.\n42\n\n2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43\n\n2.4. ORACLE Database 11g Expres Edition\nInstalarea aplicatiei\n 44', '\n', '9. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32\n\n2.3. ORACLE Server\n ORACLE Server (OS) permite \nmanagementul informaţiilor organizate în baze \nde date, astfel încât se asigură accesul mai \nmultor utilizatori în mod concurenţial la acelaşi \ndate, oferind facilităţi de prevenire a accesului \nneautorizat şi de restaurare a datelor după \nproducerea unor erori. \n33\n\n2.3. ORACLE Server\nORACLE Server este un sistem relaţional-\nobiectual de management a bazelor de date, \ncare permite o abordare deschisă, integrată şi \ncuprinzătoare a managementului \ninformaţiilor. \nOS constă dintr-un cuplu format dintr-o \nbază de date şi o instanţă Oracle.\n34\n\n2.3. ORACLE Server\nA. O bază de date Oracle este o colecţie \nunitară de date, având o structură logică şi \nuna fizică putând avea două stări: \n1. open (accesibilă) \n2. close (inaccesibilă)\n35\n\n2.3. ORACLE Server\n1) Structura logică a unei baze de date este \nformată din:\n✓tabelele spaţiu (tablespaces)\n✓schema de obiectelor bazei de date\n✓blocurile de date\n✓extensiile\n✓segmentele\n36\n\n2.3. ORACLE Server\n2) Structura fizică este definită de un set de \nfişiere specifice sistemului de operare pe care \nrezidă SGBD Oracle, folosite pentru memorarea \nstructurilor logice ale bazei de date şi pentru \npăstrarea unor informaţii tehnice de control. \nAceste fişiere sunt: \n- fişiere de date (Data files)\n- fişiere Redo log (Redo Log files) \n- fişiere de control (Control files)\n37\n\n2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n39\n\n2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40\n\n2.4. ORACLE Database 11g Expres Edition\n Pe calculatorul personal este ideal sa se \ninstaleze fisierul: \nOracle Database 11g Express Edition \n(Universal)  OracleXE112_Win32.zip\n41\n\n2.4. ORACLE Database 11g Expres Edition\nPas 1: Se porneste instalarea fisierului executabil si se vor \nurma pasii indicati de catre programul de instalare.\n42\n\n2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43\n\n2.4. ORACLE Database 11g Expres Edition\nInstalarea aplicatiei\n 44', '\n', '10. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n']","Oracle este un sistem de gestiune a bazelor de date (SGBD) relațional, dezvoltat de Oracle Corporation din 1977. A evoluat de la prima versiune bazată pe teoria relațională, implementând limbajul SQL, la versiuni care includ arhitectura client/server (versiunea 5.0), arhitectura NC (Network Computing) (versiunile 8.0 și 8i), și funcționalități cloud (versiunea 12c). Versiunile recente (9i, 10g, 11g, 12c) au adăugat îmbunătățiri precum protecție automată, tehnologia de clustere Cache Fusion, compresie avansată, și procesare a datelor în memorie. Arhitectura Oracle este structurată pe trei niveluri: nucleul (limbajele SQL și PL/SQL), interfețele (pentru dezvoltarea aplicațiilor) și instrumentele de întreținere.
",Explicați evoluția SGBD-ului Oracle și diferențele față de alte tipuri de baze de date moderne.,"['1. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '2. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '3. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '4. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nOracle 9i REAL APPLICATION CLUSTERS (RAC) se bazează pe \no nouă arhitectură de BD numită îmbinare ascunsă (Cache \nFusion). \n✓Aceasta este o nouă generaţie de tehnologie de clustere. \n✓Conform acestei arhitecturi la adăugarea unui calculator \nîntr-o reţea cu BD Oracle, clusterele se adaptează automat \nla noile resurse, fără să fie necesară redistribuirea datelor \nsau rescrierea aplicaţiei.\n✓Posibilitatea apariţiei unei erori la o configuraţie cu 12 \ncalculatoare sub Oracle 9i RAC este foarte mică, estimată \nca durată în timp la cca 100.000 de ani. \n17\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oracle 9i DEVELOPER SUITE este un mediu \ncomplet pentru dezvoltarea aplicaţiilor tip \nafaceri electronice (e-business) şi tip Web. \nEl se bazează pe tehnologiile Java şi XML şi permite \npersonalizarea (Oracle Personalization). \n• În anul 2003 a fost lansată versiunea Oracle 10g \ncare adaugă noi facilităţi sistemului Oracle 9i. \n19\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În anul 2007 a fost lansată versiunea Oracle \n11g care are cateva facilitati in plus:\n– Gestioneaza datele mai eficient prin compresii \navansate si partitionari \n– Simplifica sistemele prin stocarea tuturor datelor in \nOracle Database cu Oracle SecureFiles\n• În anul 2013 a fost lansată versiunea Oracle \n12c\n20\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle Database 12c prezintă o arhitectură nouă, cu \nmai multe entităţi găzduite, care permite unificarea \nrapidă a mai multor baze de date şi gestionarea \nacestora ca serviciu cloud. \n➢Oracle Database 12c include, de asemenea, capacităţi \nde procesare a datelor în memorie, care oferă o \nperformanţă analitică inovatoare. \n➢Inovaţiile suplimentare pentru baze de date oferă noi \nnivele de eficienţă, performanţă, securitate şi \ndisponibilitate.[*]\n21[*] https://www.oracle.com/ro/database/index.html\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', '\n', '5. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nOracle 9i REAL APPLICATION CLUSTERS (RAC) se bazează pe \no nouă arhitectură de BD numită îmbinare ascunsă (Cache \nFusion). \n✓Aceasta este o nouă generaţie de tehnologie de clustere. \n✓Conform acestei arhitecturi la adăugarea unui calculator \nîntr-o reţea cu BD Oracle, clusterele se adaptează automat \nla noile resurse, fără să fie necesară redistribuirea datelor \nsau rescrierea aplicaţiei.\n✓Posibilitatea apariţiei unei erori la o configuraţie cu 12 \ncalculatoare sub Oracle 9i RAC este foarte mică, estimată \nca durată în timp la cca 100.000 de ani. \n17\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oracle 9i DEVELOPER SUITE este un mediu \ncomplet pentru dezvoltarea aplicaţiilor tip \nafaceri electronice (e-business) şi tip Web. \nEl se bazează pe tehnologiile Java şi XML şi permite \npersonalizarea (Oracle Personalization). \n• În anul 2003 a fost lansată versiunea Oracle 10g \ncare adaugă noi facilităţi sistemului Oracle 9i. \n19\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În anul 2007 a fost lansată versiunea Oracle \n11g care are cateva facilitati in plus:\n– Gestioneaza datele mai eficient prin compresii \navansate si partitionari \n– Simplifica sistemele prin stocarea tuturor datelor in \nOracle Database cu Oracle SecureFiles\n• În anul 2013 a fost lansată versiunea Oracle \n12c\n20\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle Database 12c prezintă o arhitectură nouă, cu \nmai multe entităţi găzduite, care permite unificarea \nrapidă a mai multor baze de date şi gestionarea \nacestora ca serviciu cloud. \n➢Oracle Database 12c include, de asemenea, capacităţi \nde procesare a datelor în memorie, care oferă o \nperformanţă analitică inovatoare. \n➢Inovaţiile suplimentare pentru baze de date oferă noi \nnivele de eficienţă, performanţă, securitate şi \ndisponibilitate.[*]\n21[*] https://www.oracle.com/ro/database/index.html\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', '\n', '6. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nOracle 9i REAL APPLICATION CLUSTERS (RAC) se bazează pe \no nouă arhitectură de BD numită îmbinare ascunsă (Cache \nFusion). \n✓Aceasta este o nouă generaţie de tehnologie de clustere. \n✓Conform acestei arhitecturi la adăugarea unui calculator \nîntr-o reţea cu BD Oracle, clusterele se adaptează automat \nla noile resurse, fără să fie necesară redistribuirea datelor \nsau rescrierea aplicaţiei.\n✓Posibilitatea apariţiei unei erori la o configuraţie cu 12 \ncalculatoare sub Oracle 9i RAC este foarte mică, estimată \nca durată în timp la cca 100.000 de ani. \n17\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oracle 9i DEVELOPER SUITE este un mediu \ncomplet pentru dezvoltarea aplicaţiilor tip \nafaceri electronice (e-business) şi tip Web. \nEl se bazează pe tehnologiile Java şi XML şi permite \npersonalizarea (Oracle Personalization). \n• În anul 2003 a fost lansată versiunea Oracle 10g \ncare adaugă noi facilităţi sistemului Oracle 9i. \n19\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În anul 2007 a fost lansată versiunea Oracle \n11g care are cateva facilitati in plus:\n– Gestioneaza datele mai eficient prin compresii \navansate si partitionari \n– Simplifica sistemele prin stocarea tuturor datelor in \nOracle Database cu Oracle SecureFiles\n• În anul 2013 a fost lansată versiunea Oracle \n12c\n20\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle Database 12c prezintă o arhitectură nouă, cu \nmai multe entităţi găzduite, care permite unificarea \nrapidă a mai multor baze de date şi gestionarea \nacestora ca serviciu cloud. \n➢Oracle Database 12c include, de asemenea, capacităţi \nde procesare a datelor în memorie, care oferă o \nperformanţă analitică inovatoare. \n➢Inovaţiile suplimentare pentru baze de date oferă noi \nnivele de eficienţă, performanţă, securitate şi \ndisponibilitate.[*]\n21[*] https://www.oracle.com/ro/database/index.html\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', '\n', '7. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32\n\n2.3. ORACLE Server\n ORACLE Server (OS) permite \nmanagementul informaţiilor organizate în baze \nde date, astfel încât se asigură accesul mai \nmultor utilizatori în mod concurenţial la acelaşi \ndate, oferind facilităţi de prevenire a accesului \nneautorizat şi de restaurare a datelor după \nproducerea unor erori. \n33\n\n2.3. ORACLE Server\nORACLE Server este un sistem relaţional-\nobiectual de management a bazelor de date, \ncare permite o abordare deschisă, integrată şi \ncuprinzătoare a managementului \ninformaţiilor. \nOS constă dintr-un cuplu format dintr-o \nbază de date şi o instanţă Oracle.\n34\n\n2.3. ORACLE Server\nA. O bază de date Oracle este o colecţie \nunitară de date, având o structură logică şi \nuna fizică putând avea două stări: \n1. open (accesibilă) \n2. close (inaccesibilă)\n35\n\n2.3. ORACLE Server\n1) Structura logică a unei baze de date este \nformată din:\n✓tabelele spaţiu (tablespaces)\n✓schema de obiectelor bazei de date\n✓blocurile de date\n✓extensiile\n✓segmentele\n36\n\n2.3. ORACLE Server\n2) Structura fizică este definită de un set de \nfişiere specifice sistemului de operare pe care \nrezidă SGBD Oracle, folosite pentru memorarea \nstructurilor logice ale bazei de date şi pentru \npăstrarea unor informaţii tehnice de control. \nAceste fişiere sunt: \n- fişiere de date (Data files)\n- fişiere Redo log (Redo Log files) \n- fişiere de control (Control files)\n37\n\n2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n39\n\n2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40\n\n2.4. ORACLE Database 11g Expres Edition\n Pe calculatorul personal este ideal sa se \ninstaleze fisierul: \nOracle Database 11g Express Edition \n(Universal)  OracleXE112_Win32.zip\n41\n\n2.4. ORACLE Database 11g Expres Edition\nPas 1: Se porneste instalarea fisierului executabil si se vor \nurma pasii indicati de catre programul de instalare.\n42\n\n2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43\n\n2.4. ORACLE Database 11g Expres Edition\nInstalarea aplicatiei\n 44', '\n', '8. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32\n\n2.3. ORACLE Server\n ORACLE Server (OS) permite \nmanagementul informaţiilor organizate în baze \nde date, astfel încât se asigură accesul mai \nmultor utilizatori în mod concurenţial la acelaşi \ndate, oferind facilităţi de prevenire a accesului \nneautorizat şi de restaurare a datelor după \nproducerea unor erori. \n33\n\n2.3. ORACLE Server\nORACLE Server este un sistem relaţional-\nobiectual de management a bazelor de date, \ncare permite o abordare deschisă, integrată şi \ncuprinzătoare a managementului \ninformaţiilor. \nOS constă dintr-un cuplu format dintr-o \nbază de date şi o instanţă Oracle.\n34\n\n2.3. ORACLE Server\nA. O bază de date Oracle este o colecţie \nunitară de date, având o structură logică şi \nuna fizică putând avea două stări: \n1. open (accesibilă) \n2. close (inaccesibilă)\n35\n\n2.3. ORACLE Server\n1) Structura logică a unei baze de date este \nformată din:\n✓tabelele spaţiu (tablespaces)\n✓schema de obiectelor bazei de date\n✓blocurile de date\n✓extensiile\n✓segmentele\n36\n\n2.3. ORACLE Server\n2) Structura fizică este definită de un set de \nfişiere specifice sistemului de operare pe care \nrezidă SGBD Oracle, folosite pentru memorarea \nstructurilor logice ale bazei de date şi pentru \npăstrarea unor informaţii tehnice de control. \nAceste fişiere sunt: \n- fişiere de date (Data files)\n- fişiere Redo log (Redo Log files) \n- fişiere de control (Control files)\n37\n\n2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n39\n\n2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40\n\n2.4. ORACLE Database 11g Expres Edition\n Pe calculatorul personal este ideal sa se \ninstaleze fisierul: \nOracle Database 11g Express Edition \n(Universal)  OracleXE112_Win32.zip\n41\n\n2.4. ORACLE Database 11g Expres Edition\nPas 1: Se porneste instalarea fisierului executabil si se vor \nurma pasii indicati de catre programul de instalare.\n42\n\n2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43\n\n2.4. ORACLE Database 11g Expres Edition\nInstalarea aplicatiei\n 44', '\n', '9. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32\n\n2.3. ORACLE Server\n ORACLE Server (OS) permite \nmanagementul informaţiilor organizate în baze \nde date, astfel încât se asigură accesul mai \nmultor utilizatori în mod concurenţial la acelaşi \ndate, oferind facilităţi de prevenire a accesului \nneautorizat şi de restaurare a datelor după \nproducerea unor erori. \n33\n\n2.3. ORACLE Server\nORACLE Server este un sistem relaţional-\nobiectual de management a bazelor de date, \ncare permite o abordare deschisă, integrată şi \ncuprinzătoare a managementului \ninformaţiilor. \nOS constă dintr-un cuplu format dintr-o \nbază de date şi o instanţă Oracle.\n34\n\n2.3. ORACLE Server\nA. O bază de date Oracle este o colecţie \nunitară de date, având o structură logică şi \nuna fizică putând avea două stări: \n1. open (accesibilă) \n2. close (inaccesibilă)\n35\n\n2.3. ORACLE Server\n1) Structura logică a unei baze de date este \nformată din:\n✓tabelele spaţiu (tablespaces)\n✓schema de obiectelor bazei de date\n✓blocurile de date\n✓extensiile\n✓segmentele\n36\n\n2.3. ORACLE Server\n2) Structura fizică este definită de un set de \nfişiere specifice sistemului de operare pe care \nrezidă SGBD Oracle, folosite pentru memorarea \nstructurilor logice ale bazei de date şi pentru \npăstrarea unor informaţii tehnice de control. \nAceste fişiere sunt: \n- fişiere de date (Data files)\n- fişiere Redo log (Redo Log files) \n- fişiere de control (Control files)\n37\n\n2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n39\n\n2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40\n\n2.4. ORACLE Database 11g Expres Edition\n Pe calculatorul personal este ideal sa se \ninstaleze fisierul: \nOracle Database 11g Express Edition \n(Universal)  OracleXE112_Win32.zip\n41\n\n2.4. ORACLE Database 11g Expres Edition\nPas 1: Se porneste instalarea fisierului executabil si se vor \nurma pasii indicati de catre programul de instalare.\n42\n\n2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43\n\n2.4. ORACLE Database 11g Expres Edition\nInstalarea aplicatiei\n 44', '\n', '10. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n']","Oracle este un sistem de gestiune a bazelor de date (SGBD) relațional, dezvoltat de Oracle Corporation din 1977. A evoluat de la prima versiune bazată pe teoria relațională, implementând limbajul SQL, la versiuni care includ arhitectura client/server (versiunea 5.0), arhitectura NC (Network Computing) (versiunile 8.0 și 8i), și funcționalități cloud (versiunea 12c). Versiunile recente (9i, 10g, 11g, 12c) au adăugat îmbunătățiri precum protecție automată, tehnologia de clustere Cache Fusion, compresie avansată, și procesare a datelor în memorie. Arhitectura Oracle este structurată pe trei niveluri: nucleul (limbajele SQL și PL/SQL), interfețele (pentru dezvoltarea aplicațiilor) și instrumentele de întreținere.
","Oracle este un SGBD complet relațional, extins, cu facilități din tehnologia orientată obiect” și a evoluat de la arhitectura client/server la NC, integrând tehnici cloud și inovații pentru performanță și flexibilitate.",0.370095066374008,1.0,0.8249147322049611,0.9230769230769231,0.045959316275304786,0.2550335570469799,0.13
30,O3mini-high,High,"C3, C4",C5,"Cum se combină clauzele WHERE, ORDER BY și funcțiile agregate pentru a obține rezultate sumare?","WHERE filtrează rândurile, ORDER BY sortează rezultatul, iar funcțiile de grup (ex. AVG, COUNT) calculează valori sumare pentru fiecare grup definit prin GROUP BY. Exemplu: „SELECT deptno, AVG(sal) FROM EMP GROUP BY deptno ORDER BY AVG(sal)” – rezultatul fiind o sumă statistică pe departamente.",Este corect,C5,"['1. ', 'Clauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \n 68\n\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 69\n\nClauza ORDER BY\n➢În mod normal (fără clauza ORDER BY) rândurile sunt \nreturnate într-o ordine convenită de Oracle însă ea \nfiind consistentă de la cerere la cerere. \n➢Cu ajutorul clauzei ORDER BY rândurile vor fi afişate în \nordinea solicitată (cu toate acestea nu se va modifica \nordinea internă a rândurilor din baza de date).\n➢Clauza ORDER BY trebuie să fie ultima clauză din cerere \n(interogare).\n 70\n\nClauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine crescătoare).\nSELECT * \nFROM EMP\nORDER BY hiredata; \n 72\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare (în ordine crescătoare).\n 73\n\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine descrescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate DESC;\n 74\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă data de angajare (în ordine descrescătoare). \n 75\n\n\nClauza ORDER BY\n➢Mai putem ordona randurile returnate cu ajutorul \nalias-urilor.\nExemplu: \nListati toti angajatii ordonandu-i dupa salariul anual: \nsal*12 salariuanual (in ordine crescatoare). \nSELECT ename, job, sal*12 SALARIU_ANUAL\nFROM EMP\nORDER BY SALARIU_ANUAL;\n 76\n\nClauza ORDER BY\nRezultatul obtinut - Listati toti angajatii ordonandu-i dupa salariul \nanual: sal*12 salariuanual (in ordine crescatoare). \n 77\n\n\nClauza ORDER BY\n➢ Rândurile mai pot fi ordonate şi după mai multe coloane. \n➢ Numărul de coloane după care se pot ordona rândurile \nîntoarse este numărul maxim de coloane existente în tabelă. \nExemplu \n Listaţi toţi angajaţii ordonându-i după data de angajare, \nsalariu şi comision (în ordine crescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate, sal, comm; \n 78\n\nClauza ORDER BY\n➢ Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare, salariu şi comision (în ordine crescătoare). \n 79\n\n\nClauza ORDER BY\n➢În clauza ORDER BY se pot folosi coloane care nu sunt \nconţinute în SELECT.\n \nExemplu: \n  Listaţi toţi angajaţii ordonându-i după salariu (în \nordine crescătoare).\nSELECT ename, job\nFROM EMP\nORDER BY sal;  \n 80\n\nClauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82', '\n', '2. ', 'Clauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \n 68\n\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 69\n\nClauza ORDER BY\n➢În mod normal (fără clauza ORDER BY) rândurile sunt \nreturnate într-o ordine convenită de Oracle însă ea \nfiind consistentă de la cerere la cerere. \n➢Cu ajutorul clauzei ORDER BY rândurile vor fi afişate în \nordinea solicitată (cu toate acestea nu se va modifica \nordinea internă a rândurilor din baza de date).\n➢Clauza ORDER BY trebuie să fie ultima clauză din cerere \n(interogare).\n 70\n\nClauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine crescătoare).\nSELECT * \nFROM EMP\nORDER BY hiredata; \n 72\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare (în ordine crescătoare).\n 73\n\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine descrescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate DESC;\n 74\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă data de angajare (în ordine descrescătoare). \n 75\n\n\nClauza ORDER BY\n➢Mai putem ordona randurile returnate cu ajutorul \nalias-urilor.\nExemplu: \nListati toti angajatii ordonandu-i dupa salariul anual: \nsal*12 salariuanual (in ordine crescatoare). \nSELECT ename, job, sal*12 SALARIU_ANUAL\nFROM EMP\nORDER BY SALARIU_ANUAL;\n 76\n\nClauza ORDER BY\nRezultatul obtinut - Listati toti angajatii ordonandu-i dupa salariul \nanual: sal*12 salariuanual (in ordine crescatoare). \n 77\n\n\nClauza ORDER BY\n➢ Rândurile mai pot fi ordonate şi după mai multe coloane. \n➢ Numărul de coloane după care se pot ordona rândurile \nîntoarse este numărul maxim de coloane existente în tabelă. \nExemplu \n Listaţi toţi angajaţii ordonându-i după data de angajare, \nsalariu şi comision (în ordine crescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate, sal, comm; \n 78\n\nClauza ORDER BY\n➢ Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare, salariu şi comision (în ordine crescătoare). \n 79\n\n\nClauza ORDER BY\n➢În clauza ORDER BY se pot folosi coloane care nu sunt \nconţinute în SELECT.\n \nExemplu: \n  Listaţi toţi angajaţii ordonându-i după salariu (în \nordine crescătoare).\nSELECT ename, job\nFROM EMP\nORDER BY sal;  \n 80\n\nClauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82', '\n', '3. ', 'Clauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \n 68\n\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 69\n\nClauza ORDER BY\n➢În mod normal (fără clauza ORDER BY) rândurile sunt \nreturnate într-o ordine convenită de Oracle însă ea \nfiind consistentă de la cerere la cerere. \n➢Cu ajutorul clauzei ORDER BY rândurile vor fi afişate în \nordinea solicitată (cu toate acestea nu se va modifica \nordinea internă a rândurilor din baza de date).\n➢Clauza ORDER BY trebuie să fie ultima clauză din cerere \n(interogare).\n 70\n\nClauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine crescătoare).\nSELECT * \nFROM EMP\nORDER BY hiredata; \n 72\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare (în ordine crescătoare).\n 73\n\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine descrescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate DESC;\n 74\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă data de angajare (în ordine descrescătoare). \n 75\n\n\nClauza ORDER BY\n➢Mai putem ordona randurile returnate cu ajutorul \nalias-urilor.\nExemplu: \nListati toti angajatii ordonandu-i dupa salariul anual: \nsal*12 salariuanual (in ordine crescatoare). \nSELECT ename, job, sal*12 SALARIU_ANUAL\nFROM EMP\nORDER BY SALARIU_ANUAL;\n 76\n\nClauza ORDER BY\nRezultatul obtinut - Listati toti angajatii ordonandu-i dupa salariul \nanual: sal*12 salariuanual (in ordine crescatoare). \n 77\n\n\nClauza ORDER BY\n➢ Rândurile mai pot fi ordonate şi după mai multe coloane. \n➢ Numărul de coloane după care se pot ordona rândurile \nîntoarse este numărul maxim de coloane existente în tabelă. \nExemplu \n Listaţi toţi angajaţii ordonându-i după data de angajare, \nsalariu şi comision (în ordine crescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate, sal, comm; \n 78\n\nClauza ORDER BY\n➢ Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare, salariu şi comision (în ordine crescătoare). \n 79\n\n\nClauza ORDER BY\n➢În clauza ORDER BY se pot folosi coloane care nu sunt \nconţinute în SELECT.\n \nExemplu: \n  Listaţi toţi angajaţii ordonându-i după salariu (în \nordine crescătoare).\nSELECT ename, job\nFROM EMP\nORDER BY sal;  \n 80\n\nClauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82', '\n', '4. ', ""Rezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = 'MARTIN';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 23\n4.2.1. Funcţii pentru şiruri de caractere\n\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 25\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER.\nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename)\nFROM EMP; \nCurs 4 - BAZE DE DATE 26\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 27\n4.2.1. Funcţii pentru şiruri de caractere\n\n➢Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime. \n➢Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior. \n➢Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea: \nCurs 4 - BAZE DE DATE 28\n4.2.1. Funcţii pentru şiruri de caractere\n\nSELECT ename, LENGTH (ename) - LENGTH (TRANSLATE(ename, 'DA', \n'D')) \nFROM EMP;\nCurs 4 - BAZE DE DATE 29\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 30\n4.2.1. Funcţii pentru şiruri de caractere\n\nExplicatii:\nÎn exemplul anterior, funcţia TRANSLATE (nume, 'DA', 'D') va \ncăuta în coloana “nume” primul caracter (caracterul 'D') din cel \nde-al doilea argument al funcţiei (şirul de caractere 'DA') şi îl va \nînlocui cu primul caracter (adică tot cu caracterul 'D') din cel de-al \ntreilea argument al funcţiei (şirul de caractere 'D'), apoi va căuta \ncel de-al doilea caracter, adică caracterul 'A', şi îl va şterge din \ncâmpul nume deoarece acesta nu are caracter corespondent în \ncel de-al treilea argument al funcţiei. \n  Am folosit acest artificiu deoarece şirul de caractere vid este \nechivalent cu valoarea Null, deci funcţia TRANSLATE (nume, 'A', ' \n') ar fi înlocuit toate valorile câmpului “nume” cu valoarea Null.\nCurs 4 - BAZE DE DATE 31\n4.2.1. Funcţii pentru şiruri de caractere\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 32\n\nAceste funcţii au ca argumente date de tip \nNUMBER şi returnează date de tip numeric.\nCurs 4 - BAZE DE DATE 33\n4.2.2. Funcţii de tip numeric"", '\n', '5. ', ""Rezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = 'MARTIN';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 23\n4.2.1. Funcţii pentru şiruri de caractere\n\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 25\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER.\nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename)\nFROM EMP; \nCurs 4 - BAZE DE DATE 26\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 27\n4.2.1. Funcţii pentru şiruri de caractere\n\n➢Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime. \n➢Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior. \n➢Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea: \nCurs 4 - BAZE DE DATE 28\n4.2.1. Funcţii pentru şiruri de caractere\n\nSELECT ename, LENGTH (ename) - LENGTH (TRANSLATE(ename, 'DA', \n'D')) \nFROM EMP;\nCurs 4 - BAZE DE DATE 29\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 30\n4.2.1. Funcţii pentru şiruri de caractere\n\nExplicatii:\nÎn exemplul anterior, funcţia TRANSLATE (nume, 'DA', 'D') va \ncăuta în coloana “nume” primul caracter (caracterul 'D') din cel \nde-al doilea argument al funcţiei (şirul de caractere 'DA') şi îl va \nînlocui cu primul caracter (adică tot cu caracterul 'D') din cel de-al \ntreilea argument al funcţiei (şirul de caractere 'D'), apoi va căuta \ncel de-al doilea caracter, adică caracterul 'A', şi îl va şterge din \ncâmpul nume deoarece acesta nu are caracter corespondent în \ncel de-al treilea argument al funcţiei. \n  Am folosit acest artificiu deoarece şirul de caractere vid este \nechivalent cu valoarea Null, deci funcţia TRANSLATE (nume, 'A', ' \n') ar fi înlocuit toate valorile câmpului “nume” cu valoarea Null.\nCurs 4 - BAZE DE DATE 31\n4.2.1. Funcţii pentru şiruri de caractere\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 32\n\nAceste funcţii au ca argumente date de tip \nNUMBER şi returnează date de tip numeric.\nCurs 4 - BAZE DE DATE 33\n4.2.2. Funcţii de tip numeric"", '\n', '6. ', ""Rezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = 'MARTIN';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 23\n4.2.1. Funcţii pentru şiruri de caractere\n\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 25\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER.\nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename)\nFROM EMP; \nCurs 4 - BAZE DE DATE 26\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 27\n4.2.1. Funcţii pentru şiruri de caractere\n\n➢Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime. \n➢Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior. \n➢Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea: \nCurs 4 - BAZE DE DATE 28\n4.2.1. Funcţii pentru şiruri de caractere\n\nSELECT ename, LENGTH (ename) - LENGTH (TRANSLATE(ename, 'DA', \n'D')) \nFROM EMP;\nCurs 4 - BAZE DE DATE 29\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 30\n4.2.1. Funcţii pentru şiruri de caractere\n\nExplicatii:\nÎn exemplul anterior, funcţia TRANSLATE (nume, 'DA', 'D') va \ncăuta în coloana “nume” primul caracter (caracterul 'D') din cel \nde-al doilea argument al funcţiei (şirul de caractere 'DA') şi îl va \nînlocui cu primul caracter (adică tot cu caracterul 'D') din cel de-al \ntreilea argument al funcţiei (şirul de caractere 'D'), apoi va căuta \ncel de-al doilea caracter, adică caracterul 'A', şi îl va şterge din \ncâmpul nume deoarece acesta nu are caracter corespondent în \ncel de-al treilea argument al funcţiei. \n  Am folosit acest artificiu deoarece şirul de caractere vid este \nechivalent cu valoarea Null, deci funcţia TRANSLATE (nume, 'A', ' \n') ar fi înlocuit toate valorile câmpului “nume” cu valoarea Null.\nCurs 4 - BAZE DE DATE 31\n4.2.1. Funcţii pentru şiruri de caractere\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 32\n\nAceste funcţii au ca argumente date de tip \nNUMBER şi returnează date de tip numeric.\nCurs 4 - BAZE DE DATE 33\n4.2.2. Funcţii de tip numeric"", '\n', '7. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '8. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '9. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '10. ', ""4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14\n\n4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15\n\n4.3. Funcții de grup\nDISTINCT face ca funcţia să ignore valorile duplicat. \nALL face ca funcţia să afişeze şi valorile duplicat. \nValoarea implicită este ALL, deci nu este necesar să \nfie specificată.\n  Tipul de dată returnat de funcţia expr poate fi \nCHAR, VARCHAR2, NUMBER sau DATE.\n  Toate funcţiile de grup ignoră valorile nule. \nPentru a lua în considerare şi valorile nule se \nfolosesc funcţiile NVL, NVL2 sau COALESCE.\nCurs 5 - BAZE DE DATE 16\n\n4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17\n\n4.3. Funcții de grup\nExemplul 1: Afişarea salariului mediu, maxim, minim şi \nsuma tuturor salariilor angajaţilor cu funcţie SALESMAN. \nSELECT AVG(sal), MAX(sal), MIN(sal), SUM(sal)\nFROM EMP\nWHERE job = 'SALESMAN';\nCurs 5 - BAZE DE DATE 18\n\n\n4.3. Funcții de grup\nExemplul 2 - Datele la care s-au făcut prima şi ultima \nangajare.\nSELECT MIN(hiredate), MAX(hiredate)\nFROM EMP; \nCurs 5 - BAZE DE DATE 19\n\n\n4.3. Funcții de grup\nExemplul 3 - Primul şi ultimul nume de angajat în \nordine alfabetică:\nSELECT MIN(ename), MAX(ename)\nFROM EMP;\nCurs 5 - BAZE DE DATE 20\n\n\n4.3. Funcții de grup\nFuncţia COUNT \nFuncţia COUNT are 3 formate: \nCOUNT(*) \nCOUNT(expr) \nCOUNT(DISTINCT expr)\nCurs 5 - BAZE DE DATE 21\n\n4.3. Funcții de grup\n•COUNT(*) întoarce numărul de rânduri dintr-o tabela \ncare satisface criteriul de selecţie, incluzând rândurile \nduplicat şi rândurile conţinând valori nule.\n•Dacă clauza WHERE este introdusă, atunci COUNT(*) \nreturnează numărul de rânduri care satisfac condiţia \ndin clauza WHERE.\nCurs 5 - BAZE DE DATE 22"", '\n']","clauzele WHERE, ORDER BY și funcțiile agregate pot fi combinate într-o interogare SELECT pentru a obține rezultate sumare filtrate și ordonate. Sintaxa generală este:

```sql
SELECT [coloana,] functie_de_grup(coloana), ...
FROM tabel
[WHERE conditie]
[GROUP BY coloana]
[HAVING conditie_de_grupare]
[ORDER BY coloana];
```

Unde:
*   `functie_de_grup` poate fi AVG, COUNT, MAX, MIN, SUM, etc.
*   Clauza `WHERE` filtrează rândurile înainte de a fi grupate.
*    Clauza `GROUP BY` grupează rândurile.
*    Clauza `HAVING` filtrează grupurile.
*   Clauza `ORDER BY` sortează rezultatul.
*   `ORDER BY` trebuie sa fie ultima clauza.
","Cum se combină clauzele WHERE, ORDER BY și funcțiile agregate pentru a obține rezultate sumare?","['1. ', 'Clauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \n 68\n\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 69\n\nClauza ORDER BY\n➢În mod normal (fără clauza ORDER BY) rândurile sunt \nreturnate într-o ordine convenită de Oracle însă ea \nfiind consistentă de la cerere la cerere. \n➢Cu ajutorul clauzei ORDER BY rândurile vor fi afişate în \nordinea solicitată (cu toate acestea nu se va modifica \nordinea internă a rândurilor din baza de date).\n➢Clauza ORDER BY trebuie să fie ultima clauză din cerere \n(interogare).\n 70\n\nClauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine crescătoare).\nSELECT * \nFROM EMP\nORDER BY hiredata; \n 72\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare (în ordine crescătoare).\n 73\n\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine descrescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate DESC;\n 74\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă data de angajare (în ordine descrescătoare). \n 75\n\n\nClauza ORDER BY\n➢Mai putem ordona randurile returnate cu ajutorul \nalias-urilor.\nExemplu: \nListati toti angajatii ordonandu-i dupa salariul anual: \nsal*12 salariuanual (in ordine crescatoare). \nSELECT ename, job, sal*12 SALARIU_ANUAL\nFROM EMP\nORDER BY SALARIU_ANUAL;\n 76\n\nClauza ORDER BY\nRezultatul obtinut - Listati toti angajatii ordonandu-i dupa salariul \nanual: sal*12 salariuanual (in ordine crescatoare). \n 77\n\n\nClauza ORDER BY\n➢ Rândurile mai pot fi ordonate şi după mai multe coloane. \n➢ Numărul de coloane după care se pot ordona rândurile \nîntoarse este numărul maxim de coloane existente în tabelă. \nExemplu \n Listaţi toţi angajaţii ordonându-i după data de angajare, \nsalariu şi comision (în ordine crescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate, sal, comm; \n 78\n\nClauza ORDER BY\n➢ Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare, salariu şi comision (în ordine crescătoare). \n 79\n\n\nClauza ORDER BY\n➢În clauza ORDER BY se pot folosi coloane care nu sunt \nconţinute în SELECT.\n \nExemplu: \n  Listaţi toţi angajaţii ordonându-i după salariu (în \nordine crescătoare).\nSELECT ename, job\nFROM EMP\nORDER BY sal;  \n 80\n\nClauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82', '\n', '2. ', 'Clauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \n 68\n\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 69\n\nClauza ORDER BY\n➢În mod normal (fără clauza ORDER BY) rândurile sunt \nreturnate într-o ordine convenită de Oracle însă ea \nfiind consistentă de la cerere la cerere. \n➢Cu ajutorul clauzei ORDER BY rândurile vor fi afişate în \nordinea solicitată (cu toate acestea nu se va modifica \nordinea internă a rândurilor din baza de date).\n➢Clauza ORDER BY trebuie să fie ultima clauză din cerere \n(interogare).\n 70\n\nClauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine crescătoare).\nSELECT * \nFROM EMP\nORDER BY hiredata; \n 72\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare (în ordine crescătoare).\n 73\n\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine descrescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate DESC;\n 74\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă data de angajare (în ordine descrescătoare). \n 75\n\n\nClauza ORDER BY\n➢Mai putem ordona randurile returnate cu ajutorul \nalias-urilor.\nExemplu: \nListati toti angajatii ordonandu-i dupa salariul anual: \nsal*12 salariuanual (in ordine crescatoare). \nSELECT ename, job, sal*12 SALARIU_ANUAL\nFROM EMP\nORDER BY SALARIU_ANUAL;\n 76\n\nClauza ORDER BY\nRezultatul obtinut - Listati toti angajatii ordonandu-i dupa salariul \nanual: sal*12 salariuanual (in ordine crescatoare). \n 77\n\n\nClauza ORDER BY\n➢ Rândurile mai pot fi ordonate şi după mai multe coloane. \n➢ Numărul de coloane după care se pot ordona rândurile \nîntoarse este numărul maxim de coloane existente în tabelă. \nExemplu \n Listaţi toţi angajaţii ordonându-i după data de angajare, \nsalariu şi comision (în ordine crescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate, sal, comm; \n 78\n\nClauza ORDER BY\n➢ Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare, salariu şi comision (în ordine crescătoare). \n 79\n\n\nClauza ORDER BY\n➢În clauza ORDER BY se pot folosi coloane care nu sunt \nconţinute în SELECT.\n \nExemplu: \n  Listaţi toţi angajaţii ordonându-i după salariu (în \nordine crescătoare).\nSELECT ename, job\nFROM EMP\nORDER BY sal;  \n 80\n\nClauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82', '\n', '3. ', 'Clauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \n 68\n\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 69\n\nClauza ORDER BY\n➢În mod normal (fără clauza ORDER BY) rândurile sunt \nreturnate într-o ordine convenită de Oracle însă ea \nfiind consistentă de la cerere la cerere. \n➢Cu ajutorul clauzei ORDER BY rândurile vor fi afişate în \nordinea solicitată (cu toate acestea nu se va modifica \nordinea internă a rândurilor din baza de date).\n➢Clauza ORDER BY trebuie să fie ultima clauză din cerere \n(interogare).\n 70\n\nClauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine crescătoare).\nSELECT * \nFROM EMP\nORDER BY hiredata; \n 72\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare (în ordine crescătoare).\n 73\n\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine descrescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate DESC;\n 74\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă data de angajare (în ordine descrescătoare). \n 75\n\n\nClauza ORDER BY\n➢Mai putem ordona randurile returnate cu ajutorul \nalias-urilor.\nExemplu: \nListati toti angajatii ordonandu-i dupa salariul anual: \nsal*12 salariuanual (in ordine crescatoare). \nSELECT ename, job, sal*12 SALARIU_ANUAL\nFROM EMP\nORDER BY SALARIU_ANUAL;\n 76\n\nClauza ORDER BY\nRezultatul obtinut - Listati toti angajatii ordonandu-i dupa salariul \nanual: sal*12 salariuanual (in ordine crescatoare). \n 77\n\n\nClauza ORDER BY\n➢ Rândurile mai pot fi ordonate şi după mai multe coloane. \n➢ Numărul de coloane după care se pot ordona rândurile \nîntoarse este numărul maxim de coloane existente în tabelă. \nExemplu \n Listaţi toţi angajaţii ordonându-i după data de angajare, \nsalariu şi comision (în ordine crescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate, sal, comm; \n 78\n\nClauza ORDER BY\n➢ Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare, salariu şi comision (în ordine crescătoare). \n 79\n\n\nClauza ORDER BY\n➢În clauza ORDER BY se pot folosi coloane care nu sunt \nconţinute în SELECT.\n \nExemplu: \n  Listaţi toţi angajaţii ordonându-i după salariu (în \nordine crescătoare).\nSELECT ename, job\nFROM EMP\nORDER BY sal;  \n 80\n\nClauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82', '\n', '4. ', ""Rezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = 'MARTIN';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 23\n4.2.1. Funcţii pentru şiruri de caractere\n\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 25\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER.\nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename)\nFROM EMP; \nCurs 4 - BAZE DE DATE 26\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 27\n4.2.1. Funcţii pentru şiruri de caractere\n\n➢Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime. \n➢Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior. \n➢Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea: \nCurs 4 - BAZE DE DATE 28\n4.2.1. Funcţii pentru şiruri de caractere\n\nSELECT ename, LENGTH (ename) - LENGTH (TRANSLATE(ename, 'DA', \n'D')) \nFROM EMP;\nCurs 4 - BAZE DE DATE 29\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 30\n4.2.1. Funcţii pentru şiruri de caractere\n\nExplicatii:\nÎn exemplul anterior, funcţia TRANSLATE (nume, 'DA', 'D') va \ncăuta în coloana “nume” primul caracter (caracterul 'D') din cel \nde-al doilea argument al funcţiei (şirul de caractere 'DA') şi îl va \nînlocui cu primul caracter (adică tot cu caracterul 'D') din cel de-al \ntreilea argument al funcţiei (şirul de caractere 'D'), apoi va căuta \ncel de-al doilea caracter, adică caracterul 'A', şi îl va şterge din \ncâmpul nume deoarece acesta nu are caracter corespondent în \ncel de-al treilea argument al funcţiei. \n  Am folosit acest artificiu deoarece şirul de caractere vid este \nechivalent cu valoarea Null, deci funcţia TRANSLATE (nume, 'A', ' \n') ar fi înlocuit toate valorile câmpului “nume” cu valoarea Null.\nCurs 4 - BAZE DE DATE 31\n4.2.1. Funcţii pentru şiruri de caractere\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 32\n\nAceste funcţii au ca argumente date de tip \nNUMBER şi returnează date de tip numeric.\nCurs 4 - BAZE DE DATE 33\n4.2.2. Funcţii de tip numeric"", '\n', '5. ', ""Rezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = 'MARTIN';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 23\n4.2.1. Funcţii pentru şiruri de caractere\n\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 25\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER.\nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename)\nFROM EMP; \nCurs 4 - BAZE DE DATE 26\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 27\n4.2.1. Funcţii pentru şiruri de caractere\n\n➢Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime. \n➢Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior. \n➢Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea: \nCurs 4 - BAZE DE DATE 28\n4.2.1. Funcţii pentru şiruri de caractere\n\nSELECT ename, LENGTH (ename) - LENGTH (TRANSLATE(ename, 'DA', \n'D')) \nFROM EMP;\nCurs 4 - BAZE DE DATE 29\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 30\n4.2.1. Funcţii pentru şiruri de caractere\n\nExplicatii:\nÎn exemplul anterior, funcţia TRANSLATE (nume, 'DA', 'D') va \ncăuta în coloana “nume” primul caracter (caracterul 'D') din cel \nde-al doilea argument al funcţiei (şirul de caractere 'DA') şi îl va \nînlocui cu primul caracter (adică tot cu caracterul 'D') din cel de-al \ntreilea argument al funcţiei (şirul de caractere 'D'), apoi va căuta \ncel de-al doilea caracter, adică caracterul 'A', şi îl va şterge din \ncâmpul nume deoarece acesta nu are caracter corespondent în \ncel de-al treilea argument al funcţiei. \n  Am folosit acest artificiu deoarece şirul de caractere vid este \nechivalent cu valoarea Null, deci funcţia TRANSLATE (nume, 'A', ' \n') ar fi înlocuit toate valorile câmpului “nume” cu valoarea Null.\nCurs 4 - BAZE DE DATE 31\n4.2.1. Funcţii pentru şiruri de caractere\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 32\n\nAceste funcţii au ca argumente date de tip \nNUMBER şi returnează date de tip numeric.\nCurs 4 - BAZE DE DATE 33\n4.2.2. Funcţii de tip numeric"", '\n', '6. ', ""Rezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = 'MARTIN';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 23\n4.2.1. Funcţii pentru şiruri de caractere\n\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 25\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER.\nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename)\nFROM EMP; \nCurs 4 - BAZE DE DATE 26\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 27\n4.2.1. Funcţii pentru şiruri de caractere\n\n➢Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime. \n➢Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior. \n➢Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea: \nCurs 4 - BAZE DE DATE 28\n4.2.1. Funcţii pentru şiruri de caractere\n\nSELECT ename, LENGTH (ename) - LENGTH (TRANSLATE(ename, 'DA', \n'D')) \nFROM EMP;\nCurs 4 - BAZE DE DATE 29\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 30\n4.2.1. Funcţii pentru şiruri de caractere\n\nExplicatii:\nÎn exemplul anterior, funcţia TRANSLATE (nume, 'DA', 'D') va \ncăuta în coloana “nume” primul caracter (caracterul 'D') din cel \nde-al doilea argument al funcţiei (şirul de caractere 'DA') şi îl va \nînlocui cu primul caracter (adică tot cu caracterul 'D') din cel de-al \ntreilea argument al funcţiei (şirul de caractere 'D'), apoi va căuta \ncel de-al doilea caracter, adică caracterul 'A', şi îl va şterge din \ncâmpul nume deoarece acesta nu are caracter corespondent în \ncel de-al treilea argument al funcţiei. \n  Am folosit acest artificiu deoarece şirul de caractere vid este \nechivalent cu valoarea Null, deci funcţia TRANSLATE (nume, 'A', ' \n') ar fi înlocuit toate valorile câmpului “nume” cu valoarea Null.\nCurs 4 - BAZE DE DATE 31\n4.2.1. Funcţii pentru şiruri de caractere\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 32\n\nAceste funcţii au ca argumente date de tip \nNUMBER şi returnează date de tip numeric.\nCurs 4 - BAZE DE DATE 33\n4.2.2. Funcţii de tip numeric"", '\n', '7. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '8. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '9. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '10. ', ""4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14\n\n4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15\n\n4.3. Funcții de grup\nDISTINCT face ca funcţia să ignore valorile duplicat. \nALL face ca funcţia să afişeze şi valorile duplicat. \nValoarea implicită este ALL, deci nu este necesar să \nfie specificată.\n  Tipul de dată returnat de funcţia expr poate fi \nCHAR, VARCHAR2, NUMBER sau DATE.\n  Toate funcţiile de grup ignoră valorile nule. \nPentru a lua în considerare şi valorile nule se \nfolosesc funcţiile NVL, NVL2 sau COALESCE.\nCurs 5 - BAZE DE DATE 16\n\n4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17\n\n4.3. Funcții de grup\nExemplul 1: Afişarea salariului mediu, maxim, minim şi \nsuma tuturor salariilor angajaţilor cu funcţie SALESMAN. \nSELECT AVG(sal), MAX(sal), MIN(sal), SUM(sal)\nFROM EMP\nWHERE job = 'SALESMAN';\nCurs 5 - BAZE DE DATE 18\n\n\n4.3. Funcții de grup\nExemplul 2 - Datele la care s-au făcut prima şi ultima \nangajare.\nSELECT MIN(hiredate), MAX(hiredate)\nFROM EMP; \nCurs 5 - BAZE DE DATE 19\n\n\n4.3. Funcții de grup\nExemplul 3 - Primul şi ultimul nume de angajat în \nordine alfabetică:\nSELECT MIN(ename), MAX(ename)\nFROM EMP;\nCurs 5 - BAZE DE DATE 20\n\n\n4.3. Funcții de grup\nFuncţia COUNT \nFuncţia COUNT are 3 formate: \nCOUNT(*) \nCOUNT(expr) \nCOUNT(DISTINCT expr)\nCurs 5 - BAZE DE DATE 21\n\n4.3. Funcții de grup\n•COUNT(*) întoarce numărul de rânduri dintr-o tabela \ncare satisface criteriul de selecţie, incluzând rândurile \nduplicat şi rândurile conţinând valori nule.\n•Dacă clauza WHERE este introdusă, atunci COUNT(*) \nreturnează numărul de rânduri care satisfac condiţia \ndin clauza WHERE.\nCurs 5 - BAZE DE DATE 22"", '\n']","clauzele WHERE, ORDER BY și funcțiile agregate pot fi combinate într-o interogare SELECT pentru a obține rezultate sumare filtrate și ordonate. Sintaxa generală este:

```sql
SELECT [coloana,] functie_de_grup(coloana), ...
FROM tabel
[WHERE conditie]
[GROUP BY coloana]
[HAVING conditie_de_grupare]
[ORDER BY coloana];
```

Unde:
*   `functie_de_grup` poate fi AVG, COUNT, MAX, MIN, SUM, etc.
*   Clauza `WHERE` filtrează rândurile înainte de a fi grupate.
*    Clauza `GROUP BY` grupează rândurile.
*    Clauza `HAVING` filtrează grupurile.
*   Clauza `ORDER BY` sortează rezultatul.
*   `ORDER BY` trebuie sa fie ultima clauza.
","WHERE filtrează rândurile, ORDER BY sortează rezultatul, iar funcțiile de grup (ex. AVG, COUNT) calculează valori sumare pentru fiecare grup definit prin GROUP BY. Exemplu: „SELECT deptno, AVG(sal) FROM EMP GROUP BY deptno ORDER BY AVG(sal)” – rezultatul fiind o sumă statistică pe departamente.",0.03448275861724138,1.0,0.8871713373710395,1.0,0.07946357815712818,0.2158273381294964,0.5
31,O3mini-high,High,"C4, C3",(C5),"Cum se utilizează funcțiile UPPER, LOWER și INITCAP în manipularea șirurilor și în condițiile din clauza WHERE?","Funcțiile UPPER, LOWER și INITCAP transformă șirurile pentru o comparare uniformă. De exemplu, „SELECT empno, UPPER(ename) FROM EMP WHERE INITCAP(ename) = 'Smith'” asigură că literele sunt comparate indiferent de caz, facilitând filtrarea corectă a datelor.",Este corect,"C5, slide 24","['1. ', ""Rezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = 'MARTIN';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 23\n4.2.1. Funcţii pentru şiruri de caractere\n\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 25\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER.\nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename)\nFROM EMP; \nCurs 4 - BAZE DE DATE 26\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 27\n4.2.1. Funcţii pentru şiruri de caractere\n\n➢Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime. \n➢Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior. \n➢Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea: \nCurs 4 - BAZE DE DATE 28\n4.2.1. Funcţii pentru şiruri de caractere\n\nSELECT ename, LENGTH (ename) - LENGTH (TRANSLATE(ename, 'DA', \n'D')) \nFROM EMP;\nCurs 4 - BAZE DE DATE 29\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 30\n4.2.1. Funcţii pentru şiruri de caractere\n\nExplicatii:\nÎn exemplul anterior, funcţia TRANSLATE (nume, 'DA', 'D') va \ncăuta în coloana “nume” primul caracter (caracterul 'D') din cel \nde-al doilea argument al funcţiei (şirul de caractere 'DA') şi îl va \nînlocui cu primul caracter (adică tot cu caracterul 'D') din cel de-al \ntreilea argument al funcţiei (şirul de caractere 'D'), apoi va căuta \ncel de-al doilea caracter, adică caracterul 'A', şi îl va şterge din \ncâmpul nume deoarece acesta nu are caracter corespondent în \ncel de-al treilea argument al funcţiei. \n  Am folosit acest artificiu deoarece şirul de caractere vid este \nechivalent cu valoarea Null, deci funcţia TRANSLATE (nume, 'A', ' \n') ar fi înlocuit toate valorile câmpului “nume” cu valoarea Null.\nCurs 4 - BAZE DE DATE 31\n4.2.1. Funcţii pentru şiruri de caractere\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 32\n\nAceste funcţii au ca argumente date de tip \nNUMBER şi returnează date de tip numeric.\nCurs 4 - BAZE DE DATE 33\n4.2.2. Funcţii de tip numeric"", '\n', '2. ', ""Rezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = 'MARTIN';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 23\n4.2.1. Funcţii pentru şiruri de caractere\n\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 25\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER.\nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename)\nFROM EMP; \nCurs 4 - BAZE DE DATE 26\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 27\n4.2.1. Funcţii pentru şiruri de caractere\n\n➢Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime. \n➢Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior. \n➢Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea: \nCurs 4 - BAZE DE DATE 28\n4.2.1. Funcţii pentru şiruri de caractere\n\nSELECT ename, LENGTH (ename) - LENGTH (TRANSLATE(ename, 'DA', \n'D')) \nFROM EMP;\nCurs 4 - BAZE DE DATE 29\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 30\n4.2.1. Funcţii pentru şiruri de caractere\n\nExplicatii:\nÎn exemplul anterior, funcţia TRANSLATE (nume, 'DA', 'D') va \ncăuta în coloana “nume” primul caracter (caracterul 'D') din cel \nde-al doilea argument al funcţiei (şirul de caractere 'DA') şi îl va \nînlocui cu primul caracter (adică tot cu caracterul 'D') din cel de-al \ntreilea argument al funcţiei (şirul de caractere 'D'), apoi va căuta \ncel de-al doilea caracter, adică caracterul 'A', şi îl va şterge din \ncâmpul nume deoarece acesta nu are caracter corespondent în \ncel de-al treilea argument al funcţiei. \n  Am folosit acest artificiu deoarece şirul de caractere vid este \nechivalent cu valoarea Null, deci funcţia TRANSLATE (nume, 'A', ' \n') ar fi înlocuit toate valorile câmpului “nume” cu valoarea Null.\nCurs 4 - BAZE DE DATE 31\n4.2.1. Funcţii pentru şiruri de caractere\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 32\n\nAceste funcţii au ca argumente date de tip \nNUMBER şi returnează date de tip numeric.\nCurs 4 - BAZE DE DATE 33\n4.2.2. Funcţii de tip numeric"", '\n', '3. ', ""Rezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = 'MARTIN';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 23\n4.2.1. Funcţii pentru şiruri de caractere\n\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 25\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER.\nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename)\nFROM EMP; \nCurs 4 - BAZE DE DATE 26\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 27\n4.2.1. Funcţii pentru şiruri de caractere\n\n➢Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime. \n➢Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior. \n➢Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea: \nCurs 4 - BAZE DE DATE 28\n4.2.1. Funcţii pentru şiruri de caractere\n\nSELECT ename, LENGTH (ename) - LENGTH (TRANSLATE(ename, 'DA', \n'D')) \nFROM EMP;\nCurs 4 - BAZE DE DATE 29\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 30\n4.2.1. Funcţii pentru şiruri de caractere\n\nExplicatii:\nÎn exemplul anterior, funcţia TRANSLATE (nume, 'DA', 'D') va \ncăuta în coloana “nume” primul caracter (caracterul 'D') din cel \nde-al doilea argument al funcţiei (şirul de caractere 'DA') şi îl va \nînlocui cu primul caracter (adică tot cu caracterul 'D') din cel de-al \ntreilea argument al funcţiei (şirul de caractere 'D'), apoi va căuta \ncel de-al doilea caracter, adică caracterul 'A', şi îl va şterge din \ncâmpul nume deoarece acesta nu are caracter corespondent în \ncel de-al treilea argument al funcţiei. \n  Am folosit acest artificiu deoarece şirul de caractere vid este \nechivalent cu valoarea Null, deci funcţia TRANSLATE (nume, 'A', ' \n') ar fi înlocuit toate valorile câmpului “nume” cu valoarea Null.\nCurs 4 - BAZE DE DATE 31\n4.2.1. Funcţii pentru şiruri de caractere\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 32\n\nAceste funcţii au ca argumente date de tip \nNUMBER şi returnează date de tip numeric.\nCurs 4 - BAZE DE DATE 33\n4.2.2. Funcţii de tip numeric"", '\n', '4. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '5. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '6. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '7. ', ""4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14\n\n4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15\n\n4.3. Funcții de grup\nDISTINCT face ca funcţia să ignore valorile duplicat. \nALL face ca funcţia să afişeze şi valorile duplicat. \nValoarea implicită este ALL, deci nu este necesar să \nfie specificată.\n  Tipul de dată returnat de funcţia expr poate fi \nCHAR, VARCHAR2, NUMBER sau DATE.\n  Toate funcţiile de grup ignoră valorile nule. \nPentru a lua în considerare şi valorile nule se \nfolosesc funcţiile NVL, NVL2 sau COALESCE.\nCurs 5 - BAZE DE DATE 16\n\n4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17\n\n4.3. Funcții de grup\nExemplul 1: Afişarea salariului mediu, maxim, minim şi \nsuma tuturor salariilor angajaţilor cu funcţie SALESMAN. \nSELECT AVG(sal), MAX(sal), MIN(sal), SUM(sal)\nFROM EMP\nWHERE job = 'SALESMAN';\nCurs 5 - BAZE DE DATE 18\n\n\n4.3. Funcții de grup\nExemplul 2 - Datele la care s-au făcut prima şi ultima \nangajare.\nSELECT MIN(hiredate), MAX(hiredate)\nFROM EMP; \nCurs 5 - BAZE DE DATE 19\n\n\n4.3. Funcții de grup\nExemplul 3 - Primul şi ultimul nume de angajat în \nordine alfabetică:\nSELECT MIN(ename), MAX(ename)\nFROM EMP;\nCurs 5 - BAZE DE DATE 20\n\n\n4.3. Funcții de grup\nFuncţia COUNT \nFuncţia COUNT are 3 formate: \nCOUNT(*) \nCOUNT(expr) \nCOUNT(DISTINCT expr)\nCurs 5 - BAZE DE DATE 21\n\n4.3. Funcții de grup\n•COUNT(*) întoarce numărul de rânduri dintr-o tabela \ncare satisface criteriul de selecţie, incluzând rândurile \nduplicat şi rândurile conţinând valori nule.\n•Dacă clauza WHERE este introdusă, atunci COUNT(*) \nreturnează numărul de rânduri care satisfac condiţia \ndin clauza WHERE.\nCurs 5 - BAZE DE DATE 22"", '\n', '8. ', ""4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14\n\n4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15\n\n4.3. Funcții de grup\nDISTINCT face ca funcţia să ignore valorile duplicat. \nALL face ca funcţia să afişeze şi valorile duplicat. \nValoarea implicită este ALL, deci nu este necesar să \nfie specificată.\n  Tipul de dată returnat de funcţia expr poate fi \nCHAR, VARCHAR2, NUMBER sau DATE.\n  Toate funcţiile de grup ignoră valorile nule. \nPentru a lua în considerare şi valorile nule se \nfolosesc funcţiile NVL, NVL2 sau COALESCE.\nCurs 5 - BAZE DE DATE 16\n\n4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17\n\n4.3. Funcții de grup\nExemplul 1: Afişarea salariului mediu, maxim, minim şi \nsuma tuturor salariilor angajaţilor cu funcţie SALESMAN. \nSELECT AVG(sal), MAX(sal), MIN(sal), SUM(sal)\nFROM EMP\nWHERE job = 'SALESMAN';\nCurs 5 - BAZE DE DATE 18\n\n\n4.3. Funcții de grup\nExemplul 2 - Datele la care s-au făcut prima şi ultima \nangajare.\nSELECT MIN(hiredate), MAX(hiredate)\nFROM EMP; \nCurs 5 - BAZE DE DATE 19\n\n\n4.3. Funcții de grup\nExemplul 3 - Primul şi ultimul nume de angajat în \nordine alfabetică:\nSELECT MIN(ename), MAX(ename)\nFROM EMP;\nCurs 5 - BAZE DE DATE 20\n\n\n4.3. Funcții de grup\nFuncţia COUNT \nFuncţia COUNT are 3 formate: \nCOUNT(*) \nCOUNT(expr) \nCOUNT(DISTINCT expr)\nCurs 5 - BAZE DE DATE 21\n\n4.3. Funcții de grup\n•COUNT(*) întoarce numărul de rânduri dintr-o tabela \ncare satisface criteriul de selecţie, incluzând rândurile \nduplicat şi rândurile conţinând valori nule.\n•Dacă clauza WHERE este introdusă, atunci COUNT(*) \nreturnează numărul de rânduri care satisfac condiţia \ndin clauza WHERE.\nCurs 5 - BAZE DE DATE 22"", '\n', '9. ', ""4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14\n\n4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15\n\n4.3. Funcții de grup\nDISTINCT face ca funcţia să ignore valorile duplicat. \nALL face ca funcţia să afişeze şi valorile duplicat. \nValoarea implicită este ALL, deci nu este necesar să \nfie specificată.\n  Tipul de dată returnat de funcţia expr poate fi \nCHAR, VARCHAR2, NUMBER sau DATE.\n  Toate funcţiile de grup ignoră valorile nule. \nPentru a lua în considerare şi valorile nule se \nfolosesc funcţiile NVL, NVL2 sau COALESCE.\nCurs 5 - BAZE DE DATE 16\n\n4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17\n\n4.3. Funcții de grup\nExemplul 1: Afişarea salariului mediu, maxim, minim şi \nsuma tuturor salariilor angajaţilor cu funcţie SALESMAN. \nSELECT AVG(sal), MAX(sal), MIN(sal), SUM(sal)\nFROM EMP\nWHERE job = 'SALESMAN';\nCurs 5 - BAZE DE DATE 18\n\n\n4.3. Funcții de grup\nExemplul 2 - Datele la care s-au făcut prima şi ultima \nangajare.\nSELECT MIN(hiredate), MAX(hiredate)\nFROM EMP; \nCurs 5 - BAZE DE DATE 19\n\n\n4.3. Funcții de grup\nExemplul 3 - Primul şi ultimul nume de angajat în \nordine alfabetică:\nSELECT MIN(ename), MAX(ename)\nFROM EMP;\nCurs 5 - BAZE DE DATE 20\n\n\n4.3. Funcții de grup\nFuncţia COUNT \nFuncţia COUNT are 3 formate: \nCOUNT(*) \nCOUNT(expr) \nCOUNT(DISTINCT expr)\nCurs 5 - BAZE DE DATE 21\n\n4.3. Funcții de grup\n•COUNT(*) întoarce numărul de rânduri dintr-o tabela \ncare satisface criteriul de selecţie, incluzând rândurile \nduplicat şi rândurile conţinând valori nule.\n•Dacă clauza WHERE este introdusă, atunci COUNT(*) \nreturnează numărul de rânduri care satisfac condiţia \ndin clauza WHERE.\nCurs 5 - BAZE DE DATE 22"", '\n', '10. ', ""4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia ADD_MONTHS - exemplu:\nSELECT ADD_MONTHS(SYSDATE,3)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 49\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia LAST_DAY- exemplu:\nSELECT LAST_DAY(SYSDATE)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 50\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia MONTHS_BETWEEN - exemplu:\nSELECT MONTHS_BETWEEN (HIREDATE, \nSYSDATE)\nFROM EMP;\nRezultatul va fi un numar negativ, \ndeoarece primul parametru este o \ndata calendaristica mai mica decat al \ndoilea parametru.\nCurs 4 - BAZE DE DATE 51\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia MONTHS_BETWEEN -\nexemplu:\nSELECT MONTHS_BETWEEN \n(SYSDATE, HIREDATE)\nFROM EMP;\nPentru a afisa o valoare pozitiva, se \npot inversa cei doi parametri:\nCurs 4 - BAZE DE DATE 52\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia NEXT_DAY - exemplu:\nSELECT SYSDATE, NEXT_DAY(SYSDATE,6), \nNEXT_DAY(SYSDATE,'FRIDAY')\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 53\n\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 54\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\n4.2.4. Funcţii de conversie dintr-un tip în altul\nAceste funcţii au ca argumente date de tip DATE, \nNUMBER, CHAR şi returnează date de tip \nDATE, NUMBER, CHAR.\nCurs 4 - BAZE DE DATE 55\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\nFuncţiile de conversie din Oracle se pot folosi \npentru a converti diverse formate:\na)Conversia din dată calendaristică în şir de \ncaractere\nb)Conversia din şir de caractere în dată \ncalendaristică\nc) Conversia din număr în şir de caractere\nd)Conversia din şir de caractere în număr\nCurs 4 - BAZE DE DATE 56\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\na) Conversia din dată calendaristică în şir de \ncaractere\nConversia unei date calendaristice în şir de \ncaractere se poate realiza cu ajutorul funcţiei \nTO_CHAR. \nCurs 4 - BAZE DE DATE 57\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\na) Conversia din dată calendaristică în şir de \ncaractere\nSintaxa acestei funcţii este: TO_CHAR (dt, format)\ndt poate avea unul din tipurile pentru date \ncalendatistice:\n1. DATE, TIMESTAMP\n2. TIMESTAMP WITH TIME ZONE\n3. TIMESTAMP \n4. WITH LOCAL TIME ZONE \n5. INTERVAL MONTH TO YEAR\n6. INTERVAL DAY TO SECOND\nCurs 4 - BAZE DE DATE 58"", '\n']","funcțiile UPPER, LOWER și INITCAP pot fi utilizate pentru manipularea șirurilor de caractere și în condițiile din clauza WHERE astfel:

*   **UPPER(șir):** Convertește toate caracterele din șir în majuscule. Util în clauza WHERE pentru a face comparații case-insensitive (indiferent de majuscule/minuscule).
    Exemplu: `SELECT * FROM EMP WHERE UPPER(ename) = 'MARTIN';`

*    **LOWER(șir):** Convertește caracterele in minuscule.

*   **INITCAP(șir):** Convertește prima literă a fiecărui cuvânt din șir în majusculă, iar restul în minuscule.
    Exemplu: `SELECT * FROM EMP WHERE INITCAP(ename) = 'Smith';`
","Cum se utilizează funcțiile UPPER, LOWER și INITCAP în manipularea șirurilor și în condițiile din clauza WHERE?","['1. ', ""Rezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = 'MARTIN';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 23\n4.2.1. Funcţii pentru şiruri de caractere\n\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 25\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER.\nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename)\nFROM EMP; \nCurs 4 - BAZE DE DATE 26\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 27\n4.2.1. Funcţii pentru şiruri de caractere\n\n➢Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime. \n➢Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior. \n➢Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea: \nCurs 4 - BAZE DE DATE 28\n4.2.1. Funcţii pentru şiruri de caractere\n\nSELECT ename, LENGTH (ename) - LENGTH (TRANSLATE(ename, 'DA', \n'D')) \nFROM EMP;\nCurs 4 - BAZE DE DATE 29\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 30\n4.2.1. Funcţii pentru şiruri de caractere\n\nExplicatii:\nÎn exemplul anterior, funcţia TRANSLATE (nume, 'DA', 'D') va \ncăuta în coloana “nume” primul caracter (caracterul 'D') din cel \nde-al doilea argument al funcţiei (şirul de caractere 'DA') şi îl va \nînlocui cu primul caracter (adică tot cu caracterul 'D') din cel de-al \ntreilea argument al funcţiei (şirul de caractere 'D'), apoi va căuta \ncel de-al doilea caracter, adică caracterul 'A', şi îl va şterge din \ncâmpul nume deoarece acesta nu are caracter corespondent în \ncel de-al treilea argument al funcţiei. \n  Am folosit acest artificiu deoarece şirul de caractere vid este \nechivalent cu valoarea Null, deci funcţia TRANSLATE (nume, 'A', ' \n') ar fi înlocuit toate valorile câmpului “nume” cu valoarea Null.\nCurs 4 - BAZE DE DATE 31\n4.2.1. Funcţii pentru şiruri de caractere\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 32\n\nAceste funcţii au ca argumente date de tip \nNUMBER şi returnează date de tip numeric.\nCurs 4 - BAZE DE DATE 33\n4.2.2. Funcţii de tip numeric"", '\n', '2. ', ""Rezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = 'MARTIN';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 23\n4.2.1. Funcţii pentru şiruri de caractere\n\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 25\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER.\nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename)\nFROM EMP; \nCurs 4 - BAZE DE DATE 26\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 27\n4.2.1. Funcţii pentru şiruri de caractere\n\n➢Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime. \n➢Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior. \n➢Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea: \nCurs 4 - BAZE DE DATE 28\n4.2.1. Funcţii pentru şiruri de caractere\n\nSELECT ename, LENGTH (ename) - LENGTH (TRANSLATE(ename, 'DA', \n'D')) \nFROM EMP;\nCurs 4 - BAZE DE DATE 29\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 30\n4.2.1. Funcţii pentru şiruri de caractere\n\nExplicatii:\nÎn exemplul anterior, funcţia TRANSLATE (nume, 'DA', 'D') va \ncăuta în coloana “nume” primul caracter (caracterul 'D') din cel \nde-al doilea argument al funcţiei (şirul de caractere 'DA') şi îl va \nînlocui cu primul caracter (adică tot cu caracterul 'D') din cel de-al \ntreilea argument al funcţiei (şirul de caractere 'D'), apoi va căuta \ncel de-al doilea caracter, adică caracterul 'A', şi îl va şterge din \ncâmpul nume deoarece acesta nu are caracter corespondent în \ncel de-al treilea argument al funcţiei. \n  Am folosit acest artificiu deoarece şirul de caractere vid este \nechivalent cu valoarea Null, deci funcţia TRANSLATE (nume, 'A', ' \n') ar fi înlocuit toate valorile câmpului “nume” cu valoarea Null.\nCurs 4 - BAZE DE DATE 31\n4.2.1. Funcţii pentru şiruri de caractere\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 32\n\nAceste funcţii au ca argumente date de tip \nNUMBER şi returnează date de tip numeric.\nCurs 4 - BAZE DE DATE 33\n4.2.2. Funcţii de tip numeric"", '\n', '3. ', ""Rezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = 'MARTIN';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 23\n4.2.1. Funcţii pentru şiruri de caractere\n\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 25\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER.\nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename)\nFROM EMP; \nCurs 4 - BAZE DE DATE 26\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 27\n4.2.1. Funcţii pentru şiruri de caractere\n\n➢Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime. \n➢Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior. \n➢Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea: \nCurs 4 - BAZE DE DATE 28\n4.2.1. Funcţii pentru şiruri de caractere\n\nSELECT ename, LENGTH (ename) - LENGTH (TRANSLATE(ename, 'DA', \n'D')) \nFROM EMP;\nCurs 4 - BAZE DE DATE 29\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 30\n4.2.1. Funcţii pentru şiruri de caractere\n\nExplicatii:\nÎn exemplul anterior, funcţia TRANSLATE (nume, 'DA', 'D') va \ncăuta în coloana “nume” primul caracter (caracterul 'D') din cel \nde-al doilea argument al funcţiei (şirul de caractere 'DA') şi îl va \nînlocui cu primul caracter (adică tot cu caracterul 'D') din cel de-al \ntreilea argument al funcţiei (şirul de caractere 'D'), apoi va căuta \ncel de-al doilea caracter, adică caracterul 'A', şi îl va şterge din \ncâmpul nume deoarece acesta nu are caracter corespondent în \ncel de-al treilea argument al funcţiei. \n  Am folosit acest artificiu deoarece şirul de caractere vid este \nechivalent cu valoarea Null, deci funcţia TRANSLATE (nume, 'A', ' \n') ar fi înlocuit toate valorile câmpului “nume” cu valoarea Null.\nCurs 4 - BAZE DE DATE 31\n4.2.1. Funcţii pentru şiruri de caractere\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 32\n\nAceste funcţii au ca argumente date de tip \nNUMBER şi returnează date de tip numeric.\nCurs 4 - BAZE DE DATE 33\n4.2.2. Funcţii de tip numeric"", '\n', '4. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '5. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '6. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '7. ', ""4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14\n\n4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15\n\n4.3. Funcții de grup\nDISTINCT face ca funcţia să ignore valorile duplicat. \nALL face ca funcţia să afişeze şi valorile duplicat. \nValoarea implicită este ALL, deci nu este necesar să \nfie specificată.\n  Tipul de dată returnat de funcţia expr poate fi \nCHAR, VARCHAR2, NUMBER sau DATE.\n  Toate funcţiile de grup ignoră valorile nule. \nPentru a lua în considerare şi valorile nule se \nfolosesc funcţiile NVL, NVL2 sau COALESCE.\nCurs 5 - BAZE DE DATE 16\n\n4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17\n\n4.3. Funcții de grup\nExemplul 1: Afişarea salariului mediu, maxim, minim şi \nsuma tuturor salariilor angajaţilor cu funcţie SALESMAN. \nSELECT AVG(sal), MAX(sal), MIN(sal), SUM(sal)\nFROM EMP\nWHERE job = 'SALESMAN';\nCurs 5 - BAZE DE DATE 18\n\n\n4.3. Funcții de grup\nExemplul 2 - Datele la care s-au făcut prima şi ultima \nangajare.\nSELECT MIN(hiredate), MAX(hiredate)\nFROM EMP; \nCurs 5 - BAZE DE DATE 19\n\n\n4.3. Funcții de grup\nExemplul 3 - Primul şi ultimul nume de angajat în \nordine alfabetică:\nSELECT MIN(ename), MAX(ename)\nFROM EMP;\nCurs 5 - BAZE DE DATE 20\n\n\n4.3. Funcții de grup\nFuncţia COUNT \nFuncţia COUNT are 3 formate: \nCOUNT(*) \nCOUNT(expr) \nCOUNT(DISTINCT expr)\nCurs 5 - BAZE DE DATE 21\n\n4.3. Funcții de grup\n•COUNT(*) întoarce numărul de rânduri dintr-o tabela \ncare satisface criteriul de selecţie, incluzând rândurile \nduplicat şi rândurile conţinând valori nule.\n•Dacă clauza WHERE este introdusă, atunci COUNT(*) \nreturnează numărul de rânduri care satisfac condiţia \ndin clauza WHERE.\nCurs 5 - BAZE DE DATE 22"", '\n', '8. ', ""4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14\n\n4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15\n\n4.3. Funcții de grup\nDISTINCT face ca funcţia să ignore valorile duplicat. \nALL face ca funcţia să afişeze şi valorile duplicat. \nValoarea implicită este ALL, deci nu este necesar să \nfie specificată.\n  Tipul de dată returnat de funcţia expr poate fi \nCHAR, VARCHAR2, NUMBER sau DATE.\n  Toate funcţiile de grup ignoră valorile nule. \nPentru a lua în considerare şi valorile nule se \nfolosesc funcţiile NVL, NVL2 sau COALESCE.\nCurs 5 - BAZE DE DATE 16\n\n4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17\n\n4.3. Funcții de grup\nExemplul 1: Afişarea salariului mediu, maxim, minim şi \nsuma tuturor salariilor angajaţilor cu funcţie SALESMAN. \nSELECT AVG(sal), MAX(sal), MIN(sal), SUM(sal)\nFROM EMP\nWHERE job = 'SALESMAN';\nCurs 5 - BAZE DE DATE 18\n\n\n4.3. Funcții de grup\nExemplul 2 - Datele la care s-au făcut prima şi ultima \nangajare.\nSELECT MIN(hiredate), MAX(hiredate)\nFROM EMP; \nCurs 5 - BAZE DE DATE 19\n\n\n4.3. Funcții de grup\nExemplul 3 - Primul şi ultimul nume de angajat în \nordine alfabetică:\nSELECT MIN(ename), MAX(ename)\nFROM EMP;\nCurs 5 - BAZE DE DATE 20\n\n\n4.3. Funcții de grup\nFuncţia COUNT \nFuncţia COUNT are 3 formate: \nCOUNT(*) \nCOUNT(expr) \nCOUNT(DISTINCT expr)\nCurs 5 - BAZE DE DATE 21\n\n4.3. Funcții de grup\n•COUNT(*) întoarce numărul de rânduri dintr-o tabela \ncare satisface criteriul de selecţie, incluzând rândurile \nduplicat şi rândurile conţinând valori nule.\n•Dacă clauza WHERE este introdusă, atunci COUNT(*) \nreturnează numărul de rânduri care satisfac condiţia \ndin clauza WHERE.\nCurs 5 - BAZE DE DATE 22"", '\n', '9. ', ""4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14\n\n4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15\n\n4.3. Funcții de grup\nDISTINCT face ca funcţia să ignore valorile duplicat. \nALL face ca funcţia să afişeze şi valorile duplicat. \nValoarea implicită este ALL, deci nu este necesar să \nfie specificată.\n  Tipul de dată returnat de funcţia expr poate fi \nCHAR, VARCHAR2, NUMBER sau DATE.\n  Toate funcţiile de grup ignoră valorile nule. \nPentru a lua în considerare şi valorile nule se \nfolosesc funcţiile NVL, NVL2 sau COALESCE.\nCurs 5 - BAZE DE DATE 16\n\n4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17\n\n4.3. Funcții de grup\nExemplul 1: Afişarea salariului mediu, maxim, minim şi \nsuma tuturor salariilor angajaţilor cu funcţie SALESMAN. \nSELECT AVG(sal), MAX(sal), MIN(sal), SUM(sal)\nFROM EMP\nWHERE job = 'SALESMAN';\nCurs 5 - BAZE DE DATE 18\n\n\n4.3. Funcții de grup\nExemplul 2 - Datele la care s-au făcut prima şi ultima \nangajare.\nSELECT MIN(hiredate), MAX(hiredate)\nFROM EMP; \nCurs 5 - BAZE DE DATE 19\n\n\n4.3. Funcții de grup\nExemplul 3 - Primul şi ultimul nume de angajat în \nordine alfabetică:\nSELECT MIN(ename), MAX(ename)\nFROM EMP;\nCurs 5 - BAZE DE DATE 20\n\n\n4.3. Funcții de grup\nFuncţia COUNT \nFuncţia COUNT are 3 formate: \nCOUNT(*) \nCOUNT(expr) \nCOUNT(DISTINCT expr)\nCurs 5 - BAZE DE DATE 21\n\n4.3. Funcții de grup\n•COUNT(*) întoarce numărul de rânduri dintr-o tabela \ncare satisface criteriul de selecţie, incluzând rândurile \nduplicat şi rândurile conţinând valori nule.\n•Dacă clauza WHERE este introdusă, atunci COUNT(*) \nreturnează numărul de rânduri care satisfac condiţia \ndin clauza WHERE.\nCurs 5 - BAZE DE DATE 22"", '\n', '10. ', ""4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia ADD_MONTHS - exemplu:\nSELECT ADD_MONTHS(SYSDATE,3)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 49\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia LAST_DAY- exemplu:\nSELECT LAST_DAY(SYSDATE)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 50\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia MONTHS_BETWEEN - exemplu:\nSELECT MONTHS_BETWEEN (HIREDATE, \nSYSDATE)\nFROM EMP;\nRezultatul va fi un numar negativ, \ndeoarece primul parametru este o \ndata calendaristica mai mica decat al \ndoilea parametru.\nCurs 4 - BAZE DE DATE 51\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia MONTHS_BETWEEN -\nexemplu:\nSELECT MONTHS_BETWEEN \n(SYSDATE, HIREDATE)\nFROM EMP;\nPentru a afisa o valoare pozitiva, se \npot inversa cei doi parametri:\nCurs 4 - BAZE DE DATE 52\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia NEXT_DAY - exemplu:\nSELECT SYSDATE, NEXT_DAY(SYSDATE,6), \nNEXT_DAY(SYSDATE,'FRIDAY')\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 53\n\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 54\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\n4.2.4. Funcţii de conversie dintr-un tip în altul\nAceste funcţii au ca argumente date de tip DATE, \nNUMBER, CHAR şi returnează date de tip \nDATE, NUMBER, CHAR.\nCurs 4 - BAZE DE DATE 55\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\nFuncţiile de conversie din Oracle se pot folosi \npentru a converti diverse formate:\na)Conversia din dată calendaristică în şir de \ncaractere\nb)Conversia din şir de caractere în dată \ncalendaristică\nc) Conversia din număr în şir de caractere\nd)Conversia din şir de caractere în număr\nCurs 4 - BAZE DE DATE 56\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\na) Conversia din dată calendaristică în şir de \ncaractere\nConversia unei date calendaristice în şir de \ncaractere se poate realiza cu ajutorul funcţiei \nTO_CHAR. \nCurs 4 - BAZE DE DATE 57\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\na) Conversia din dată calendaristică în şir de \ncaractere\nSintaxa acestei funcţii este: TO_CHAR (dt, format)\ndt poate avea unul din tipurile pentru date \ncalendatistice:\n1. DATE, TIMESTAMP\n2. TIMESTAMP WITH TIME ZONE\n3. TIMESTAMP \n4. WITH LOCAL TIME ZONE \n5. INTERVAL MONTH TO YEAR\n6. INTERVAL DAY TO SECOND\nCurs 4 - BAZE DE DATE 58"", '\n']","funcțiile UPPER, LOWER și INITCAP pot fi utilizate pentru manipularea șirurilor de caractere și în condițiile din clauza WHERE astfel:

*   **UPPER(șir):** Convertește toate caracterele din șir în majuscule. Util în clauza WHERE pentru a face comparații case-insensitive (indiferent de majuscule/minuscule).
    Exemplu: `SELECT * FROM EMP WHERE UPPER(ename) = 'MARTIN';`

*    **LOWER(șir):** Convertește caracterele in minuscule.

*   **INITCAP(șir):** Convertește prima literă a fiecărui cuvânt din șir în majusculă, iar restul în minuscule.
    Exemplu: `SELECT * FROM EMP WHERE INITCAP(ename) = 'Smith';`
","Funcțiile UPPER, LOWER și INITCAP transformă șirurile pentru o comparare uniformă. De exemplu, „SELECT empno, UPPER(ename) FROM EMP WHERE INITCAP(ename) = 'Smith'” asigură că literele sunt comparate indiferent de caz, facilitând filtrarea corectă a datelor.",0.4249999999858333,1.0,0.8901861193132182,1.0,0.11103047724581815,0.28346456692913385,0.61
32,O3mini-high,High,"C6, C3",C5,Explicați mecanismul de execuție al unei subinterogări single-row și integrarea acesteia în clauza WHERE.,"O subinterogare single-row se execută înaintea interogării principale, returnând o valoare unică folosită în condiția WHERE. Exemplu: „WHERE sal > (SELECT sal FROM EMP WHERE ename = 'SMITH')” – fiecare salariu este comparat cu valoarea unică obținută din subquery.",Este corect,"C6, slide 11","['1. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '2. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '3. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '4. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Are facilităţi de salvare/restaurare automate şi \ninteligente\n• Permite partiţionarea integrală pentru tabele şi indecşi\n• Are mesagerie integrală, prin comunicarea între \naplicaţii şi procesare offline (chiar dacă aplicaţiile nu \nsunt conectate)\n• Prelucrarea paralelă pentru: \n– replicare\n– cereri de regăsire\n– actualizare\n10SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oferă facilităţi din tehnologia OO, prin care se permite \ndefinirea şi utilizarea de obiecte mari şi complexe\n• Optimizează cererile de regăsire prin reutilizarea \ncomenzilor SQL identice lansate de utilizatori diferiţi şi \nprin realizarea unui plan de execuţie a instrucţiunilor \nSQL\n• Are un grad de securitate sporit prin: \n– server de criptare\n– control trafic reţea\n– niveluri de parolare, etc.\n11SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Permite lucrul cu depozite de date (Data Warehouse) \ncare conţin date multidimensionale (cu tehnologia \nOLAP)\n• Conţine foarte multe produse ceea ce-l face să fie o \nplatformă pentru baze de date:\n– servere (Oracle 8, Application, Security, Internet Commerce, \netc)\n– instrumente (Designer, Developer, Express, WebDB, etc)\n– aplicaţii (Financials, Projects, Market Manager, \nManufacturing, etc)\n12SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Este primul SGBD pentru Internet cu server Java inclus\n• Reduce drastic costurile pentru realizarea unei aplicaţii \n(de circa 10 ori faţă de versiunea anterioară)\n• Este o platformă multiplă permiţând lucrul pe orice \ncalculator, orice sistem de operare, orice aplicaţie, \norice utilizator\n13SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Are instrumente diverse pentru dezvoltarea aplicaţiilor: \n✓bazate pe modelare (Designer, Developer, Application Server)\n✓bazate pe componente (Java)\n✓bazate pe HTML (browsere, editoare Web) şi XML\n✓prin programare: \n✓proceduri stocate (PL/SQL, Java)\n✓obiecte standard\n✓obiecte ODBC\n✓obiecte JDBC\n✓fraze SQL\n✓tip internet WebDB\n14SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nUlterior a fost lansat sistemul Oracle 9i care a \nmarcat trecerea la o nouă generaţie de servicii \ninternet. \nEl este mai mult decât un suport pentru baze de \ndate deoarece oferă o infrastructură completă de \nsoftware pentru afaceri electronice (e-business) şi \nrulează pe o varietate de sisteme de calcul şi de \noperare: \n➢ SUN-SOLARIS \n➢ HP-Unix\n➢ IBM-AIX\n➢ PC_WINDOWS\n➢ LINUX\n15\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16', '\n', '5. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Are facilităţi de salvare/restaurare automate şi \ninteligente\n• Permite partiţionarea integrală pentru tabele şi indecşi\n• Are mesagerie integrală, prin comunicarea între \naplicaţii şi procesare offline (chiar dacă aplicaţiile nu \nsunt conectate)\n• Prelucrarea paralelă pentru: \n– replicare\n– cereri de regăsire\n– actualizare\n10SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oferă facilităţi din tehnologia OO, prin care se permite \ndefinirea şi utilizarea de obiecte mari şi complexe\n• Optimizează cererile de regăsire prin reutilizarea \ncomenzilor SQL identice lansate de utilizatori diferiţi şi \nprin realizarea unui plan de execuţie a instrucţiunilor \nSQL\n• Are un grad de securitate sporit prin: \n– server de criptare\n– control trafic reţea\n– niveluri de parolare, etc.\n11SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Permite lucrul cu depozite de date (Data Warehouse) \ncare conţin date multidimensionale (cu tehnologia \nOLAP)\n• Conţine foarte multe produse ceea ce-l face să fie o \nplatformă pentru baze de date:\n– servere (Oracle 8, Application, Security, Internet Commerce, \netc)\n– instrumente (Designer, Developer, Express, WebDB, etc)\n– aplicaţii (Financials, Projects, Market Manager, \nManufacturing, etc)\n12SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Este primul SGBD pentru Internet cu server Java inclus\n• Reduce drastic costurile pentru realizarea unei aplicaţii \n(de circa 10 ori faţă de versiunea anterioară)\n• Este o platformă multiplă permiţând lucrul pe orice \ncalculator, orice sistem de operare, orice aplicaţie, \norice utilizator\n13SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Are instrumente diverse pentru dezvoltarea aplicaţiilor: \n✓bazate pe modelare (Designer, Developer, Application Server)\n✓bazate pe componente (Java)\n✓bazate pe HTML (browsere, editoare Web) şi XML\n✓prin programare: \n✓proceduri stocate (PL/SQL, Java)\n✓obiecte standard\n✓obiecte ODBC\n✓obiecte JDBC\n✓fraze SQL\n✓tip internet WebDB\n14SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nUlterior a fost lansat sistemul Oracle 9i care a \nmarcat trecerea la o nouă generaţie de servicii \ninternet. \nEl este mai mult decât un suport pentru baze de \ndate deoarece oferă o infrastructură completă de \nsoftware pentru afaceri electronice (e-business) şi \nrulează pe o varietate de sisteme de calcul şi de \noperare: \n➢ SUN-SOLARIS \n➢ HP-Unix\n➢ IBM-AIX\n➢ PC_WINDOWS\n➢ LINUX\n15\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16', '\n', '6. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Are facilităţi de salvare/restaurare automate şi \ninteligente\n• Permite partiţionarea integrală pentru tabele şi indecşi\n• Are mesagerie integrală, prin comunicarea între \naplicaţii şi procesare offline (chiar dacă aplicaţiile nu \nsunt conectate)\n• Prelucrarea paralelă pentru: \n– replicare\n– cereri de regăsire\n– actualizare\n10SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oferă facilităţi din tehnologia OO, prin care se permite \ndefinirea şi utilizarea de obiecte mari şi complexe\n• Optimizează cererile de regăsire prin reutilizarea \ncomenzilor SQL identice lansate de utilizatori diferiţi şi \nprin realizarea unui plan de execuţie a instrucţiunilor \nSQL\n• Are un grad de securitate sporit prin: \n– server de criptare\n– control trafic reţea\n– niveluri de parolare, etc.\n11SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Permite lucrul cu depozite de date (Data Warehouse) \ncare conţin date multidimensionale (cu tehnologia \nOLAP)\n• Conţine foarte multe produse ceea ce-l face să fie o \nplatformă pentru baze de date:\n– servere (Oracle 8, Application, Security, Internet Commerce, \netc)\n– instrumente (Designer, Developer, Express, WebDB, etc)\n– aplicaţii (Financials, Projects, Market Manager, \nManufacturing, etc)\n12SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Este primul SGBD pentru Internet cu server Java inclus\n• Reduce drastic costurile pentru realizarea unei aplicaţii \n(de circa 10 ori faţă de versiunea anterioară)\n• Este o platformă multiplă permiţând lucrul pe orice \ncalculator, orice sistem de operare, orice aplicaţie, \norice utilizator\n13SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Are instrumente diverse pentru dezvoltarea aplicaţiilor: \n✓bazate pe modelare (Designer, Developer, Application Server)\n✓bazate pe componente (Java)\n✓bazate pe HTML (browsere, editoare Web) şi XML\n✓prin programare: \n✓proceduri stocate (PL/SQL, Java)\n✓obiecte standard\n✓obiecte ODBC\n✓obiecte JDBC\n✓fraze SQL\n✓tip internet WebDB\n14SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nUlterior a fost lansat sistemul Oracle 9i care a \nmarcat trecerea la o nouă generaţie de servicii \ninternet. \nEl este mai mult decât un suport pentru baze de \ndate deoarece oferă o infrastructură completă de \nsoftware pentru afaceri electronice (e-business) şi \nrulează pe o varietate de sisteme de calcul şi de \noperare: \n➢ SUN-SOLARIS \n➢ HP-Unix\n➢ IBM-AIX\n➢ PC_WINDOWS\n➢ LINUX\n15\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16', '\n', '7. ', 'FOREIGN KEY (CursID) REFERENCES Curs(ID) \n); \n \nExplicație: \n➢ Student și Curs sunt entități separate, evitând redundanța datelor. \n➢ Inscriere leagă studenții de cursuri prin referințe, menținând integritatea datelor. \n \nScenariul 3: Sistem de gestionare a rezervărilor la un hotel \nDescriere: \nUn hotel stochează toate rezervările într-un singur tabel care include informații despre clienți, \ncamere și durata șederii. \nCerințe pentru normalizare: \n1. Crearea unui tabel Client pentru a reține informațiile clienților. \n2. Crearea unui tabel Camera pentru a stoca detalii despre camere. \n3. Crearea unui tabel Rezervare pentru a înregistra fiecare rezervare și a evita redundanțele. \n \nScenariul 4: Sistem de gestionare a angajaților și departamentelor într-o companie \nDescriere: \nO companie păstrează într-un tabel unic date despre angajați, departamente și salarii, ceea ce \nduce la redundanță și anomalii la actualizare. \nCerințe pentru normalizare: \n1. Separarea angajaților și departamentelor în tabele distincte. \n2. Crearea unui tabel Plata pentru a înregistra salariile și a menține consistența. \n \nScenariul 5: Sistem de gestionare a pacienților într-un spital \nDescriere: \nUn spital înregistrează pacienți, doctori și tratamente într-un singur tabel, ceea ce creează \nprobleme de integritate a datelor. \nCerințe pentru normalizare: \n1. Crearea unui tabel Pacient pentru a stoca datele pacienților. \n2. Crearea unui tabel Doctor pentru informațiile despre medici. \n3. Crearea unui tabel Consultatie care să lege pacienții, doctorii și tratamentele administrate. \n \n \nReferințe și resurse web \n1) Connolly, T. & Begg, C. (2014). Database Systems: A Practical Approach to Design, \nImplementation, and Management. Pearson. \n2) Silberschatz, A., Korth, H., & Sudarshan, S. (2020). Database System Concepts. McGraw-\nHill. \n3) Elmasri, R., & Navathe, S. (2016). Fundamentals of Database Systems. Pearson. \n4) W3Schools SQL Tutorial \n5) MongoDB Documentation \n6) PostgreSQL Documentation \n7) Redis Documentation', '\n', '8. ', 'FOREIGN KEY (CursID) REFERENCES Curs(ID) \n); \n \nExplicație: \n➢ Student și Curs sunt entități separate, evitând redundanța datelor. \n➢ Inscriere leagă studenții de cursuri prin referințe, menținând integritatea datelor. \n \nScenariul 3: Sistem de gestionare a rezervărilor la un hotel \nDescriere: \nUn hotel stochează toate rezervările într-un singur tabel care include informații despre clienți, \ncamere și durata șederii. \nCerințe pentru normalizare: \n1. Crearea unui tabel Client pentru a reține informațiile clienților. \n2. Crearea unui tabel Camera pentru a stoca detalii despre camere. \n3. Crearea unui tabel Rezervare pentru a înregistra fiecare rezervare și a evita redundanțele. \n \nScenariul 4: Sistem de gestionare a angajaților și departamentelor într-o companie \nDescriere: \nO companie păstrează într-un tabel unic date despre angajați, departamente și salarii, ceea ce \nduce la redundanță și anomalii la actualizare. \nCerințe pentru normalizare: \n1. Separarea angajaților și departamentelor în tabele distincte. \n2. Crearea unui tabel Plata pentru a înregistra salariile și a menține consistența. \n \nScenariul 5: Sistem de gestionare a pacienților într-un spital \nDescriere: \nUn spital înregistrează pacienți, doctori și tratamente într-un singur tabel, ceea ce creează \nprobleme de integritate a datelor. \nCerințe pentru normalizare: \n1. Crearea unui tabel Pacient pentru a stoca datele pacienților. \n2. Crearea unui tabel Doctor pentru informațiile despre medici. \n3. Crearea unui tabel Consultatie care să lege pacienții, doctorii și tratamentele administrate. \n \n \nReferințe și resurse web \n1) Connolly, T. & Begg, C. (2014). Database Systems: A Practical Approach to Design, \nImplementation, and Management. Pearson. \n2) Silberschatz, A., Korth, H., & Sudarshan, S. (2020). Database System Concepts. McGraw-\nHill. \n3) Elmasri, R., & Navathe, S. (2016). Fundamentals of Database Systems. Pearson. \n4) W3Schools SQL Tutorial \n5) MongoDB Documentation \n6) PostgreSQL Documentation \n7) Redis Documentation', '\n', '9. ', 'FOREIGN KEY (CursID) REFERENCES Curs(ID) \n); \n \nExplicație: \n➢ Student și Curs sunt entități separate, evitând redundanța datelor. \n➢ Inscriere leagă studenții de cursuri prin referințe, menținând integritatea datelor. \n \nScenariul 3: Sistem de gestionare a rezervărilor la un hotel \nDescriere: \nUn hotel stochează toate rezervările într-un singur tabel care include informații despre clienți, \ncamere și durata șederii. \nCerințe pentru normalizare: \n1. Crearea unui tabel Client pentru a reține informațiile clienților. \n2. Crearea unui tabel Camera pentru a stoca detalii despre camere. \n3. Crearea unui tabel Rezervare pentru a înregistra fiecare rezervare și a evita redundanțele. \n \nScenariul 4: Sistem de gestionare a angajaților și departamentelor într-o companie \nDescriere: \nO companie păstrează într-un tabel unic date despre angajați, departamente și salarii, ceea ce \nduce la redundanță și anomalii la actualizare. \nCerințe pentru normalizare: \n1. Separarea angajaților și departamentelor în tabele distincte. \n2. Crearea unui tabel Plata pentru a înregistra salariile și a menține consistența. \n \nScenariul 5: Sistem de gestionare a pacienților într-un spital \nDescriere: \nUn spital înregistrează pacienți, doctori și tratamente într-un singur tabel, ceea ce creează \nprobleme de integritate a datelor. \nCerințe pentru normalizare: \n1. Crearea unui tabel Pacient pentru a stoca datele pacienților. \n2. Crearea unui tabel Doctor pentru informațiile despre medici. \n3. Crearea unui tabel Consultatie care să lege pacienții, doctorii și tratamentele administrate. \n \n \nReferințe și resurse web \n1) Connolly, T. & Begg, C. (2014). Database Systems: A Practical Approach to Design, \nImplementation, and Management. Pearson. \n2) Silberschatz, A., Korth, H., & Sudarshan, S. (2020). Database System Concepts. McGraw-\nHill. \n3) Elmasri, R., & Navathe, S. (2016). Fundamentals of Database Systems. Pearson. \n4) W3Schools SQL Tutorial \n5) MongoDB Documentation \n6) PostgreSQL Documentation \n7) Redis Documentation', '\n']","mecanismul de execuție al unei subinterogări single-row implică următorii pași:

1.  **Execuția cererilor interne:** Blocurile de cereri interne sunt executate primele, returnând valori singulare.
2.  **Procesarea cererii exterioare:** Blocul exterior de cereri este procesat, folosind valorile returnate de cererile interne pentru a finaliza condițiile de căutare.

Subinterogările single-row sunt integrate în clauza WHERE (sau HAVING) și trebuie să returneze o singură valoare. Exemplu:

```sql
SELECT ename, job
FROM  EMP
WHERE job = 
            (SELECT job          
              FROM EMP        
              WHERE empno = 7369)
            AND  sal > 
           ( SELECT  sal
             FROM     EMP
             WHERE  empno = 7876 );
```

În acest exemplu, subinterogările `(SELECT job FROM EMP WHERE empno = 7369)` și `(SELECT sal FROM EMP WHERE empno = 7876)` sunt executate primele, iar rezultatele lor sunt folosite în condiția WHERE a interogării exterioare.
",Explicați mecanismul de execuție al unei subinterogări single-row și integrarea acesteia în clauza WHERE.,"['1. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '2. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '3. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '4. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Are facilităţi de salvare/restaurare automate şi \ninteligente\n• Permite partiţionarea integrală pentru tabele şi indecşi\n• Are mesagerie integrală, prin comunicarea între \naplicaţii şi procesare offline (chiar dacă aplicaţiile nu \nsunt conectate)\n• Prelucrarea paralelă pentru: \n– replicare\n– cereri de regăsire\n– actualizare\n10SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oferă facilităţi din tehnologia OO, prin care se permite \ndefinirea şi utilizarea de obiecte mari şi complexe\n• Optimizează cererile de regăsire prin reutilizarea \ncomenzilor SQL identice lansate de utilizatori diferiţi şi \nprin realizarea unui plan de execuţie a instrucţiunilor \nSQL\n• Are un grad de securitate sporit prin: \n– server de criptare\n– control trafic reţea\n– niveluri de parolare, etc.\n11SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Permite lucrul cu depozite de date (Data Warehouse) \ncare conţin date multidimensionale (cu tehnologia \nOLAP)\n• Conţine foarte multe produse ceea ce-l face să fie o \nplatformă pentru baze de date:\n– servere (Oracle 8, Application, Security, Internet Commerce, \netc)\n– instrumente (Designer, Developer, Express, WebDB, etc)\n– aplicaţii (Financials, Projects, Market Manager, \nManufacturing, etc)\n12SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Este primul SGBD pentru Internet cu server Java inclus\n• Reduce drastic costurile pentru realizarea unei aplicaţii \n(de circa 10 ori faţă de versiunea anterioară)\n• Este o platformă multiplă permiţând lucrul pe orice \ncalculator, orice sistem de operare, orice aplicaţie, \norice utilizator\n13SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Are instrumente diverse pentru dezvoltarea aplicaţiilor: \n✓bazate pe modelare (Designer, Developer, Application Server)\n✓bazate pe componente (Java)\n✓bazate pe HTML (browsere, editoare Web) şi XML\n✓prin programare: \n✓proceduri stocate (PL/SQL, Java)\n✓obiecte standard\n✓obiecte ODBC\n✓obiecte JDBC\n✓fraze SQL\n✓tip internet WebDB\n14SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nUlterior a fost lansat sistemul Oracle 9i care a \nmarcat trecerea la o nouă generaţie de servicii \ninternet. \nEl este mai mult decât un suport pentru baze de \ndate deoarece oferă o infrastructură completă de \nsoftware pentru afaceri electronice (e-business) şi \nrulează pe o varietate de sisteme de calcul şi de \noperare: \n➢ SUN-SOLARIS \n➢ HP-Unix\n➢ IBM-AIX\n➢ PC_WINDOWS\n➢ LINUX\n15\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16', '\n', '5. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Are facilităţi de salvare/restaurare automate şi \ninteligente\n• Permite partiţionarea integrală pentru tabele şi indecşi\n• Are mesagerie integrală, prin comunicarea între \naplicaţii şi procesare offline (chiar dacă aplicaţiile nu \nsunt conectate)\n• Prelucrarea paralelă pentru: \n– replicare\n– cereri de regăsire\n– actualizare\n10SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oferă facilităţi din tehnologia OO, prin care se permite \ndefinirea şi utilizarea de obiecte mari şi complexe\n• Optimizează cererile de regăsire prin reutilizarea \ncomenzilor SQL identice lansate de utilizatori diferiţi şi \nprin realizarea unui plan de execuţie a instrucţiunilor \nSQL\n• Are un grad de securitate sporit prin: \n– server de criptare\n– control trafic reţea\n– niveluri de parolare, etc.\n11SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Permite lucrul cu depozite de date (Data Warehouse) \ncare conţin date multidimensionale (cu tehnologia \nOLAP)\n• Conţine foarte multe produse ceea ce-l face să fie o \nplatformă pentru baze de date:\n– servere (Oracle 8, Application, Security, Internet Commerce, \netc)\n– instrumente (Designer, Developer, Express, WebDB, etc)\n– aplicaţii (Financials, Projects, Market Manager, \nManufacturing, etc)\n12SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Este primul SGBD pentru Internet cu server Java inclus\n• Reduce drastic costurile pentru realizarea unei aplicaţii \n(de circa 10 ori faţă de versiunea anterioară)\n• Este o platformă multiplă permiţând lucrul pe orice \ncalculator, orice sistem de operare, orice aplicaţie, \norice utilizator\n13SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Are instrumente diverse pentru dezvoltarea aplicaţiilor: \n✓bazate pe modelare (Designer, Developer, Application Server)\n✓bazate pe componente (Java)\n✓bazate pe HTML (browsere, editoare Web) şi XML\n✓prin programare: \n✓proceduri stocate (PL/SQL, Java)\n✓obiecte standard\n✓obiecte ODBC\n✓obiecte JDBC\n✓fraze SQL\n✓tip internet WebDB\n14SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nUlterior a fost lansat sistemul Oracle 9i care a \nmarcat trecerea la o nouă generaţie de servicii \ninternet. \nEl este mai mult decât un suport pentru baze de \ndate deoarece oferă o infrastructură completă de \nsoftware pentru afaceri electronice (e-business) şi \nrulează pe o varietate de sisteme de calcul şi de \noperare: \n➢ SUN-SOLARIS \n➢ HP-Unix\n➢ IBM-AIX\n➢ PC_WINDOWS\n➢ LINUX\n15\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16', '\n', '6. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Are facilităţi de salvare/restaurare automate şi \ninteligente\n• Permite partiţionarea integrală pentru tabele şi indecşi\n• Are mesagerie integrală, prin comunicarea între \naplicaţii şi procesare offline (chiar dacă aplicaţiile nu \nsunt conectate)\n• Prelucrarea paralelă pentru: \n– replicare\n– cereri de regăsire\n– actualizare\n10SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oferă facilităţi din tehnologia OO, prin care se permite \ndefinirea şi utilizarea de obiecte mari şi complexe\n• Optimizează cererile de regăsire prin reutilizarea \ncomenzilor SQL identice lansate de utilizatori diferiţi şi \nprin realizarea unui plan de execuţie a instrucţiunilor \nSQL\n• Are un grad de securitate sporit prin: \n– server de criptare\n– control trafic reţea\n– niveluri de parolare, etc.\n11SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Permite lucrul cu depozite de date (Data Warehouse) \ncare conţin date multidimensionale (cu tehnologia \nOLAP)\n• Conţine foarte multe produse ceea ce-l face să fie o \nplatformă pentru baze de date:\n– servere (Oracle 8, Application, Security, Internet Commerce, \netc)\n– instrumente (Designer, Developer, Express, WebDB, etc)\n– aplicaţii (Financials, Projects, Market Manager, \nManufacturing, etc)\n12SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Este primul SGBD pentru Internet cu server Java inclus\n• Reduce drastic costurile pentru realizarea unei aplicaţii \n(de circa 10 ori faţă de versiunea anterioară)\n• Este o platformă multiplă permiţând lucrul pe orice \ncalculator, orice sistem de operare, orice aplicaţie, \norice utilizator\n13SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Are instrumente diverse pentru dezvoltarea aplicaţiilor: \n✓bazate pe modelare (Designer, Developer, Application Server)\n✓bazate pe componente (Java)\n✓bazate pe HTML (browsere, editoare Web) şi XML\n✓prin programare: \n✓proceduri stocate (PL/SQL, Java)\n✓obiecte standard\n✓obiecte ODBC\n✓obiecte JDBC\n✓fraze SQL\n✓tip internet WebDB\n14SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nUlterior a fost lansat sistemul Oracle 9i care a \nmarcat trecerea la o nouă generaţie de servicii \ninternet. \nEl este mai mult decât un suport pentru baze de \ndate deoarece oferă o infrastructură completă de \nsoftware pentru afaceri electronice (e-business) şi \nrulează pe o varietate de sisteme de calcul şi de \noperare: \n➢ SUN-SOLARIS \n➢ HP-Unix\n➢ IBM-AIX\n➢ PC_WINDOWS\n➢ LINUX\n15\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16', '\n', '7. ', 'FOREIGN KEY (CursID) REFERENCES Curs(ID) \n); \n \nExplicație: \n➢ Student și Curs sunt entități separate, evitând redundanța datelor. \n➢ Inscriere leagă studenții de cursuri prin referințe, menținând integritatea datelor. \n \nScenariul 3: Sistem de gestionare a rezervărilor la un hotel \nDescriere: \nUn hotel stochează toate rezervările într-un singur tabel care include informații despre clienți, \ncamere și durata șederii. \nCerințe pentru normalizare: \n1. Crearea unui tabel Client pentru a reține informațiile clienților. \n2. Crearea unui tabel Camera pentru a stoca detalii despre camere. \n3. Crearea unui tabel Rezervare pentru a înregistra fiecare rezervare și a evita redundanțele. \n \nScenariul 4: Sistem de gestionare a angajaților și departamentelor într-o companie \nDescriere: \nO companie păstrează într-un tabel unic date despre angajați, departamente și salarii, ceea ce \nduce la redundanță și anomalii la actualizare. \nCerințe pentru normalizare: \n1. Separarea angajaților și departamentelor în tabele distincte. \n2. Crearea unui tabel Plata pentru a înregistra salariile și a menține consistența. \n \nScenariul 5: Sistem de gestionare a pacienților într-un spital \nDescriere: \nUn spital înregistrează pacienți, doctori și tratamente într-un singur tabel, ceea ce creează \nprobleme de integritate a datelor. \nCerințe pentru normalizare: \n1. Crearea unui tabel Pacient pentru a stoca datele pacienților. \n2. Crearea unui tabel Doctor pentru informațiile despre medici. \n3. Crearea unui tabel Consultatie care să lege pacienții, doctorii și tratamentele administrate. \n \n \nReferințe și resurse web \n1) Connolly, T. & Begg, C. (2014). Database Systems: A Practical Approach to Design, \nImplementation, and Management. Pearson. \n2) Silberschatz, A., Korth, H., & Sudarshan, S. (2020). Database System Concepts. McGraw-\nHill. \n3) Elmasri, R., & Navathe, S. (2016). Fundamentals of Database Systems. Pearson. \n4) W3Schools SQL Tutorial \n5) MongoDB Documentation \n6) PostgreSQL Documentation \n7) Redis Documentation', '\n', '8. ', 'FOREIGN KEY (CursID) REFERENCES Curs(ID) \n); \n \nExplicație: \n➢ Student și Curs sunt entități separate, evitând redundanța datelor. \n➢ Inscriere leagă studenții de cursuri prin referințe, menținând integritatea datelor. \n \nScenariul 3: Sistem de gestionare a rezervărilor la un hotel \nDescriere: \nUn hotel stochează toate rezervările într-un singur tabel care include informații despre clienți, \ncamere și durata șederii. \nCerințe pentru normalizare: \n1. Crearea unui tabel Client pentru a reține informațiile clienților. \n2. Crearea unui tabel Camera pentru a stoca detalii despre camere. \n3. Crearea unui tabel Rezervare pentru a înregistra fiecare rezervare și a evita redundanțele. \n \nScenariul 4: Sistem de gestionare a angajaților și departamentelor într-o companie \nDescriere: \nO companie păstrează într-un tabel unic date despre angajați, departamente și salarii, ceea ce \nduce la redundanță și anomalii la actualizare. \nCerințe pentru normalizare: \n1. Separarea angajaților și departamentelor în tabele distincte. \n2. Crearea unui tabel Plata pentru a înregistra salariile și a menține consistența. \n \nScenariul 5: Sistem de gestionare a pacienților într-un spital \nDescriere: \nUn spital înregistrează pacienți, doctori și tratamente într-un singur tabel, ceea ce creează \nprobleme de integritate a datelor. \nCerințe pentru normalizare: \n1. Crearea unui tabel Pacient pentru a stoca datele pacienților. \n2. Crearea unui tabel Doctor pentru informațiile despre medici. \n3. Crearea unui tabel Consultatie care să lege pacienții, doctorii și tratamentele administrate. \n \n \nReferințe și resurse web \n1) Connolly, T. & Begg, C. (2014). Database Systems: A Practical Approach to Design, \nImplementation, and Management. Pearson. \n2) Silberschatz, A., Korth, H., & Sudarshan, S. (2020). Database System Concepts. McGraw-\nHill. \n3) Elmasri, R., & Navathe, S. (2016). Fundamentals of Database Systems. Pearson. \n4) W3Schools SQL Tutorial \n5) MongoDB Documentation \n6) PostgreSQL Documentation \n7) Redis Documentation', '\n', '9. ', 'FOREIGN KEY (CursID) REFERENCES Curs(ID) \n); \n \nExplicație: \n➢ Student și Curs sunt entități separate, evitând redundanța datelor. \n➢ Inscriere leagă studenții de cursuri prin referințe, menținând integritatea datelor. \n \nScenariul 3: Sistem de gestionare a rezervărilor la un hotel \nDescriere: \nUn hotel stochează toate rezervările într-un singur tabel care include informații despre clienți, \ncamere și durata șederii. \nCerințe pentru normalizare: \n1. Crearea unui tabel Client pentru a reține informațiile clienților. \n2. Crearea unui tabel Camera pentru a stoca detalii despre camere. \n3. Crearea unui tabel Rezervare pentru a înregistra fiecare rezervare și a evita redundanțele. \n \nScenariul 4: Sistem de gestionare a angajaților și departamentelor într-o companie \nDescriere: \nO companie păstrează într-un tabel unic date despre angajați, departamente și salarii, ceea ce \nduce la redundanță și anomalii la actualizare. \nCerințe pentru normalizare: \n1. Separarea angajaților și departamentelor în tabele distincte. \n2. Crearea unui tabel Plata pentru a înregistra salariile și a menține consistența. \n \nScenariul 5: Sistem de gestionare a pacienților într-un spital \nDescriere: \nUn spital înregistrează pacienți, doctori și tratamente într-un singur tabel, ceea ce creează \nprobleme de integritate a datelor. \nCerințe pentru normalizare: \n1. Crearea unui tabel Pacient pentru a stoca datele pacienților. \n2. Crearea unui tabel Doctor pentru informațiile despre medici. \n3. Crearea unui tabel Consultatie care să lege pacienții, doctorii și tratamentele administrate. \n \n \nReferințe și resurse web \n1) Connolly, T. & Begg, C. (2014). Database Systems: A Practical Approach to Design, \nImplementation, and Management. Pearson. \n2) Silberschatz, A., Korth, H., & Sudarshan, S. (2020). Database System Concepts. McGraw-\nHill. \n3) Elmasri, R., & Navathe, S. (2016). Fundamentals of Database Systems. Pearson. \n4) W3Schools SQL Tutorial \n5) MongoDB Documentation \n6) PostgreSQL Documentation \n7) Redis Documentation', '\n']","mecanismul de execuție al unei subinterogări single-row implică următorii pași:

1.  **Execuția cererilor interne:** Blocurile de cereri interne sunt executate primele, returnând valori singulare.
2.  **Procesarea cererii exterioare:** Blocul exterior de cereri este procesat, folosind valorile returnate de cererile interne pentru a finaliza condițiile de căutare.

Subinterogările single-row sunt integrate în clauza WHERE (sau HAVING) și trebuie să returneze o singură valoare. Exemplu:

```sql
SELECT ename, job
FROM  EMP
WHERE job = 
            (SELECT job          
              FROM EMP        
              WHERE empno = 7369)
            AND  sal > 
           ( SELECT  sal
             FROM     EMP
             WHERE  empno = 7876 );
```

În acest exemplu, subinterogările `(SELECT job FROM EMP WHERE empno = 7369)` și `(SELECT sal FROM EMP WHERE empno = 7876)` sunt executate primele, iar rezultatele lor sunt folosite în condiția WHERE a interogării exterioare.
","O subinterogare single-row se execută înaintea interogării principale, returnând o valoare unică folosită în condiția WHERE. Exemplu: „WHERE sal > (SELECT sal FROM EMP WHERE ename = 'SMITH')” – fiecare salariu este comparat cu valoarea unică obținută din subquery.",0.4249999999858333,1.0,0.8391591843272442,0.8571428571428571,0.02654925636345778,0.17142857142857143,0.62
33,O3mini-high,High,C7,"C3, C6",Cum se utilizează instrucțiunea UPDATE combinată cu subinterogări pentru a actualiza date selective?,UPDATE poate folosi o subinterogare pentru a seta valori. Exemplu: „UPDATE EMP SET sal = (SELECT AVG(sal) FROM EMP) WHERE deptno = 10” actualizează salariile din departamentul 10 cu media salarială calculată prin subquery.,Este corect,C7,"['1. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n', '2. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n', '3. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n', '4. ', ""4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia ADD_MONTHS - exemplu:\nSELECT ADD_MONTHS(SYSDATE,3)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 49\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia LAST_DAY- exemplu:\nSELECT LAST_DAY(SYSDATE)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 50\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia MONTHS_BETWEEN - exemplu:\nSELECT MONTHS_BETWEEN (HIREDATE, \nSYSDATE)\nFROM EMP;\nRezultatul va fi un numar negativ, \ndeoarece primul parametru este o \ndata calendaristica mai mica decat al \ndoilea parametru.\nCurs 4 - BAZE DE DATE 51\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia MONTHS_BETWEEN -\nexemplu:\nSELECT MONTHS_BETWEEN \n(SYSDATE, HIREDATE)\nFROM EMP;\nPentru a afisa o valoare pozitiva, se \npot inversa cei doi parametri:\nCurs 4 - BAZE DE DATE 52\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia NEXT_DAY - exemplu:\nSELECT SYSDATE, NEXT_DAY(SYSDATE,6), \nNEXT_DAY(SYSDATE,'FRIDAY')\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 53\n\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 54\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\n4.2.4. Funcţii de conversie dintr-un tip în altul\nAceste funcţii au ca argumente date de tip DATE, \nNUMBER, CHAR şi returnează date de tip \nDATE, NUMBER, CHAR.\nCurs 4 - BAZE DE DATE 55\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\nFuncţiile de conversie din Oracle se pot folosi \npentru a converti diverse formate:\na)Conversia din dată calendaristică în şir de \ncaractere\nb)Conversia din şir de caractere în dată \ncalendaristică\nc) Conversia din număr în şir de caractere\nd)Conversia din şir de caractere în număr\nCurs 4 - BAZE DE DATE 56\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\na) Conversia din dată calendaristică în şir de \ncaractere\nConversia unei date calendaristice în şir de \ncaractere se poate realiza cu ajutorul funcţiei \nTO_CHAR. \nCurs 4 - BAZE DE DATE 57\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\na) Conversia din dată calendaristică în şir de \ncaractere\nSintaxa acestei funcţii este: TO_CHAR (dt, format)\ndt poate avea unul din tipurile pentru date \ncalendatistice:\n1. DATE, TIMESTAMP\n2. TIMESTAMP WITH TIME ZONE\n3. TIMESTAMP \n4. WITH LOCAL TIME ZONE \n5. INTERVAL MONTH TO YEAR\n6. INTERVAL DAY TO SECOND\nCurs 4 - BAZE DE DATE 58"", '\n', '5. ', ""4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia ADD_MONTHS - exemplu:\nSELECT ADD_MONTHS(SYSDATE,3)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 49\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia LAST_DAY- exemplu:\nSELECT LAST_DAY(SYSDATE)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 50\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia MONTHS_BETWEEN - exemplu:\nSELECT MONTHS_BETWEEN (HIREDATE, \nSYSDATE)\nFROM EMP;\nRezultatul va fi un numar negativ, \ndeoarece primul parametru este o \ndata calendaristica mai mica decat al \ndoilea parametru.\nCurs 4 - BAZE DE DATE 51\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia MONTHS_BETWEEN -\nexemplu:\nSELECT MONTHS_BETWEEN \n(SYSDATE, HIREDATE)\nFROM EMP;\nPentru a afisa o valoare pozitiva, se \npot inversa cei doi parametri:\nCurs 4 - BAZE DE DATE 52\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia NEXT_DAY - exemplu:\nSELECT SYSDATE, NEXT_DAY(SYSDATE,6), \nNEXT_DAY(SYSDATE,'FRIDAY')\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 53\n\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 54\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\n4.2.4. Funcţii de conversie dintr-un tip în altul\nAceste funcţii au ca argumente date de tip DATE, \nNUMBER, CHAR şi returnează date de tip \nDATE, NUMBER, CHAR.\nCurs 4 - BAZE DE DATE 55\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\nFuncţiile de conversie din Oracle se pot folosi \npentru a converti diverse formate:\na)Conversia din dată calendaristică în şir de \ncaractere\nb)Conversia din şir de caractere în dată \ncalendaristică\nc) Conversia din număr în şir de caractere\nd)Conversia din şir de caractere în număr\nCurs 4 - BAZE DE DATE 56\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\na) Conversia din dată calendaristică în şir de \ncaractere\nConversia unei date calendaristice în şir de \ncaractere se poate realiza cu ajutorul funcţiei \nTO_CHAR. \nCurs 4 - BAZE DE DATE 57\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\na) Conversia din dată calendaristică în şir de \ncaractere\nSintaxa acestei funcţii este: TO_CHAR (dt, format)\ndt poate avea unul din tipurile pentru date \ncalendatistice:\n1. DATE, TIMESTAMP\n2. TIMESTAMP WITH TIME ZONE\n3. TIMESTAMP \n4. WITH LOCAL TIME ZONE \n5. INTERVAL MONTH TO YEAR\n6. INTERVAL DAY TO SECOND\nCurs 4 - BAZE DE DATE 58"", '\n', '6. ', ""4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia ADD_MONTHS - exemplu:\nSELECT ADD_MONTHS(SYSDATE,3)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 49\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia LAST_DAY- exemplu:\nSELECT LAST_DAY(SYSDATE)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 50\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia MONTHS_BETWEEN - exemplu:\nSELECT MONTHS_BETWEEN (HIREDATE, \nSYSDATE)\nFROM EMP;\nRezultatul va fi un numar negativ, \ndeoarece primul parametru este o \ndata calendaristica mai mica decat al \ndoilea parametru.\nCurs 4 - BAZE DE DATE 51\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia MONTHS_BETWEEN -\nexemplu:\nSELECT MONTHS_BETWEEN \n(SYSDATE, HIREDATE)\nFROM EMP;\nPentru a afisa o valoare pozitiva, se \npot inversa cei doi parametri:\nCurs 4 - BAZE DE DATE 52\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia NEXT_DAY - exemplu:\nSELECT SYSDATE, NEXT_DAY(SYSDATE,6), \nNEXT_DAY(SYSDATE,'FRIDAY')\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 53\n\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 54\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\n4.2.4. Funcţii de conversie dintr-un tip în altul\nAceste funcţii au ca argumente date de tip DATE, \nNUMBER, CHAR şi returnează date de tip \nDATE, NUMBER, CHAR.\nCurs 4 - BAZE DE DATE 55\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\nFuncţiile de conversie din Oracle se pot folosi \npentru a converti diverse formate:\na)Conversia din dată calendaristică în şir de \ncaractere\nb)Conversia din şir de caractere în dată \ncalendaristică\nc) Conversia din număr în şir de caractere\nd)Conversia din şir de caractere în număr\nCurs 4 - BAZE DE DATE 56\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\na) Conversia din dată calendaristică în şir de \ncaractere\nConversia unei date calendaristice în şir de \ncaractere se poate realiza cu ajutorul funcţiei \nTO_CHAR. \nCurs 4 - BAZE DE DATE 57\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\na) Conversia din dată calendaristică în şir de \ncaractere\nSintaxa acestei funcţii este: TO_CHAR (dt, format)\ndt poate avea unul din tipurile pentru date \ncalendatistice:\n1. DATE, TIMESTAMP\n2. TIMESTAMP WITH TIME ZONE\n3. TIMESTAMP \n4. WITH LOCAL TIME ZONE \n5. INTERVAL MONTH TO YEAR\n6. INTERVAL DAY TO SECOND\nCurs 4 - BAZE DE DATE 58"", '\n', '7. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '8. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '9. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '10. ', 'Extragere de date dintr-o vedere\n➢Extragerea de date se face exact ca în cazul \nunei tabele. \n➢Se pot selecta anumite rânduri sau toată \nvederea. \nSELECT * FROM emp10;\nCurs - BAZE DE DATE 26\n\n\nInterogarea unei vederi\nInterogarea unei vederi de către serverul \nORACLE se face în felul următor: \n1. Extragere definiţie vedere din tabela \ndicţionarului de date USER_VIEWS\n2. Verificare drepturi acces pentru tabela vederii\n3. Convertire interogare vedere într-o interogare \nechivalentă a tabelei vederii. \nDeci datele sunt extrase, inserate din tabele \npropriu-zise. \nCurs - BAZE DE DATE 27\n\nModificarea unei vederi\nPână acum am verificat dacă vederea \nexistă sau nu şi numai în cazul în care nu exista \no cream. \nAvem posibilitatea de a crea o vedere chiar \ndacă ea există, înlocuind-o pe cea veche cu o \nnouă versiune. \nCurs - BAZE DE DATE 28\n\nÎn acest scop se foloseşte clauza OR REPLACE. \nVom înlocui vederea emp20 cu alta.\nCREATE OR REPLACE VIEW emp20 (COD, NUME, \nSAL_ANUAL)\n AS SELECT  empno, ename, sal * 12 \n     FROM   emp\n     WHERE  deptno = 20;\nCurs - BAZE DE DATE 29\n\n\nExerciţiu \nVizualizaţi conţinutul vederii cu o cerere SELECT. \nCurs - BAZE DE DATE 30\n\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCREATE OR REPLACE VIEW dept_sal(Denumire_dept, \nSAL_MIN, SAL_MAX, SAL_MEDIU)\n AS SELECT  d.dname, MIN(e.sal), MAX(e.sal), \nAVG(e.sal) \n     FROM   emp e, dept d\n     WHERE  d.deptno = e.deptno\n     GROUP BY d.dname;\nCurs - BAZE DE DATE 31\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n\n\nNOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n\n\nEfectuarea operaţiilor DML asupra vederilor\nSe pot efectua operaţii DML asupra \nvederilor, dar numai în anumite condiţii. \na) Nu se poate şterge un rând dintr-o \nvedere care conţine: \n1. funcţii de grup\n2. GROUP BY\n3. DISTINCT\n4. ROWNUM\nCurs - BAZE DE DATE 34\n\nb) De asemenea nu se pot modifica date printr-o vedere \ndacă aceasta verifică condiţiile de mai sus şi dacă există \ncoloane definite prin expresii cum ar fi SALARIU*12. \nc) Adăugarea de date printr-o vedere este imposibilădacă\nvederea conţine elementele enumerate mai sus şi dacă\nexistă coloane NOT NULL în tabela neselectate de către\nvedere.\nPrin adăugare de date se modifică de fapt tabela propriu-\nzisă deci în coloanele neselectate se va adăuga NULL\nceea ce încalcă constrângerea.\nCurs - BAZE DE DATE 35\n\nExemplu - Crearea vederii dept_sal utilizând clauza OR \nREPLACE. \nCREATE OR REPLACE VIEW dept_sal (COD, SAL_MEDIU)\n  AS SELECT deptno, AVG(sal)\n    FROM     emp\n    GROUP BY deptno;\n \nCurs - BAZE DE DATE 36', '\n']","instrucțiunea `UPDATE` combinată cu subinterogări pentru a actualiza date selective se utilizează conform sintaxei:

```sql
UPDATE tabela
SET coloana = (SELECT valoare FROM alta_tabela WHERE conditie)
WHERE conditie;
```

`valoare`  poate fi valoarea corespunzătoare din subquery (subinterogare).
",Cum se utilizează instrucțiunea UPDATE combinată cu subinterogări pentru a actualiza date selective?,"['1. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n', '2. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n', '3. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n', '4. ', ""4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia ADD_MONTHS - exemplu:\nSELECT ADD_MONTHS(SYSDATE,3)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 49\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia LAST_DAY- exemplu:\nSELECT LAST_DAY(SYSDATE)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 50\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia MONTHS_BETWEEN - exemplu:\nSELECT MONTHS_BETWEEN (HIREDATE, \nSYSDATE)\nFROM EMP;\nRezultatul va fi un numar negativ, \ndeoarece primul parametru este o \ndata calendaristica mai mica decat al \ndoilea parametru.\nCurs 4 - BAZE DE DATE 51\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia MONTHS_BETWEEN -\nexemplu:\nSELECT MONTHS_BETWEEN \n(SYSDATE, HIREDATE)\nFROM EMP;\nPentru a afisa o valoare pozitiva, se \npot inversa cei doi parametri:\nCurs 4 - BAZE DE DATE 52\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia NEXT_DAY - exemplu:\nSELECT SYSDATE, NEXT_DAY(SYSDATE,6), \nNEXT_DAY(SYSDATE,'FRIDAY')\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 53\n\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 54\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\n4.2.4. Funcţii de conversie dintr-un tip în altul\nAceste funcţii au ca argumente date de tip DATE, \nNUMBER, CHAR şi returnează date de tip \nDATE, NUMBER, CHAR.\nCurs 4 - BAZE DE DATE 55\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\nFuncţiile de conversie din Oracle se pot folosi \npentru a converti diverse formate:\na)Conversia din dată calendaristică în şir de \ncaractere\nb)Conversia din şir de caractere în dată \ncalendaristică\nc) Conversia din număr în şir de caractere\nd)Conversia din şir de caractere în număr\nCurs 4 - BAZE DE DATE 56\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\na) Conversia din dată calendaristică în şir de \ncaractere\nConversia unei date calendaristice în şir de \ncaractere se poate realiza cu ajutorul funcţiei \nTO_CHAR. \nCurs 4 - BAZE DE DATE 57\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\na) Conversia din dată calendaristică în şir de \ncaractere\nSintaxa acestei funcţii este: TO_CHAR (dt, format)\ndt poate avea unul din tipurile pentru date \ncalendatistice:\n1. DATE, TIMESTAMP\n2. TIMESTAMP WITH TIME ZONE\n3. TIMESTAMP \n4. WITH LOCAL TIME ZONE \n5. INTERVAL MONTH TO YEAR\n6. INTERVAL DAY TO SECOND\nCurs 4 - BAZE DE DATE 58"", '\n', '5. ', ""4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia ADD_MONTHS - exemplu:\nSELECT ADD_MONTHS(SYSDATE,3)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 49\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia LAST_DAY- exemplu:\nSELECT LAST_DAY(SYSDATE)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 50\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia MONTHS_BETWEEN - exemplu:\nSELECT MONTHS_BETWEEN (HIREDATE, \nSYSDATE)\nFROM EMP;\nRezultatul va fi un numar negativ, \ndeoarece primul parametru este o \ndata calendaristica mai mica decat al \ndoilea parametru.\nCurs 4 - BAZE DE DATE 51\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia MONTHS_BETWEEN -\nexemplu:\nSELECT MONTHS_BETWEEN \n(SYSDATE, HIREDATE)\nFROM EMP;\nPentru a afisa o valoare pozitiva, se \npot inversa cei doi parametri:\nCurs 4 - BAZE DE DATE 52\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia NEXT_DAY - exemplu:\nSELECT SYSDATE, NEXT_DAY(SYSDATE,6), \nNEXT_DAY(SYSDATE,'FRIDAY')\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 53\n\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 54\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\n4.2.4. Funcţii de conversie dintr-un tip în altul\nAceste funcţii au ca argumente date de tip DATE, \nNUMBER, CHAR şi returnează date de tip \nDATE, NUMBER, CHAR.\nCurs 4 - BAZE DE DATE 55\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\nFuncţiile de conversie din Oracle se pot folosi \npentru a converti diverse formate:\na)Conversia din dată calendaristică în şir de \ncaractere\nb)Conversia din şir de caractere în dată \ncalendaristică\nc) Conversia din număr în şir de caractere\nd)Conversia din şir de caractere în număr\nCurs 4 - BAZE DE DATE 56\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\na) Conversia din dată calendaristică în şir de \ncaractere\nConversia unei date calendaristice în şir de \ncaractere se poate realiza cu ajutorul funcţiei \nTO_CHAR. \nCurs 4 - BAZE DE DATE 57\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\na) Conversia din dată calendaristică în şir de \ncaractere\nSintaxa acestei funcţii este: TO_CHAR (dt, format)\ndt poate avea unul din tipurile pentru date \ncalendatistice:\n1. DATE, TIMESTAMP\n2. TIMESTAMP WITH TIME ZONE\n3. TIMESTAMP \n4. WITH LOCAL TIME ZONE \n5. INTERVAL MONTH TO YEAR\n6. INTERVAL DAY TO SECOND\nCurs 4 - BAZE DE DATE 58"", '\n', '6. ', ""4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia ADD_MONTHS - exemplu:\nSELECT ADD_MONTHS(SYSDATE,3)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 49\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia LAST_DAY- exemplu:\nSELECT LAST_DAY(SYSDATE)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 50\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia MONTHS_BETWEEN - exemplu:\nSELECT MONTHS_BETWEEN (HIREDATE, \nSYSDATE)\nFROM EMP;\nRezultatul va fi un numar negativ, \ndeoarece primul parametru este o \ndata calendaristica mai mica decat al \ndoilea parametru.\nCurs 4 - BAZE DE DATE 51\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia MONTHS_BETWEEN -\nexemplu:\nSELECT MONTHS_BETWEEN \n(SYSDATE, HIREDATE)\nFROM EMP;\nPentru a afisa o valoare pozitiva, se \npot inversa cei doi parametri:\nCurs 4 - BAZE DE DATE 52\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia NEXT_DAY - exemplu:\nSELECT SYSDATE, NEXT_DAY(SYSDATE,6), \nNEXT_DAY(SYSDATE,'FRIDAY')\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 53\n\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 54\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\n4.2.4. Funcţii de conversie dintr-un tip în altul\nAceste funcţii au ca argumente date de tip DATE, \nNUMBER, CHAR şi returnează date de tip \nDATE, NUMBER, CHAR.\nCurs 4 - BAZE DE DATE 55\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\nFuncţiile de conversie din Oracle se pot folosi \npentru a converti diverse formate:\na)Conversia din dată calendaristică în şir de \ncaractere\nb)Conversia din şir de caractere în dată \ncalendaristică\nc) Conversia din număr în şir de caractere\nd)Conversia din şir de caractere în număr\nCurs 4 - BAZE DE DATE 56\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\na) Conversia din dată calendaristică în şir de \ncaractere\nConversia unei date calendaristice în şir de \ncaractere se poate realiza cu ajutorul funcţiei \nTO_CHAR. \nCurs 4 - BAZE DE DATE 57\n\n4.2.4. Funcţii de conversie dintr-un tip în \naltul\na) Conversia din dată calendaristică în şir de \ncaractere\nSintaxa acestei funcţii este: TO_CHAR (dt, format)\ndt poate avea unul din tipurile pentru date \ncalendatistice:\n1. DATE, TIMESTAMP\n2. TIMESTAMP WITH TIME ZONE\n3. TIMESTAMP \n4. WITH LOCAL TIME ZONE \n5. INTERVAL MONTH TO YEAR\n6. INTERVAL DAY TO SECOND\nCurs 4 - BAZE DE DATE 58"", '\n', '7. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '8. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '9. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '10. ', 'Extragere de date dintr-o vedere\n➢Extragerea de date se face exact ca în cazul \nunei tabele. \n➢Se pot selecta anumite rânduri sau toată \nvederea. \nSELECT * FROM emp10;\nCurs - BAZE DE DATE 26\n\n\nInterogarea unei vederi\nInterogarea unei vederi de către serverul \nORACLE se face în felul următor: \n1. Extragere definiţie vedere din tabela \ndicţionarului de date USER_VIEWS\n2. Verificare drepturi acces pentru tabela vederii\n3. Convertire interogare vedere într-o interogare \nechivalentă a tabelei vederii. \nDeci datele sunt extrase, inserate din tabele \npropriu-zise. \nCurs - BAZE DE DATE 27\n\nModificarea unei vederi\nPână acum am verificat dacă vederea \nexistă sau nu şi numai în cazul în care nu exista \no cream. \nAvem posibilitatea de a crea o vedere chiar \ndacă ea există, înlocuind-o pe cea veche cu o \nnouă versiune. \nCurs - BAZE DE DATE 28\n\nÎn acest scop se foloseşte clauza OR REPLACE. \nVom înlocui vederea emp20 cu alta.\nCREATE OR REPLACE VIEW emp20 (COD, NUME, \nSAL_ANUAL)\n AS SELECT  empno, ename, sal * 12 \n     FROM   emp\n     WHERE  deptno = 20;\nCurs - BAZE DE DATE 29\n\n\nExerciţiu \nVizualizaţi conţinutul vederii cu o cerere SELECT. \nCurs - BAZE DE DATE 30\n\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCREATE OR REPLACE VIEW dept_sal(Denumire_dept, \nSAL_MIN, SAL_MAX, SAL_MEDIU)\n AS SELECT  d.dname, MIN(e.sal), MAX(e.sal), \nAVG(e.sal) \n     FROM   emp e, dept d\n     WHERE  d.deptno = e.deptno\n     GROUP BY d.dname;\nCurs - BAZE DE DATE 31\n\nCrearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n\n\nNOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n\n\nEfectuarea operaţiilor DML asupra vederilor\nSe pot efectua operaţii DML asupra \nvederilor, dar numai în anumite condiţii. \na) Nu se poate şterge un rând dintr-o \nvedere care conţine: \n1. funcţii de grup\n2. GROUP BY\n3. DISTINCT\n4. ROWNUM\nCurs - BAZE DE DATE 34\n\nb) De asemenea nu se pot modifica date printr-o vedere \ndacă aceasta verifică condiţiile de mai sus şi dacă există \ncoloane definite prin expresii cum ar fi SALARIU*12. \nc) Adăugarea de date printr-o vedere este imposibilădacă\nvederea conţine elementele enumerate mai sus şi dacă\nexistă coloane NOT NULL în tabela neselectate de către\nvedere.\nPrin adăugare de date se modifică de fapt tabela propriu-\nzisă deci în coloanele neselectate se va adăuga NULL\nceea ce încalcă constrângerea.\nCurs - BAZE DE DATE 35\n\nExemplu - Crearea vederii dept_sal utilizând clauza OR \nREPLACE. \nCREATE OR REPLACE VIEW dept_sal (COD, SAL_MEDIU)\n  AS SELECT deptno, AVG(sal)\n    FROM     emp\n    GROUP BY deptno;\n \nCurs - BAZE DE DATE 36', '\n']","instrucțiunea `UPDATE` combinată cu subinterogări pentru a actualiza date selective se utilizează conform sintaxei:

```sql
UPDATE tabela
SET coloana = (SELECT valoare FROM alta_tabela WHERE conditie)
WHERE conditie;
```

`valoare`  poate fi valoarea corespunzătoare din subquery (subinterogare).
",UPDATE poate folosi o subinterogare pentru a seta valori. Exemplu: „UPDATE EMP SET sal = (SELECT AVG(sal) FROM EMP) WHERE deptno = 10” actualizează salariile din departamentul 10 cu media salarială calculată prin subquery.,0.4249999999858333,0.5,0.8698100117675255,0.6666666666666666,0.04641805978132844,0.2777777777777778,0.67
34,O3mini-high,High,"C8, C11",C2,"Cum se aplică constrângerile de integritate (PRIMARY KEY, FOREIGN KEY, CHECK) pentru a asigura securitatea și consistența datelor?","Constrângerile asigură integritatea: PRIMARY KEY identifică unic fiecare rând, FOREIGN KEY “REFERENCES” stabilește relații corecte între tabele, iar CHECK impune condiții (ex.: CHECK(sal > 0)). Aceste reguli „previn pătrunderea de date invalide” și susțin securitatea în medii multi-user.",Este corect,"C11, slide 4","['1. ', ""6 \n \n    PRIMARY KEY (CarteID, AutorID), \n    FOREIGN KEY (CarteID) REFERENCES Carte(ID), \n    FOREIGN KEY (AutorID) REFERENCES Autor(ID) \n); \n \nInserare date de test: \nINSERT INTO Carte (ID, Titlu) V ALUES (1, 'Programare în C'), (2, 'Algoritmi și structuri de \ndate'); \nINSERT INTO Autor (ID, Nume) V ALUES (1, 'John Smith'), (2, 'Jane Doe'); \nINSERT INTO Carte_Autor (CarteID, AutorID) V ALUES (1, 1), (2, 2); \n \nInterogare pentru cărțile unui autor: \nSELECT Carte.Titlu FROM Carte \nJOIN Carte_Autor ON Carte.ID = Carte_Autor.CarteID \nJOIN Autor ON Carte_Autor.AutorID = Autor.ID \nWHERE Autor.Nume = 'John Smith'; \n \n \n2.3. Baze de date relaționale (RDBMS) \n \nDefiniție: Bazele de date relaționale utilizează tabele pentru stocarea datelor, iar relațiile dintre \nacestea sunt definite prin chei primare și chei străine. \nExemplu: Sisteme populare: MySQL, PostgreSQL, Oracle, SQL Server. \nAvantaje: \n✓ Ușurință în utilizare și interogare cu SQL \n✓ Scalabilitate și integritate a datelor \nDezavantaje: \n✓ Performanță redusă pentru date foarte mari sau nestructurate \n✓ Necesită schema rigidă \n \n \n2.4. Baze de date NoSQL \nDefiniție: Bazele de date NoSQL sunt concepute pentru a gestiona date nestructurate și semi -\nstructurate, fără o schemă rigidă. \n \nTipuri de baze de date NoSQL: \n✓ Bazele de date orientate pe documente: Stochează datele sub formă de documente JSON, \nBSON (ex. MongoDB, CouchDB). \n✓ Bazele de date de tip key -value: Stochează perechi cheie -valoare (ex. Redis, \nDynamoDB). \n✓ Bazele de date de tip columnar: Optimizate pentru interogări analitice pe seturi mari de \ndate (ex. Apache Cassandra, HBase). \n✓ Bazele de date graf: Model specializat pentru date interconectate (ex. Neo4j, ArangoDB). \n \nAvantaje: \n✓ Scalabilitate orizontală mare"", '\n', '2. ', ""6 \n \n    PRIMARY KEY (CarteID, AutorID), \n    FOREIGN KEY (CarteID) REFERENCES Carte(ID), \n    FOREIGN KEY (AutorID) REFERENCES Autor(ID) \n); \n \nInserare date de test: \nINSERT INTO Carte (ID, Titlu) V ALUES (1, 'Programare în C'), (2, 'Algoritmi și structuri de \ndate'); \nINSERT INTO Autor (ID, Nume) V ALUES (1, 'John Smith'), (2, 'Jane Doe'); \nINSERT INTO Carte_Autor (CarteID, AutorID) V ALUES (1, 1), (2, 2); \n \nInterogare pentru cărțile unui autor: \nSELECT Carte.Titlu FROM Carte \nJOIN Carte_Autor ON Carte.ID = Carte_Autor.CarteID \nJOIN Autor ON Carte_Autor.AutorID = Autor.ID \nWHERE Autor.Nume = 'John Smith'; \n \n \n2.3. Baze de date relaționale (RDBMS) \n \nDefiniție: Bazele de date relaționale utilizează tabele pentru stocarea datelor, iar relațiile dintre \nacestea sunt definite prin chei primare și chei străine. \nExemplu: Sisteme populare: MySQL, PostgreSQL, Oracle, SQL Server. \nAvantaje: \n✓ Ușurință în utilizare și interogare cu SQL \n✓ Scalabilitate și integritate a datelor \nDezavantaje: \n✓ Performanță redusă pentru date foarte mari sau nestructurate \n✓ Necesită schema rigidă \n \n \n2.4. Baze de date NoSQL \nDefiniție: Bazele de date NoSQL sunt concepute pentru a gestiona date nestructurate și semi -\nstructurate, fără o schemă rigidă. \n \nTipuri de baze de date NoSQL: \n✓ Bazele de date orientate pe documente: Stochează datele sub formă de documente JSON, \nBSON (ex. MongoDB, CouchDB). \n✓ Bazele de date de tip key -value: Stochează perechi cheie -valoare (ex. Redis, \nDynamoDB). \n✓ Bazele de date de tip columnar: Optimizate pentru interogări analitice pe seturi mari de \ndate (ex. Apache Cassandra, HBase). \n✓ Bazele de date graf: Model specializat pentru date interconectate (ex. Neo4j, ArangoDB). \n \nAvantaje: \n✓ Scalabilitate orizontală mare"", '\n', '3. ', ""6 \n \n    PRIMARY KEY (CarteID, AutorID), \n    FOREIGN KEY (CarteID) REFERENCES Carte(ID), \n    FOREIGN KEY (AutorID) REFERENCES Autor(ID) \n); \n \nInserare date de test: \nINSERT INTO Carte (ID, Titlu) V ALUES (1, 'Programare în C'), (2, 'Algoritmi și structuri de \ndate'); \nINSERT INTO Autor (ID, Nume) V ALUES (1, 'John Smith'), (2, 'Jane Doe'); \nINSERT INTO Carte_Autor (CarteID, AutorID) V ALUES (1, 1), (2, 2); \n \nInterogare pentru cărțile unui autor: \nSELECT Carte.Titlu FROM Carte \nJOIN Carte_Autor ON Carte.ID = Carte_Autor.CarteID \nJOIN Autor ON Carte_Autor.AutorID = Autor.ID \nWHERE Autor.Nume = 'John Smith'; \n \n \n2.3. Baze de date relaționale (RDBMS) \n \nDefiniție: Bazele de date relaționale utilizează tabele pentru stocarea datelor, iar relațiile dintre \nacestea sunt definite prin chei primare și chei străine. \nExemplu: Sisteme populare: MySQL, PostgreSQL, Oracle, SQL Server. \nAvantaje: \n✓ Ușurință în utilizare și interogare cu SQL \n✓ Scalabilitate și integritate a datelor \nDezavantaje: \n✓ Performanță redusă pentru date foarte mari sau nestructurate \n✓ Necesită schema rigidă \n \n \n2.4. Baze de date NoSQL \nDefiniție: Bazele de date NoSQL sunt concepute pentru a gestiona date nestructurate și semi -\nstructurate, fără o schemă rigidă. \n \nTipuri de baze de date NoSQL: \n✓ Bazele de date orientate pe documente: Stochează datele sub formă de documente JSON, \nBSON (ex. MongoDB, CouchDB). \n✓ Bazele de date de tip key -value: Stochează perechi cheie -valoare (ex. Redis, \nDynamoDB). \n✓ Bazele de date de tip columnar: Optimizate pentru interogări analitice pe seturi mari de \ndate (ex. Apache Cassandra, HBase). \n✓ Bazele de date graf: Model specializat pentru date interconectate (ex. Neo4j, ArangoDB). \n \nAvantaje: \n✓ Scalabilitate orizontală mare"", '\n', '4. ', 'Curs 11\nControlul accesului utilizatorilor\nCurs - BAZE DE DATE 2\n\n\nCuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3\n\nControlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4\n\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5\n\ntt\n1) Securitatea sistemului acopera accesarea si \nutilizarea bazei de date la nivelul sistemului, cum \nar fi: numele utilizatorului si parola, spatiul pe \ndisc alocat utilizatorilor, si operatiile de sistem \npermise utilizatorilor. \nCurs - BAZE DE DATE 6\nhttps://www.scnsoft.com/blog/database-security-best-practices\n\ntt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/\n\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8\n\nScheme \nO schema este o colectie de obiecte, cum ar fi: \n✓tabele\n✓indecsi\n✓vizualizari\n✓secvente\nSchema este detinuta de un utilizator al bazei de \ndate si are acelasi nume cu utilizatorul.\nCurs - BAZE DE DATE 9\n\ntt\nPrivilegii de sistem\nSunt disponibile mai mult de 80 de privilegii de \nsistem pentru utilizatori si pentru roluri. \nPrivilegiile de sistem sunt setate  de catre  \nadministratorul bazei de date.\nCurs - BAZE DE DATE 10\n\nPrivilegiile caracteristice ale DBA\nPrivilegii de sistem Operatii autorizate\nCreare de utilizatori Permite crearea unui alt utilizator Oracle (privilegiu\ncerut pentru rolul de DBA)\nStergerea de utilizatori Permite stergerea altui utilizator\nStergerea oricarei tabele Permite stergerea unei tabele în orice schema\nRecuperarea oricarei\ntabele\nRecuperarea oricarei tabele în orice schema cu\nutilitare de export\nCurs - BAZE DE DATE 11', '\n', '5. ', 'Curs 11\nControlul accesului utilizatorilor\nCurs - BAZE DE DATE 2\n\n\nCuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3\n\nControlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4\n\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5\n\ntt\n1) Securitatea sistemului acopera accesarea si \nutilizarea bazei de date la nivelul sistemului, cum \nar fi: numele utilizatorului si parola, spatiul pe \ndisc alocat utilizatorilor, si operatiile de sistem \npermise utilizatorilor. \nCurs - BAZE DE DATE 6\nhttps://www.scnsoft.com/blog/database-security-best-practices\n\ntt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/\n\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8\n\nScheme \nO schema este o colectie de obiecte, cum ar fi: \n✓tabele\n✓indecsi\n✓vizualizari\n✓secvente\nSchema este detinuta de un utilizator al bazei de \ndate si are acelasi nume cu utilizatorul.\nCurs - BAZE DE DATE 9\n\ntt\nPrivilegii de sistem\nSunt disponibile mai mult de 80 de privilegii de \nsistem pentru utilizatori si pentru roluri. \nPrivilegiile de sistem sunt setate  de catre  \nadministratorul bazei de date.\nCurs - BAZE DE DATE 10\n\nPrivilegiile caracteristice ale DBA\nPrivilegii de sistem Operatii autorizate\nCreare de utilizatori Permite crearea unui alt utilizator Oracle (privilegiu\ncerut pentru rolul de DBA)\nStergerea de utilizatori Permite stergerea altui utilizator\nStergerea oricarei tabele Permite stergerea unei tabele în orice schema\nRecuperarea oricarei\ntabele\nRecuperarea oricarei tabele în orice schema cu\nutilitare de export\nCurs - BAZE DE DATE 11', '\n', '6. ', 'Curs 11\nControlul accesului utilizatorilor\nCurs - BAZE DE DATE 2\n\n\nCuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3\n\nControlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4\n\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5\n\ntt\n1) Securitatea sistemului acopera accesarea si \nutilizarea bazei de date la nivelul sistemului, cum \nar fi: numele utilizatorului si parola, spatiul pe \ndisc alocat utilizatorilor, si operatiile de sistem \npermise utilizatorilor. \nCurs - BAZE DE DATE 6\nhttps://www.scnsoft.com/blog/database-security-best-practices\n\ntt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/\n\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8\n\nScheme \nO schema este o colectie de obiecte, cum ar fi: \n✓tabele\n✓indecsi\n✓vizualizari\n✓secvente\nSchema este detinuta de un utilizator al bazei de \ndate si are acelasi nume cu utilizatorul.\nCurs - BAZE DE DATE 9\n\ntt\nPrivilegii de sistem\nSunt disponibile mai mult de 80 de privilegii de \nsistem pentru utilizatori si pentru roluri. \nPrivilegiile de sistem sunt setate  de catre  \nadministratorul bazei de date.\nCurs - BAZE DE DATE 10\n\nPrivilegiile caracteristice ale DBA\nPrivilegii de sistem Operatii autorizate\nCreare de utilizatori Permite crearea unui alt utilizator Oracle (privilegiu\ncerut pentru rolul de DBA)\nStergerea de utilizatori Permite stergerea altui utilizator\nStergerea oricarei tabele Permite stergerea unei tabele în orice schema\nRecuperarea oricarei\ntabele\nRecuperarea oricarei tabele în orice schema cu\nutilitare de export\nCurs - BAZE DE DATE 11', '\n', '7. ', 'Titlu V ARCHAR(100), \n    Autor V ARCHAR(100), \n    ExemplareDisponibile INT \n); \n \nCREATE TABLE Imprumut ( \n    ID INT PRIMARY KEY , \n    CititorID INT, \n    CarteID INT, \n    DataImprumut DATE, \n    DataReturnare DATE, \n    FOREIGN KEY (CititorID) REFERENCES Cititor(ID), \n    FOREIGN KEY (CarteID) REFERENCES Carte(ID) \n); \n \nExplicație: \n• Cititor conține informații despre cititori. \n• Carte include titlul, autorul și numărul de exemplare disponibile. \n• Imprumut leagă cititorii cu cărțile împrumutate și datele asociate acestora. \n \nExemplu de interogare: \nSELECT C.Nume, B.Titlu, I.DataImprumut, I.DataReturnare  \nFROM Imprumut I \nJOIN Cititor C ON I.CititorID = C.ID \nJOIN Carte B ON I.CarteID = B.ID; \nAceastă interogare returnează detaliile despre împrumuturile active din bibliotecă. \n \n \n \nScenariul 3: Sistem de gestionare a angajaților într-o companie \nDescriere: \nO companie dorește să își gestioneze angajații, împreună cu departamentele și salariile \nacestora. \nCerințe pentru implementare: \n1. Crearea unui tabel Angajat care să conțină ID-ul, numele, poziția și salariul fiecărui \nangajat. \n2. Crearea unui tabel Departament pentru a organiza angajații în echipe specifice. \n3. Crearea unui tabel Plata pentru a înregistra salariile plătite fiecărui angajat. \n \n \nScenariul 4: Sistem de gestionare a comenzilor într-un restaurant \nDescriere: \nUn restaurant are nevoie de o bază de date pentru a monitoriza comenzile clienților și \npreparatele din meniu. \nCerințe pentru implementare: \n1. Crearea unui tabel Client care să rețină detalii despre clienți. \n\n2. Crearea unui tabel Comanda care să stocheze comenzile făcute de clienți. \n3. Crearea unui tabel Preparat care să conțină lista de produse disponibile. \n4. Crearea unui tabel ComandaPreparat pentru a lega comenzile cu preparatele comandate. \n \n \nScenariul 5: Sistem de gestionare a pacienților într-un spital \nDescriere: \nUn spital are nevoie de un sistem care să țină evidența pacienților internați, a doctorilor și \ntratamentelor administrate. \nCerințe pentru implementare: \n1. Crearea unui tabel Pacient pentru a înregistra informațiile personale ale pacienților. \n2. Crearea unui tabel Doctor pentru a stoca detalii despre doctori. \n3. Crearea unui tabel Internare care să înregistreze perioada internării pacienților. \n4. Crearea unui tabel Tratament care să urmărească medicamentele administrate pacienților. \n \n \n \n \nReferințe și resurse web \n1) Connolly, T. & Begg, C. (2014). Database Systems: A Practical Approach to Design, \nImplementation, and Management. Pearson. \n2) Silberschatz, A., Korth, H., & Sudarshan, S. (2020). Database System Concepts. McGraw-\nHill. \n3) Elmasri, R., & Navathe, S. (2016). Fundamentals of Database Systems. Pearson. \n4) W3Schools SQL Tutorial \n5) MongoDB Documentation \n6) PostgreSQL Documentation \n7) Redis Documentation', '\n', '8. ', 'Titlu V ARCHAR(100), \n    Autor V ARCHAR(100), \n    ExemplareDisponibile INT \n); \n \nCREATE TABLE Imprumut ( \n    ID INT PRIMARY KEY , \n    CititorID INT, \n    CarteID INT, \n    DataImprumut DATE, \n    DataReturnare DATE, \n    FOREIGN KEY (CititorID) REFERENCES Cititor(ID), \n    FOREIGN KEY (CarteID) REFERENCES Carte(ID) \n); \n \nExplicație: \n• Cititor conține informații despre cititori. \n• Carte include titlul, autorul și numărul de exemplare disponibile. \n• Imprumut leagă cititorii cu cărțile împrumutate și datele asociate acestora. \n \nExemplu de interogare: \nSELECT C.Nume, B.Titlu, I.DataImprumut, I.DataReturnare  \nFROM Imprumut I \nJOIN Cititor C ON I.CititorID = C.ID \nJOIN Carte B ON I.CarteID = B.ID; \nAceastă interogare returnează detaliile despre împrumuturile active din bibliotecă. \n \n \n \nScenariul 3: Sistem de gestionare a angajaților într-o companie \nDescriere: \nO companie dorește să își gestioneze angajații, împreună cu departamentele și salariile \nacestora. \nCerințe pentru implementare: \n1. Crearea unui tabel Angajat care să conțină ID-ul, numele, poziția și salariul fiecărui \nangajat. \n2. Crearea unui tabel Departament pentru a organiza angajații în echipe specifice. \n3. Crearea unui tabel Plata pentru a înregistra salariile plătite fiecărui angajat. \n \n \nScenariul 4: Sistem de gestionare a comenzilor într-un restaurant \nDescriere: \nUn restaurant are nevoie de o bază de date pentru a monitoriza comenzile clienților și \npreparatele din meniu. \nCerințe pentru implementare: \n1. Crearea unui tabel Client care să rețină detalii despre clienți. \n\n2. Crearea unui tabel Comanda care să stocheze comenzile făcute de clienți. \n3. Crearea unui tabel Preparat care să conțină lista de produse disponibile. \n4. Crearea unui tabel ComandaPreparat pentru a lega comenzile cu preparatele comandate. \n \n \nScenariul 5: Sistem de gestionare a pacienților într-un spital \nDescriere: \nUn spital are nevoie de un sistem care să țină evidența pacienților internați, a doctorilor și \ntratamentelor administrate. \nCerințe pentru implementare: \n1. Crearea unui tabel Pacient pentru a înregistra informațiile personale ale pacienților. \n2. Crearea unui tabel Doctor pentru a stoca detalii despre doctori. \n3. Crearea unui tabel Internare care să înregistreze perioada internării pacienților. \n4. Crearea unui tabel Tratament care să urmărească medicamentele administrate pacienților. \n \n \n \n \nReferințe și resurse web \n1) Connolly, T. & Begg, C. (2014). Database Systems: A Practical Approach to Design, \nImplementation, and Management. Pearson. \n2) Silberschatz, A., Korth, H., & Sudarshan, S. (2020). Database System Concepts. McGraw-\nHill. \n3) Elmasri, R., & Navathe, S. (2016). Fundamentals of Database Systems. Pearson. \n4) W3Schools SQL Tutorial \n5) MongoDB Documentation \n6) PostgreSQL Documentation \n7) Redis Documentation', '\n', '9. ', 'Titlu V ARCHAR(100), \n    Autor V ARCHAR(100), \n    ExemplareDisponibile INT \n); \n \nCREATE TABLE Imprumut ( \n    ID INT PRIMARY KEY , \n    CititorID INT, \n    CarteID INT, \n    DataImprumut DATE, \n    DataReturnare DATE, \n    FOREIGN KEY (CititorID) REFERENCES Cititor(ID), \n    FOREIGN KEY (CarteID) REFERENCES Carte(ID) \n); \n \nExplicație: \n• Cititor conține informații despre cititori. \n• Carte include titlul, autorul și numărul de exemplare disponibile. \n• Imprumut leagă cititorii cu cărțile împrumutate și datele asociate acestora. \n \nExemplu de interogare: \nSELECT C.Nume, B.Titlu, I.DataImprumut, I.DataReturnare  \nFROM Imprumut I \nJOIN Cititor C ON I.CititorID = C.ID \nJOIN Carte B ON I.CarteID = B.ID; \nAceastă interogare returnează detaliile despre împrumuturile active din bibliotecă. \n \n \n \nScenariul 3: Sistem de gestionare a angajaților într-o companie \nDescriere: \nO companie dorește să își gestioneze angajații, împreună cu departamentele și salariile \nacestora. \nCerințe pentru implementare: \n1. Crearea unui tabel Angajat care să conțină ID-ul, numele, poziția și salariul fiecărui \nangajat. \n2. Crearea unui tabel Departament pentru a organiza angajații în echipe specifice. \n3. Crearea unui tabel Plata pentru a înregistra salariile plătite fiecărui angajat. \n \n \nScenariul 4: Sistem de gestionare a comenzilor într-un restaurant \nDescriere: \nUn restaurant are nevoie de o bază de date pentru a monitoriza comenzile clienților și \npreparatele din meniu. \nCerințe pentru implementare: \n1. Crearea unui tabel Client care să rețină detalii despre clienți. \n\n2. Crearea unui tabel Comanda care să stocheze comenzile făcute de clienți. \n3. Crearea unui tabel Preparat care să conțină lista de produse disponibile. \n4. Crearea unui tabel ComandaPreparat pentru a lega comenzile cu preparatele comandate. \n \n \nScenariul 5: Sistem de gestionare a pacienților într-un spital \nDescriere: \nUn spital are nevoie de un sistem care să țină evidența pacienților internați, a doctorilor și \ntratamentelor administrate. \nCerințe pentru implementare: \n1. Crearea unui tabel Pacient pentru a înregistra informațiile personale ale pacienților. \n2. Crearea unui tabel Doctor pentru a stoca detalii despre doctori. \n3. Crearea unui tabel Internare care să înregistreze perioada internării pacienților. \n4. Crearea unui tabel Tratament care să urmărească medicamentele administrate pacienților. \n \n \n \n \nReferințe și resurse web \n1) Connolly, T. & Begg, C. (2014). Database Systems: A Practical Approach to Design, \nImplementation, and Management. Pearson. \n2) Silberschatz, A., Korth, H., & Sudarshan, S. (2020). Database System Concepts. McGraw-\nHill. \n3) Elmasri, R., & Navathe, S. (2016). Fundamentals of Database Systems. Pearson. \n4) W3Schools SQL Tutorial \n5) MongoDB Documentation \n6) PostgreSQL Documentation \n7) Redis Documentation', '\n', '10. ', ""3.2. Sistem bancar - Proiectare bază de date pentru conturi \nCREATE TABLE ContBancar ( \n    ID INT PRIMARY KEY , \n    Titular V ARCHAR(50), \n    Sold DECIMAL(15,2) CHECK (Sold >= 0) \n); \n \nCREATE TABLE Tranzactie ( \n    ID INT PRIMARY KEY , \n    ContID INT, \n    Suma DECIMAL(15,2), \n    Tip V ARCHAR(10) CHECK (Tip IN ('Depunere', 'Retragere')), \n    DataTranzactie DATE, \n    FOREIGN KEY (ContID) REFERENCES ContBancar(ID) \n); \n \n \n3.4 Optimizarea bazei de date \n \nPentru a îmbunătăți performanța unei baze de date relaționale, se folosesc diferite tehnici de \noptimizare: \n1. Indexarea - Crearea de indexuri pentru căutări rapide. \n2. Partiționarea tabelelor - Împărțirea unei tabele mari în părți mai mici pentru acces mai \nrapid. \n3. Denormalizarea parțială - Îmbunătățirea performanței prin eliminarea anumitor reguli \nde normalizare în cazuri specifice. \n4. Utilizarea procedurilor stocate - Optimizarea execuției interogărilor frecvente. \nExemplu de creare a unui index pentru îmbunătățirea căutărilor: \nCREATE INDEX idx_nume_client ON Client(Nume); \n \n \n \n3.5 Scenarii reale de proiectare a bazelor de date \n \nScenariul 1: Sistem de gestionare a rezervărilor pentru un hotel \nDescriere: \nUn hotel dorește să își gestioneze rezervările printr-o bază de date care să permită urmărirea \ncamerelor disponibile, a rezervărilor făcute de clienți și a detaliilor despre clienți. \nModelul relațional propus: \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Telefon V ARCHAR(15), \n    Email V ARCHAR(50) \n); \n \n\nCREATE TABLE Camera ( \n    ID INT PRIMARY KEY , \n    Tip V ARCHAR(50), \n    Pret DECIMAL(10,2), \n    Disponibilitate BOOLEAN \n); \n \nCREATE TABLE Rezervare ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    CameraID INT, \n    DataStart DATE, \n    DataEnd DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID), \n    FOREIGN KEY (CameraID) REFERENCES Camera(ID) \n); \n \nExplicație: \n• Tabelul Client reține informațiile despre clienți. \n• Tabelul Camera păstrează detalii despre camere și disponibilitatea acestora. \n• Tabelul Rezervare conectează clienții cu camerele rezervate. \n• Se utilizează chei străine pentru a menține integritatea datelor. \n \nExemplu de interogare: \nSELECT C.Nume, R.DataStart, R.DataEnd, Cam.Tip  \nFROM Rezervare R \nJOIN Client C ON R.ClientID = C.ID \nJOIN Camera Cam ON R.CameraID = Cam.ID \nWHERE Cam.Disponibilitate = TRUE; \nAceastă interogare returnează toate rezervările active cu detaliile clienților și tipurile de camere \nrezervate. \n \n \nScenariul 2: Sistem de evidență a împrumuturilor dintr-o bibliotecă \nDescriere: \nO bibliotecă dorește un sistem care să monitorizeze împrumuturile cărților și să asigure că fiecare \ncarte este returnată la timp. \nModelul relațional propus: \nCREATE TABLE Cititor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY ,"", '\n']","constrângerile de integritate se aplică astfel:

*   **PRIMARY KEY:** Asigură unicitatea înregistrărilor într-un tabel. Exemplu: `ID INT PRIMARY KEY` în tabelele `ContBancar`, `Tranzactie`, `Client`, `Camera`, `Rezervare`, `Cititor`, `Carte`, `Imprumut`.
*   **FOREIGN KEY:** Stabilește relații între tabele și asigură integritatea referențială. Exemplu: `FOREIGN KEY (ContID) REFERENCES ContBancar(ID)` în tabelul `Tranzactie`, sau `FOREIGN KEY (ClientID) REFERENCES Client(ID)` si `FOREIGN KEY (CameraID) REFERENCES Camera(ID)` in tabelul `Rezervare`.
*  **CHECK:** impune restrictii, conditii, pentru valorile permise într-o coloană:. Exemplu: `CHECK (Sold >= 0)` în tabelul `ContBancar`, `CHECK (Tip IN ('Depunere', 'Retragere'))` in tabelul `Tranzactie`.
","Cum se aplică constrângerile de integritate (PRIMARY KEY, FOREIGN KEY, CHECK) pentru a asigura securitatea și consistența datelor?","['1. ', ""6 \n \n    PRIMARY KEY (CarteID, AutorID), \n    FOREIGN KEY (CarteID) REFERENCES Carte(ID), \n    FOREIGN KEY (AutorID) REFERENCES Autor(ID) \n); \n \nInserare date de test: \nINSERT INTO Carte (ID, Titlu) V ALUES (1, 'Programare în C'), (2, 'Algoritmi și structuri de \ndate'); \nINSERT INTO Autor (ID, Nume) V ALUES (1, 'John Smith'), (2, 'Jane Doe'); \nINSERT INTO Carte_Autor (CarteID, AutorID) V ALUES (1, 1), (2, 2); \n \nInterogare pentru cărțile unui autor: \nSELECT Carte.Titlu FROM Carte \nJOIN Carte_Autor ON Carte.ID = Carte_Autor.CarteID \nJOIN Autor ON Carte_Autor.AutorID = Autor.ID \nWHERE Autor.Nume = 'John Smith'; \n \n \n2.3. Baze de date relaționale (RDBMS) \n \nDefiniție: Bazele de date relaționale utilizează tabele pentru stocarea datelor, iar relațiile dintre \nacestea sunt definite prin chei primare și chei străine. \nExemplu: Sisteme populare: MySQL, PostgreSQL, Oracle, SQL Server. \nAvantaje: \n✓ Ușurință în utilizare și interogare cu SQL \n✓ Scalabilitate și integritate a datelor \nDezavantaje: \n✓ Performanță redusă pentru date foarte mari sau nestructurate \n✓ Necesită schema rigidă \n \n \n2.4. Baze de date NoSQL \nDefiniție: Bazele de date NoSQL sunt concepute pentru a gestiona date nestructurate și semi -\nstructurate, fără o schemă rigidă. \n \nTipuri de baze de date NoSQL: \n✓ Bazele de date orientate pe documente: Stochează datele sub formă de documente JSON, \nBSON (ex. MongoDB, CouchDB). \n✓ Bazele de date de tip key -value: Stochează perechi cheie -valoare (ex. Redis, \nDynamoDB). \n✓ Bazele de date de tip columnar: Optimizate pentru interogări analitice pe seturi mari de \ndate (ex. Apache Cassandra, HBase). \n✓ Bazele de date graf: Model specializat pentru date interconectate (ex. Neo4j, ArangoDB). \n \nAvantaje: \n✓ Scalabilitate orizontală mare"", '\n', '2. ', ""6 \n \n    PRIMARY KEY (CarteID, AutorID), \n    FOREIGN KEY (CarteID) REFERENCES Carte(ID), \n    FOREIGN KEY (AutorID) REFERENCES Autor(ID) \n); \n \nInserare date de test: \nINSERT INTO Carte (ID, Titlu) V ALUES (1, 'Programare în C'), (2, 'Algoritmi și structuri de \ndate'); \nINSERT INTO Autor (ID, Nume) V ALUES (1, 'John Smith'), (2, 'Jane Doe'); \nINSERT INTO Carte_Autor (CarteID, AutorID) V ALUES (1, 1), (2, 2); \n \nInterogare pentru cărțile unui autor: \nSELECT Carte.Titlu FROM Carte \nJOIN Carte_Autor ON Carte.ID = Carte_Autor.CarteID \nJOIN Autor ON Carte_Autor.AutorID = Autor.ID \nWHERE Autor.Nume = 'John Smith'; \n \n \n2.3. Baze de date relaționale (RDBMS) \n \nDefiniție: Bazele de date relaționale utilizează tabele pentru stocarea datelor, iar relațiile dintre \nacestea sunt definite prin chei primare și chei străine. \nExemplu: Sisteme populare: MySQL, PostgreSQL, Oracle, SQL Server. \nAvantaje: \n✓ Ușurință în utilizare și interogare cu SQL \n✓ Scalabilitate și integritate a datelor \nDezavantaje: \n✓ Performanță redusă pentru date foarte mari sau nestructurate \n✓ Necesită schema rigidă \n \n \n2.4. Baze de date NoSQL \nDefiniție: Bazele de date NoSQL sunt concepute pentru a gestiona date nestructurate și semi -\nstructurate, fără o schemă rigidă. \n \nTipuri de baze de date NoSQL: \n✓ Bazele de date orientate pe documente: Stochează datele sub formă de documente JSON, \nBSON (ex. MongoDB, CouchDB). \n✓ Bazele de date de tip key -value: Stochează perechi cheie -valoare (ex. Redis, \nDynamoDB). \n✓ Bazele de date de tip columnar: Optimizate pentru interogări analitice pe seturi mari de \ndate (ex. Apache Cassandra, HBase). \n✓ Bazele de date graf: Model specializat pentru date interconectate (ex. Neo4j, ArangoDB). \n \nAvantaje: \n✓ Scalabilitate orizontală mare"", '\n', '3. ', ""6 \n \n    PRIMARY KEY (CarteID, AutorID), \n    FOREIGN KEY (CarteID) REFERENCES Carte(ID), \n    FOREIGN KEY (AutorID) REFERENCES Autor(ID) \n); \n \nInserare date de test: \nINSERT INTO Carte (ID, Titlu) V ALUES (1, 'Programare în C'), (2, 'Algoritmi și structuri de \ndate'); \nINSERT INTO Autor (ID, Nume) V ALUES (1, 'John Smith'), (2, 'Jane Doe'); \nINSERT INTO Carte_Autor (CarteID, AutorID) V ALUES (1, 1), (2, 2); \n \nInterogare pentru cărțile unui autor: \nSELECT Carte.Titlu FROM Carte \nJOIN Carte_Autor ON Carte.ID = Carte_Autor.CarteID \nJOIN Autor ON Carte_Autor.AutorID = Autor.ID \nWHERE Autor.Nume = 'John Smith'; \n \n \n2.3. Baze de date relaționale (RDBMS) \n \nDefiniție: Bazele de date relaționale utilizează tabele pentru stocarea datelor, iar relațiile dintre \nacestea sunt definite prin chei primare și chei străine. \nExemplu: Sisteme populare: MySQL, PostgreSQL, Oracle, SQL Server. \nAvantaje: \n✓ Ușurință în utilizare și interogare cu SQL \n✓ Scalabilitate și integritate a datelor \nDezavantaje: \n✓ Performanță redusă pentru date foarte mari sau nestructurate \n✓ Necesită schema rigidă \n \n \n2.4. Baze de date NoSQL \nDefiniție: Bazele de date NoSQL sunt concepute pentru a gestiona date nestructurate și semi -\nstructurate, fără o schemă rigidă. \n \nTipuri de baze de date NoSQL: \n✓ Bazele de date orientate pe documente: Stochează datele sub formă de documente JSON, \nBSON (ex. MongoDB, CouchDB). \n✓ Bazele de date de tip key -value: Stochează perechi cheie -valoare (ex. Redis, \nDynamoDB). \n✓ Bazele de date de tip columnar: Optimizate pentru interogări analitice pe seturi mari de \ndate (ex. Apache Cassandra, HBase). \n✓ Bazele de date graf: Model specializat pentru date interconectate (ex. Neo4j, ArangoDB). \n \nAvantaje: \n✓ Scalabilitate orizontală mare"", '\n', '4. ', 'Curs 11\nControlul accesului utilizatorilor\nCurs - BAZE DE DATE 2\n\n\nCuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3\n\nControlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4\n\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5\n\ntt\n1) Securitatea sistemului acopera accesarea si \nutilizarea bazei de date la nivelul sistemului, cum \nar fi: numele utilizatorului si parola, spatiul pe \ndisc alocat utilizatorilor, si operatiile de sistem \npermise utilizatorilor. \nCurs - BAZE DE DATE 6\nhttps://www.scnsoft.com/blog/database-security-best-practices\n\ntt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/\n\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8\n\nScheme \nO schema este o colectie de obiecte, cum ar fi: \n✓tabele\n✓indecsi\n✓vizualizari\n✓secvente\nSchema este detinuta de un utilizator al bazei de \ndate si are acelasi nume cu utilizatorul.\nCurs - BAZE DE DATE 9\n\ntt\nPrivilegii de sistem\nSunt disponibile mai mult de 80 de privilegii de \nsistem pentru utilizatori si pentru roluri. \nPrivilegiile de sistem sunt setate  de catre  \nadministratorul bazei de date.\nCurs - BAZE DE DATE 10\n\nPrivilegiile caracteristice ale DBA\nPrivilegii de sistem Operatii autorizate\nCreare de utilizatori Permite crearea unui alt utilizator Oracle (privilegiu\ncerut pentru rolul de DBA)\nStergerea de utilizatori Permite stergerea altui utilizator\nStergerea oricarei tabele Permite stergerea unei tabele în orice schema\nRecuperarea oricarei\ntabele\nRecuperarea oricarei tabele în orice schema cu\nutilitare de export\nCurs - BAZE DE DATE 11', '\n', '5. ', 'Curs 11\nControlul accesului utilizatorilor\nCurs - BAZE DE DATE 2\n\n\nCuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3\n\nControlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4\n\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5\n\ntt\n1) Securitatea sistemului acopera accesarea si \nutilizarea bazei de date la nivelul sistemului, cum \nar fi: numele utilizatorului si parola, spatiul pe \ndisc alocat utilizatorilor, si operatiile de sistem \npermise utilizatorilor. \nCurs - BAZE DE DATE 6\nhttps://www.scnsoft.com/blog/database-security-best-practices\n\ntt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/\n\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8\n\nScheme \nO schema este o colectie de obiecte, cum ar fi: \n✓tabele\n✓indecsi\n✓vizualizari\n✓secvente\nSchema este detinuta de un utilizator al bazei de \ndate si are acelasi nume cu utilizatorul.\nCurs - BAZE DE DATE 9\n\ntt\nPrivilegii de sistem\nSunt disponibile mai mult de 80 de privilegii de \nsistem pentru utilizatori si pentru roluri. \nPrivilegiile de sistem sunt setate  de catre  \nadministratorul bazei de date.\nCurs - BAZE DE DATE 10\n\nPrivilegiile caracteristice ale DBA\nPrivilegii de sistem Operatii autorizate\nCreare de utilizatori Permite crearea unui alt utilizator Oracle (privilegiu\ncerut pentru rolul de DBA)\nStergerea de utilizatori Permite stergerea altui utilizator\nStergerea oricarei tabele Permite stergerea unei tabele în orice schema\nRecuperarea oricarei\ntabele\nRecuperarea oricarei tabele în orice schema cu\nutilitare de export\nCurs - BAZE DE DATE 11', '\n', '6. ', 'Curs 11\nControlul accesului utilizatorilor\nCurs - BAZE DE DATE 2\n\n\nCuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3\n\nControlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4\n\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5\n\ntt\n1) Securitatea sistemului acopera accesarea si \nutilizarea bazei de date la nivelul sistemului, cum \nar fi: numele utilizatorului si parola, spatiul pe \ndisc alocat utilizatorilor, si operatiile de sistem \npermise utilizatorilor. \nCurs - BAZE DE DATE 6\nhttps://www.scnsoft.com/blog/database-security-best-practices\n\ntt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/\n\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8\n\nScheme \nO schema este o colectie de obiecte, cum ar fi: \n✓tabele\n✓indecsi\n✓vizualizari\n✓secvente\nSchema este detinuta de un utilizator al bazei de \ndate si are acelasi nume cu utilizatorul.\nCurs - BAZE DE DATE 9\n\ntt\nPrivilegii de sistem\nSunt disponibile mai mult de 80 de privilegii de \nsistem pentru utilizatori si pentru roluri. \nPrivilegiile de sistem sunt setate  de catre  \nadministratorul bazei de date.\nCurs - BAZE DE DATE 10\n\nPrivilegiile caracteristice ale DBA\nPrivilegii de sistem Operatii autorizate\nCreare de utilizatori Permite crearea unui alt utilizator Oracle (privilegiu\ncerut pentru rolul de DBA)\nStergerea de utilizatori Permite stergerea altui utilizator\nStergerea oricarei tabele Permite stergerea unei tabele în orice schema\nRecuperarea oricarei\ntabele\nRecuperarea oricarei tabele în orice schema cu\nutilitare de export\nCurs - BAZE DE DATE 11', '\n', '7. ', 'Titlu V ARCHAR(100), \n    Autor V ARCHAR(100), \n    ExemplareDisponibile INT \n); \n \nCREATE TABLE Imprumut ( \n    ID INT PRIMARY KEY , \n    CititorID INT, \n    CarteID INT, \n    DataImprumut DATE, \n    DataReturnare DATE, \n    FOREIGN KEY (CititorID) REFERENCES Cititor(ID), \n    FOREIGN KEY (CarteID) REFERENCES Carte(ID) \n); \n \nExplicație: \n• Cititor conține informații despre cititori. \n• Carte include titlul, autorul și numărul de exemplare disponibile. \n• Imprumut leagă cititorii cu cărțile împrumutate și datele asociate acestora. \n \nExemplu de interogare: \nSELECT C.Nume, B.Titlu, I.DataImprumut, I.DataReturnare  \nFROM Imprumut I \nJOIN Cititor C ON I.CititorID = C.ID \nJOIN Carte B ON I.CarteID = B.ID; \nAceastă interogare returnează detaliile despre împrumuturile active din bibliotecă. \n \n \n \nScenariul 3: Sistem de gestionare a angajaților într-o companie \nDescriere: \nO companie dorește să își gestioneze angajații, împreună cu departamentele și salariile \nacestora. \nCerințe pentru implementare: \n1. Crearea unui tabel Angajat care să conțină ID-ul, numele, poziția și salariul fiecărui \nangajat. \n2. Crearea unui tabel Departament pentru a organiza angajații în echipe specifice. \n3. Crearea unui tabel Plata pentru a înregistra salariile plătite fiecărui angajat. \n \n \nScenariul 4: Sistem de gestionare a comenzilor într-un restaurant \nDescriere: \nUn restaurant are nevoie de o bază de date pentru a monitoriza comenzile clienților și \npreparatele din meniu. \nCerințe pentru implementare: \n1. Crearea unui tabel Client care să rețină detalii despre clienți. \n\n2. Crearea unui tabel Comanda care să stocheze comenzile făcute de clienți. \n3. Crearea unui tabel Preparat care să conțină lista de produse disponibile. \n4. Crearea unui tabel ComandaPreparat pentru a lega comenzile cu preparatele comandate. \n \n \nScenariul 5: Sistem de gestionare a pacienților într-un spital \nDescriere: \nUn spital are nevoie de un sistem care să țină evidența pacienților internați, a doctorilor și \ntratamentelor administrate. \nCerințe pentru implementare: \n1. Crearea unui tabel Pacient pentru a înregistra informațiile personale ale pacienților. \n2. Crearea unui tabel Doctor pentru a stoca detalii despre doctori. \n3. Crearea unui tabel Internare care să înregistreze perioada internării pacienților. \n4. Crearea unui tabel Tratament care să urmărească medicamentele administrate pacienților. \n \n \n \n \nReferințe și resurse web \n1) Connolly, T. & Begg, C. (2014). Database Systems: A Practical Approach to Design, \nImplementation, and Management. Pearson. \n2) Silberschatz, A., Korth, H., & Sudarshan, S. (2020). Database System Concepts. McGraw-\nHill. \n3) Elmasri, R., & Navathe, S. (2016). Fundamentals of Database Systems. Pearson. \n4) W3Schools SQL Tutorial \n5) MongoDB Documentation \n6) PostgreSQL Documentation \n7) Redis Documentation', '\n', '8. ', 'Titlu V ARCHAR(100), \n    Autor V ARCHAR(100), \n    ExemplareDisponibile INT \n); \n \nCREATE TABLE Imprumut ( \n    ID INT PRIMARY KEY , \n    CititorID INT, \n    CarteID INT, \n    DataImprumut DATE, \n    DataReturnare DATE, \n    FOREIGN KEY (CititorID) REFERENCES Cititor(ID), \n    FOREIGN KEY (CarteID) REFERENCES Carte(ID) \n); \n \nExplicație: \n• Cititor conține informații despre cititori. \n• Carte include titlul, autorul și numărul de exemplare disponibile. \n• Imprumut leagă cititorii cu cărțile împrumutate și datele asociate acestora. \n \nExemplu de interogare: \nSELECT C.Nume, B.Titlu, I.DataImprumut, I.DataReturnare  \nFROM Imprumut I \nJOIN Cititor C ON I.CititorID = C.ID \nJOIN Carte B ON I.CarteID = B.ID; \nAceastă interogare returnează detaliile despre împrumuturile active din bibliotecă. \n \n \n \nScenariul 3: Sistem de gestionare a angajaților într-o companie \nDescriere: \nO companie dorește să își gestioneze angajații, împreună cu departamentele și salariile \nacestora. \nCerințe pentru implementare: \n1. Crearea unui tabel Angajat care să conțină ID-ul, numele, poziția și salariul fiecărui \nangajat. \n2. Crearea unui tabel Departament pentru a organiza angajații în echipe specifice. \n3. Crearea unui tabel Plata pentru a înregistra salariile plătite fiecărui angajat. \n \n \nScenariul 4: Sistem de gestionare a comenzilor într-un restaurant \nDescriere: \nUn restaurant are nevoie de o bază de date pentru a monitoriza comenzile clienților și \npreparatele din meniu. \nCerințe pentru implementare: \n1. Crearea unui tabel Client care să rețină detalii despre clienți. \n\n2. Crearea unui tabel Comanda care să stocheze comenzile făcute de clienți. \n3. Crearea unui tabel Preparat care să conțină lista de produse disponibile. \n4. Crearea unui tabel ComandaPreparat pentru a lega comenzile cu preparatele comandate. \n \n \nScenariul 5: Sistem de gestionare a pacienților într-un spital \nDescriere: \nUn spital are nevoie de un sistem care să țină evidența pacienților internați, a doctorilor și \ntratamentelor administrate. \nCerințe pentru implementare: \n1. Crearea unui tabel Pacient pentru a înregistra informațiile personale ale pacienților. \n2. Crearea unui tabel Doctor pentru a stoca detalii despre doctori. \n3. Crearea unui tabel Internare care să înregistreze perioada internării pacienților. \n4. Crearea unui tabel Tratament care să urmărească medicamentele administrate pacienților. \n \n \n \n \nReferințe și resurse web \n1) Connolly, T. & Begg, C. (2014). Database Systems: A Practical Approach to Design, \nImplementation, and Management. Pearson. \n2) Silberschatz, A., Korth, H., & Sudarshan, S. (2020). Database System Concepts. McGraw-\nHill. \n3) Elmasri, R., & Navathe, S. (2016). Fundamentals of Database Systems. Pearson. \n4) W3Schools SQL Tutorial \n5) MongoDB Documentation \n6) PostgreSQL Documentation \n7) Redis Documentation', '\n', '9. ', 'Titlu V ARCHAR(100), \n    Autor V ARCHAR(100), \n    ExemplareDisponibile INT \n); \n \nCREATE TABLE Imprumut ( \n    ID INT PRIMARY KEY , \n    CititorID INT, \n    CarteID INT, \n    DataImprumut DATE, \n    DataReturnare DATE, \n    FOREIGN KEY (CititorID) REFERENCES Cititor(ID), \n    FOREIGN KEY (CarteID) REFERENCES Carte(ID) \n); \n \nExplicație: \n• Cititor conține informații despre cititori. \n• Carte include titlul, autorul și numărul de exemplare disponibile. \n• Imprumut leagă cititorii cu cărțile împrumutate și datele asociate acestora. \n \nExemplu de interogare: \nSELECT C.Nume, B.Titlu, I.DataImprumut, I.DataReturnare  \nFROM Imprumut I \nJOIN Cititor C ON I.CititorID = C.ID \nJOIN Carte B ON I.CarteID = B.ID; \nAceastă interogare returnează detaliile despre împrumuturile active din bibliotecă. \n \n \n \nScenariul 3: Sistem de gestionare a angajaților într-o companie \nDescriere: \nO companie dorește să își gestioneze angajații, împreună cu departamentele și salariile \nacestora. \nCerințe pentru implementare: \n1. Crearea unui tabel Angajat care să conțină ID-ul, numele, poziția și salariul fiecărui \nangajat. \n2. Crearea unui tabel Departament pentru a organiza angajații în echipe specifice. \n3. Crearea unui tabel Plata pentru a înregistra salariile plătite fiecărui angajat. \n \n \nScenariul 4: Sistem de gestionare a comenzilor într-un restaurant \nDescriere: \nUn restaurant are nevoie de o bază de date pentru a monitoriza comenzile clienților și \npreparatele din meniu. \nCerințe pentru implementare: \n1. Crearea unui tabel Client care să rețină detalii despre clienți. \n\n2. Crearea unui tabel Comanda care să stocheze comenzile făcute de clienți. \n3. Crearea unui tabel Preparat care să conțină lista de produse disponibile. \n4. Crearea unui tabel ComandaPreparat pentru a lega comenzile cu preparatele comandate. \n \n \nScenariul 5: Sistem de gestionare a pacienților într-un spital \nDescriere: \nUn spital are nevoie de un sistem care să țină evidența pacienților internați, a doctorilor și \ntratamentelor administrate. \nCerințe pentru implementare: \n1. Crearea unui tabel Pacient pentru a înregistra informațiile personale ale pacienților. \n2. Crearea unui tabel Doctor pentru a stoca detalii despre doctori. \n3. Crearea unui tabel Internare care să înregistreze perioada internării pacienților. \n4. Crearea unui tabel Tratament care să urmărească medicamentele administrate pacienților. \n \n \n \n \nReferințe și resurse web \n1) Connolly, T. & Begg, C. (2014). Database Systems: A Practical Approach to Design, \nImplementation, and Management. Pearson. \n2) Silberschatz, A., Korth, H., & Sudarshan, S. (2020). Database System Concepts. McGraw-\nHill. \n3) Elmasri, R., & Navathe, S. (2016). Fundamentals of Database Systems. Pearson. \n4) W3Schools SQL Tutorial \n5) MongoDB Documentation \n6) PostgreSQL Documentation \n7) Redis Documentation', '\n', '10. ', ""3.2. Sistem bancar - Proiectare bază de date pentru conturi \nCREATE TABLE ContBancar ( \n    ID INT PRIMARY KEY , \n    Titular V ARCHAR(50), \n    Sold DECIMAL(15,2) CHECK (Sold >= 0) \n); \n \nCREATE TABLE Tranzactie ( \n    ID INT PRIMARY KEY , \n    ContID INT, \n    Suma DECIMAL(15,2), \n    Tip V ARCHAR(10) CHECK (Tip IN ('Depunere', 'Retragere')), \n    DataTranzactie DATE, \n    FOREIGN KEY (ContID) REFERENCES ContBancar(ID) \n); \n \n \n3.4 Optimizarea bazei de date \n \nPentru a îmbunătăți performanța unei baze de date relaționale, se folosesc diferite tehnici de \noptimizare: \n1. Indexarea - Crearea de indexuri pentru căutări rapide. \n2. Partiționarea tabelelor - Împărțirea unei tabele mari în părți mai mici pentru acces mai \nrapid. \n3. Denormalizarea parțială - Îmbunătățirea performanței prin eliminarea anumitor reguli \nde normalizare în cazuri specifice. \n4. Utilizarea procedurilor stocate - Optimizarea execuției interogărilor frecvente. \nExemplu de creare a unui index pentru îmbunătățirea căutărilor: \nCREATE INDEX idx_nume_client ON Client(Nume); \n \n \n \n3.5 Scenarii reale de proiectare a bazelor de date \n \nScenariul 1: Sistem de gestionare a rezervărilor pentru un hotel \nDescriere: \nUn hotel dorește să își gestioneze rezervările printr-o bază de date care să permită urmărirea \ncamerelor disponibile, a rezervărilor făcute de clienți și a detaliilor despre clienți. \nModelul relațional propus: \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Telefon V ARCHAR(15), \n    Email V ARCHAR(50) \n); \n \n\nCREATE TABLE Camera ( \n    ID INT PRIMARY KEY , \n    Tip V ARCHAR(50), \n    Pret DECIMAL(10,2), \n    Disponibilitate BOOLEAN \n); \n \nCREATE TABLE Rezervare ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    CameraID INT, \n    DataStart DATE, \n    DataEnd DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID), \n    FOREIGN KEY (CameraID) REFERENCES Camera(ID) \n); \n \nExplicație: \n• Tabelul Client reține informațiile despre clienți. \n• Tabelul Camera păstrează detalii despre camere și disponibilitatea acestora. \n• Tabelul Rezervare conectează clienții cu camerele rezervate. \n• Se utilizează chei străine pentru a menține integritatea datelor. \n \nExemplu de interogare: \nSELECT C.Nume, R.DataStart, R.DataEnd, Cam.Tip  \nFROM Rezervare R \nJOIN Client C ON R.ClientID = C.ID \nJOIN Camera Cam ON R.CameraID = Cam.ID \nWHERE Cam.Disponibilitate = TRUE; \nAceastă interogare returnează toate rezervările active cu detaliile clienților și tipurile de camere \nrezervate. \n \n \nScenariul 2: Sistem de evidență a împrumuturilor dintr-o bibliotecă \nDescriere: \nO bibliotecă dorește un sistem care să monitorizeze împrumuturile cărților și să asigure că fiecare \ncarte este returnată la timp. \nModelul relațional propus: \nCREATE TABLE Cititor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY ,"", '\n']","constrângerile de integritate se aplică astfel:

*   **PRIMARY KEY:** Asigură unicitatea înregistrărilor într-un tabel. Exemplu: `ID INT PRIMARY KEY` în tabelele `ContBancar`, `Tranzactie`, `Client`, `Camera`, `Rezervare`, `Cititor`, `Carte`, `Imprumut`.
*   **FOREIGN KEY:** Stabilește relații între tabele și asigură integritatea referențială. Exemplu: `FOREIGN KEY (ContID) REFERENCES ContBancar(ID)` în tabelul `Tranzactie`, sau `FOREIGN KEY (ClientID) REFERENCES Client(ID)` si `FOREIGN KEY (CameraID) REFERENCES Camera(ID)` in tabelul `Rezervare`.
*  **CHECK:** impune restrictii, conditii, pentru valorile permise într-o coloană:. Exemplu: `CHECK (Sold >= 0)` în tabelul `ContBancar`, `CHECK (Tip IN ('Depunere', 'Retragere'))` in tabelul `Tranzactie`.
","Constrângerile asigură integritatea: PRIMARY KEY identifică unic fiecare rând, FOREIGN KEY “REFERENCES” stabilește relații corecte între tabele, iar CHECK impune condiții (ex.: CHECK(sal > 0)). Aceste reguli „previn pătrunderea de date invalide” și susțin securitatea în medii multi-user.",0.07461653788241648,1.0,0.9106624227739535,0.5555555555555556,0.04814971807094068,0.25352112676056343,0.4
35,O3mini-high,High,"C9, C3",C4,Ce avantaje oferă utilizarea vederilor (views) și cum simplifică ele interogările complexe?,"Vederile sunt „tabele logice” definite printr-o instrucțiune SELECT, care nu stochează date proprii, ci le extrag din tabele. Ele oferă acces restricționat, simplifică join-urile complexe și permit reutilizarea codului SQL, facilitând astfel interogările complexe.",Este corect,"C9, slide 6",[],"Nu am gasit informatii in curs despre intrebarea ta
",Ce avantaje oferă utilizarea vederilor (views) și cum simplifică ele interogările complexe?,[],"Nu am gasit informatii in curs despre intrebarea ta
","Vederile sunt „tabele logice” definite printr-o instrucțiune SELECT, care nu stochează date proprii, ci le extrag din tabele. Ele oferă acces restricționat, simplifică join-urile complexe și permit reutilizarea codului SQL, facilitând astfel interogările complexe.",0.0,0.0,0.0,0.0,0.0,0.04081632653061225,
36,O3mini-high,High,"C10, C3",C8,Cum contribuie secvențele și indicii la performanța bazelor de date?,"Secvențele generează „rapid numere întregi unice” pentru chei primare, evitând blocajele, iar indicii optimizează căutările prin reducerea operațiilor I/O. Astfel, ele îmbunătățesc semnificativ performanța bazei de date.",Este corect,C10,"['1. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '2. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '3. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '4. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '5. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '6. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '7. ', '4. Normalizarea bazelor de date \n \n4.1. Introducere în normalizarea bazelor de date \nNormalizarea este procesul de organizare a datelor într-o bază de date pentru a minimiza \nredundanța și dependențele nedorite. Aceasta implică aplicarea mai multor forme normale (NF), \nfiecare având un set de reguli specifice care îmbunătățesc structura bazei de date. \nObiectivele normalizării: \n1. Eliminarea redundanței datelor. \n2. Îmbunătățirea integrității și consistenței bazei de date. \n3. Creșterea eficienței interogărilor și a actualizărilor datelor. \n \n \n4.2. Prima formă normală (1NF) \nReguli: \n1. Fiecare coloană trebuie să conțină doar valori atomice (nu liste sau seturi de valori). \n2. Fiecare coloană trebuie să conțină doar un singur tip de date. \n \nExemplu de tabel neconform cu 1NF: \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Telefoane V ARCHAR(100) \n); \nÎn această structură, coloana Telefoane poate conține mai multe numere de telefon pentru \nun singur student, ceea ce încalcă principiile 1NF. \n \nTabel conform cu 1NF: \nCREATE TABLE Telefon ( \n    StudentID INT, \n    Numar V ARCHAR(15), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID) \n); \n \n \n4.3. A doua formă normală (2NF) \nReguli: \n1. Baza de date trebuie să fie în 1NF. \n2. Toate atributele necheie trebuie să depindă în întregime de cheia primară. \n \nExemplu de tabel neconform cu 2NF: \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    Profesor V ARCHAR(50), \n    PRIMARY KEY (StudentID, CursCod) \n); \n\n \nÎn acest exemplu, Profesor nu depinde de cheia compusă (StudentID, CursCod), ci doar de \nCursCod. \nTabel conform cu 2NF: \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    Profesor V ARCHAR(50) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n4.4. A treia formă normală (3NF) \nReguli: \n1. Baza de date trebuie să fie în 2NF. \n2. Nicio coloană non-cheie nu trebuie să depindă tranzitiv de cheia primară. \n \nExemplu de tabel neconform cu 3NF: \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Oras V ARCHAR(50), \n    CodPostal V ARCHAR(10) \n); \nÎn această structură, CodPostal depinde de Oras, nu de ID, ceea ce încalcă regula 3NF. \nTabel conform cu 3NF: \nCREATE TABLE Oras ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    CodPostal V ARCHAR(10) \n); \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    OrasID INT, \n    FOREIGN KEY (OrasID) REFERENCES Oras(ID) \n);', '\n', '8. ', '4. Normalizarea bazelor de date \n \n4.1. Introducere în normalizarea bazelor de date \nNormalizarea este procesul de organizare a datelor într-o bază de date pentru a minimiza \nredundanța și dependențele nedorite. Aceasta implică aplicarea mai multor forme normale (NF), \nfiecare având un set de reguli specifice care îmbunătățesc structura bazei de date. \nObiectivele normalizării: \n1. Eliminarea redundanței datelor. \n2. Îmbunătățirea integrității și consistenței bazei de date. \n3. Creșterea eficienței interogărilor și a actualizărilor datelor. \n \n \n4.2. Prima formă normală (1NF) \nReguli: \n1. Fiecare coloană trebuie să conțină doar valori atomice (nu liste sau seturi de valori). \n2. Fiecare coloană trebuie să conțină doar un singur tip de date. \n \nExemplu de tabel neconform cu 1NF: \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Telefoane V ARCHAR(100) \n); \nÎn această structură, coloana Telefoane poate conține mai multe numere de telefon pentru \nun singur student, ceea ce încalcă principiile 1NF. \n \nTabel conform cu 1NF: \nCREATE TABLE Telefon ( \n    StudentID INT, \n    Numar V ARCHAR(15), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID) \n); \n \n \n4.3. A doua formă normală (2NF) \nReguli: \n1. Baza de date trebuie să fie în 1NF. \n2. Toate atributele necheie trebuie să depindă în întregime de cheia primară. \n \nExemplu de tabel neconform cu 2NF: \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    Profesor V ARCHAR(50), \n    PRIMARY KEY (StudentID, CursCod) \n); \n\n \nÎn acest exemplu, Profesor nu depinde de cheia compusă (StudentID, CursCod), ci doar de \nCursCod. \nTabel conform cu 2NF: \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    Profesor V ARCHAR(50) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n4.4. A treia formă normală (3NF) \nReguli: \n1. Baza de date trebuie să fie în 2NF. \n2. Nicio coloană non-cheie nu trebuie să depindă tranzitiv de cheia primară. \n \nExemplu de tabel neconform cu 3NF: \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Oras V ARCHAR(50), \n    CodPostal V ARCHAR(10) \n); \nÎn această structură, CodPostal depinde de Oras, nu de ID, ceea ce încalcă regula 3NF. \nTabel conform cu 3NF: \nCREATE TABLE Oras ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    CodPostal V ARCHAR(10) \n); \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    OrasID INT, \n    FOREIGN KEY (OrasID) REFERENCES Oras(ID) \n);', '\n', '9. ', '4. Normalizarea bazelor de date \n \n4.1. Introducere în normalizarea bazelor de date \nNormalizarea este procesul de organizare a datelor într-o bază de date pentru a minimiza \nredundanța și dependențele nedorite. Aceasta implică aplicarea mai multor forme normale (NF), \nfiecare având un set de reguli specifice care îmbunătățesc structura bazei de date. \nObiectivele normalizării: \n1. Eliminarea redundanței datelor. \n2. Îmbunătățirea integrității și consistenței bazei de date. \n3. Creșterea eficienței interogărilor și a actualizărilor datelor. \n \n \n4.2. Prima formă normală (1NF) \nReguli: \n1. Fiecare coloană trebuie să conțină doar valori atomice (nu liste sau seturi de valori). \n2. Fiecare coloană trebuie să conțină doar un singur tip de date. \n \nExemplu de tabel neconform cu 1NF: \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Telefoane V ARCHAR(100) \n); \nÎn această structură, coloana Telefoane poate conține mai multe numere de telefon pentru \nun singur student, ceea ce încalcă principiile 1NF. \n \nTabel conform cu 1NF: \nCREATE TABLE Telefon ( \n    StudentID INT, \n    Numar V ARCHAR(15), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID) \n); \n \n \n4.3. A doua formă normală (2NF) \nReguli: \n1. Baza de date trebuie să fie în 1NF. \n2. Toate atributele necheie trebuie să depindă în întregime de cheia primară. \n \nExemplu de tabel neconform cu 2NF: \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    Profesor V ARCHAR(50), \n    PRIMARY KEY (StudentID, CursCod) \n); \n\n \nÎn acest exemplu, Profesor nu depinde de cheia compusă (StudentID, CursCod), ci doar de \nCursCod. \nTabel conform cu 2NF: \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    Profesor V ARCHAR(50) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n4.4. A treia formă normală (3NF) \nReguli: \n1. Baza de date trebuie să fie în 2NF. \n2. Nicio coloană non-cheie nu trebuie să depindă tranzitiv de cheia primară. \n \nExemplu de tabel neconform cu 3NF: \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Oras V ARCHAR(50), \n    CodPostal V ARCHAR(10) \n); \nÎn această structură, CodPostal depinde de Oras, nu de ID, ceea ce încalcă regula 3NF. \nTabel conform cu 3NF: \nCREATE TABLE Oras ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    CodPostal V ARCHAR(10) \n); \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    OrasID INT, \n    FOREIGN KEY (OrasID) REFERENCES Oras(ID) \n);', '\n', '10. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n']","nu există detalii specifice despre modul în care secvențele și indicii contribuie la performanța bazelor de date. Cursurile acoperă definiții, caracteristici ale bazelor de date, modelul relațional, algebra relațională, și normalizarea, dar nu detaliază aspectele legate de secvențe și indici.
",Cum contribuie secvențele și indicii la performanța bazelor de date?,"['1. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '2. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '3. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '4. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '5. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '6. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '7. ', '4. Normalizarea bazelor de date \n \n4.1. Introducere în normalizarea bazelor de date \nNormalizarea este procesul de organizare a datelor într-o bază de date pentru a minimiza \nredundanța și dependențele nedorite. Aceasta implică aplicarea mai multor forme normale (NF), \nfiecare având un set de reguli specifice care îmbunătățesc structura bazei de date. \nObiectivele normalizării: \n1. Eliminarea redundanței datelor. \n2. Îmbunătățirea integrității și consistenței bazei de date. \n3. Creșterea eficienței interogărilor și a actualizărilor datelor. \n \n \n4.2. Prima formă normală (1NF) \nReguli: \n1. Fiecare coloană trebuie să conțină doar valori atomice (nu liste sau seturi de valori). \n2. Fiecare coloană trebuie să conțină doar un singur tip de date. \n \nExemplu de tabel neconform cu 1NF: \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Telefoane V ARCHAR(100) \n); \nÎn această structură, coloana Telefoane poate conține mai multe numere de telefon pentru \nun singur student, ceea ce încalcă principiile 1NF. \n \nTabel conform cu 1NF: \nCREATE TABLE Telefon ( \n    StudentID INT, \n    Numar V ARCHAR(15), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID) \n); \n \n \n4.3. A doua formă normală (2NF) \nReguli: \n1. Baza de date trebuie să fie în 1NF. \n2. Toate atributele necheie trebuie să depindă în întregime de cheia primară. \n \nExemplu de tabel neconform cu 2NF: \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    Profesor V ARCHAR(50), \n    PRIMARY KEY (StudentID, CursCod) \n); \n\n \nÎn acest exemplu, Profesor nu depinde de cheia compusă (StudentID, CursCod), ci doar de \nCursCod. \nTabel conform cu 2NF: \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    Profesor V ARCHAR(50) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n4.4. A treia formă normală (3NF) \nReguli: \n1. Baza de date trebuie să fie în 2NF. \n2. Nicio coloană non-cheie nu trebuie să depindă tranzitiv de cheia primară. \n \nExemplu de tabel neconform cu 3NF: \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Oras V ARCHAR(50), \n    CodPostal V ARCHAR(10) \n); \nÎn această structură, CodPostal depinde de Oras, nu de ID, ceea ce încalcă regula 3NF. \nTabel conform cu 3NF: \nCREATE TABLE Oras ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    CodPostal V ARCHAR(10) \n); \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    OrasID INT, \n    FOREIGN KEY (OrasID) REFERENCES Oras(ID) \n);', '\n', '8. ', '4. Normalizarea bazelor de date \n \n4.1. Introducere în normalizarea bazelor de date \nNormalizarea este procesul de organizare a datelor într-o bază de date pentru a minimiza \nredundanța și dependențele nedorite. Aceasta implică aplicarea mai multor forme normale (NF), \nfiecare având un set de reguli specifice care îmbunătățesc structura bazei de date. \nObiectivele normalizării: \n1. Eliminarea redundanței datelor. \n2. Îmbunătățirea integrității și consistenței bazei de date. \n3. Creșterea eficienței interogărilor și a actualizărilor datelor. \n \n \n4.2. Prima formă normală (1NF) \nReguli: \n1. Fiecare coloană trebuie să conțină doar valori atomice (nu liste sau seturi de valori). \n2. Fiecare coloană trebuie să conțină doar un singur tip de date. \n \nExemplu de tabel neconform cu 1NF: \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Telefoane V ARCHAR(100) \n); \nÎn această structură, coloana Telefoane poate conține mai multe numere de telefon pentru \nun singur student, ceea ce încalcă principiile 1NF. \n \nTabel conform cu 1NF: \nCREATE TABLE Telefon ( \n    StudentID INT, \n    Numar V ARCHAR(15), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID) \n); \n \n \n4.3. A doua formă normală (2NF) \nReguli: \n1. Baza de date trebuie să fie în 1NF. \n2. Toate atributele necheie trebuie să depindă în întregime de cheia primară. \n \nExemplu de tabel neconform cu 2NF: \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    Profesor V ARCHAR(50), \n    PRIMARY KEY (StudentID, CursCod) \n); \n\n \nÎn acest exemplu, Profesor nu depinde de cheia compusă (StudentID, CursCod), ci doar de \nCursCod. \nTabel conform cu 2NF: \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    Profesor V ARCHAR(50) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n4.4. A treia formă normală (3NF) \nReguli: \n1. Baza de date trebuie să fie în 2NF. \n2. Nicio coloană non-cheie nu trebuie să depindă tranzitiv de cheia primară. \n \nExemplu de tabel neconform cu 3NF: \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Oras V ARCHAR(50), \n    CodPostal V ARCHAR(10) \n); \nÎn această structură, CodPostal depinde de Oras, nu de ID, ceea ce încalcă regula 3NF. \nTabel conform cu 3NF: \nCREATE TABLE Oras ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    CodPostal V ARCHAR(10) \n); \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    OrasID INT, \n    FOREIGN KEY (OrasID) REFERENCES Oras(ID) \n);', '\n', '9. ', '4. Normalizarea bazelor de date \n \n4.1. Introducere în normalizarea bazelor de date \nNormalizarea este procesul de organizare a datelor într-o bază de date pentru a minimiza \nredundanța și dependențele nedorite. Aceasta implică aplicarea mai multor forme normale (NF), \nfiecare având un set de reguli specifice care îmbunătățesc structura bazei de date. \nObiectivele normalizării: \n1. Eliminarea redundanței datelor. \n2. Îmbunătățirea integrității și consistenței bazei de date. \n3. Creșterea eficienței interogărilor și a actualizărilor datelor. \n \n \n4.2. Prima formă normală (1NF) \nReguli: \n1. Fiecare coloană trebuie să conțină doar valori atomice (nu liste sau seturi de valori). \n2. Fiecare coloană trebuie să conțină doar un singur tip de date. \n \nExemplu de tabel neconform cu 1NF: \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Telefoane V ARCHAR(100) \n); \nÎn această structură, coloana Telefoane poate conține mai multe numere de telefon pentru \nun singur student, ceea ce încalcă principiile 1NF. \n \nTabel conform cu 1NF: \nCREATE TABLE Telefon ( \n    StudentID INT, \n    Numar V ARCHAR(15), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID) \n); \n \n \n4.3. A doua formă normală (2NF) \nReguli: \n1. Baza de date trebuie să fie în 1NF. \n2. Toate atributele necheie trebuie să depindă în întregime de cheia primară. \n \nExemplu de tabel neconform cu 2NF: \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    Profesor V ARCHAR(50), \n    PRIMARY KEY (StudentID, CursCod) \n); \n\n \nÎn acest exemplu, Profesor nu depinde de cheia compusă (StudentID, CursCod), ci doar de \nCursCod. \nTabel conform cu 2NF: \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    Profesor V ARCHAR(50) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n4.4. A treia formă normală (3NF) \nReguli: \n1. Baza de date trebuie să fie în 2NF. \n2. Nicio coloană non-cheie nu trebuie să depindă tranzitiv de cheia primară. \n \nExemplu de tabel neconform cu 3NF: \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Oras V ARCHAR(50), \n    CodPostal V ARCHAR(10) \n); \nÎn această structură, CodPostal depinde de Oras, nu de ID, ceea ce încalcă regula 3NF. \nTabel conform cu 3NF: \nCREATE TABLE Oras ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    CodPostal V ARCHAR(10) \n); \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    OrasID INT, \n    FOREIGN KEY (OrasID) REFERENCES Oras(ID) \n);', '\n', '10. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n']","nu există detalii specifice despre modul în care secvențele și indicii contribuie la performanța bazelor de date. Cursurile acoperă definiții, caracteristici ale bazelor de date, modelul relațional, algebra relațională, și normalizarea, dar nu detaliază aspectele legate de secvențe și indici.
","Secvențele generează „rapid numere întregi unice” pentru chei primare, evitând blocajele, iar indicii optimizează căutările prin reducerea operațiilor I/O. Astfel, ele îmbunătățesc semnificativ performanța bazei de date.",0.0,0.0,0.0,1.0,0.03821774391346778,0.17073170731707318,0.0
37,O3mini-high,High,"C11, C2",C8,Cum se implementează controlul accesului și gestionarea privilegiilor în Oracle?,"Controlul accesului se realizează prin acordarea de privilegii de sistem și obiect de către DBA, folosind comenzi precum CREATE USER și GRANT. Aceste măsuri „asigură securitatea utilizării și accesării bazei de date” într-un mediu multi-user.",Este corect,"C11, slide 18","['1. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32\n\n2.3. ORACLE Server\n ORACLE Server (OS) permite \nmanagementul informaţiilor organizate în baze \nde date, astfel încât se asigură accesul mai \nmultor utilizatori în mod concurenţial la acelaşi \ndate, oferind facilităţi de prevenire a accesului \nneautorizat şi de restaurare a datelor după \nproducerea unor erori. \n33\n\n2.3. ORACLE Server\nORACLE Server este un sistem relaţional-\nobiectual de management a bazelor de date, \ncare permite o abordare deschisă, integrată şi \ncuprinzătoare a managementului \ninformaţiilor. \nOS constă dintr-un cuplu format dintr-o \nbază de date şi o instanţă Oracle.\n34\n\n2.3. ORACLE Server\nA. O bază de date Oracle este o colecţie \nunitară de date, având o structură logică şi \nuna fizică putând avea două stări: \n1. open (accesibilă) \n2. close (inaccesibilă)\n35\n\n2.3. ORACLE Server\n1) Structura logică a unei baze de date este \nformată din:\n✓tabelele spaţiu (tablespaces)\n✓schema de obiectelor bazei de date\n✓blocurile de date\n✓extensiile\n✓segmentele\n36\n\n2.3. ORACLE Server\n2) Structura fizică este definită de un set de \nfişiere specifice sistemului de operare pe care \nrezidă SGBD Oracle, folosite pentru memorarea \nstructurilor logice ale bazei de date şi pentru \npăstrarea unor informaţii tehnice de control. \nAceste fişiere sunt: \n- fişiere de date (Data files)\n- fişiere Redo log (Redo Log files) \n- fişiere de control (Control files)\n37\n\n2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n39\n\n2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40\n\n2.4. ORACLE Database 11g Expres Edition\n Pe calculatorul personal este ideal sa se \ninstaleze fisierul: \nOracle Database 11g Express Edition \n(Universal)  OracleXE112_Win32.zip\n41\n\n2.4. ORACLE Database 11g Expres Edition\nPas 1: Se porneste instalarea fisierului executabil si se vor \nurma pasii indicati de catre programul de instalare.\n42\n\n2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43\n\n2.4. ORACLE Database 11g Expres Edition\nInstalarea aplicatiei\n 44', '\n', '2. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32\n\n2.3. ORACLE Server\n ORACLE Server (OS) permite \nmanagementul informaţiilor organizate în baze \nde date, astfel încât se asigură accesul mai \nmultor utilizatori în mod concurenţial la acelaşi \ndate, oferind facilităţi de prevenire a accesului \nneautorizat şi de restaurare a datelor după \nproducerea unor erori. \n33\n\n2.3. ORACLE Server\nORACLE Server este un sistem relaţional-\nobiectual de management a bazelor de date, \ncare permite o abordare deschisă, integrată şi \ncuprinzătoare a managementului \ninformaţiilor. \nOS constă dintr-un cuplu format dintr-o \nbază de date şi o instanţă Oracle.\n34\n\n2.3. ORACLE Server\nA. O bază de date Oracle este o colecţie \nunitară de date, având o structură logică şi \nuna fizică putând avea două stări: \n1. open (accesibilă) \n2. close (inaccesibilă)\n35\n\n2.3. ORACLE Server\n1) Structura logică a unei baze de date este \nformată din:\n✓tabelele spaţiu (tablespaces)\n✓schema de obiectelor bazei de date\n✓blocurile de date\n✓extensiile\n✓segmentele\n36\n\n2.3. ORACLE Server\n2) Structura fizică este definită de un set de \nfişiere specifice sistemului de operare pe care \nrezidă SGBD Oracle, folosite pentru memorarea \nstructurilor logice ale bazei de date şi pentru \npăstrarea unor informaţii tehnice de control. \nAceste fişiere sunt: \n- fişiere de date (Data files)\n- fişiere Redo log (Redo Log files) \n- fişiere de control (Control files)\n37\n\n2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n39\n\n2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40\n\n2.4. ORACLE Database 11g Expres Edition\n Pe calculatorul personal este ideal sa se \ninstaleze fisierul: \nOracle Database 11g Express Edition \n(Universal)  OracleXE112_Win32.zip\n41\n\n2.4. ORACLE Database 11g Expres Edition\nPas 1: Se porneste instalarea fisierului executabil si se vor \nurma pasii indicati de catre programul de instalare.\n42\n\n2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43\n\n2.4. ORACLE Database 11g Expres Edition\nInstalarea aplicatiei\n 44', '\n', '3. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32\n\n2.3. ORACLE Server\n ORACLE Server (OS) permite \nmanagementul informaţiilor organizate în baze \nde date, astfel încât se asigură accesul mai \nmultor utilizatori în mod concurenţial la acelaşi \ndate, oferind facilităţi de prevenire a accesului \nneautorizat şi de restaurare a datelor după \nproducerea unor erori. \n33\n\n2.3. ORACLE Server\nORACLE Server este un sistem relaţional-\nobiectual de management a bazelor de date, \ncare permite o abordare deschisă, integrată şi \ncuprinzătoare a managementului \ninformaţiilor. \nOS constă dintr-un cuplu format dintr-o \nbază de date şi o instanţă Oracle.\n34\n\n2.3. ORACLE Server\nA. O bază de date Oracle este o colecţie \nunitară de date, având o structură logică şi \nuna fizică putând avea două stări: \n1. open (accesibilă) \n2. close (inaccesibilă)\n35\n\n2.3. ORACLE Server\n1) Structura logică a unei baze de date este \nformată din:\n✓tabelele spaţiu (tablespaces)\n✓schema de obiectelor bazei de date\n✓blocurile de date\n✓extensiile\n✓segmentele\n36\n\n2.3. ORACLE Server\n2) Structura fizică este definită de un set de \nfişiere specifice sistemului de operare pe care \nrezidă SGBD Oracle, folosite pentru memorarea \nstructurilor logice ale bazei de date şi pentru \npăstrarea unor informaţii tehnice de control. \nAceste fişiere sunt: \n- fişiere de date (Data files)\n- fişiere Redo log (Redo Log files) \n- fişiere de control (Control files)\n37\n\n2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n39\n\n2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40\n\n2.4. ORACLE Database 11g Expres Edition\n Pe calculatorul personal este ideal sa se \ninstaleze fisierul: \nOracle Database 11g Express Edition \n(Universal)  OracleXE112_Win32.zip\n41\n\n2.4. ORACLE Database 11g Expres Edition\nPas 1: Se porneste instalarea fisierului executabil si se vor \nurma pasii indicati de catre programul de instalare.\n42\n\n2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43\n\n2.4. ORACLE Database 11g Expres Edition\nInstalarea aplicatiei\n 44', '\n', '4. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nOracle 9i REAL APPLICATION CLUSTERS (RAC) se bazează pe \no nouă arhitectură de BD numită îmbinare ascunsă (Cache \nFusion). \n✓Aceasta este o nouă generaţie de tehnologie de clustere. \n✓Conform acestei arhitecturi la adăugarea unui calculator \nîntr-o reţea cu BD Oracle, clusterele se adaptează automat \nla noile resurse, fără să fie necesară redistribuirea datelor \nsau rescrierea aplicaţiei.\n✓Posibilitatea apariţiei unei erori la o configuraţie cu 12 \ncalculatoare sub Oracle 9i RAC este foarte mică, estimată \nca durată în timp la cca 100.000 de ani. \n17\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oracle 9i DEVELOPER SUITE este un mediu \ncomplet pentru dezvoltarea aplicaţiilor tip \nafaceri electronice (e-business) şi tip Web. \nEl se bazează pe tehnologiile Java şi XML şi permite \npersonalizarea (Oracle Personalization). \n• În anul 2003 a fost lansată versiunea Oracle 10g \ncare adaugă noi facilităţi sistemului Oracle 9i. \n19\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În anul 2007 a fost lansată versiunea Oracle \n11g care are cateva facilitati in plus:\n– Gestioneaza datele mai eficient prin compresii \navansate si partitionari \n– Simplifica sistemele prin stocarea tuturor datelor in \nOracle Database cu Oracle SecureFiles\n• În anul 2013 a fost lansată versiunea Oracle \n12c\n20\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle Database 12c prezintă o arhitectură nouă, cu \nmai multe entităţi găzduite, care permite unificarea \nrapidă a mai multor baze de date şi gestionarea \nacestora ca serviciu cloud. \n➢Oracle Database 12c include, de asemenea, capacităţi \nde procesare a datelor în memorie, care oferă o \nperformanţă analitică inovatoare. \n➢Inovaţiile suplimentare pentru baze de date oferă noi \nnivele de eficienţă, performanţă, securitate şi \ndisponibilitate.[*]\n21[*] https://www.oracle.com/ro/database/index.html\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', '\n', '5. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nOracle 9i REAL APPLICATION CLUSTERS (RAC) se bazează pe \no nouă arhitectură de BD numită îmbinare ascunsă (Cache \nFusion). \n✓Aceasta este o nouă generaţie de tehnologie de clustere. \n✓Conform acestei arhitecturi la adăugarea unui calculator \nîntr-o reţea cu BD Oracle, clusterele se adaptează automat \nla noile resurse, fără să fie necesară redistribuirea datelor \nsau rescrierea aplicaţiei.\n✓Posibilitatea apariţiei unei erori la o configuraţie cu 12 \ncalculatoare sub Oracle 9i RAC este foarte mică, estimată \nca durată în timp la cca 100.000 de ani. \n17\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oracle 9i DEVELOPER SUITE este un mediu \ncomplet pentru dezvoltarea aplicaţiilor tip \nafaceri electronice (e-business) şi tip Web. \nEl se bazează pe tehnologiile Java şi XML şi permite \npersonalizarea (Oracle Personalization). \n• În anul 2003 a fost lansată versiunea Oracle 10g \ncare adaugă noi facilităţi sistemului Oracle 9i. \n19\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În anul 2007 a fost lansată versiunea Oracle \n11g care are cateva facilitati in plus:\n– Gestioneaza datele mai eficient prin compresii \navansate si partitionari \n– Simplifica sistemele prin stocarea tuturor datelor in \nOracle Database cu Oracle SecureFiles\n• În anul 2013 a fost lansată versiunea Oracle \n12c\n20\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle Database 12c prezintă o arhitectură nouă, cu \nmai multe entităţi găzduite, care permite unificarea \nrapidă a mai multor baze de date şi gestionarea \nacestora ca serviciu cloud. \n➢Oracle Database 12c include, de asemenea, capacităţi \nde procesare a datelor în memorie, care oferă o \nperformanţă analitică inovatoare. \n➢Inovaţiile suplimentare pentru baze de date oferă noi \nnivele de eficienţă, performanţă, securitate şi \ndisponibilitate.[*]\n21[*] https://www.oracle.com/ro/database/index.html\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', '\n', '6. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nOracle 9i REAL APPLICATION CLUSTERS (RAC) se bazează pe \no nouă arhitectură de BD numită îmbinare ascunsă (Cache \nFusion). \n✓Aceasta este o nouă generaţie de tehnologie de clustere. \n✓Conform acestei arhitecturi la adăugarea unui calculator \nîntr-o reţea cu BD Oracle, clusterele se adaptează automat \nla noile resurse, fără să fie necesară redistribuirea datelor \nsau rescrierea aplicaţiei.\n✓Posibilitatea apariţiei unei erori la o configuraţie cu 12 \ncalculatoare sub Oracle 9i RAC este foarte mică, estimată \nca durată în timp la cca 100.000 de ani. \n17\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oracle 9i DEVELOPER SUITE este un mediu \ncomplet pentru dezvoltarea aplicaţiilor tip \nafaceri electronice (e-business) şi tip Web. \nEl se bazează pe tehnologiile Java şi XML şi permite \npersonalizarea (Oracle Personalization). \n• În anul 2003 a fost lansată versiunea Oracle 10g \ncare adaugă noi facilităţi sistemului Oracle 9i. \n19\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În anul 2007 a fost lansată versiunea Oracle \n11g care are cateva facilitati in plus:\n– Gestioneaza datele mai eficient prin compresii \navansate si partitionari \n– Simplifica sistemele prin stocarea tuturor datelor in \nOracle Database cu Oracle SecureFiles\n• În anul 2013 a fost lansată versiunea Oracle \n12c\n20\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle Database 12c prezintă o arhitectură nouă, cu \nmai multe entităţi găzduite, care permite unificarea \nrapidă a mai multor baze de date şi gestionarea \nacestora ca serviciu cloud. \n➢Oracle Database 12c include, de asemenea, capacităţi \nde procesare a datelor în memorie, care oferă o \nperformanţă analitică inovatoare. \n➢Inovaţiile suplimentare pentru baze de date oferă noi \nnivele de eficienţă, performanţă, securitate şi \ndisponibilitate.[*]\n21[*] https://www.oracle.com/ro/database/index.html\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', '\n', '7. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n', '8. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n', '9. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n', '10. ', 'Curs 11\nControlul accesului utilizatorilor\nCurs - BAZE DE DATE 2\n\n\nCuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3\n\nControlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4\n\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5\n\ntt\n1) Securitatea sistemului acopera accesarea si \nutilizarea bazei de date la nivelul sistemului, cum \nar fi: numele utilizatorului si parola, spatiul pe \ndisc alocat utilizatorilor, si operatiile de sistem \npermise utilizatorilor. \nCurs - BAZE DE DATE 6\nhttps://www.scnsoft.com/blog/database-security-best-practices\n\ntt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/\n\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8\n\nScheme \nO schema este o colectie de obiecte, cum ar fi: \n✓tabele\n✓indecsi\n✓vizualizari\n✓secvente\nSchema este detinuta de un utilizator al bazei de \ndate si are acelasi nume cu utilizatorul.\nCurs - BAZE DE DATE 9\n\ntt\nPrivilegii de sistem\nSunt disponibile mai mult de 80 de privilegii de \nsistem pentru utilizatori si pentru roluri. \nPrivilegiile de sistem sunt setate  de catre  \nadministratorul bazei de date.\nCurs - BAZE DE DATE 10\n\nPrivilegiile caracteristice ale DBA\nPrivilegii de sistem Operatii autorizate\nCreare de utilizatori Permite crearea unui alt utilizator Oracle (privilegiu\ncerut pentru rolul de DBA)\nStergerea de utilizatori Permite stergerea altui utilizator\nStergerea oricarei tabele Permite stergerea unei tabele în orice schema\nRecuperarea oricarei\ntabele\nRecuperarea oricarei tabele în orice schema cu\nutilitare de export\nCurs - BAZE DE DATE 11', '\n']","controlul accesului și gestionarea privilegiilor în Oracle se implementează prin acordarea de privilegii utilizatorilor. Există două tipuri principale de privilegii:

1.  **Privilegii de sistem:** Acestea controlează accesul la nivelul bazei de date (ex: crearea, ștergerea utilizatorilor, ștergerea oricărei tabele, recuperarea oricărei tabele).
2.  **Privilegii de obiect:** Acestea permit manipularea conținutului obiectelor din baza de date (ex: tabele, indecși, vizualizări, secvențe) aflate intr-o schema.

Administratorul bazei de date (DBA) este responsabil de acordarea acestor privilegii. Utilizatorii pot primi, de asemenea, privilegiul de a acorda mai departe privilegii altor utilizatori sau roluri.
",Cum se implementează controlul accesului și gestionarea privilegiilor în Oracle?,"['1. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32\n\n2.3. ORACLE Server\n ORACLE Server (OS) permite \nmanagementul informaţiilor organizate în baze \nde date, astfel încât se asigură accesul mai \nmultor utilizatori în mod concurenţial la acelaşi \ndate, oferind facilităţi de prevenire a accesului \nneautorizat şi de restaurare a datelor după \nproducerea unor erori. \n33\n\n2.3. ORACLE Server\nORACLE Server este un sistem relaţional-\nobiectual de management a bazelor de date, \ncare permite o abordare deschisă, integrată şi \ncuprinzătoare a managementului \ninformaţiilor. \nOS constă dintr-un cuplu format dintr-o \nbază de date şi o instanţă Oracle.\n34\n\n2.3. ORACLE Server\nA. O bază de date Oracle este o colecţie \nunitară de date, având o structură logică şi \nuna fizică putând avea două stări: \n1. open (accesibilă) \n2. close (inaccesibilă)\n35\n\n2.3. ORACLE Server\n1) Structura logică a unei baze de date este \nformată din:\n✓tabelele spaţiu (tablespaces)\n✓schema de obiectelor bazei de date\n✓blocurile de date\n✓extensiile\n✓segmentele\n36\n\n2.3. ORACLE Server\n2) Structura fizică este definită de un set de \nfişiere specifice sistemului de operare pe care \nrezidă SGBD Oracle, folosite pentru memorarea \nstructurilor logice ale bazei de date şi pentru \npăstrarea unor informaţii tehnice de control. \nAceste fişiere sunt: \n- fişiere de date (Data files)\n- fişiere Redo log (Redo Log files) \n- fişiere de control (Control files)\n37\n\n2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n39\n\n2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40\n\n2.4. ORACLE Database 11g Expres Edition\n Pe calculatorul personal este ideal sa se \ninstaleze fisierul: \nOracle Database 11g Express Edition \n(Universal)  OracleXE112_Win32.zip\n41\n\n2.4. ORACLE Database 11g Expres Edition\nPas 1: Se porneste instalarea fisierului executabil si se vor \nurma pasii indicati de catre programul de instalare.\n42\n\n2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43\n\n2.4. ORACLE Database 11g Expres Edition\nInstalarea aplicatiei\n 44', '\n', '2. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32\n\n2.3. ORACLE Server\n ORACLE Server (OS) permite \nmanagementul informaţiilor organizate în baze \nde date, astfel încât se asigură accesul mai \nmultor utilizatori în mod concurenţial la acelaşi \ndate, oferind facilităţi de prevenire a accesului \nneautorizat şi de restaurare a datelor după \nproducerea unor erori. \n33\n\n2.3. ORACLE Server\nORACLE Server este un sistem relaţional-\nobiectual de management a bazelor de date, \ncare permite o abordare deschisă, integrată şi \ncuprinzătoare a managementului \ninformaţiilor. \nOS constă dintr-un cuplu format dintr-o \nbază de date şi o instanţă Oracle.\n34\n\n2.3. ORACLE Server\nA. O bază de date Oracle este o colecţie \nunitară de date, având o structură logică şi \nuna fizică putând avea două stări: \n1. open (accesibilă) \n2. close (inaccesibilă)\n35\n\n2.3. ORACLE Server\n1) Structura logică a unei baze de date este \nformată din:\n✓tabelele spaţiu (tablespaces)\n✓schema de obiectelor bazei de date\n✓blocurile de date\n✓extensiile\n✓segmentele\n36\n\n2.3. ORACLE Server\n2) Structura fizică este definită de un set de \nfişiere specifice sistemului de operare pe care \nrezidă SGBD Oracle, folosite pentru memorarea \nstructurilor logice ale bazei de date şi pentru \npăstrarea unor informaţii tehnice de control. \nAceste fişiere sunt: \n- fişiere de date (Data files)\n- fişiere Redo log (Redo Log files) \n- fişiere de control (Control files)\n37\n\n2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n39\n\n2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40\n\n2.4. ORACLE Database 11g Expres Edition\n Pe calculatorul personal este ideal sa se \ninstaleze fisierul: \nOracle Database 11g Express Edition \n(Universal)  OracleXE112_Win32.zip\n41\n\n2.4. ORACLE Database 11g Expres Edition\nPas 1: Se porneste instalarea fisierului executabil si se vor \nurma pasii indicati de catre programul de instalare.\n42\n\n2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43\n\n2.4. ORACLE Database 11g Expres Edition\nInstalarea aplicatiei\n 44', '\n', '3. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32\n\n2.3. ORACLE Server\n ORACLE Server (OS) permite \nmanagementul informaţiilor organizate în baze \nde date, astfel încât se asigură accesul mai \nmultor utilizatori în mod concurenţial la acelaşi \ndate, oferind facilităţi de prevenire a accesului \nneautorizat şi de restaurare a datelor după \nproducerea unor erori. \n33\n\n2.3. ORACLE Server\nORACLE Server este un sistem relaţional-\nobiectual de management a bazelor de date, \ncare permite o abordare deschisă, integrată şi \ncuprinzătoare a managementului \ninformaţiilor. \nOS constă dintr-un cuplu format dintr-o \nbază de date şi o instanţă Oracle.\n34\n\n2.3. ORACLE Server\nA. O bază de date Oracle este o colecţie \nunitară de date, având o structură logică şi \nuna fizică putând avea două stări: \n1. open (accesibilă) \n2. close (inaccesibilă)\n35\n\n2.3. ORACLE Server\n1) Structura logică a unei baze de date este \nformată din:\n✓tabelele spaţiu (tablespaces)\n✓schema de obiectelor bazei de date\n✓blocurile de date\n✓extensiile\n✓segmentele\n36\n\n2.3. ORACLE Server\n2) Structura fizică este definită de un set de \nfişiere specifice sistemului de operare pe care \nrezidă SGBD Oracle, folosite pentru memorarea \nstructurilor logice ale bazei de date şi pentru \npăstrarea unor informaţii tehnice de control. \nAceste fişiere sunt: \n- fişiere de date (Data files)\n- fişiere Redo log (Redo Log files) \n- fişiere de control (Control files)\n37\n\n2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n39\n\n2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40\n\n2.4. ORACLE Database 11g Expres Edition\n Pe calculatorul personal este ideal sa se \ninstaleze fisierul: \nOracle Database 11g Express Edition \n(Universal)  OracleXE112_Win32.zip\n41\n\n2.4. ORACLE Database 11g Expres Edition\nPas 1: Se porneste instalarea fisierului executabil si se vor \nurma pasii indicati de catre programul de instalare.\n42\n\n2.4. ORACLE Database 11g Expres Edition\nPas 2: La un moment se va solicita introducerea unei parole \npentru utilizatorul SYS si pentru SYSTEM. Aceasta trebuie \nretinuta pentru a putea fi utilizata ulterior.\n43\n\n2.4. ORACLE Database 11g Expres Edition\nInstalarea aplicatiei\n 44', '\n', '4. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nOracle 9i REAL APPLICATION CLUSTERS (RAC) se bazează pe \no nouă arhitectură de BD numită îmbinare ascunsă (Cache \nFusion). \n✓Aceasta este o nouă generaţie de tehnologie de clustere. \n✓Conform acestei arhitecturi la adăugarea unui calculator \nîntr-o reţea cu BD Oracle, clusterele se adaptează automat \nla noile resurse, fără să fie necesară redistribuirea datelor \nsau rescrierea aplicaţiei.\n✓Posibilitatea apariţiei unei erori la o configuraţie cu 12 \ncalculatoare sub Oracle 9i RAC este foarte mică, estimată \nca durată în timp la cca 100.000 de ani. \n17\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oracle 9i DEVELOPER SUITE este un mediu \ncomplet pentru dezvoltarea aplicaţiilor tip \nafaceri electronice (e-business) şi tip Web. \nEl se bazează pe tehnologiile Java şi XML şi permite \npersonalizarea (Oracle Personalization). \n• În anul 2003 a fost lansată versiunea Oracle 10g \ncare adaugă noi facilităţi sistemului Oracle 9i. \n19\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În anul 2007 a fost lansată versiunea Oracle \n11g care are cateva facilitati in plus:\n– Gestioneaza datele mai eficient prin compresii \navansate si partitionari \n– Simplifica sistemele prin stocarea tuturor datelor in \nOracle Database cu Oracle SecureFiles\n• În anul 2013 a fost lansată versiunea Oracle \n12c\n20\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle Database 12c prezintă o arhitectură nouă, cu \nmai multe entităţi găzduite, care permite unificarea \nrapidă a mai multor baze de date şi gestionarea \nacestora ca serviciu cloud. \n➢Oracle Database 12c include, de asemenea, capacităţi \nde procesare a datelor în memorie, care oferă o \nperformanţă analitică inovatoare. \n➢Inovaţiile suplimentare pentru baze de date oferă noi \nnivele de eficienţă, performanţă, securitate şi \ndisponibilitate.[*]\n21[*] https://www.oracle.com/ro/database/index.html\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', '\n', '5. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nOracle 9i REAL APPLICATION CLUSTERS (RAC) se bazează pe \no nouă arhitectură de BD numită îmbinare ascunsă (Cache \nFusion). \n✓Aceasta este o nouă generaţie de tehnologie de clustere. \n✓Conform acestei arhitecturi la adăugarea unui calculator \nîntr-o reţea cu BD Oracle, clusterele se adaptează automat \nla noile resurse, fără să fie necesară redistribuirea datelor \nsau rescrierea aplicaţiei.\n✓Posibilitatea apariţiei unei erori la o configuraţie cu 12 \ncalculatoare sub Oracle 9i RAC este foarte mică, estimată \nca durată în timp la cca 100.000 de ani. \n17\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oracle 9i DEVELOPER SUITE este un mediu \ncomplet pentru dezvoltarea aplicaţiilor tip \nafaceri electronice (e-business) şi tip Web. \nEl se bazează pe tehnologiile Java şi XML şi permite \npersonalizarea (Oracle Personalization). \n• În anul 2003 a fost lansată versiunea Oracle 10g \ncare adaugă noi facilităţi sistemului Oracle 9i. \n19\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În anul 2007 a fost lansată versiunea Oracle \n11g care are cateva facilitati in plus:\n– Gestioneaza datele mai eficient prin compresii \navansate si partitionari \n– Simplifica sistemele prin stocarea tuturor datelor in \nOracle Database cu Oracle SecureFiles\n• În anul 2013 a fost lansată versiunea Oracle \n12c\n20\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle Database 12c prezintă o arhitectură nouă, cu \nmai multe entităţi găzduite, care permite unificarea \nrapidă a mai multor baze de date şi gestionarea \nacestora ca serviciu cloud. \n➢Oracle Database 12c include, de asemenea, capacităţi \nde procesare a datelor în memorie, care oferă o \nperformanţă analitică inovatoare. \n➢Inovaţiile suplimentare pentru baze de date oferă noi \nnivele de eficienţă, performanţă, securitate şi \ndisponibilitate.[*]\n21[*] https://www.oracle.com/ro/database/index.html\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', '\n', '6. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nOracle 9i REAL APPLICATION CLUSTERS (RAC) se bazează pe \no nouă arhitectură de BD numită îmbinare ascunsă (Cache \nFusion). \n✓Aceasta este o nouă generaţie de tehnologie de clustere. \n✓Conform acestei arhitecturi la adăugarea unui calculator \nîntr-o reţea cu BD Oracle, clusterele se adaptează automat \nla noile resurse, fără să fie necesară redistribuirea datelor \nsau rescrierea aplicaţiei.\n✓Posibilitatea apariţiei unei erori la o configuraţie cu 12 \ncalculatoare sub Oracle 9i RAC este foarte mică, estimată \nca durată în timp la cca 100.000 de ani. \n17\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În Oracle 9i APPLICATION SERVER se pot creea \nşi utiliza aplicaţii Web care sunt foarte rapide şi \npermit integrarea serviciilor de Internet. \n18\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oracle 9i DEVELOPER SUITE este un mediu \ncomplet pentru dezvoltarea aplicaţiilor tip \nafaceri electronice (e-business) şi tip Web. \nEl se bazează pe tehnologiile Java şi XML şi permite \npersonalizarea (Oracle Personalization). \n• În anul 2003 a fost lansată versiunea Oracle 10g \ncare adaugă noi facilităţi sistemului Oracle 9i. \n19\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• În anul 2007 a fost lansată versiunea Oracle \n11g care are cateva facilitati in plus:\n– Gestioneaza datele mai eficient prin compresii \navansate si partitionari \n– Simplifica sistemele prin stocarea tuturor datelor in \nOracle Database cu Oracle SecureFiles\n• În anul 2013 a fost lansată versiunea Oracle \n12c\n20\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle Database 12c prezintă o arhitectură nouă, cu \nmai multe entităţi găzduite, care permite unificarea \nrapidă a mai multor baze de date şi gestionarea \nacestora ca serviciu cloud. \n➢Oracle Database 12c include, de asemenea, capacităţi \nde procesare a datelor în memorie, care oferă o \nperformanţă analitică inovatoare. \n➢Inovaţiile suplimentare pentru baze de date oferă noi \nnivele de eficienţă, performanţă, securitate şi \ndisponibilitate.[*]\n21[*] https://www.oracle.com/ro/database/index.html\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', '\n', '7. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n', '8. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n', '9. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n', '10. ', 'Curs 11\nControlul accesului utilizatorilor\nCurs - BAZE DE DATE 2\n\n\nCuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3\n\nControlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4\n\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5\n\ntt\n1) Securitatea sistemului acopera accesarea si \nutilizarea bazei de date la nivelul sistemului, cum \nar fi: numele utilizatorului si parola, spatiul pe \ndisc alocat utilizatorilor, si operatiile de sistem \npermise utilizatorilor. \nCurs - BAZE DE DATE 6\nhttps://www.scnsoft.com/blog/database-security-best-practices\n\ntt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/\n\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8\n\nScheme \nO schema este o colectie de obiecte, cum ar fi: \n✓tabele\n✓indecsi\n✓vizualizari\n✓secvente\nSchema este detinuta de un utilizator al bazei de \ndate si are acelasi nume cu utilizatorul.\nCurs - BAZE DE DATE 9\n\ntt\nPrivilegii de sistem\nSunt disponibile mai mult de 80 de privilegii de \nsistem pentru utilizatori si pentru roluri. \nPrivilegiile de sistem sunt setate  de catre  \nadministratorul bazei de date.\nCurs - BAZE DE DATE 10\n\nPrivilegiile caracteristice ale DBA\nPrivilegii de sistem Operatii autorizate\nCreare de utilizatori Permite crearea unui alt utilizator Oracle (privilegiu\ncerut pentru rolul de DBA)\nStergerea de utilizatori Permite stergerea altui utilizator\nStergerea oricarei tabele Permite stergerea unei tabele în orice schema\nRecuperarea oricarei\ntabele\nRecuperarea oricarei tabele în orice schema cu\nutilitare de export\nCurs - BAZE DE DATE 11', '\n']","controlul accesului și gestionarea privilegiilor în Oracle se implementează prin acordarea de privilegii utilizatorilor. Există două tipuri principale de privilegii:

1.  **Privilegii de sistem:** Acestea controlează accesul la nivelul bazei de date (ex: crearea, ștergerea utilizatorilor, ștergerea oricărei tabele, recuperarea oricărei tabele).
2.  **Privilegii de obiect:** Acestea permit manipularea conținutului obiectelor din baza de date (ex: tabele, indecși, vizualizări, secvențe) aflate intr-o schema.

Administratorul bazei de date (DBA) este responsabil de acordarea acestor privilegii. Utilizatorii pot primi, de asemenea, privilegiul de a acorda mai departe privilegii altor utilizatori sau roluri.
","Controlul accesului se realizează prin acordarea de privilegii de sistem și obiect de către DBA, folosind comenzi precum CREATE USER și GRANT. Aceste măsuri „asigură securitatea utilizării și accesării bazei de date” într-un mediu multi-user.",0.03448275861724138,1.0,0.9999999999999997,1.0,0.20448007360218387,0.21739130434782608,0.46
38,O3mini-high,High,"C12, C1",C13,Care sunt principalele diferențe între sistemele tradiționale de fișiere și bazele de date moderne?,"Bazele de date moderne elimină redundanța, îmbunătățesc integritatea, oferă acces rapid și securitate sporită, spre deosebire de sistemele tradiționale de fișiere, unde datele sunt gestionate prin programe personalizate. „Accesul rapid și sigur la date” este un avantaj major al bazelor de date moderne.",Este corect,"C12, pagina 2","['1. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '2. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '3. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '4. ', '2 \n \n1.2.2. Limitări ale sistemelor tradiționale de fișiere: \n1. Redundanță și inconsistență - Aceleași date pot fi stocate în mai multe fișiere, ducând la \ninconsistențe și consum excesiv de spațiu. \n2. Lipsa integrității  - Nu există mecanisme automate pentru a asigura corectitudinea și \nvaliditatea datelor. \n3. Dificultăți în accesul la date  - Accesul la date necesită dezvoltarea de programe \npersonalizate pentru fiecare tip de interogare. \n4. Lipsa securității  - Nu există mecanisme eficiente pentru restricționarea accesului la \nanumite date. \n5. Dificultăți în partajarea datelor - Accesul simultan la fișiere de către mai mulți utilizatori \neste dificil de gestionat. \n \n1.3. Bazele de date moderne \nBazele de date elimină majoritatea acestor probleme prin utilizarea unui sistem centralizat \nde gestionare a datelor. Acestea permit accesul eficient la informații, reduc redundanța și oferă \nmecanisme avansate de securitate și integritate. \n \n1.4.Avantajele bazelor de date față de fișierele tradiționale: \n1. Eliminarea redundanței  - Datele sunt normalizate și stocate într -un mod care \nminimizează duplicările. \n2. Îmbunătățirea integrității - Se pot defini constrângeri care asigură coerența și validitatea \ndatelor. \n3. Acces flexibil la date  - Utilizatorii pot efectua interogări complexe folosind limbaje \nprecum SQL. \n4. Securitate sporită - Se pot implementa niveluri diferite de acces pentru utilizatori. \n5. Partajare eficientă a datelor - Mai mulți utilizatori pot accesa simultan baza de date fără \na afecta integritatea informațiilor. \n \n \n1.5. Componentele unui sistem de baze de date \nUn sistem de baze de date este compus din mai multe elemente esențiale care asigură \nfuncționarea și gestionarea eficientă a datelor. Aceste componente includ hardware, software, date, \nutilizatori și proceduri.  \n \n \n1. Hardware \nHardware-ul reprezintă infrastructura fizică necesară pentru \noperarea unei baze de date. Acesta include: \n✓ Servere și stații de lucru \n✓ Dispozitive de stocare (SSD, HDD, unități cloud) \n✓ Rețele de comunicație \n✓ Procesoare și memorie RAM pentru optimizarea \nperformanței', '\n', '5. ', '2 \n \n1.2.2. Limitări ale sistemelor tradiționale de fișiere: \n1. Redundanță și inconsistență - Aceleași date pot fi stocate în mai multe fișiere, ducând la \ninconsistențe și consum excesiv de spațiu. \n2. Lipsa integrității  - Nu există mecanisme automate pentru a asigura corectitudinea și \nvaliditatea datelor. \n3. Dificultăți în accesul la date  - Accesul la date necesită dezvoltarea de programe \npersonalizate pentru fiecare tip de interogare. \n4. Lipsa securității  - Nu există mecanisme eficiente pentru restricționarea accesului la \nanumite date. \n5. Dificultăți în partajarea datelor - Accesul simultan la fișiere de către mai mulți utilizatori \neste dificil de gestionat. \n \n1.3. Bazele de date moderne \nBazele de date elimină majoritatea acestor probleme prin utilizarea unui sistem centralizat \nde gestionare a datelor. Acestea permit accesul eficient la informații, reduc redundanța și oferă \nmecanisme avansate de securitate și integritate. \n \n1.4.Avantajele bazelor de date față de fișierele tradiționale: \n1. Eliminarea redundanței  - Datele sunt normalizate și stocate într -un mod care \nminimizează duplicările. \n2. Îmbunătățirea integrității - Se pot defini constrângeri care asigură coerența și validitatea \ndatelor. \n3. Acces flexibil la date  - Utilizatorii pot efectua interogări complexe folosind limbaje \nprecum SQL. \n4. Securitate sporită - Se pot implementa niveluri diferite de acces pentru utilizatori. \n5. Partajare eficientă a datelor - Mai mulți utilizatori pot accesa simultan baza de date fără \na afecta integritatea informațiilor. \n \n \n1.5. Componentele unui sistem de baze de date \nUn sistem de baze de date este compus din mai multe elemente esențiale care asigură \nfuncționarea și gestionarea eficientă a datelor. Aceste componente includ hardware, software, date, \nutilizatori și proceduri.  \n \n \n1. Hardware \nHardware-ul reprezintă infrastructura fizică necesară pentru \noperarea unei baze de date. Acesta include: \n✓ Servere și stații de lucru \n✓ Dispozitive de stocare (SSD, HDD, unități cloud) \n✓ Rețele de comunicație \n✓ Procesoare și memorie RAM pentru optimizarea \nperformanței', '\n', '6. ', '2 \n \n1.2.2. Limitări ale sistemelor tradiționale de fișiere: \n1. Redundanță și inconsistență - Aceleași date pot fi stocate în mai multe fișiere, ducând la \ninconsistențe și consum excesiv de spațiu. \n2. Lipsa integrității  - Nu există mecanisme automate pentru a asigura corectitudinea și \nvaliditatea datelor. \n3. Dificultăți în accesul la date  - Accesul la date necesită dezvoltarea de programe \npersonalizate pentru fiecare tip de interogare. \n4. Lipsa securității  - Nu există mecanisme eficiente pentru restricționarea accesului la \nanumite date. \n5. Dificultăți în partajarea datelor - Accesul simultan la fișiere de către mai mulți utilizatori \neste dificil de gestionat. \n \n1.3. Bazele de date moderne \nBazele de date elimină majoritatea acestor probleme prin utilizarea unui sistem centralizat \nde gestionare a datelor. Acestea permit accesul eficient la informații, reduc redundanța și oferă \nmecanisme avansate de securitate și integritate. \n \n1.4.Avantajele bazelor de date față de fișierele tradiționale: \n1. Eliminarea redundanței  - Datele sunt normalizate și stocate într -un mod care \nminimizează duplicările. \n2. Îmbunătățirea integrității - Se pot defini constrângeri care asigură coerența și validitatea \ndatelor. \n3. Acces flexibil la date  - Utilizatorii pot efectua interogări complexe folosind limbaje \nprecum SQL. \n4. Securitate sporită - Se pot implementa niveluri diferite de acces pentru utilizatori. \n5. Partajare eficientă a datelor - Mai mulți utilizatori pot accesa simultan baza de date fără \na afecta integritatea informațiilor. \n \n \n1.5. Componentele unui sistem de baze de date \nUn sistem de baze de date este compus din mai multe elemente esențiale care asigură \nfuncționarea și gestionarea eficientă a datelor. Aceste componente includ hardware, software, date, \nutilizatori și proceduri.  \n \n \n1. Hardware \nHardware-ul reprezintă infrastructura fizică necesară pentru \noperarea unei baze de date. Acesta include: \n✓ Servere și stații de lucru \n✓ Dispozitive de stocare (SSD, HDD, unități cloud) \n✓ Rețele de comunicație \n✓ Procesoare și memorie RAM pentru optimizarea \nperformanței', '\n', '7. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '8. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '9. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '10. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n']","bazele de date moderne oferă avantaje față de sistemele tradiționale de fișiere, precum: eliminarea redundanței, îmbunătățirea integrității datelor, acces flexibil la date prin limbaje ca SQL, securitate sporită, și partajarea eficientă a datelor între utilizatori. Sistemele tradiționale suferă de redundanță, inconsistență, lipsa integrității, dificultăți în accesul și partajarea datelor, și lipsa securității.
",Care sunt principalele diferențe între sistemele tradiționale de fișiere și bazele de date moderne?,"['1. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '2. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '3. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '4. ', '2 \n \n1.2.2. Limitări ale sistemelor tradiționale de fișiere: \n1. Redundanță și inconsistență - Aceleași date pot fi stocate în mai multe fișiere, ducând la \ninconsistențe și consum excesiv de spațiu. \n2. Lipsa integrității  - Nu există mecanisme automate pentru a asigura corectitudinea și \nvaliditatea datelor. \n3. Dificultăți în accesul la date  - Accesul la date necesită dezvoltarea de programe \npersonalizate pentru fiecare tip de interogare. \n4. Lipsa securității  - Nu există mecanisme eficiente pentru restricționarea accesului la \nanumite date. \n5. Dificultăți în partajarea datelor - Accesul simultan la fișiere de către mai mulți utilizatori \neste dificil de gestionat. \n \n1.3. Bazele de date moderne \nBazele de date elimină majoritatea acestor probleme prin utilizarea unui sistem centralizat \nde gestionare a datelor. Acestea permit accesul eficient la informații, reduc redundanța și oferă \nmecanisme avansate de securitate și integritate. \n \n1.4.Avantajele bazelor de date față de fișierele tradiționale: \n1. Eliminarea redundanței  - Datele sunt normalizate și stocate într -un mod care \nminimizează duplicările. \n2. Îmbunătățirea integrității - Se pot defini constrângeri care asigură coerența și validitatea \ndatelor. \n3. Acces flexibil la date  - Utilizatorii pot efectua interogări complexe folosind limbaje \nprecum SQL. \n4. Securitate sporită - Se pot implementa niveluri diferite de acces pentru utilizatori. \n5. Partajare eficientă a datelor - Mai mulți utilizatori pot accesa simultan baza de date fără \na afecta integritatea informațiilor. \n \n \n1.5. Componentele unui sistem de baze de date \nUn sistem de baze de date este compus din mai multe elemente esențiale care asigură \nfuncționarea și gestionarea eficientă a datelor. Aceste componente includ hardware, software, date, \nutilizatori și proceduri.  \n \n \n1. Hardware \nHardware-ul reprezintă infrastructura fizică necesară pentru \noperarea unei baze de date. Acesta include: \n✓ Servere și stații de lucru \n✓ Dispozitive de stocare (SSD, HDD, unități cloud) \n✓ Rețele de comunicație \n✓ Procesoare și memorie RAM pentru optimizarea \nperformanței', '\n', '5. ', '2 \n \n1.2.2. Limitări ale sistemelor tradiționale de fișiere: \n1. Redundanță și inconsistență - Aceleași date pot fi stocate în mai multe fișiere, ducând la \ninconsistențe și consum excesiv de spațiu. \n2. Lipsa integrității  - Nu există mecanisme automate pentru a asigura corectitudinea și \nvaliditatea datelor. \n3. Dificultăți în accesul la date  - Accesul la date necesită dezvoltarea de programe \npersonalizate pentru fiecare tip de interogare. \n4. Lipsa securității  - Nu există mecanisme eficiente pentru restricționarea accesului la \nanumite date. \n5. Dificultăți în partajarea datelor - Accesul simultan la fișiere de către mai mulți utilizatori \neste dificil de gestionat. \n \n1.3. Bazele de date moderne \nBazele de date elimină majoritatea acestor probleme prin utilizarea unui sistem centralizat \nde gestionare a datelor. Acestea permit accesul eficient la informații, reduc redundanța și oferă \nmecanisme avansate de securitate și integritate. \n \n1.4.Avantajele bazelor de date față de fișierele tradiționale: \n1. Eliminarea redundanței  - Datele sunt normalizate și stocate într -un mod care \nminimizează duplicările. \n2. Îmbunătățirea integrității - Se pot defini constrângeri care asigură coerența și validitatea \ndatelor. \n3. Acces flexibil la date  - Utilizatorii pot efectua interogări complexe folosind limbaje \nprecum SQL. \n4. Securitate sporită - Se pot implementa niveluri diferite de acces pentru utilizatori. \n5. Partajare eficientă a datelor - Mai mulți utilizatori pot accesa simultan baza de date fără \na afecta integritatea informațiilor. \n \n \n1.5. Componentele unui sistem de baze de date \nUn sistem de baze de date este compus din mai multe elemente esențiale care asigură \nfuncționarea și gestionarea eficientă a datelor. Aceste componente includ hardware, software, date, \nutilizatori și proceduri.  \n \n \n1. Hardware \nHardware-ul reprezintă infrastructura fizică necesară pentru \noperarea unei baze de date. Acesta include: \n✓ Servere și stații de lucru \n✓ Dispozitive de stocare (SSD, HDD, unități cloud) \n✓ Rețele de comunicație \n✓ Procesoare și memorie RAM pentru optimizarea \nperformanței', '\n', '6. ', '2 \n \n1.2.2. Limitări ale sistemelor tradiționale de fișiere: \n1. Redundanță și inconsistență - Aceleași date pot fi stocate în mai multe fișiere, ducând la \ninconsistențe și consum excesiv de spațiu. \n2. Lipsa integrității  - Nu există mecanisme automate pentru a asigura corectitudinea și \nvaliditatea datelor. \n3. Dificultăți în accesul la date  - Accesul la date necesită dezvoltarea de programe \npersonalizate pentru fiecare tip de interogare. \n4. Lipsa securității  - Nu există mecanisme eficiente pentru restricționarea accesului la \nanumite date. \n5. Dificultăți în partajarea datelor - Accesul simultan la fișiere de către mai mulți utilizatori \neste dificil de gestionat. \n \n1.3. Bazele de date moderne \nBazele de date elimină majoritatea acestor probleme prin utilizarea unui sistem centralizat \nde gestionare a datelor. Acestea permit accesul eficient la informații, reduc redundanța și oferă \nmecanisme avansate de securitate și integritate. \n \n1.4.Avantajele bazelor de date față de fișierele tradiționale: \n1. Eliminarea redundanței  - Datele sunt normalizate și stocate într -un mod care \nminimizează duplicările. \n2. Îmbunătățirea integrității - Se pot defini constrângeri care asigură coerența și validitatea \ndatelor. \n3. Acces flexibil la date  - Utilizatorii pot efectua interogări complexe folosind limbaje \nprecum SQL. \n4. Securitate sporită - Se pot implementa niveluri diferite de acces pentru utilizatori. \n5. Partajare eficientă a datelor - Mai mulți utilizatori pot accesa simultan baza de date fără \na afecta integritatea informațiilor. \n \n \n1.5. Componentele unui sistem de baze de date \nUn sistem de baze de date este compus din mai multe elemente esențiale care asigură \nfuncționarea și gestionarea eficientă a datelor. Aceste componente includ hardware, software, date, \nutilizatori și proceduri.  \n \n \n1. Hardware \nHardware-ul reprezintă infrastructura fizică necesară pentru \noperarea unei baze de date. Acesta include: \n✓ Servere și stații de lucru \n✓ Dispozitive de stocare (SSD, HDD, unități cloud) \n✓ Rețele de comunicație \n✓ Procesoare și memorie RAM pentru optimizarea \nperformanței', '\n', '7. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '8. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '9. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '10. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n']","bazele de date moderne oferă avantaje față de sistemele tradiționale de fișiere, precum: eliminarea redundanței, îmbunătățirea integrității datelor, acces flexibil la date prin limbaje ca SQL, securitate sporită, și partajarea eficientă a datelor între utilizatori. Sistemele tradiționale suferă de redundanță, inconsistență, lipsa integrității, dificultăți în accesul și partajarea datelor, și lipsa securității.
","Bazele de date moderne elimină redundanța, îmbunătățesc integritatea, oferă acces rapid și securitate sporită, spre deosebire de sistemele tradiționale de fișiere, unde datele sunt gestionate prin programe personalizate. „Accesul rapid și sigur la date” este un avantaj major al bazelor de date moderne.",0.39145339953511066,1.0,0.8429553717847388,1.0,0.18864449706599445,0.29090909090909095,0.67
39,O3mini-high,High,"C13, C4",C5,Cum asigură modelul relațional integritatea datelor și ce rol joacă SQL în implementarea constrângerilor?,"Modelul relațional folosește chei primare și străine pentru a asigura integritatea, iar SQL permite definirea constrângerilor (ex.: PRIMARY KEY, FOREIGN KEY, CHECK). Aceste reguli „mențin coerența și validitatea datelor” la nivel de tabelă.",Este corect,"C13, pagina 1","['1. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '2. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '3. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '4. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '5. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '6. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '7. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '8. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '9. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '10. ', ""- SQL echivalent: SELECT * FROM Student JOIN Inscriere ON Student.ID = \nInscriere.StudentID; \n \n \n2.2 Studiu de caz: Utilizarea algebrei relaționale într-o companie de livrări \nO companie de livrări utilizează o bază de date relațională pentru a gestiona comenzile, clienții și \nlivratorii. Relațiile cheie sunt: \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    Status V ARCHAR(20), \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE Livrator ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \nInterogări pentru monitorizarea livrărilor: \nSELECT Client.Nume, Comanda.Status \nFROM Client \nJOIN Comanda ON Client.ID = Comanda.ClientID; \n \n \n \n2.3. SQL - Limbajul interogărilor \nLimbajul SQL (Structured Query Language) este standardul pentru interacțiunea cu bazele de \ndate relaționale. \n \n2.3.1 Crearea bazelor de date și a tabelelor \nCREATE DATABASE Universitate; \nUSE Universitate; \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Prenume V ARCHAR(50), \n    An INT \n); \n \nCREATE TABLE Curs ( \n\n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n2.3.2 Inserarea datelor \nINSERT INTO Student (ID, Nume, Prenume, An) V ALUES (1, 'Popescu', 'Ion', 2); \nINSERT INTO Curs (Cod, Denumire) V ALUES (101, 'Baze de date'); \nINSERT INTO Inscriere (StudentID, CursCod) V ALUES (1, 101); \n \n2.3.3 Interogarea bazelor de date \n-- Selectarea tuturor studenților \nSELECT * FROM Student; \n \n-- Selectarea studenților de anul 2 \nSELECT * FROM Student WHERE An = 2; \n \n-- Afișarea cursurilor la care este înscris un student \nSELECT Curs.Denumire  \nFROM Curs  \nJOIN Inscriere ON Curs.Cod = Inscriere.CursCod  \nWHERE Inscriere.StudentID = 1; \n \n \n3. Integritatea datelor \nIntegritatea datelor asigură corectitudinea și consistența acestora în cadrul bazei de date. Tipurile \nprincipale sunt: \n \n1. Integritatea entităților: Fiecare tabel trebuie să aibă un identificator unic. \n2. Integritatea referențială: Relațiile dintre tabele trebuie să fie menținute corect prin chei primare \nși străine. \n3. Integritatea domeniului: Valorile din coloane trebuie să respecte tipul de date definit."", '\n']","modelul relațional asigură integritatea datelor prin:

1.  **Integritatea entităților:** Fiecare tabel are un identificator unic (cheie primară).
2.  **Integritatea referențială:** Relațiile dintre tabele sunt menținute prin chei primare și chei străine.
3.  **Integritatea domeniului:** Valorile din coloane respectă tipul de date definit.

SQL implementează aceste constrângeri prin:

*   `PRIMARY KEY`: Pentru integritatea entităților.
*   `FOREIGN KEY`: Pentru integritatea referențială.
    \-   `CREATE TABLE`, definirea tipului de date: Asigura Integritatea domeniului
",Cum asigură modelul relațional integritatea datelor și ce rol joacă SQL în implementarea constrângerilor?,"['1. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '2. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '3. ', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere"", '\n', '4. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '5. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '6. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '7. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '8. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '9. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '10. ', ""- SQL echivalent: SELECT * FROM Student JOIN Inscriere ON Student.ID = \nInscriere.StudentID; \n \n \n2.2 Studiu de caz: Utilizarea algebrei relaționale într-o companie de livrări \nO companie de livrări utilizează o bază de date relațională pentru a gestiona comenzile, clienții și \nlivratorii. Relațiile cheie sunt: \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    Status V ARCHAR(20), \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE Livrator ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \nInterogări pentru monitorizarea livrărilor: \nSELECT Client.Nume, Comanda.Status \nFROM Client \nJOIN Comanda ON Client.ID = Comanda.ClientID; \n \n \n \n2.3. SQL - Limbajul interogărilor \nLimbajul SQL (Structured Query Language) este standardul pentru interacțiunea cu bazele de \ndate relaționale. \n \n2.3.1 Crearea bazelor de date și a tabelelor \nCREATE DATABASE Universitate; \nUSE Universitate; \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Prenume V ARCHAR(50), \n    An INT \n); \n \nCREATE TABLE Curs ( \n\n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n2.3.2 Inserarea datelor \nINSERT INTO Student (ID, Nume, Prenume, An) V ALUES (1, 'Popescu', 'Ion', 2); \nINSERT INTO Curs (Cod, Denumire) V ALUES (101, 'Baze de date'); \nINSERT INTO Inscriere (StudentID, CursCod) V ALUES (1, 101); \n \n2.3.3 Interogarea bazelor de date \n-- Selectarea tuturor studenților \nSELECT * FROM Student; \n \n-- Selectarea studenților de anul 2 \nSELECT * FROM Student WHERE An = 2; \n \n-- Afișarea cursurilor la care este înscris un student \nSELECT Curs.Denumire  \nFROM Curs  \nJOIN Inscriere ON Curs.Cod = Inscriere.CursCod  \nWHERE Inscriere.StudentID = 1; \n \n \n3. Integritatea datelor \nIntegritatea datelor asigură corectitudinea și consistența acestora în cadrul bazei de date. Tipurile \nprincipale sunt: \n \n1. Integritatea entităților: Fiecare tabel trebuie să aibă un identificator unic. \n2. Integritatea referențială: Relațiile dintre tabele trebuie să fie menținute corect prin chei primare \nși străine. \n3. Integritatea domeniului: Valorile din coloane trebuie să respecte tipul de date definit."", '\n']","modelul relațional asigură integritatea datelor prin:

1.  **Integritatea entităților:** Fiecare tabel are un identificator unic (cheie primară).
2.  **Integritatea referențială:** Relațiile dintre tabele sunt menținute prin chei primare și chei străine.
3.  **Integritatea domeniului:** Valorile din coloane respectă tipul de date definit.

SQL implementează aceste constrângeri prin:

*   `PRIMARY KEY`: Pentru integritatea entităților.
*   `FOREIGN KEY`: Pentru integritatea referențială.
    \-   `CREATE TABLE`, definirea tipului de date: Asigura Integritatea domeniului
","Modelul relațional folosește chei primare și străine pentru a asigura integritatea, iar SQL permite definirea constrângerilor (ex.: PRIMARY KEY, FOREIGN KEY, CHECK). Aceste reguli „mențin coerența și validitatea datelor” la nivel de tabelă.",0.3532327586118588,1.0,0.8549549322979466,1.0,0.04408194605881708,0.2807017543859649,0.5
40,O3mini-high,High,"C7, C6",C3,Cum se realizează o operație complexă de manipulare a datelor folosind subinterogări?,"Operația combină DML și subinterogări pentru actualizări selective. De exemplu: „UPDATE EMP SET sal = sal * 1.1 WHERE sal < (SELECT AVG(sal) FROM EMP)” actualizează salariile angajaților cu valori sub medie, folosind rezultatul unei subinterogări în clauza WHERE.",Este corect,Curs ???,"['1. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '2. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '3. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '4. ', '1.1.Sisteme de baze de date\n- precompilatorul limbajului de manipulare\na datelor care transformă instrucţiunile\nDML de la programele de aplicaţii la\nlimbajul gazdă, şi lucrează cu procesorul de\ninterogări;\n- compilatorul limbajului de definiţie a\ndatelor care transformă instrucţiunile DDL\nîn tabele de metadate.\n 32\n\n1.1.Sisteme de baze de date\nMetadatele sunt\nmemorate în \ndicţionarul de \ndate, care \ninclude:\n➢structura bazei\nde date sau\nschema\n➢constrângerile\nde integritate\n➢constrângerile\nde securitate\n 33\n\nModele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\n 34\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 35\n\n1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36\n\n1.2.Modelul de date relaţional\nFormal, o relaţie R este o mulţime, unde D1, D2, ..., \nDn sunt domeniile a n atribute A1, A2, ..., An. \n✓ Elementele relaţiei sunt n-tuplurile (v1, v2, ..., vn) cu vi\nDi, adică valoarea celui de-al i-lea atribut trebuie să fie \nun element din mulţimea Di.  \n✓ Elementele dintr-un tuplu sunt numite câmpuri. \n✓ Când un camp nu conţine nici o valoare, vom reprezenta \nacest fapt cu o valoare specială numită valoare null, \nsemnificând că “nu este nici o intrare” în loc de “intrarea \neste necunoscută”. \n 37\n\n1.2.Modelul de date relaţional\nPrezentăm în continuare un exemplu de tabelă \npentru gestiunea studenţilor dintr-o facultate:\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\nAtributeTuplu\nCâmp\n38\n\n1.2.Modelul de date relaţional\nConstrângeri de integritate\nConstrângerile de integritate restricţionează mulţimea\ntuplu-rilor teoretice posibile la o mulţime care este în mod\npractic cu o semnificaţie. \nFie X şi Y două mulţimi cu unul sau mai multe atribute\nAi, din schema relaţională. \nSpunem că Y este dependent funcţional de X, şi notăm \nacest lucru prin X Y,dacă şi numai dacă nu este posibil să\navem două tupluri cu aceeaşi valoare pentru toate\natributele din X dar cu valoare diferită pentru toate\natributele din Y . \n→ 39', '\n', '5. ', '1.1.Sisteme de baze de date\n- precompilatorul limbajului de manipulare\na datelor care transformă instrucţiunile\nDML de la programele de aplicaţii la\nlimbajul gazdă, şi lucrează cu procesorul de\ninterogări;\n- compilatorul limbajului de definiţie a\ndatelor care transformă instrucţiunile DDL\nîn tabele de metadate.\n 32\n\n1.1.Sisteme de baze de date\nMetadatele sunt\nmemorate în \ndicţionarul de \ndate, care \ninclude:\n➢structura bazei\nde date sau\nschema\n➢constrângerile\nde integritate\n➢constrângerile\nde securitate\n 33\n\nModele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\n 34\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 35\n\n1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36\n\n1.2.Modelul de date relaţional\nFormal, o relaţie R este o mulţime, unde D1, D2, ..., \nDn sunt domeniile a n atribute A1, A2, ..., An. \n✓ Elementele relaţiei sunt n-tuplurile (v1, v2, ..., vn) cu vi\nDi, adică valoarea celui de-al i-lea atribut trebuie să fie \nun element din mulţimea Di.  \n✓ Elementele dintr-un tuplu sunt numite câmpuri. \n✓ Când un camp nu conţine nici o valoare, vom reprezenta \nacest fapt cu o valoare specială numită valoare null, \nsemnificând că “nu este nici o intrare” în loc de “intrarea \neste necunoscută”. \n 37\n\n1.2.Modelul de date relaţional\nPrezentăm în continuare un exemplu de tabelă \npentru gestiunea studenţilor dintr-o facultate:\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\nAtributeTuplu\nCâmp\n38\n\n1.2.Modelul de date relaţional\nConstrângeri de integritate\nConstrângerile de integritate restricţionează mulţimea\ntuplu-rilor teoretice posibile la o mulţime care este în mod\npractic cu o semnificaţie. \nFie X şi Y două mulţimi cu unul sau mai multe atribute\nAi, din schema relaţională. \nSpunem că Y este dependent funcţional de X, şi notăm \nacest lucru prin X Y,dacă şi numai dacă nu este posibil să\navem două tupluri cu aceeaşi valoare pentru toate\natributele din X dar cu valoare diferită pentru toate\natributele din Y . \n→ 39', '\n', '6. ', '1.1.Sisteme de baze de date\n- precompilatorul limbajului de manipulare\na datelor care transformă instrucţiunile\nDML de la programele de aplicaţii la\nlimbajul gazdă, şi lucrează cu procesorul de\ninterogări;\n- compilatorul limbajului de definiţie a\ndatelor care transformă instrucţiunile DDL\nîn tabele de metadate.\n 32\n\n1.1.Sisteme de baze de date\nMetadatele sunt\nmemorate în \ndicţionarul de \ndate, care \ninclude:\n➢structura bazei\nde date sau\nschema\n➢constrângerile\nde integritate\n➢constrângerile\nde securitate\n 33\n\nModele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\n 34\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 35\n\n1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36\n\n1.2.Modelul de date relaţional\nFormal, o relaţie R este o mulţime, unde D1, D2, ..., \nDn sunt domeniile a n atribute A1, A2, ..., An. \n✓ Elementele relaţiei sunt n-tuplurile (v1, v2, ..., vn) cu vi\nDi, adică valoarea celui de-al i-lea atribut trebuie să fie \nun element din mulţimea Di.  \n✓ Elementele dintr-un tuplu sunt numite câmpuri. \n✓ Când un camp nu conţine nici o valoare, vom reprezenta \nacest fapt cu o valoare specială numită valoare null, \nsemnificând că “nu este nici o intrare” în loc de “intrarea \neste necunoscută”. \n 37\n\n1.2.Modelul de date relaţional\nPrezentăm în continuare un exemplu de tabelă \npentru gestiunea studenţilor dintr-o facultate:\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\nAtributeTuplu\nCâmp\n38\n\n1.2.Modelul de date relaţional\nConstrângeri de integritate\nConstrângerile de integritate restricţionează mulţimea\ntuplu-rilor teoretice posibile la o mulţime care este în mod\npractic cu o semnificaţie. \nFie X şi Y două mulţimi cu unul sau mai multe atribute\nAi, din schema relaţională. \nSpunem că Y este dependent funcţional de X, şi notăm \nacest lucru prin X Y,dacă şi numai dacă nu este posibil să\navem două tupluri cu aceeaşi valoare pentru toate\natributele din X dar cu valoare diferită pentru toate\natributele din Y . \n→ 39', '\n', '7. ', '7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nProcesarea unei Tranzactii \nO tranzacţie este o operaţie asupra unei \nbaze de date care implică una sau mai \nmulte modificări în una sau mai multe \ntabele.\nCurs 7 - BAZE DE DATE 41\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nExistă două clase de tranzacţii:\n1. Tranzacţii DML (Data Manipulation Language) care conţin \nun număr oarecare de blocuri DML şi pe care ORACLE le \ntratează ca o singură entitate sau o singură unitate logica \nde lucru\n2. Tranzacţii DDL (Data Definition Language) care conţin un \nsingur bloc DDL\nCurs 7 - BAZE DE DATE 42\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\n•Nu pot exista situaţii ""jumătate de drum"" în \ntimpul execuţiei unei tranzactii, aşa încât \nunele modificări specificate în tranzacţie să \nfie aplicate bazei de date şi altele nu. \n•Pentru fiecare tranzacţie ori toate \nmodificările sunt aplicate bazei de date, ori \nnici una din modificări nu este îndeplinită \n(sunt toate abandonate - discarded ). \nCurs 7 - BAZE DE DATE 43\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nO tranzacţie începe când prima comandă executabilă \nDML sau DDL este întâlnită şi se termină în una din \nurmătoarele situaţii: \n1. Întâlneşte COMMIT/ROLLBACK \n2. Comanda DDL se termină \n3. Anumite erori (DEADLOCK) \n4. EXIT - ieşire din SQL*Plus \n5. Eroare sistem \n6. Un bloc DDL este executat automat şi de aceea implicit \nîncheie o tranzacţie\n7. După încheierea unei tranzacţii, următorul bloc \nexecutabil SQL va lansa automat următoarea tranzacţie\nCurs 7 - BAZE DE DATE 44\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nTranzacţii \nCurs 7 - BAZE DE DATE 45\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nPermanentizarea Modificărilor\n• Pentru ca modificările să rămână permanente, ele \ntrebuie executate asupra bazei de date. \n• Comanda COMMIT realizează permanentizarea \nmodificărilor; \n• Comanda ROLLBACK permite să abandonăm sau să \nanulăm modificările. \n• Modificarea/modificările, executate asupra bazei de \ndate între 2 comenzi COMMIT reprezintă o tranzacţie. \n• Până când tranzacţia nu este executată, nici una din \nmodificări nu este vizibilă utilizatorilor. \nCurs 7 - BAZE DE DATE 46\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nÎnlăturarea modificărilor nedorite \n• Modificările neexecutate pot fi abandonate prin \ncomanda ROLLBACK. \n• ROLLBACK va atribui datelor valorile care acestea le \naveau imediat dupa executarea ultimului COMMIT\nprin anularea tuturor modificărilor făcute după \nultimul COMMIT. \nCurs 7 - BAZE DE DATE 47\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nSemnificaţia tranzacţiilor \n• ORACLE asigură consistenţa datelor bazată pe \ntranzacţii. \n• Tranzacţiile dau utilizatorului mai multă flexibilitate şi \ncontrol la lucrul asupra datelor, şi asigură consistenţa \ndatelor în cazul unei erori a procesului utilizator sau a \nunei erori de sistem. \nCurs 7 - BAZE DE DATE 48', '\n', '8. ', '7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nProcesarea unei Tranzactii \nO tranzacţie este o operaţie asupra unei \nbaze de date care implică una sau mai \nmulte modificări în una sau mai multe \ntabele.\nCurs 7 - BAZE DE DATE 41\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nExistă două clase de tranzacţii:\n1. Tranzacţii DML (Data Manipulation Language) care conţin \nun număr oarecare de blocuri DML şi pe care ORACLE le \ntratează ca o singură entitate sau o singură unitate logica \nde lucru\n2. Tranzacţii DDL (Data Definition Language) care conţin un \nsingur bloc DDL\nCurs 7 - BAZE DE DATE 42\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\n•Nu pot exista situaţii ""jumătate de drum"" în \ntimpul execuţiei unei tranzactii, aşa încât \nunele modificări specificate în tranzacţie să \nfie aplicate bazei de date şi altele nu. \n•Pentru fiecare tranzacţie ori toate \nmodificările sunt aplicate bazei de date, ori \nnici una din modificări nu este îndeplinită \n(sunt toate abandonate - discarded ). \nCurs 7 - BAZE DE DATE 43\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nO tranzacţie începe când prima comandă executabilă \nDML sau DDL este întâlnită şi se termină în una din \nurmătoarele situaţii: \n1. Întâlneşte COMMIT/ROLLBACK \n2. Comanda DDL se termină \n3. Anumite erori (DEADLOCK) \n4. EXIT - ieşire din SQL*Plus \n5. Eroare sistem \n6. Un bloc DDL este executat automat şi de aceea implicit \nîncheie o tranzacţie\n7. După încheierea unei tranzacţii, următorul bloc \nexecutabil SQL va lansa automat următoarea tranzacţie\nCurs 7 - BAZE DE DATE 44\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nTranzacţii \nCurs 7 - BAZE DE DATE 45\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nPermanentizarea Modificărilor\n• Pentru ca modificările să rămână permanente, ele \ntrebuie executate asupra bazei de date. \n• Comanda COMMIT realizează permanentizarea \nmodificărilor; \n• Comanda ROLLBACK permite să abandonăm sau să \nanulăm modificările. \n• Modificarea/modificările, executate asupra bazei de \ndate între 2 comenzi COMMIT reprezintă o tranzacţie. \n• Până când tranzacţia nu este executată, nici una din \nmodificări nu este vizibilă utilizatorilor. \nCurs 7 - BAZE DE DATE 46\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nÎnlăturarea modificărilor nedorite \n• Modificările neexecutate pot fi abandonate prin \ncomanda ROLLBACK. \n• ROLLBACK va atribui datelor valorile care acestea le \naveau imediat dupa executarea ultimului COMMIT\nprin anularea tuturor modificărilor făcute după \nultimul COMMIT. \nCurs 7 - BAZE DE DATE 47\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nSemnificaţia tranzacţiilor \n• ORACLE asigură consistenţa datelor bazată pe \ntranzacţii. \n• Tranzacţiile dau utilizatorului mai multă flexibilitate şi \ncontrol la lucrul asupra datelor, şi asigură consistenţa \ndatelor în cazul unei erori a procesului utilizator sau a \nunei erori de sistem. \nCurs 7 - BAZE DE DATE 48', '\n', '9. ', '7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nProcesarea unei Tranzactii \nO tranzacţie este o operaţie asupra unei \nbaze de date care implică una sau mai \nmulte modificări în una sau mai multe \ntabele.\nCurs 7 - BAZE DE DATE 41\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nExistă două clase de tranzacţii:\n1. Tranzacţii DML (Data Manipulation Language) care conţin \nun număr oarecare de blocuri DML şi pe care ORACLE le \ntratează ca o singură entitate sau o singură unitate logica \nde lucru\n2. Tranzacţii DDL (Data Definition Language) care conţin un \nsingur bloc DDL\nCurs 7 - BAZE DE DATE 42\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\n•Nu pot exista situaţii ""jumătate de drum"" în \ntimpul execuţiei unei tranzactii, aşa încât \nunele modificări specificate în tranzacţie să \nfie aplicate bazei de date şi altele nu. \n•Pentru fiecare tranzacţie ori toate \nmodificările sunt aplicate bazei de date, ori \nnici una din modificări nu este îndeplinită \n(sunt toate abandonate - discarded ). \nCurs 7 - BAZE DE DATE 43\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nO tranzacţie începe când prima comandă executabilă \nDML sau DDL este întâlnită şi se termină în una din \nurmătoarele situaţii: \n1. Întâlneşte COMMIT/ROLLBACK \n2. Comanda DDL se termină \n3. Anumite erori (DEADLOCK) \n4. EXIT - ieşire din SQL*Plus \n5. Eroare sistem \n6. Un bloc DDL este executat automat şi de aceea implicit \nîncheie o tranzacţie\n7. După încheierea unei tranzacţii, următorul bloc \nexecutabil SQL va lansa automat următoarea tranzacţie\nCurs 7 - BAZE DE DATE 44\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nTranzacţii \nCurs 7 - BAZE DE DATE 45\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nPermanentizarea Modificărilor\n• Pentru ca modificările să rămână permanente, ele \ntrebuie executate asupra bazei de date. \n• Comanda COMMIT realizează permanentizarea \nmodificărilor; \n• Comanda ROLLBACK permite să abandonăm sau să \nanulăm modificările. \n• Modificarea/modificările, executate asupra bazei de \ndate între 2 comenzi COMMIT reprezintă o tranzacţie. \n• Până când tranzacţia nu este executată, nici una din \nmodificări nu este vizibilă utilizatorilor. \nCurs 7 - BAZE DE DATE 46\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nÎnlăturarea modificărilor nedorite \n• Modificările neexecutate pot fi abandonate prin \ncomanda ROLLBACK. \n• ROLLBACK va atribui datelor valorile care acestea le \naveau imediat dupa executarea ultimului COMMIT\nprin anularea tuturor modificărilor făcute după \nultimul COMMIT. \nCurs 7 - BAZE DE DATE 47\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nSemnificaţia tranzacţiilor \n• ORACLE asigură consistenţa datelor bazată pe \ntranzacţii. \n• Tranzacţiile dau utilizatorului mai multă flexibilitate şi \ncontrol la lucrul asupra datelor, şi asigură consistenţa \ndatelor în cazul unei erori a procesului utilizator sau a \nunei erori de sistem. \nCurs 7 - BAZE DE DATE 48', '\n', '10. ', '7 \n \n✓ Flexibilitate în modelarea datelor \n✓ Performanță ridicată pentru date mari și distribuție geografică \nDezavantaje: \n✓ Lipsa standardizării interogărilor \n✓ Unele implementări nu oferă suport pentru tranzacții complexe \n \n \n2.5. Compararea tipurilor de baze de date \n \nTip de bază de \ndate Structură Scalabilitate Flexibilitate Cazuri de utilizare \nIerarhică Arbore Redusă Scăzută Sistemele bancare vechi \nRețea Grafic Medie Medie Aplicații complexe \nRelațională Tabelară Scalabilitate \nlimitată Medie CRM, ERP, eCommerce \nNoSQL Diversă Mare Mare Big Data, IoT, social \nmedia \n \n \n3. Baze de date NoSQL \nBazele de date NoSQL sunt o categorie modernă de sisteme de gestionare a bazelor de date \ncare elimină limitările sistemelor relaționale pentru a permite o stocare și o interogare mai eficiente \na datelor nestructurate și semi-structurate. \n \n3.1. Utilizări comune \n✓ Big Data: MongoDB, Cassandra \n✓ Caching și sesiuni web: Redis, Memcached \n✓ Aplicații distribuite: DynamoDB, CouchDB \n✓ Rețele sociale și grafică de date: Neo4j, ArangoDB \n \n \n3.2. Avantajele bazelor de date NoSQL \n✓ Scalabilitate orizontală: Pot gestiona volume mari de date prin distribuire pe mai multe \nservere. \n✓ Flexibilitate: Nu impun o schemă strictă a datelor, ceea ce permite schimbări rapide. \n✓ Performanță ridicată: Se adaptează bine la cerințele aplicațiilor moderne, unde latența \nredusă este esențială. \n \n1.3.3 Dezavantajele bazelor de date NoSQL \n✓ Lipsa unui standard unificat:  Fiecare sistem are propriul model de interogare și \nadministrare. \n✓ Consistența datelor:  Majoritatea bazelor NoSQL sacrifică consistența în favoarea \ndisponibilității și performanței (modelul CAP). \n \n \n \n\n8 \n \nExemplu 1 - MongoDB (bază de date orientată pe documente): \n{ \n    ""_id"": ObjectId(""60c72b2f5f1b2c6d88fdf301""), \n    ""nume"": ""Maria Ionescu"", \n    ""email"": ""maria@example.com"", \n    ""adresa"": { \n        ""oras"": ""București"", \n        ""strada"": ""Bd. Unirii"" \n    } \n} \n \nInterogare MongoDB: \n{ ""nume"": ""Maria Ionescu"" } \n \nExemplu 2 - Redis (bază de date key-value): \nSET user:1000 ""Ion Popescu"" \nGET user:1000 \n \nProiectarea unei baze de date NoSQL: \nProiectarea unei baze de date NoSQL trebuie să țină cont de cerințele aplicației. De \nexemplu, pentru o aplicație de rețele sociale, un model de bază de date NoSQL ar trebui să permită \nstocarea rapidă a mesajelor și a relațiilor între utilizatori fără a impune constrângerile unei baze de \ndate relaționale. \n \n \nReferințe și resurse web \n1) Connolly, T. & Begg, C. (2014). Database Systems: A Practical Approach to Design, \nImplementation, and Management. Pearson. \n2) Silberschatz, A., Korth, H., & Sudarshan, S. (2020). Database System Concepts. McGraw-\nHill. \n3) Elmasri, R., & Navathe, S. (2016). Fundamentals of Database Systems. Pearson. \n4) W3Schools SQL Tutorial \n5) MongoDB Documentation \n6) PostgreSQL Documentation \n7) Redis Documentation', '\n']","o operație complexă de manipulare a datelor folosind subinterogări se realizează prin includerea unei instrucțiuni SELECT în clauza altei instrucțiuni SQL. Subinterogările sunt utile când interogarea se bazează pe criterii necunoscute și pot transmite unul sau mai multe rânduri de date instrucțiunii principale, utilizând operatori single-row (=, <>, >, >=, <, <=) sau multiple-row (IN, ANY, ALL).
",Cum se realizează o operație complexă de manipulare a datelor folosind subinterogări?,"['1. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '2. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '3. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '4. ', '1.1.Sisteme de baze de date\n- precompilatorul limbajului de manipulare\na datelor care transformă instrucţiunile\nDML de la programele de aplicaţii la\nlimbajul gazdă, şi lucrează cu procesorul de\ninterogări;\n- compilatorul limbajului de definiţie a\ndatelor care transformă instrucţiunile DDL\nîn tabele de metadate.\n 32\n\n1.1.Sisteme de baze de date\nMetadatele sunt\nmemorate în \ndicţionarul de \ndate, care \ninclude:\n➢structura bazei\nde date sau\nschema\n➢constrângerile\nde integritate\n➢constrângerile\nde securitate\n 33\n\nModele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\n 34\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 35\n\n1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36\n\n1.2.Modelul de date relaţional\nFormal, o relaţie R este o mulţime, unde D1, D2, ..., \nDn sunt domeniile a n atribute A1, A2, ..., An. \n✓ Elementele relaţiei sunt n-tuplurile (v1, v2, ..., vn) cu vi\nDi, adică valoarea celui de-al i-lea atribut trebuie să fie \nun element din mulţimea Di.  \n✓ Elementele dintr-un tuplu sunt numite câmpuri. \n✓ Când un camp nu conţine nici o valoare, vom reprezenta \nacest fapt cu o valoare specială numită valoare null, \nsemnificând că “nu este nici o intrare” în loc de “intrarea \neste necunoscută”. \n 37\n\n1.2.Modelul de date relaţional\nPrezentăm în continuare un exemplu de tabelă \npentru gestiunea studenţilor dintr-o facultate:\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\nAtributeTuplu\nCâmp\n38\n\n1.2.Modelul de date relaţional\nConstrângeri de integritate\nConstrângerile de integritate restricţionează mulţimea\ntuplu-rilor teoretice posibile la o mulţime care este în mod\npractic cu o semnificaţie. \nFie X şi Y două mulţimi cu unul sau mai multe atribute\nAi, din schema relaţională. \nSpunem că Y este dependent funcţional de X, şi notăm \nacest lucru prin X Y,dacă şi numai dacă nu este posibil să\navem două tupluri cu aceeaşi valoare pentru toate\natributele din X dar cu valoare diferită pentru toate\natributele din Y . \n→ 39', '\n', '5. ', '1.1.Sisteme de baze de date\n- precompilatorul limbajului de manipulare\na datelor care transformă instrucţiunile\nDML de la programele de aplicaţii la\nlimbajul gazdă, şi lucrează cu procesorul de\ninterogări;\n- compilatorul limbajului de definiţie a\ndatelor care transformă instrucţiunile DDL\nîn tabele de metadate.\n 32\n\n1.1.Sisteme de baze de date\nMetadatele sunt\nmemorate în \ndicţionarul de \ndate, care \ninclude:\n➢structura bazei\nde date sau\nschema\n➢constrângerile\nde integritate\n➢constrângerile\nde securitate\n 33\n\nModele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\n 34\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 35\n\n1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36\n\n1.2.Modelul de date relaţional\nFormal, o relaţie R este o mulţime, unde D1, D2, ..., \nDn sunt domeniile a n atribute A1, A2, ..., An. \n✓ Elementele relaţiei sunt n-tuplurile (v1, v2, ..., vn) cu vi\nDi, adică valoarea celui de-al i-lea atribut trebuie să fie \nun element din mulţimea Di.  \n✓ Elementele dintr-un tuplu sunt numite câmpuri. \n✓ Când un camp nu conţine nici o valoare, vom reprezenta \nacest fapt cu o valoare specială numită valoare null, \nsemnificând că “nu este nici o intrare” în loc de “intrarea \neste necunoscută”. \n 37\n\n1.2.Modelul de date relaţional\nPrezentăm în continuare un exemplu de tabelă \npentru gestiunea studenţilor dintr-o facultate:\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\nAtributeTuplu\nCâmp\n38\n\n1.2.Modelul de date relaţional\nConstrângeri de integritate\nConstrângerile de integritate restricţionează mulţimea\ntuplu-rilor teoretice posibile la o mulţime care este în mod\npractic cu o semnificaţie. \nFie X şi Y două mulţimi cu unul sau mai multe atribute\nAi, din schema relaţională. \nSpunem că Y este dependent funcţional de X, şi notăm \nacest lucru prin X Y,dacă şi numai dacă nu este posibil să\navem două tupluri cu aceeaşi valoare pentru toate\natributele din X dar cu valoare diferită pentru toate\natributele din Y . \n→ 39', '\n', '6. ', '1.1.Sisteme de baze de date\n- precompilatorul limbajului de manipulare\na datelor care transformă instrucţiunile\nDML de la programele de aplicaţii la\nlimbajul gazdă, şi lucrează cu procesorul de\ninterogări;\n- compilatorul limbajului de definiţie a\ndatelor care transformă instrucţiunile DDL\nîn tabele de metadate.\n 32\n\n1.1.Sisteme de baze de date\nMetadatele sunt\nmemorate în \ndicţionarul de \ndate, care \ninclude:\n➢structura bazei\nde date sau\nschema\n➢constrângerile\nde integritate\n➢constrângerile\nde securitate\n 33\n\nModele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\n 34\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 35\n\n1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36\n\n1.2.Modelul de date relaţional\nFormal, o relaţie R este o mulţime, unde D1, D2, ..., \nDn sunt domeniile a n atribute A1, A2, ..., An. \n✓ Elementele relaţiei sunt n-tuplurile (v1, v2, ..., vn) cu vi\nDi, adică valoarea celui de-al i-lea atribut trebuie să fie \nun element din mulţimea Di.  \n✓ Elementele dintr-un tuplu sunt numite câmpuri. \n✓ Când un camp nu conţine nici o valoare, vom reprezenta \nacest fapt cu o valoare specială numită valoare null, \nsemnificând că “nu este nici o intrare” în loc de “intrarea \neste necunoscută”. \n 37\n\n1.2.Modelul de date relaţional\nPrezentăm în continuare un exemplu de tabelă \npentru gestiunea studenţilor dintr-o facultate:\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\nAtributeTuplu\nCâmp\n38\n\n1.2.Modelul de date relaţional\nConstrângeri de integritate\nConstrângerile de integritate restricţionează mulţimea\ntuplu-rilor teoretice posibile la o mulţime care este în mod\npractic cu o semnificaţie. \nFie X şi Y două mulţimi cu unul sau mai multe atribute\nAi, din schema relaţională. \nSpunem că Y este dependent funcţional de X, şi notăm \nacest lucru prin X Y,dacă şi numai dacă nu este posibil să\navem două tupluri cu aceeaşi valoare pentru toate\natributele din X dar cu valoare diferită pentru toate\natributele din Y . \n→ 39', '\n', '7. ', '7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nProcesarea unei Tranzactii \nO tranzacţie este o operaţie asupra unei \nbaze de date care implică una sau mai \nmulte modificări în una sau mai multe \ntabele.\nCurs 7 - BAZE DE DATE 41\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nExistă două clase de tranzacţii:\n1. Tranzacţii DML (Data Manipulation Language) care conţin \nun număr oarecare de blocuri DML şi pe care ORACLE le \ntratează ca o singură entitate sau o singură unitate logica \nde lucru\n2. Tranzacţii DDL (Data Definition Language) care conţin un \nsingur bloc DDL\nCurs 7 - BAZE DE DATE 42\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\n•Nu pot exista situaţii ""jumătate de drum"" în \ntimpul execuţiei unei tranzactii, aşa încât \nunele modificări specificate în tranzacţie să \nfie aplicate bazei de date şi altele nu. \n•Pentru fiecare tranzacţie ori toate \nmodificările sunt aplicate bazei de date, ori \nnici una din modificări nu este îndeplinită \n(sunt toate abandonate - discarded ). \nCurs 7 - BAZE DE DATE 43\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nO tranzacţie începe când prima comandă executabilă \nDML sau DDL este întâlnită şi se termină în una din \nurmătoarele situaţii: \n1. Întâlneşte COMMIT/ROLLBACK \n2. Comanda DDL se termină \n3. Anumite erori (DEADLOCK) \n4. EXIT - ieşire din SQL*Plus \n5. Eroare sistem \n6. Un bloc DDL este executat automat şi de aceea implicit \nîncheie o tranzacţie\n7. După încheierea unei tranzacţii, următorul bloc \nexecutabil SQL va lansa automat următoarea tranzacţie\nCurs 7 - BAZE DE DATE 44\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nTranzacţii \nCurs 7 - BAZE DE DATE 45\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nPermanentizarea Modificărilor\n• Pentru ca modificările să rămână permanente, ele \ntrebuie executate asupra bazei de date. \n• Comanda COMMIT realizează permanentizarea \nmodificărilor; \n• Comanda ROLLBACK permite să abandonăm sau să \nanulăm modificările. \n• Modificarea/modificările, executate asupra bazei de \ndate între 2 comenzi COMMIT reprezintă o tranzacţie. \n• Până când tranzacţia nu este executată, nici una din \nmodificări nu este vizibilă utilizatorilor. \nCurs 7 - BAZE DE DATE 46\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nÎnlăturarea modificărilor nedorite \n• Modificările neexecutate pot fi abandonate prin \ncomanda ROLLBACK. \n• ROLLBACK va atribui datelor valorile care acestea le \naveau imediat dupa executarea ultimului COMMIT\nprin anularea tuturor modificărilor făcute după \nultimul COMMIT. \nCurs 7 - BAZE DE DATE 47\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nSemnificaţia tranzacţiilor \n• ORACLE asigură consistenţa datelor bazată pe \ntranzacţii. \n• Tranzacţiile dau utilizatorului mai multă flexibilitate şi \ncontrol la lucrul asupra datelor, şi asigură consistenţa \ndatelor în cazul unei erori a procesului utilizator sau a \nunei erori de sistem. \nCurs 7 - BAZE DE DATE 48', '\n', '8. ', '7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nProcesarea unei Tranzactii \nO tranzacţie este o operaţie asupra unei \nbaze de date care implică una sau mai \nmulte modificări în una sau mai multe \ntabele.\nCurs 7 - BAZE DE DATE 41\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nExistă două clase de tranzacţii:\n1. Tranzacţii DML (Data Manipulation Language) care conţin \nun număr oarecare de blocuri DML şi pe care ORACLE le \ntratează ca o singură entitate sau o singură unitate logica \nde lucru\n2. Tranzacţii DDL (Data Definition Language) care conţin un \nsingur bloc DDL\nCurs 7 - BAZE DE DATE 42\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\n•Nu pot exista situaţii ""jumătate de drum"" în \ntimpul execuţiei unei tranzactii, aşa încât \nunele modificări specificate în tranzacţie să \nfie aplicate bazei de date şi altele nu. \n•Pentru fiecare tranzacţie ori toate \nmodificările sunt aplicate bazei de date, ori \nnici una din modificări nu este îndeplinită \n(sunt toate abandonate - discarded ). \nCurs 7 - BAZE DE DATE 43\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nO tranzacţie începe când prima comandă executabilă \nDML sau DDL este întâlnită şi se termină în una din \nurmătoarele situaţii: \n1. Întâlneşte COMMIT/ROLLBACK \n2. Comanda DDL se termină \n3. Anumite erori (DEADLOCK) \n4. EXIT - ieşire din SQL*Plus \n5. Eroare sistem \n6. Un bloc DDL este executat automat şi de aceea implicit \nîncheie o tranzacţie\n7. După încheierea unei tranzacţii, următorul bloc \nexecutabil SQL va lansa automat următoarea tranzacţie\nCurs 7 - BAZE DE DATE 44\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nTranzacţii \nCurs 7 - BAZE DE DATE 45\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nPermanentizarea Modificărilor\n• Pentru ca modificările să rămână permanente, ele \ntrebuie executate asupra bazei de date. \n• Comanda COMMIT realizează permanentizarea \nmodificărilor; \n• Comanda ROLLBACK permite să abandonăm sau să \nanulăm modificările. \n• Modificarea/modificările, executate asupra bazei de \ndate între 2 comenzi COMMIT reprezintă o tranzacţie. \n• Până când tranzacţia nu este executată, nici una din \nmodificări nu este vizibilă utilizatorilor. \nCurs 7 - BAZE DE DATE 46\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nÎnlăturarea modificărilor nedorite \n• Modificările neexecutate pot fi abandonate prin \ncomanda ROLLBACK. \n• ROLLBACK va atribui datelor valorile care acestea le \naveau imediat dupa executarea ultimului COMMIT\nprin anularea tuturor modificărilor făcute după \nultimul COMMIT. \nCurs 7 - BAZE DE DATE 47\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nSemnificaţia tranzacţiilor \n• ORACLE asigură consistenţa datelor bazată pe \ntranzacţii. \n• Tranzacţiile dau utilizatorului mai multă flexibilitate şi \ncontrol la lucrul asupra datelor, şi asigură consistenţa \ndatelor în cazul unei erori a procesului utilizator sau a \nunei erori de sistem. \nCurs 7 - BAZE DE DATE 48', '\n', '9. ', '7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nProcesarea unei Tranzactii \nO tranzacţie este o operaţie asupra unei \nbaze de date care implică una sau mai \nmulte modificări în una sau mai multe \ntabele.\nCurs 7 - BAZE DE DATE 41\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nExistă două clase de tranzacţii:\n1. Tranzacţii DML (Data Manipulation Language) care conţin \nun număr oarecare de blocuri DML şi pe care ORACLE le \ntratează ca o singură entitate sau o singură unitate logica \nde lucru\n2. Tranzacţii DDL (Data Definition Language) care conţin un \nsingur bloc DDL\nCurs 7 - BAZE DE DATE 42\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\n•Nu pot exista situaţii ""jumătate de drum"" în \ntimpul execuţiei unei tranzactii, aşa încât \nunele modificări specificate în tranzacţie să \nfie aplicate bazei de date şi altele nu. \n•Pentru fiecare tranzacţie ori toate \nmodificările sunt aplicate bazei de date, ori \nnici una din modificări nu este îndeplinită \n(sunt toate abandonate - discarded ). \nCurs 7 - BAZE DE DATE 43\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nO tranzacţie începe când prima comandă executabilă \nDML sau DDL este întâlnită şi se termină în una din \nurmătoarele situaţii: \n1. Întâlneşte COMMIT/ROLLBACK \n2. Comanda DDL se termină \n3. Anumite erori (DEADLOCK) \n4. EXIT - ieşire din SQL*Plus \n5. Eroare sistem \n6. Un bloc DDL este executat automat şi de aceea implicit \nîncheie o tranzacţie\n7. După încheierea unei tranzacţii, următorul bloc \nexecutabil SQL va lansa automat următoarea tranzacţie\nCurs 7 - BAZE DE DATE 44\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nTranzacţii \nCurs 7 - BAZE DE DATE 45\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nPermanentizarea Modificărilor\n• Pentru ca modificările să rămână permanente, ele \ntrebuie executate asupra bazei de date. \n• Comanda COMMIT realizează permanentizarea \nmodificărilor; \n• Comanda ROLLBACK permite să abandonăm sau să \nanulăm modificările. \n• Modificarea/modificările, executate asupra bazei de \ndate între 2 comenzi COMMIT reprezintă o tranzacţie. \n• Până când tranzacţia nu este executată, nici una din \nmodificări nu este vizibilă utilizatorilor. \nCurs 7 - BAZE DE DATE 46\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nÎnlăturarea modificărilor nedorite \n• Modificările neexecutate pot fi abandonate prin \ncomanda ROLLBACK. \n• ROLLBACK va atribui datelor valorile care acestea le \naveau imediat dupa executarea ultimului COMMIT\nprin anularea tuturor modificărilor făcute după \nultimul COMMIT. \nCurs 7 - BAZE DE DATE 47\n\n7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nSemnificaţia tranzacţiilor \n• ORACLE asigură consistenţa datelor bazată pe \ntranzacţii. \n• Tranzacţiile dau utilizatorului mai multă flexibilitate şi \ncontrol la lucrul asupra datelor, şi asigură consistenţa \ndatelor în cazul unei erori a procesului utilizator sau a \nunei erori de sistem. \nCurs 7 - BAZE DE DATE 48', '\n', '10. ', '7 \n \n✓ Flexibilitate în modelarea datelor \n✓ Performanță ridicată pentru date mari și distribuție geografică \nDezavantaje: \n✓ Lipsa standardizării interogărilor \n✓ Unele implementări nu oferă suport pentru tranzacții complexe \n \n \n2.5. Compararea tipurilor de baze de date \n \nTip de bază de \ndate Structură Scalabilitate Flexibilitate Cazuri de utilizare \nIerarhică Arbore Redusă Scăzută Sistemele bancare vechi \nRețea Grafic Medie Medie Aplicații complexe \nRelațională Tabelară Scalabilitate \nlimitată Medie CRM, ERP, eCommerce \nNoSQL Diversă Mare Mare Big Data, IoT, social \nmedia \n \n \n3. Baze de date NoSQL \nBazele de date NoSQL sunt o categorie modernă de sisteme de gestionare a bazelor de date \ncare elimină limitările sistemelor relaționale pentru a permite o stocare și o interogare mai eficiente \na datelor nestructurate și semi-structurate. \n \n3.1. Utilizări comune \n✓ Big Data: MongoDB, Cassandra \n✓ Caching și sesiuni web: Redis, Memcached \n✓ Aplicații distribuite: DynamoDB, CouchDB \n✓ Rețele sociale și grafică de date: Neo4j, ArangoDB \n \n \n3.2. Avantajele bazelor de date NoSQL \n✓ Scalabilitate orizontală: Pot gestiona volume mari de date prin distribuire pe mai multe \nservere. \n✓ Flexibilitate: Nu impun o schemă strictă a datelor, ceea ce permite schimbări rapide. \n✓ Performanță ridicată: Se adaptează bine la cerințele aplicațiilor moderne, unde latența \nredusă este esențială. \n \n1.3.3 Dezavantajele bazelor de date NoSQL \n✓ Lipsa unui standard unificat:  Fiecare sistem are propriul model de interogare și \nadministrare. \n✓ Consistența datelor:  Majoritatea bazelor NoSQL sacrifică consistența în favoarea \ndisponibilității și performanței (modelul CAP). \n \n \n \n\n8 \n \nExemplu 1 - MongoDB (bază de date orientată pe documente): \n{ \n    ""_id"": ObjectId(""60c72b2f5f1b2c6d88fdf301""), \n    ""nume"": ""Maria Ionescu"", \n    ""email"": ""maria@example.com"", \n    ""adresa"": { \n        ""oras"": ""București"", \n        ""strada"": ""Bd. Unirii"" \n    } \n} \n \nInterogare MongoDB: \n{ ""nume"": ""Maria Ionescu"" } \n \nExemplu 2 - Redis (bază de date key-value): \nSET user:1000 ""Ion Popescu"" \nGET user:1000 \n \nProiectarea unei baze de date NoSQL: \nProiectarea unei baze de date NoSQL trebuie să țină cont de cerințele aplicației. De \nexemplu, pentru o aplicație de rețele sociale, un model de bază de date NoSQL ar trebui să permită \nstocarea rapidă a mesajelor și a relațiilor între utilizatori fără a impune constrângerile unei baze de \ndate relaționale. \n \n \nReferințe și resurse web \n1) Connolly, T. & Begg, C. (2014). Database Systems: A Practical Approach to Design, \nImplementation, and Management. Pearson. \n2) Silberschatz, A., Korth, H., & Sudarshan, S. (2020). Database System Concepts. McGraw-\nHill. \n3) Elmasri, R., & Navathe, S. (2016). Fundamentals of Database Systems. Pearson. \n4) W3Schools SQL Tutorial \n5) MongoDB Documentation \n6) PostgreSQL Documentation \n7) Redis Documentation', '\n']","o operație complexă de manipulare a datelor folosind subinterogări se realizează prin includerea unei instrucțiuni SELECT în clauza altei instrucțiuni SQL. Subinterogările sunt utile când interogarea se bazează pe criterii necunoscute și pot transmite unul sau mai multe rânduri de date instrucțiunii principale, utilizând operatori single-row (=, <>, >, >=, <, <=) sau multiple-row (IN, ANY, ALL).
","Operația combină DML și subinterogări pentru actualizări selective. De exemplu: „UPDATE EMP SET sal = sal * 1.1 WHERE sal < (SELECT AVG(sal) FROM EMP)” actualizează salariile angajaților cu valori sub medie, folosind rezultatul unei subinterogări în clauza WHERE.",0.4249999999858333,0.0,0.9420751813233336,1.0,0.04780204393760627,0.13333333333333333,0.22
41,O3mini-high,High,"C8, C9",C11,Cum pot fi utilizate constrângerile și vederile pentru implementarea politicilor de securitate în baze de date?,"Constrângerile (NOT NULL, FOREIGN KEY, CHECK) asigură „integritatea datelor”, iar vederile controlează accesul la informații sensibile. Împreună, ele permit „controlul accesului la obiecte specifice” și implementează politici stricte de securitate în mediul de baze de date.",Este corect,Curs ???,"['1. ', 'Curs 11\nControlul accesului utilizatorilor\nCurs - BAZE DE DATE 2\n\n\nCuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3\n\nControlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4\n\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5\n\ntt\n1) Securitatea sistemului acopera accesarea si \nutilizarea bazei de date la nivelul sistemului, cum \nar fi: numele utilizatorului si parola, spatiul pe \ndisc alocat utilizatorilor, si operatiile de sistem \npermise utilizatorilor. \nCurs - BAZE DE DATE 6\nhttps://www.scnsoft.com/blog/database-security-best-practices\n\ntt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/\n\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8\n\nScheme \nO schema este o colectie de obiecte, cum ar fi: \n✓tabele\n✓indecsi\n✓vizualizari\n✓secvente\nSchema este detinuta de un utilizator al bazei de \ndate si are acelasi nume cu utilizatorul.\nCurs - BAZE DE DATE 9\n\ntt\nPrivilegii de sistem\nSunt disponibile mai mult de 80 de privilegii de \nsistem pentru utilizatori si pentru roluri. \nPrivilegiile de sistem sunt setate  de catre  \nadministratorul bazei de date.\nCurs - BAZE DE DATE 10\n\nPrivilegiile caracteristice ale DBA\nPrivilegii de sistem Operatii autorizate\nCreare de utilizatori Permite crearea unui alt utilizator Oracle (privilegiu\ncerut pentru rolul de DBA)\nStergerea de utilizatori Permite stergerea altui utilizator\nStergerea oricarei tabele Permite stergerea unei tabele în orice schema\nRecuperarea oricarei\ntabele\nRecuperarea oricarei tabele în orice schema cu\nutilitare de export\nCurs - BAZE DE DATE 11', '\n', '2. ', 'Curs 11\nControlul accesului utilizatorilor\nCurs - BAZE DE DATE 2\n\n\nCuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3\n\nControlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4\n\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5\n\ntt\n1) Securitatea sistemului acopera accesarea si \nutilizarea bazei de date la nivelul sistemului, cum \nar fi: numele utilizatorului si parola, spatiul pe \ndisc alocat utilizatorilor, si operatiile de sistem \npermise utilizatorilor. \nCurs - BAZE DE DATE 6\nhttps://www.scnsoft.com/blog/database-security-best-practices\n\ntt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/\n\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8\n\nScheme \nO schema este o colectie de obiecte, cum ar fi: \n✓tabele\n✓indecsi\n✓vizualizari\n✓secvente\nSchema este detinuta de un utilizator al bazei de \ndate si are acelasi nume cu utilizatorul.\nCurs - BAZE DE DATE 9\n\ntt\nPrivilegii de sistem\nSunt disponibile mai mult de 80 de privilegii de \nsistem pentru utilizatori si pentru roluri. \nPrivilegiile de sistem sunt setate  de catre  \nadministratorul bazei de date.\nCurs - BAZE DE DATE 10\n\nPrivilegiile caracteristice ale DBA\nPrivilegii de sistem Operatii autorizate\nCreare de utilizatori Permite crearea unui alt utilizator Oracle (privilegiu\ncerut pentru rolul de DBA)\nStergerea de utilizatori Permite stergerea altui utilizator\nStergerea oricarei tabele Permite stergerea unei tabele în orice schema\nRecuperarea oricarei\ntabele\nRecuperarea oricarei tabele în orice schema cu\nutilitare de export\nCurs - BAZE DE DATE 11', '\n', '3. ', 'Curs 11\nControlul accesului utilizatorilor\nCurs - BAZE DE DATE 2\n\n\nCuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3\n\nControlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4\n\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5\n\ntt\n1) Securitatea sistemului acopera accesarea si \nutilizarea bazei de date la nivelul sistemului, cum \nar fi: numele utilizatorului si parola, spatiul pe \ndisc alocat utilizatorilor, si operatiile de sistem \npermise utilizatorilor. \nCurs - BAZE DE DATE 6\nhttps://www.scnsoft.com/blog/database-security-best-practices\n\ntt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/\n\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8\n\nScheme \nO schema este o colectie de obiecte, cum ar fi: \n✓tabele\n✓indecsi\n✓vizualizari\n✓secvente\nSchema este detinuta de un utilizator al bazei de \ndate si are acelasi nume cu utilizatorul.\nCurs - BAZE DE DATE 9\n\ntt\nPrivilegii de sistem\nSunt disponibile mai mult de 80 de privilegii de \nsistem pentru utilizatori si pentru roluri. \nPrivilegiile de sistem sunt setate  de catre  \nadministratorul bazei de date.\nCurs - BAZE DE DATE 10\n\nPrivilegiile caracteristice ale DBA\nPrivilegii de sistem Operatii autorizate\nCreare de utilizatori Permite crearea unui alt utilizator Oracle (privilegiu\ncerut pentru rolul de DBA)\nStergerea de utilizatori Permite stergerea altui utilizator\nStergerea oricarei tabele Permite stergerea unei tabele în orice schema\nRecuperarea oricarei\ntabele\nRecuperarea oricarei tabele în orice schema cu\nutilitare de export\nCurs - BAZE DE DATE 11', '\n', '4. ', 'Orice firmă utilizează baze de date pentru păstrarea \nşi gestionarea informaţiilor. Câteva astfel de aplicaţii sunt \nuzuale:\n1.bazele de date ale liniilor aeriene care sunt accesate \nsimultan din sute de agenţii pentru a realiza rezervări şi \nvânzări de locuri pentru date şi zboruri diferite\n2.bazele de date ale băncilor care permit realizarea a mii \nde tranzacţii zilnic\n3.bazele de date ale supermagazinelor care sunt accesate \natât de la casele de marcaj cât şi de la echipamentele de \ninventariere\n4.bazele de date ale bibliotecilor care păstrează milioane \nde titluri şi permit localizarea unei lucrări folosind diferite \ncriterii (cuvinte cheie, titlu, autori, domeniu)\n 17\n\nPentru realizarea unei aplicaţii care foloseşte baze de \ndate se poate proceda în două moduri:\na)Se creează baza de date cu ajutorul unei aplicaţii de tip server \nde baze de date şi se scriu apoi aplicaţiile care accesează baza \nde date într-un limbaj care posedă funcţiile necesare accesării \nserver-ului (frecvent se folosesc limbajele C++, Java, C# sau \nVisual Basic)\nb)Se foloseste o aplicaţie de tip sistem de gestiune de baze de \ndate (S.G.B.D. sau D.B.M.S. - DataBase Management System). \n      Un astfel de sistem oferă un ansamblu de instrumente \nsoftware cu ajutorul cărora se crează atât baza de date cât şi \naplicaţiile prin care aceasta este exploatată. \n      Pentru utilizatorii sistemului de operare Windows cele mai \ncunoscute sisteme de acest fel sunt Access şi Visual FoxPro. \n 18\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 19\n\n1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20\n\n1.1.Sisteme de baze de date\nUn sistem de baze de date poate fi \nconsiderat ca având patru părţi: \n1. date\n2. utilizatori\n3. hardware \n4. software\n 21\n\n1.1.Sisteme de baze de date\nDatele: \nSunt informaţii pe care diferiţi utilizatori (firme, \nagenţii, sau simpli utilizatori) le colectează pentru a-şi \nîndeplini scopurile sau misiunile. \nDatele individuale sunt stocate în mulţimi de date \nrelaţionate (legate) numite înregistrări. \nO colecţie de înregistrări dependente se numeşte \nbază de date.\n 22\n\n1.1.Sisteme de baze de date\nUtilizatorii: \nDiferite persoane sau grupuri de \npersoane care folosesc informaţiile sunt\ndefinite ca utilizatori.\nHardware: De obicei noţiunea de \nhardware constă din device-uri fizice, cum \nar fi harddisk-uri, imprimante, interfeţe de \nintrare/ieşire şi procesorul de date cu\nmemoria sa asociată.\n 23', '\n', '5. ', 'Orice firmă utilizează baze de date pentru păstrarea \nşi gestionarea informaţiilor. Câteva astfel de aplicaţii sunt \nuzuale:\n1.bazele de date ale liniilor aeriene care sunt accesate \nsimultan din sute de agenţii pentru a realiza rezervări şi \nvânzări de locuri pentru date şi zboruri diferite\n2.bazele de date ale băncilor care permit realizarea a mii \nde tranzacţii zilnic\n3.bazele de date ale supermagazinelor care sunt accesate \natât de la casele de marcaj cât şi de la echipamentele de \ninventariere\n4.bazele de date ale bibliotecilor care păstrează milioane \nde titluri şi permit localizarea unei lucrări folosind diferite \ncriterii (cuvinte cheie, titlu, autori, domeniu)\n 17\n\nPentru realizarea unei aplicaţii care foloseşte baze de \ndate se poate proceda în două moduri:\na)Se creează baza de date cu ajutorul unei aplicaţii de tip server \nde baze de date şi se scriu apoi aplicaţiile care accesează baza \nde date într-un limbaj care posedă funcţiile necesare accesării \nserver-ului (frecvent se folosesc limbajele C++, Java, C# sau \nVisual Basic)\nb)Se foloseste o aplicaţie de tip sistem de gestiune de baze de \ndate (S.G.B.D. sau D.B.M.S. - DataBase Management System). \n      Un astfel de sistem oferă un ansamblu de instrumente \nsoftware cu ajutorul cărora se crează atât baza de date cât şi \naplicaţiile prin care aceasta este exploatată. \n      Pentru utilizatorii sistemului de operare Windows cele mai \ncunoscute sisteme de acest fel sunt Access şi Visual FoxPro. \n 18\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 19\n\n1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20\n\n1.1.Sisteme de baze de date\nUn sistem de baze de date poate fi \nconsiderat ca având patru părţi: \n1. date\n2. utilizatori\n3. hardware \n4. software\n 21\n\n1.1.Sisteme de baze de date\nDatele: \nSunt informaţii pe care diferiţi utilizatori (firme, \nagenţii, sau simpli utilizatori) le colectează pentru a-şi \nîndeplini scopurile sau misiunile. \nDatele individuale sunt stocate în mulţimi de date \nrelaţionate (legate) numite înregistrări. \nO colecţie de înregistrări dependente se numeşte \nbază de date.\n 22\n\n1.1.Sisteme de baze de date\nUtilizatorii: \nDiferite persoane sau grupuri de \npersoane care folosesc informaţiile sunt\ndefinite ca utilizatori.\nHardware: De obicei noţiunea de \nhardware constă din device-uri fizice, cum \nar fi harddisk-uri, imprimante, interfeţe de \nintrare/ieşire şi procesorul de date cu\nmemoria sa asociată.\n 23', '\n', '6. ', 'Orice firmă utilizează baze de date pentru păstrarea \nşi gestionarea informaţiilor. Câteva astfel de aplicaţii sunt \nuzuale:\n1.bazele de date ale liniilor aeriene care sunt accesate \nsimultan din sute de agenţii pentru a realiza rezervări şi \nvânzări de locuri pentru date şi zboruri diferite\n2.bazele de date ale băncilor care permit realizarea a mii \nde tranzacţii zilnic\n3.bazele de date ale supermagazinelor care sunt accesate \natât de la casele de marcaj cât şi de la echipamentele de \ninventariere\n4.bazele de date ale bibliotecilor care păstrează milioane \nde titluri şi permit localizarea unei lucrări folosind diferite \ncriterii (cuvinte cheie, titlu, autori, domeniu)\n 17\n\nPentru realizarea unei aplicaţii care foloseşte baze de \ndate se poate proceda în două moduri:\na)Se creează baza de date cu ajutorul unei aplicaţii de tip server \nde baze de date şi se scriu apoi aplicaţiile care accesează baza \nde date într-un limbaj care posedă funcţiile necesare accesării \nserver-ului (frecvent se folosesc limbajele C++, Java, C# sau \nVisual Basic)\nb)Se foloseste o aplicaţie de tip sistem de gestiune de baze de \ndate (S.G.B.D. sau D.B.M.S. - DataBase Management System). \n      Un astfel de sistem oferă un ansamblu de instrumente \nsoftware cu ajutorul cărora se crează atât baza de date cât şi \naplicaţiile prin care aceasta este exploatată. \n      Pentru utilizatorii sistemului de operare Windows cele mai \ncunoscute sisteme de acest fel sunt Access şi Visual FoxPro. \n 18\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 19\n\n1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20\n\n1.1.Sisteme de baze de date\nUn sistem de baze de date poate fi \nconsiderat ca având patru părţi: \n1. date\n2. utilizatori\n3. hardware \n4. software\n 21\n\n1.1.Sisteme de baze de date\nDatele: \nSunt informaţii pe care diferiţi utilizatori (firme, \nagenţii, sau simpli utilizatori) le colectează pentru a-şi \nîndeplini scopurile sau misiunile. \nDatele individuale sunt stocate în mulţimi de date \nrelaţionate (legate) numite înregistrări. \nO colecţie de înregistrări dependente se numeşte \nbază de date.\n 22\n\n1.1.Sisteme de baze de date\nUtilizatorii: \nDiferite persoane sau grupuri de \npersoane care folosesc informaţiile sunt\ndefinite ca utilizatori.\nHardware: De obicei noţiunea de \nhardware constă din device-uri fizice, cum \nar fi harddisk-uri, imprimante, interfeţe de \nintrare/ieşire şi procesorul de date cu\nmemoria sa asociată.\n 23', '\n', '7. ', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 8\nLimbajul SQL \nCurs 8 - BAZE DE DATE 2\n\nLimbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3\n\nServerul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4\n\nTipuri de constrângeri\nCurs 8 - BAZE DE DATE 5\n\nGhidul Constrângerilor\n1. Toate constrângerile sunt cuprinse într-un dicţionar. \n2. Este uşor să se facă referinţă la constrângeri dacă li se \ndă nume sugestive. \n3. Numele unei constrângeri trebuie să urmeze un \nanumit standard. \n4. Dacă nu se denumeşte constrângerea, server-ul Oracle\ngenerează un nume de forma SYS_Cn, unde n este un \nnumăr întreg astfel încât numele constrângerii este \nunic.\n5. Constrângerile definite pentru o anumita tabela pot fi \nvizualizate în USER_CONSTRAINTS (dicţionarul tabelei).\nCurs 8 - BAZE DE DATE 6\n\nDefinirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7\n\nÎn sintaxa prezentată anterior avem:\nCurs 8 - BAZE DE DATE 8\n\nEXEMPLU - Adăugarea unei \nconstrângeri unei tabele odată cu \ncrearea lui.\nCREATE TABLE EMP1(\nempno number(6) NOT NULL,\nename varchar2(20),\nsal number(4),\nmgr number(4),\njob varchar2(20), \nPRIMARY KEY(empno));\nConstrângere \npentru tabela\nConstrângere \npentru coloană\nCurs 8 - BAZE DE DATE 9\n\n\n• De obicei constrângerile sunt create în acelaşi timp cu \ntabela.\n• Constrângerile pot fi adăugate tabelei după crearea ei.\n• Constrângerile pot fi definite pe 2 nivele: \nCurs 8 - BAZE DE DATE 10\n\nSintaxa:\n1. Constrângere la nivel de coloană\n2. Constrângere la nivel de tabela\nCurs 8 - BAZE DE DATE 11\n\n• In sintaxa avem:\nCurs 8 - BAZE DE DATE 12\n\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13\n\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14\n\nCREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15', '\n', '8. ', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 8\nLimbajul SQL \nCurs 8 - BAZE DE DATE 2\n\nLimbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3\n\nServerul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4\n\nTipuri de constrângeri\nCurs 8 - BAZE DE DATE 5\n\nGhidul Constrângerilor\n1. Toate constrângerile sunt cuprinse într-un dicţionar. \n2. Este uşor să se facă referinţă la constrângeri dacă li se \ndă nume sugestive. \n3. Numele unei constrângeri trebuie să urmeze un \nanumit standard. \n4. Dacă nu se denumeşte constrângerea, server-ul Oracle\ngenerează un nume de forma SYS_Cn, unde n este un \nnumăr întreg astfel încât numele constrângerii este \nunic.\n5. Constrângerile definite pentru o anumita tabela pot fi \nvizualizate în USER_CONSTRAINTS (dicţionarul tabelei).\nCurs 8 - BAZE DE DATE 6\n\nDefinirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7\n\nÎn sintaxa prezentată anterior avem:\nCurs 8 - BAZE DE DATE 8\n\nEXEMPLU - Adăugarea unei \nconstrângeri unei tabele odată cu \ncrearea lui.\nCREATE TABLE EMP1(\nempno number(6) NOT NULL,\nename varchar2(20),\nsal number(4),\nmgr number(4),\njob varchar2(20), \nPRIMARY KEY(empno));\nConstrângere \npentru tabela\nConstrângere \npentru coloană\nCurs 8 - BAZE DE DATE 9\n\n\n• De obicei constrângerile sunt create în acelaşi timp cu \ntabela.\n• Constrângerile pot fi adăugate tabelei după crearea ei.\n• Constrângerile pot fi definite pe 2 nivele: \nCurs 8 - BAZE DE DATE 10\n\nSintaxa:\n1. Constrângere la nivel de coloană\n2. Constrângere la nivel de tabela\nCurs 8 - BAZE DE DATE 11\n\n• In sintaxa avem:\nCurs 8 - BAZE DE DATE 12\n\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13\n\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14\n\nCREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15', '\n', '9. ', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 8\nLimbajul SQL \nCurs 8 - BAZE DE DATE 2\n\nLimbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3\n\nServerul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4\n\nTipuri de constrângeri\nCurs 8 - BAZE DE DATE 5\n\nGhidul Constrângerilor\n1. Toate constrângerile sunt cuprinse într-un dicţionar. \n2. Este uşor să se facă referinţă la constrângeri dacă li se \ndă nume sugestive. \n3. Numele unei constrângeri trebuie să urmeze un \nanumit standard. \n4. Dacă nu se denumeşte constrângerea, server-ul Oracle\ngenerează un nume de forma SYS_Cn, unde n este un \nnumăr întreg astfel încât numele constrângerii este \nunic.\n5. Constrângerile definite pentru o anumita tabela pot fi \nvizualizate în USER_CONSTRAINTS (dicţionarul tabelei).\nCurs 8 - BAZE DE DATE 6\n\nDefinirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7\n\nÎn sintaxa prezentată anterior avem:\nCurs 8 - BAZE DE DATE 8\n\nEXEMPLU - Adăugarea unei \nconstrângeri unei tabele odată cu \ncrearea lui.\nCREATE TABLE EMP1(\nempno number(6) NOT NULL,\nename varchar2(20),\nsal number(4),\nmgr number(4),\njob varchar2(20), \nPRIMARY KEY(empno));\nConstrângere \npentru tabela\nConstrângere \npentru coloană\nCurs 8 - BAZE DE DATE 9\n\n\n• De obicei constrângerile sunt create în acelaşi timp cu \ntabela.\n• Constrângerile pot fi adăugate tabelei după crearea ei.\n• Constrângerile pot fi definite pe 2 nivele: \nCurs 8 - BAZE DE DATE 10\n\nSintaxa:\n1. Constrângere la nivel de coloană\n2. Constrângere la nivel de tabela\nCurs 8 - BAZE DE DATE 11\n\n• In sintaxa avem:\nCurs 8 - BAZE DE DATE 12\n\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13\n\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14\n\nCREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15', '\n', '10. ', ""Curs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n\n2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n);"", '\n']","constrângerile sunt utilizate pentru a impune reguli datelor și pentru a preveni introducerea de date invalide. Ele pot fi definite la nivel de coloană sau tabelă și includ tipuri precum NOT NULL, UNIQUE, PRIMARY KEY, FOREIGN KEY și CHECK. Aceste constrângeri ajută la menținerea integrității datelor și la asigurarea securității prin limitarea acțiunilor care pot fi efectuate asupra datelor.
",Cum pot fi utilizate constrângerile și vederile pentru implementarea politicilor de securitate în baze de date?,"['1. ', 'Curs 11\nControlul accesului utilizatorilor\nCurs - BAZE DE DATE 2\n\n\nCuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3\n\nControlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4\n\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5\n\ntt\n1) Securitatea sistemului acopera accesarea si \nutilizarea bazei de date la nivelul sistemului, cum \nar fi: numele utilizatorului si parola, spatiul pe \ndisc alocat utilizatorilor, si operatiile de sistem \npermise utilizatorilor. \nCurs - BAZE DE DATE 6\nhttps://www.scnsoft.com/blog/database-security-best-practices\n\ntt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/\n\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8\n\nScheme \nO schema este o colectie de obiecte, cum ar fi: \n✓tabele\n✓indecsi\n✓vizualizari\n✓secvente\nSchema este detinuta de un utilizator al bazei de \ndate si are acelasi nume cu utilizatorul.\nCurs - BAZE DE DATE 9\n\ntt\nPrivilegii de sistem\nSunt disponibile mai mult de 80 de privilegii de \nsistem pentru utilizatori si pentru roluri. \nPrivilegiile de sistem sunt setate  de catre  \nadministratorul bazei de date.\nCurs - BAZE DE DATE 10\n\nPrivilegiile caracteristice ale DBA\nPrivilegii de sistem Operatii autorizate\nCreare de utilizatori Permite crearea unui alt utilizator Oracle (privilegiu\ncerut pentru rolul de DBA)\nStergerea de utilizatori Permite stergerea altui utilizator\nStergerea oricarei tabele Permite stergerea unei tabele în orice schema\nRecuperarea oricarei\ntabele\nRecuperarea oricarei tabele în orice schema cu\nutilitare de export\nCurs - BAZE DE DATE 11', '\n', '2. ', 'Curs 11\nControlul accesului utilizatorilor\nCurs - BAZE DE DATE 2\n\n\nCuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3\n\nControlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4\n\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5\n\ntt\n1) Securitatea sistemului acopera accesarea si \nutilizarea bazei de date la nivelul sistemului, cum \nar fi: numele utilizatorului si parola, spatiul pe \ndisc alocat utilizatorilor, si operatiile de sistem \npermise utilizatorilor. \nCurs - BAZE DE DATE 6\nhttps://www.scnsoft.com/blog/database-security-best-practices\n\ntt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/\n\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8\n\nScheme \nO schema este o colectie de obiecte, cum ar fi: \n✓tabele\n✓indecsi\n✓vizualizari\n✓secvente\nSchema este detinuta de un utilizator al bazei de \ndate si are acelasi nume cu utilizatorul.\nCurs - BAZE DE DATE 9\n\ntt\nPrivilegii de sistem\nSunt disponibile mai mult de 80 de privilegii de \nsistem pentru utilizatori si pentru roluri. \nPrivilegiile de sistem sunt setate  de catre  \nadministratorul bazei de date.\nCurs - BAZE DE DATE 10\n\nPrivilegiile caracteristice ale DBA\nPrivilegii de sistem Operatii autorizate\nCreare de utilizatori Permite crearea unui alt utilizator Oracle (privilegiu\ncerut pentru rolul de DBA)\nStergerea de utilizatori Permite stergerea altui utilizator\nStergerea oricarei tabele Permite stergerea unei tabele în orice schema\nRecuperarea oricarei\ntabele\nRecuperarea oricarei tabele în orice schema cu\nutilitare de export\nCurs - BAZE DE DATE 11', '\n', '3. ', 'Curs 11\nControlul accesului utilizatorilor\nCurs - BAZE DE DATE 2\n\n\nCuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3\n\nControlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4\n\ntt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5\n\ntt\n1) Securitatea sistemului acopera accesarea si \nutilizarea bazei de date la nivelul sistemului, cum \nar fi: numele utilizatorului si parola, spatiul pe \ndisc alocat utilizatorilor, si operatiile de sistem \npermise utilizatorilor. \nCurs - BAZE DE DATE 6\nhttps://www.scnsoft.com/blog/database-security-best-practices\n\ntt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/\n\nPrivilegii\nAdministratorul bazei de date este un utilizator de nivel \nînalt ce are posibilitatea de a acorda accesul utilizatorilor \nla baza de date si la obiectele sale. \nUtilizatorii necesita privilegii de sistem pentru a dobândi \nacces la baza de date si privilegii de obiect pentru a \nputea manipula continutul obiectelor în baza de date. \nUtilizatorilor li se poate da de asemeni privilegiul de a \nacorda privilegii aditionale altor utilizatori sau unor \nroluri, cum sunt numite grupurile de privilegii adiacente.\nCurs - BAZE DE DATE 8\n\nScheme \nO schema este o colectie de obiecte, cum ar fi: \n✓tabele\n✓indecsi\n✓vizualizari\n✓secvente\nSchema este detinuta de un utilizator al bazei de \ndate si are acelasi nume cu utilizatorul.\nCurs - BAZE DE DATE 9\n\ntt\nPrivilegii de sistem\nSunt disponibile mai mult de 80 de privilegii de \nsistem pentru utilizatori si pentru roluri. \nPrivilegiile de sistem sunt setate  de catre  \nadministratorul bazei de date.\nCurs - BAZE DE DATE 10\n\nPrivilegiile caracteristice ale DBA\nPrivilegii de sistem Operatii autorizate\nCreare de utilizatori Permite crearea unui alt utilizator Oracle (privilegiu\ncerut pentru rolul de DBA)\nStergerea de utilizatori Permite stergerea altui utilizator\nStergerea oricarei tabele Permite stergerea unei tabele în orice schema\nRecuperarea oricarei\ntabele\nRecuperarea oricarei tabele în orice schema cu\nutilitare de export\nCurs - BAZE DE DATE 11', '\n', '4. ', 'Orice firmă utilizează baze de date pentru păstrarea \nşi gestionarea informaţiilor. Câteva astfel de aplicaţii sunt \nuzuale:\n1.bazele de date ale liniilor aeriene care sunt accesate \nsimultan din sute de agenţii pentru a realiza rezervări şi \nvânzări de locuri pentru date şi zboruri diferite\n2.bazele de date ale băncilor care permit realizarea a mii \nde tranzacţii zilnic\n3.bazele de date ale supermagazinelor care sunt accesate \natât de la casele de marcaj cât şi de la echipamentele de \ninventariere\n4.bazele de date ale bibliotecilor care păstrează milioane \nde titluri şi permit localizarea unei lucrări folosind diferite \ncriterii (cuvinte cheie, titlu, autori, domeniu)\n 17\n\nPentru realizarea unei aplicaţii care foloseşte baze de \ndate se poate proceda în două moduri:\na)Se creează baza de date cu ajutorul unei aplicaţii de tip server \nde baze de date şi se scriu apoi aplicaţiile care accesează baza \nde date într-un limbaj care posedă funcţiile necesare accesării \nserver-ului (frecvent se folosesc limbajele C++, Java, C# sau \nVisual Basic)\nb)Se foloseste o aplicaţie de tip sistem de gestiune de baze de \ndate (S.G.B.D. sau D.B.M.S. - DataBase Management System). \n      Un astfel de sistem oferă un ansamblu de instrumente \nsoftware cu ajutorul cărora se crează atât baza de date cât şi \naplicaţiile prin care aceasta este exploatată. \n      Pentru utilizatorii sistemului de operare Windows cele mai \ncunoscute sisteme de acest fel sunt Access şi Visual FoxPro. \n 18\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 19\n\n1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20\n\n1.1.Sisteme de baze de date\nUn sistem de baze de date poate fi \nconsiderat ca având patru părţi: \n1. date\n2. utilizatori\n3. hardware \n4. software\n 21\n\n1.1.Sisteme de baze de date\nDatele: \nSunt informaţii pe care diferiţi utilizatori (firme, \nagenţii, sau simpli utilizatori) le colectează pentru a-şi \nîndeplini scopurile sau misiunile. \nDatele individuale sunt stocate în mulţimi de date \nrelaţionate (legate) numite înregistrări. \nO colecţie de înregistrări dependente se numeşte \nbază de date.\n 22\n\n1.1.Sisteme de baze de date\nUtilizatorii: \nDiferite persoane sau grupuri de \npersoane care folosesc informaţiile sunt\ndefinite ca utilizatori.\nHardware: De obicei noţiunea de \nhardware constă din device-uri fizice, cum \nar fi harddisk-uri, imprimante, interfeţe de \nintrare/ieşire şi procesorul de date cu\nmemoria sa asociată.\n 23', '\n', '5. ', 'Orice firmă utilizează baze de date pentru păstrarea \nşi gestionarea informaţiilor. Câteva astfel de aplicaţii sunt \nuzuale:\n1.bazele de date ale liniilor aeriene care sunt accesate \nsimultan din sute de agenţii pentru a realiza rezervări şi \nvânzări de locuri pentru date şi zboruri diferite\n2.bazele de date ale băncilor care permit realizarea a mii \nde tranzacţii zilnic\n3.bazele de date ale supermagazinelor care sunt accesate \natât de la casele de marcaj cât şi de la echipamentele de \ninventariere\n4.bazele de date ale bibliotecilor care păstrează milioane \nde titluri şi permit localizarea unei lucrări folosind diferite \ncriterii (cuvinte cheie, titlu, autori, domeniu)\n 17\n\nPentru realizarea unei aplicaţii care foloseşte baze de \ndate se poate proceda în două moduri:\na)Se creează baza de date cu ajutorul unei aplicaţii de tip server \nde baze de date şi se scriu apoi aplicaţiile care accesează baza \nde date într-un limbaj care posedă funcţiile necesare accesării \nserver-ului (frecvent se folosesc limbajele C++, Java, C# sau \nVisual Basic)\nb)Se foloseste o aplicaţie de tip sistem de gestiune de baze de \ndate (S.G.B.D. sau D.B.M.S. - DataBase Management System). \n      Un astfel de sistem oferă un ansamblu de instrumente \nsoftware cu ajutorul cărora se crează atât baza de date cât şi \naplicaţiile prin care aceasta este exploatată. \n      Pentru utilizatorii sistemului de operare Windows cele mai \ncunoscute sisteme de acest fel sunt Access şi Visual FoxPro. \n 18\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 19\n\n1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20\n\n1.1.Sisteme de baze de date\nUn sistem de baze de date poate fi \nconsiderat ca având patru părţi: \n1. date\n2. utilizatori\n3. hardware \n4. software\n 21\n\n1.1.Sisteme de baze de date\nDatele: \nSunt informaţii pe care diferiţi utilizatori (firme, \nagenţii, sau simpli utilizatori) le colectează pentru a-şi \nîndeplini scopurile sau misiunile. \nDatele individuale sunt stocate în mulţimi de date \nrelaţionate (legate) numite înregistrări. \nO colecţie de înregistrări dependente se numeşte \nbază de date.\n 22\n\n1.1.Sisteme de baze de date\nUtilizatorii: \nDiferite persoane sau grupuri de \npersoane care folosesc informaţiile sunt\ndefinite ca utilizatori.\nHardware: De obicei noţiunea de \nhardware constă din device-uri fizice, cum \nar fi harddisk-uri, imprimante, interfeţe de \nintrare/ieşire şi procesorul de date cu\nmemoria sa asociată.\n 23', '\n', '6. ', 'Orice firmă utilizează baze de date pentru păstrarea \nşi gestionarea informaţiilor. Câteva astfel de aplicaţii sunt \nuzuale:\n1.bazele de date ale liniilor aeriene care sunt accesate \nsimultan din sute de agenţii pentru a realiza rezervări şi \nvânzări de locuri pentru date şi zboruri diferite\n2.bazele de date ale băncilor care permit realizarea a mii \nde tranzacţii zilnic\n3.bazele de date ale supermagazinelor care sunt accesate \natât de la casele de marcaj cât şi de la echipamentele de \ninventariere\n4.bazele de date ale bibliotecilor care păstrează milioane \nde titluri şi permit localizarea unei lucrări folosind diferite \ncriterii (cuvinte cheie, titlu, autori, domeniu)\n 17\n\nPentru realizarea unei aplicaţii care foloseşte baze de \ndate se poate proceda în două moduri:\na)Se creează baza de date cu ajutorul unei aplicaţii de tip server \nde baze de date şi se scriu apoi aplicaţiile care accesează baza \nde date într-un limbaj care posedă funcţiile necesare accesării \nserver-ului (frecvent se folosesc limbajele C++, Java, C# sau \nVisual Basic)\nb)Se foloseste o aplicaţie de tip sistem de gestiune de baze de \ndate (S.G.B.D. sau D.B.M.S. - DataBase Management System). \n      Un astfel de sistem oferă un ansamblu de instrumente \nsoftware cu ajutorul cărora se crează atât baza de date cât şi \naplicaţiile prin care aceasta este exploatată. \n      Pentru utilizatorii sistemului de operare Windows cele mai \ncunoscute sisteme de acest fel sunt Access şi Visual FoxPro. \n 18\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 19\n\n1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20\n\n1.1.Sisteme de baze de date\nUn sistem de baze de date poate fi \nconsiderat ca având patru părţi: \n1. date\n2. utilizatori\n3. hardware \n4. software\n 21\n\n1.1.Sisteme de baze de date\nDatele: \nSunt informaţii pe care diferiţi utilizatori (firme, \nagenţii, sau simpli utilizatori) le colectează pentru a-şi \nîndeplini scopurile sau misiunile. \nDatele individuale sunt stocate în mulţimi de date \nrelaţionate (legate) numite înregistrări. \nO colecţie de înregistrări dependente se numeşte \nbază de date.\n 22\n\n1.1.Sisteme de baze de date\nUtilizatorii: \nDiferite persoane sau grupuri de \npersoane care folosesc informaţiile sunt\ndefinite ca utilizatori.\nHardware: De obicei noţiunea de \nhardware constă din device-uri fizice, cum \nar fi harddisk-uri, imprimante, interfeţe de \nintrare/ieşire şi procesorul de date cu\nmemoria sa asociată.\n 23', '\n', '7. ', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 8\nLimbajul SQL \nCurs 8 - BAZE DE DATE 2\n\nLimbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3\n\nServerul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4\n\nTipuri de constrângeri\nCurs 8 - BAZE DE DATE 5\n\nGhidul Constrângerilor\n1. Toate constrângerile sunt cuprinse într-un dicţionar. \n2. Este uşor să se facă referinţă la constrângeri dacă li se \ndă nume sugestive. \n3. Numele unei constrângeri trebuie să urmeze un \nanumit standard. \n4. Dacă nu se denumeşte constrângerea, server-ul Oracle\ngenerează un nume de forma SYS_Cn, unde n este un \nnumăr întreg astfel încât numele constrângerii este \nunic.\n5. Constrângerile definite pentru o anumita tabela pot fi \nvizualizate în USER_CONSTRAINTS (dicţionarul tabelei).\nCurs 8 - BAZE DE DATE 6\n\nDefinirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7\n\nÎn sintaxa prezentată anterior avem:\nCurs 8 - BAZE DE DATE 8\n\nEXEMPLU - Adăugarea unei \nconstrângeri unei tabele odată cu \ncrearea lui.\nCREATE TABLE EMP1(\nempno number(6) NOT NULL,\nename varchar2(20),\nsal number(4),\nmgr number(4),\njob varchar2(20), \nPRIMARY KEY(empno));\nConstrângere \npentru tabela\nConstrângere \npentru coloană\nCurs 8 - BAZE DE DATE 9\n\n\n• De obicei constrângerile sunt create în acelaşi timp cu \ntabela.\n• Constrângerile pot fi adăugate tabelei după crearea ei.\n• Constrângerile pot fi definite pe 2 nivele: \nCurs 8 - BAZE DE DATE 10\n\nSintaxa:\n1. Constrângere la nivel de coloană\n2. Constrângere la nivel de tabela\nCurs 8 - BAZE DE DATE 11\n\n• In sintaxa avem:\nCurs 8 - BAZE DE DATE 12\n\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13\n\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14\n\nCREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15', '\n', '8. ', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 8\nLimbajul SQL \nCurs 8 - BAZE DE DATE 2\n\nLimbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3\n\nServerul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4\n\nTipuri de constrângeri\nCurs 8 - BAZE DE DATE 5\n\nGhidul Constrângerilor\n1. Toate constrângerile sunt cuprinse într-un dicţionar. \n2. Este uşor să se facă referinţă la constrângeri dacă li se \ndă nume sugestive. \n3. Numele unei constrângeri trebuie să urmeze un \nanumit standard. \n4. Dacă nu se denumeşte constrângerea, server-ul Oracle\ngenerează un nume de forma SYS_Cn, unde n este un \nnumăr întreg astfel încât numele constrângerii este \nunic.\n5. Constrângerile definite pentru o anumita tabela pot fi \nvizualizate în USER_CONSTRAINTS (dicţionarul tabelei).\nCurs 8 - BAZE DE DATE 6\n\nDefinirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7\n\nÎn sintaxa prezentată anterior avem:\nCurs 8 - BAZE DE DATE 8\n\nEXEMPLU - Adăugarea unei \nconstrângeri unei tabele odată cu \ncrearea lui.\nCREATE TABLE EMP1(\nempno number(6) NOT NULL,\nename varchar2(20),\nsal number(4),\nmgr number(4),\njob varchar2(20), \nPRIMARY KEY(empno));\nConstrângere \npentru tabela\nConstrângere \npentru coloană\nCurs 8 - BAZE DE DATE 9\n\n\n• De obicei constrângerile sunt create în acelaşi timp cu \ntabela.\n• Constrângerile pot fi adăugate tabelei după crearea ei.\n• Constrângerile pot fi definite pe 2 nivele: \nCurs 8 - BAZE DE DATE 10\n\nSintaxa:\n1. Constrângere la nivel de coloană\n2. Constrângere la nivel de tabela\nCurs 8 - BAZE DE DATE 11\n\n• In sintaxa avem:\nCurs 8 - BAZE DE DATE 12\n\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13\n\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14\n\nCREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15', '\n', '9. ', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 8\nLimbajul SQL \nCurs 8 - BAZE DE DATE 2\n\nLimbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3\n\nServerul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4\n\nTipuri de constrângeri\nCurs 8 - BAZE DE DATE 5\n\nGhidul Constrângerilor\n1. Toate constrângerile sunt cuprinse într-un dicţionar. \n2. Este uşor să se facă referinţă la constrângeri dacă li se \ndă nume sugestive. \n3. Numele unei constrângeri trebuie să urmeze un \nanumit standard. \n4. Dacă nu se denumeşte constrângerea, server-ul Oracle\ngenerează un nume de forma SYS_Cn, unde n este un \nnumăr întreg astfel încât numele constrângerii este \nunic.\n5. Constrângerile definite pentru o anumita tabela pot fi \nvizualizate în USER_CONSTRAINTS (dicţionarul tabelei).\nCurs 8 - BAZE DE DATE 6\n\nDefinirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7\n\nÎn sintaxa prezentată anterior avem:\nCurs 8 - BAZE DE DATE 8\n\nEXEMPLU - Adăugarea unei \nconstrângeri unei tabele odată cu \ncrearea lui.\nCREATE TABLE EMP1(\nempno number(6) NOT NULL,\nename varchar2(20),\nsal number(4),\nmgr number(4),\njob varchar2(20), \nPRIMARY KEY(empno));\nConstrângere \npentru tabela\nConstrângere \npentru coloană\nCurs 8 - BAZE DE DATE 9\n\n\n• De obicei constrângerile sunt create în acelaşi timp cu \ntabela.\n• Constrângerile pot fi adăugate tabelei după crearea ei.\n• Constrângerile pot fi definite pe 2 nivele: \nCurs 8 - BAZE DE DATE 10\n\nSintaxa:\n1. Constrângere la nivel de coloană\n2. Constrângere la nivel de tabela\nCurs 8 - BAZE DE DATE 11\n\n• In sintaxa avem:\nCurs 8 - BAZE DE DATE 12\n\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13\n\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14\n\nCREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15', '\n', '10. ', ""Curs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n\n2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n);"", '\n']","constrângerile sunt utilizate pentru a impune reguli datelor și pentru a preveni introducerea de date invalide. Ele pot fi definite la nivel de coloană sau tabelă și includ tipuri precum NOT NULL, UNIQUE, PRIMARY KEY, FOREIGN KEY și CHECK. Aceste constrângeri ajută la menținerea integrității datelor și la asigurarea securității prin limitarea acțiunilor care pot fi efectuate asupra datelor.
","Constrângerile (NOT NULL, FOREIGN KEY, CHECK) asigură „integritatea datelor”, iar vederile controlează accesul la informații sensibile. Împreună, ele permit „controlul accesului la obiecte specifice” și implementează politici stricte de securitate în mediul de baze de date.",0.33847826086279564,0.5,0.7966857006725592,0.7142857142857143,0.039602274881956834,0.21359223300970875,0.46
42,Manual - Test 1,,,1,Ce înseamnă SQL?,Structured Query Language,Este corect,,"['1. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '2. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '3. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '4. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '5. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '6. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '7. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '8. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '9. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '10. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n']","SQL este un limbaj pentru interogarea bazelor de date și include subinterogări (subqueries) care sunt instrucțiuni SELECT incluse în clauza unei alte instrucțiuni SELECT.
",Ce înseamnă SQL?,"['1. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '2. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '3. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '4. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '5. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '6. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '7. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '8. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '9. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '10. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n']","SQL este un limbaj pentru interogarea bazelor de date și include subinterogări (subqueries) care sunt instrucțiuni SELECT incluse în clauza unei alte instrucțiuni SELECT.
",Structured Query Language,0.0,0.0,0.8556368160691287,1.0,0.0,0.0,0.4
43,Manual - Test 1,,,2,Ce instrucțiune SQL se folosește pentru extragerea datelor dintr-o bază de date?,SELECT,Este corect,,"['1. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '2. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '3. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '4. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '5. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '6. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '7. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '8. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '9. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '10. ', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 8\nLimbajul SQL \nCurs 8 - BAZE DE DATE 2\n\nLimbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3\n\nServerul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4\n\nTipuri de constrângeri\nCurs 8 - BAZE DE DATE 5\n\nGhidul Constrângerilor\n1. Toate constrângerile sunt cuprinse într-un dicţionar. \n2. Este uşor să se facă referinţă la constrângeri dacă li se \ndă nume sugestive. \n3. Numele unei constrângeri trebuie să urmeze un \nanumit standard. \n4. Dacă nu se denumeşte constrângerea, server-ul Oracle\ngenerează un nume de forma SYS_Cn, unde n este un \nnumăr întreg astfel încât numele constrângerii este \nunic.\n5. Constrângerile definite pentru o anumita tabela pot fi \nvizualizate în USER_CONSTRAINTS (dicţionarul tabelei).\nCurs 8 - BAZE DE DATE 6\n\nDefinirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7\n\nÎn sintaxa prezentată anterior avem:\nCurs 8 - BAZE DE DATE 8\n\nEXEMPLU - Adăugarea unei \nconstrângeri unei tabele odată cu \ncrearea lui.\nCREATE TABLE EMP1(\nempno number(6) NOT NULL,\nename varchar2(20),\nsal number(4),\nmgr number(4),\njob varchar2(20), \nPRIMARY KEY(empno));\nConstrângere \npentru tabela\nConstrângere \npentru coloană\nCurs 8 - BAZE DE DATE 9\n\n\n• De obicei constrângerile sunt create în acelaşi timp cu \ntabela.\n• Constrângerile pot fi adăugate tabelei după crearea ei.\n• Constrângerile pot fi definite pe 2 nivele: \nCurs 8 - BAZE DE DATE 10\n\nSintaxa:\n1. Constrângere la nivel de coloană\n2. Constrângere la nivel de tabela\nCurs 8 - BAZE DE DATE 11\n\n• In sintaxa avem:\nCurs 8 - BAZE DE DATE 12\n\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13\n\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14\n\nCREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15', '\n']","o instrucțiune SELECT este folosită pentru extragerea datelor dintr-o bază de date. Aceasta poate fi inclusă în clauza unei alte instrucțiuni SELECT, formând o subinterogare.
",Ce instrucțiune SQL se folosește pentru extragerea datelor dintr-o bază de date?,"['1. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '2. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '3. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '4. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '5. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '6. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '7. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '8. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '9. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '10. ', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 8\nLimbajul SQL \nCurs 8 - BAZE DE DATE 2\n\nLimbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3\n\nServerul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4\n\nTipuri de constrângeri\nCurs 8 - BAZE DE DATE 5\n\nGhidul Constrângerilor\n1. Toate constrângerile sunt cuprinse într-un dicţionar. \n2. Este uşor să se facă referinţă la constrângeri dacă li se \ndă nume sugestive. \n3. Numele unei constrângeri trebuie să urmeze un \nanumit standard. \n4. Dacă nu se denumeşte constrângerea, server-ul Oracle\ngenerează un nume de forma SYS_Cn, unde n este un \nnumăr întreg astfel încât numele constrângerii este \nunic.\n5. Constrângerile definite pentru o anumita tabela pot fi \nvizualizate în USER_CONSTRAINTS (dicţionarul tabelei).\nCurs 8 - BAZE DE DATE 6\n\nDefinirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7\n\nÎn sintaxa prezentată anterior avem:\nCurs 8 - BAZE DE DATE 8\n\nEXEMPLU - Adăugarea unei \nconstrângeri unei tabele odată cu \ncrearea lui.\nCREATE TABLE EMP1(\nempno number(6) NOT NULL,\nename varchar2(20),\nsal number(4),\nmgr number(4),\njob varchar2(20), \nPRIMARY KEY(empno));\nConstrângere \npentru tabela\nConstrângere \npentru coloană\nCurs 8 - BAZE DE DATE 9\n\n\n• De obicei constrângerile sunt create în acelaşi timp cu \ntabela.\n• Constrângerile pot fi adăugate tabelei după crearea ei.\n• Constrângerile pot fi definite pe 2 nivele: \nCurs 8 - BAZE DE DATE 10\n\nSintaxa:\n1. Constrângere la nivel de coloană\n2. Constrângere la nivel de tabela\nCurs 8 - BAZE DE DATE 11\n\n• In sintaxa avem:\nCurs 8 - BAZE DE DATE 12\n\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13\n\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14\n\nCREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15', '\n']","o instrucțiune SELECT este folosită pentru extragerea datelor dintr-o bază de date. Aceasta poate fi inclusă în clauza unei alte instrucțiuni SELECT, formând o subinterogare.
",SELECT,0.22499999998875,1.0,0.8261847865992061,0.6666666666666666,0.033864985683445356,0.06666666666666667,0.0
44,Manual - Test 1,,,3,Ce instrucțiune SQL se folosește pentru actualizarea datelor dintr-o bază de date?,UPDATE,Este corect,,"['1. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '2. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '3. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '4. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '5. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '6. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '7. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n', '8. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n', '9. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n', '10. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n']","instrucțiunea SQL folosită pentru actualizarea datelor dintr-o bază de date este `UPDATE`. Sintaxa generală este:

```sql
UPDATE tabela
SET coloana = valoare [, coloana = valoare, ...]
[WHERE conditie];
```
unde *tabela* este numele tabelei, *coloana* este numele coloanei de actualizat si *valoare* reprezinta noua valoare si *conditie* selecteaza inregistrarile.
",Ce instrucțiune SQL se folosește pentru actualizarea datelor dintr-o bază de date?,"['1. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '2. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '3. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '4. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '5. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '6. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '7. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n', '8. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n', '9. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n', '10. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n']","instrucțiunea SQL folosită pentru actualizarea datelor dintr-o bază de date este `UPDATE`. Sintaxa generală este:

```sql
UPDATE tabela
SET coloana = valoare [, coloana = valoare, ...]
[WHERE conditie];
```
unde *tabela* este numele tabelei, *coloana* este numele coloanei de actualizat si *valoare* reprezinta noua valoare si *conditie* selecteaza inregistrarile.
",UPDATE,0.3205267558475007,1.0,0.8726657713162371,1.0,0.028398387225677894,0.04166666666666667,0.29
45,Manual - Test 1,,,4,Ce instrucțiune SQL se folosește pentru ștergerea datelor dintr-o bază de date?,DELETE,Este corect,,"['1. ', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 8\nLimbajul SQL \nCurs 8 - BAZE DE DATE 2\n\nLimbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3\n\nServerul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4\n\nTipuri de constrângeri\nCurs 8 - BAZE DE DATE 5\n\nGhidul Constrângerilor\n1. Toate constrângerile sunt cuprinse într-un dicţionar. \n2. Este uşor să se facă referinţă la constrângeri dacă li se \ndă nume sugestive. \n3. Numele unei constrângeri trebuie să urmeze un \nanumit standard. \n4. Dacă nu se denumeşte constrângerea, server-ul Oracle\ngenerează un nume de forma SYS_Cn, unde n este un \nnumăr întreg astfel încât numele constrângerii este \nunic.\n5. Constrângerile definite pentru o anumita tabela pot fi \nvizualizate în USER_CONSTRAINTS (dicţionarul tabelei).\nCurs 8 - BAZE DE DATE 6\n\nDefinirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7\n\nÎn sintaxa prezentată anterior avem:\nCurs 8 - BAZE DE DATE 8\n\nEXEMPLU - Adăugarea unei \nconstrângeri unei tabele odată cu \ncrearea lui.\nCREATE TABLE EMP1(\nempno number(6) NOT NULL,\nename varchar2(20),\nsal number(4),\nmgr number(4),\njob varchar2(20), \nPRIMARY KEY(empno));\nConstrângere \npentru tabela\nConstrângere \npentru coloană\nCurs 8 - BAZE DE DATE 9\n\n\n• De obicei constrângerile sunt create în acelaşi timp cu \ntabela.\n• Constrângerile pot fi adăugate tabelei după crearea ei.\n• Constrângerile pot fi definite pe 2 nivele: \nCurs 8 - BAZE DE DATE 10\n\nSintaxa:\n1. Constrângere la nivel de coloană\n2. Constrângere la nivel de tabela\nCurs 8 - BAZE DE DATE 11\n\n• In sintaxa avem:\nCurs 8 - BAZE DE DATE 12\n\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13\n\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14\n\nCREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15', '\n', '2. ', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 8\nLimbajul SQL \nCurs 8 - BAZE DE DATE 2\n\nLimbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3\n\nServerul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4\n\nTipuri de constrângeri\nCurs 8 - BAZE DE DATE 5\n\nGhidul Constrângerilor\n1. Toate constrângerile sunt cuprinse într-un dicţionar. \n2. Este uşor să se facă referinţă la constrângeri dacă li se \ndă nume sugestive. \n3. Numele unei constrângeri trebuie să urmeze un \nanumit standard. \n4. Dacă nu se denumeşte constrângerea, server-ul Oracle\ngenerează un nume de forma SYS_Cn, unde n este un \nnumăr întreg astfel încât numele constrângerii este \nunic.\n5. Constrângerile definite pentru o anumita tabela pot fi \nvizualizate în USER_CONSTRAINTS (dicţionarul tabelei).\nCurs 8 - BAZE DE DATE 6\n\nDefinirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7\n\nÎn sintaxa prezentată anterior avem:\nCurs 8 - BAZE DE DATE 8\n\nEXEMPLU - Adăugarea unei \nconstrângeri unei tabele odată cu \ncrearea lui.\nCREATE TABLE EMP1(\nempno number(6) NOT NULL,\nename varchar2(20),\nsal number(4),\nmgr number(4),\njob varchar2(20), \nPRIMARY KEY(empno));\nConstrângere \npentru tabela\nConstrângere \npentru coloană\nCurs 8 - BAZE DE DATE 9\n\n\n• De obicei constrângerile sunt create în acelaşi timp cu \ntabela.\n• Constrângerile pot fi adăugate tabelei după crearea ei.\n• Constrângerile pot fi definite pe 2 nivele: \nCurs 8 - BAZE DE DATE 10\n\nSintaxa:\n1. Constrângere la nivel de coloană\n2. Constrângere la nivel de tabela\nCurs 8 - BAZE DE DATE 11\n\n• In sintaxa avem:\nCurs 8 - BAZE DE DATE 12\n\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13\n\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14\n\nCREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15', '\n', '3. ', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 8\nLimbajul SQL \nCurs 8 - BAZE DE DATE 2\n\nLimbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3\n\nServerul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4\n\nTipuri de constrângeri\nCurs 8 - BAZE DE DATE 5\n\nGhidul Constrângerilor\n1. Toate constrângerile sunt cuprinse într-un dicţionar. \n2. Este uşor să se facă referinţă la constrângeri dacă li se \ndă nume sugestive. \n3. Numele unei constrângeri trebuie să urmeze un \nanumit standard. \n4. Dacă nu se denumeşte constrângerea, server-ul Oracle\ngenerează un nume de forma SYS_Cn, unde n este un \nnumăr întreg astfel încât numele constrângerii este \nunic.\n5. Constrângerile definite pentru o anumita tabela pot fi \nvizualizate în USER_CONSTRAINTS (dicţionarul tabelei).\nCurs 8 - BAZE DE DATE 6\n\nDefinirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7\n\nÎn sintaxa prezentată anterior avem:\nCurs 8 - BAZE DE DATE 8\n\nEXEMPLU - Adăugarea unei \nconstrângeri unei tabele odată cu \ncrearea lui.\nCREATE TABLE EMP1(\nempno number(6) NOT NULL,\nename varchar2(20),\nsal number(4),\nmgr number(4),\njob varchar2(20), \nPRIMARY KEY(empno));\nConstrângere \npentru tabela\nConstrângere \npentru coloană\nCurs 8 - BAZE DE DATE 9\n\n\n• De obicei constrângerile sunt create în acelaşi timp cu \ntabela.\n• Constrângerile pot fi adăugate tabelei după crearea ei.\n• Constrângerile pot fi definite pe 2 nivele: \nCurs 8 - BAZE DE DATE 10\n\nSintaxa:\n1. Constrângere la nivel de coloană\n2. Constrângere la nivel de tabela\nCurs 8 - BAZE DE DATE 11\n\n• In sintaxa avem:\nCurs 8 - BAZE DE DATE 12\n\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13\n\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14\n\nCREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15', '\n', '4. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '5. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '6. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '7. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '8. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '9. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '10. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n']","instrucțiunea SQL pentru ștergerea structurii bazei de date este DROP. Pentru ștergerea conținutului unei tabele se folosește TRUNCATE.
",Ce instrucțiune SQL se folosește pentru ștergerea datelor dintr-o bază de date?,"['1. ', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 8\nLimbajul SQL \nCurs 8 - BAZE DE DATE 2\n\nLimbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3\n\nServerul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4\n\nTipuri de constrângeri\nCurs 8 - BAZE DE DATE 5\n\nGhidul Constrângerilor\n1. Toate constrângerile sunt cuprinse într-un dicţionar. \n2. Este uşor să se facă referinţă la constrângeri dacă li se \ndă nume sugestive. \n3. Numele unei constrângeri trebuie să urmeze un \nanumit standard. \n4. Dacă nu se denumeşte constrângerea, server-ul Oracle\ngenerează un nume de forma SYS_Cn, unde n este un \nnumăr întreg astfel încât numele constrângerii este \nunic.\n5. Constrângerile definite pentru o anumita tabela pot fi \nvizualizate în USER_CONSTRAINTS (dicţionarul tabelei).\nCurs 8 - BAZE DE DATE 6\n\nDefinirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7\n\nÎn sintaxa prezentată anterior avem:\nCurs 8 - BAZE DE DATE 8\n\nEXEMPLU - Adăugarea unei \nconstrângeri unei tabele odată cu \ncrearea lui.\nCREATE TABLE EMP1(\nempno number(6) NOT NULL,\nename varchar2(20),\nsal number(4),\nmgr number(4),\njob varchar2(20), \nPRIMARY KEY(empno));\nConstrângere \npentru tabela\nConstrângere \npentru coloană\nCurs 8 - BAZE DE DATE 9\n\n\n• De obicei constrângerile sunt create în acelaşi timp cu \ntabela.\n• Constrângerile pot fi adăugate tabelei după crearea ei.\n• Constrângerile pot fi definite pe 2 nivele: \nCurs 8 - BAZE DE DATE 10\n\nSintaxa:\n1. Constrângere la nivel de coloană\n2. Constrângere la nivel de tabela\nCurs 8 - BAZE DE DATE 11\n\n• In sintaxa avem:\nCurs 8 - BAZE DE DATE 12\n\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13\n\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14\n\nCREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15', '\n', '2. ', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 8\nLimbajul SQL \nCurs 8 - BAZE DE DATE 2\n\nLimbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3\n\nServerul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4\n\nTipuri de constrângeri\nCurs 8 - BAZE DE DATE 5\n\nGhidul Constrângerilor\n1. Toate constrângerile sunt cuprinse într-un dicţionar. \n2. Este uşor să se facă referinţă la constrângeri dacă li se \ndă nume sugestive. \n3. Numele unei constrângeri trebuie să urmeze un \nanumit standard. \n4. Dacă nu se denumeşte constrângerea, server-ul Oracle\ngenerează un nume de forma SYS_Cn, unde n este un \nnumăr întreg astfel încât numele constrângerii este \nunic.\n5. Constrângerile definite pentru o anumita tabela pot fi \nvizualizate în USER_CONSTRAINTS (dicţionarul tabelei).\nCurs 8 - BAZE DE DATE 6\n\nDefinirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7\n\nÎn sintaxa prezentată anterior avem:\nCurs 8 - BAZE DE DATE 8\n\nEXEMPLU - Adăugarea unei \nconstrângeri unei tabele odată cu \ncrearea lui.\nCREATE TABLE EMP1(\nempno number(6) NOT NULL,\nename varchar2(20),\nsal number(4),\nmgr number(4),\njob varchar2(20), \nPRIMARY KEY(empno));\nConstrângere \npentru tabela\nConstrângere \npentru coloană\nCurs 8 - BAZE DE DATE 9\n\n\n• De obicei constrângerile sunt create în acelaşi timp cu \ntabela.\n• Constrângerile pot fi adăugate tabelei după crearea ei.\n• Constrângerile pot fi definite pe 2 nivele: \nCurs 8 - BAZE DE DATE 10\n\nSintaxa:\n1. Constrângere la nivel de coloană\n2. Constrângere la nivel de tabela\nCurs 8 - BAZE DE DATE 11\n\n• In sintaxa avem:\nCurs 8 - BAZE DE DATE 12\n\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13\n\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14\n\nCREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15', '\n', '3. ', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 8\nLimbajul SQL \nCurs 8 - BAZE DE DATE 2\n\nLimbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3\n\nServerul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4\n\nTipuri de constrângeri\nCurs 8 - BAZE DE DATE 5\n\nGhidul Constrângerilor\n1. Toate constrângerile sunt cuprinse într-un dicţionar. \n2. Este uşor să se facă referinţă la constrângeri dacă li se \ndă nume sugestive. \n3. Numele unei constrângeri trebuie să urmeze un \nanumit standard. \n4. Dacă nu se denumeşte constrângerea, server-ul Oracle\ngenerează un nume de forma SYS_Cn, unde n este un \nnumăr întreg astfel încât numele constrângerii este \nunic.\n5. Constrângerile definite pentru o anumita tabela pot fi \nvizualizate în USER_CONSTRAINTS (dicţionarul tabelei).\nCurs 8 - BAZE DE DATE 6\n\nDefinirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7\n\nÎn sintaxa prezentată anterior avem:\nCurs 8 - BAZE DE DATE 8\n\nEXEMPLU - Adăugarea unei \nconstrângeri unei tabele odată cu \ncrearea lui.\nCREATE TABLE EMP1(\nempno number(6) NOT NULL,\nename varchar2(20),\nsal number(4),\nmgr number(4),\njob varchar2(20), \nPRIMARY KEY(empno));\nConstrângere \npentru tabela\nConstrângere \npentru coloană\nCurs 8 - BAZE DE DATE 9\n\n\n• De obicei constrângerile sunt create în acelaşi timp cu \ntabela.\n• Constrângerile pot fi adăugate tabelei după crearea ei.\n• Constrângerile pot fi definite pe 2 nivele: \nCurs 8 - BAZE DE DATE 10\n\nSintaxa:\n1. Constrângere la nivel de coloană\n2. Constrângere la nivel de tabela\nCurs 8 - BAZE DE DATE 11\n\n• In sintaxa avem:\nCurs 8 - BAZE DE DATE 12\n\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13\n\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14\n\nCREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15', '\n', '4. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '5. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '6. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '7. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '8. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '9. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '10. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n']","instrucțiunea SQL pentru ștergerea structurii bazei de date este DROP. Pentru ștergerea conținutului unei tabele se folosește TRUNCATE.
",DELETE,0.0,0.0,0.8111681880200293,1.0,0.0,0.0,0.0
46,Manual - Test 1,,,5,Ce instrucțiune SQL se folosește pentru inserarea de date noi într-o bază de date?,INSERT INTO,Este corect,,"['1. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '2. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '3. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '4. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '5. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '6. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '7. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '8. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '9. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '10. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n']","instrucțiunea SQL folosită pentru inserarea de date noi într-o bază de date este:

```sql
INSERT INTO tabela [ ( coloana [ , coloana . . . ])] 
VALUES ( valoare [, valoare . . . ]);
```

unde:

*   `tabela` – numele tabelei
*   `coloana` – numele coloanei din tabela
*    `valoare` – valoarea corespunzătoare coloanei
",Ce instrucțiune SQL se folosește pentru inserarea de date noi într-o bază de date?,"['1. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '2. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '3. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '4. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '5. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '6. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '7. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '8. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '9. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '10. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n']","instrucțiunea SQL folosită pentru inserarea de date noi într-o bază de date este:

```sql
INSERT INTO tabela [ ( coloana [ , coloana . . . ])] 
VALUES ( valoare [, valoare . . . ]);
```

unde:

*   `tabela` – numele tabelei
*   `coloana` – numele coloanei din tabela
*    `valoare` – valoarea corespunzătoare coloanei
",INSERT INTO,0.4249999999858333,1.0,0.8736754204667041,1.0,0.02775638555723182,0.1,0.29
47,Manual - Test 1,,,6,"Folosind SQL, cum se selectează coloana ""FirstName"" din tabelul ""Persons"" ?",SELECT FirstName FROM Persons,Este corect,,"['1. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '2. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '3. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '4. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '5. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '6. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '7. ', ""3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43\n\n3. Sinonime\nPentru crearea sinonimelor este necesara o cerere SQL \ncare are urmatorul format:\nCurs - BAZE DE DATE 44\nCREATE [PUBLIC] SYNONYM nume_sinonim\nFOR nume_obiect;\nPUBLIC\nDefineste faptul ca acest sinonim este accesibil de catre toti \nutilizatorii. Daca nu este precizat atunci sinonimul este disponibil \ndoar pentru utilizatorul curent. Sinonimele publice pot fi create doar \nde catre utilizatorii care au drepturi administrative.\nnume_sinonim Numele sinonimului care va fi creat.\nnume_obiect Identifica obiectul pentru care se doreste crearea sinonimului \n\n3. Sinonime\n➢Daca dorim sa accesam o tabela pe care un alt utilizator \na creat-o in prealabil si careia ii dorim asignarea unui \nsinonim suntem obligati sa introducem inaintea numelui \ntabelei si numele utilizatorului care a creat tabela, in \nfata numelui tabelei, despartite de un punct.\nExemplu 1 - In acest exemplu vom incerca sa cream un \nsinonim pentru tabela departamente care are un nume \ndestul de lung.\nCREATE PUBLIC SYNONYM dep\nFOR dept;\nCurs - BAZE DE DATE 45\n\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46\n\n3. Sinonime\nExista unele restrictii in folosirea sinonimelor:\n➢obiectele respective nu pot sa fie continute intr-un \npachet.\n➢numele sinonimului privat trebuie sa fie unic in cadrul \ngrupului de obiecte pentru care acel user este \nproprietar.\nCurs - BAZE DE DATE 47\n\n3. Sinonime\n➢Un sinonim nu poate fi schimbat odata creat. \n➢El poate sa fie doar distrus. \n➢Distrugerea unui sinonim nu implica si distrugerea \nobiectului de care aliasul este atasat. \n➢Distrugerea unui sinonim este facuta folosind o \ninterogare SQL de tipul urmator:\nDROP [PUBLIC] SYNONYM nume_sinonim\nunde nume_sinonim este numele sinonimului care sa fie \ndistrus.\nCurs - BAZE DE DATE 48\n\n3. Sinonime\n➢Un sinonim de tip public poate sa fie sa fie distrus doar \nde catre un utilizator administrativ. \n➢Sinonimele private trebuie distruse de utilizatorul care \nle-a creat acestea nefiind disponibile in cadrul listei \nnumelor de obiecte a celorlalti utilizatori.\nCurs - BAZE DE DATE 49\n\nBibliografie\nFlorin Rădulescu: Oracle SQL, PL/SQL, Editura \nPrintech, ISBN 973-718-203-02005\nCurs - BAZE DE DATE 50\n\nÎntrebări?\nCurs - BAZE DE DATE 51"", '\n', '8. ', ""3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43\n\n3. Sinonime\nPentru crearea sinonimelor este necesara o cerere SQL \ncare are urmatorul format:\nCurs - BAZE DE DATE 44\nCREATE [PUBLIC] SYNONYM nume_sinonim\nFOR nume_obiect;\nPUBLIC\nDefineste faptul ca acest sinonim este accesibil de catre toti \nutilizatorii. Daca nu este precizat atunci sinonimul este disponibil \ndoar pentru utilizatorul curent. Sinonimele publice pot fi create doar \nde catre utilizatorii care au drepturi administrative.\nnume_sinonim Numele sinonimului care va fi creat.\nnume_obiect Identifica obiectul pentru care se doreste crearea sinonimului \n\n3. Sinonime\n➢Daca dorim sa accesam o tabela pe care un alt utilizator \na creat-o in prealabil si careia ii dorim asignarea unui \nsinonim suntem obligati sa introducem inaintea numelui \ntabelei si numele utilizatorului care a creat tabela, in \nfata numelui tabelei, despartite de un punct.\nExemplu 1 - In acest exemplu vom incerca sa cream un \nsinonim pentru tabela departamente care are un nume \ndestul de lung.\nCREATE PUBLIC SYNONYM dep\nFOR dept;\nCurs - BAZE DE DATE 45\n\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46\n\n3. Sinonime\nExista unele restrictii in folosirea sinonimelor:\n➢obiectele respective nu pot sa fie continute intr-un \npachet.\n➢numele sinonimului privat trebuie sa fie unic in cadrul \ngrupului de obiecte pentru care acel user este \nproprietar.\nCurs - BAZE DE DATE 47\n\n3. Sinonime\n➢Un sinonim nu poate fi schimbat odata creat. \n➢El poate sa fie doar distrus. \n➢Distrugerea unui sinonim nu implica si distrugerea \nobiectului de care aliasul este atasat. \n➢Distrugerea unui sinonim este facuta folosind o \ninterogare SQL de tipul urmator:\nDROP [PUBLIC] SYNONYM nume_sinonim\nunde nume_sinonim este numele sinonimului care sa fie \ndistrus.\nCurs - BAZE DE DATE 48\n\n3. Sinonime\n➢Un sinonim de tip public poate sa fie sa fie distrus doar \nde catre un utilizator administrativ. \n➢Sinonimele private trebuie distruse de utilizatorul care \nle-a creat acestea nefiind disponibile in cadrul listei \nnumelor de obiecte a celorlalti utilizatori.\nCurs - BAZE DE DATE 49\n\nBibliografie\nFlorin Rădulescu: Oracle SQL, PL/SQL, Editura \nPrintech, ISBN 973-718-203-02005\nCurs - BAZE DE DATE 50\n\nÎntrebări?\nCurs - BAZE DE DATE 51"", '\n', '9. ', ""3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43\n\n3. Sinonime\nPentru crearea sinonimelor este necesara o cerere SQL \ncare are urmatorul format:\nCurs - BAZE DE DATE 44\nCREATE [PUBLIC] SYNONYM nume_sinonim\nFOR nume_obiect;\nPUBLIC\nDefineste faptul ca acest sinonim este accesibil de catre toti \nutilizatorii. Daca nu este precizat atunci sinonimul este disponibil \ndoar pentru utilizatorul curent. Sinonimele publice pot fi create doar \nde catre utilizatorii care au drepturi administrative.\nnume_sinonim Numele sinonimului care va fi creat.\nnume_obiect Identifica obiectul pentru care se doreste crearea sinonimului \n\n3. Sinonime\n➢Daca dorim sa accesam o tabela pe care un alt utilizator \na creat-o in prealabil si careia ii dorim asignarea unui \nsinonim suntem obligati sa introducem inaintea numelui \ntabelei si numele utilizatorului care a creat tabela, in \nfata numelui tabelei, despartite de un punct.\nExemplu 1 - In acest exemplu vom incerca sa cream un \nsinonim pentru tabela departamente care are un nume \ndestul de lung.\nCREATE PUBLIC SYNONYM dep\nFOR dept;\nCurs - BAZE DE DATE 45\n\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46\n\n3. Sinonime\nExista unele restrictii in folosirea sinonimelor:\n➢obiectele respective nu pot sa fie continute intr-un \npachet.\n➢numele sinonimului privat trebuie sa fie unic in cadrul \ngrupului de obiecte pentru care acel user este \nproprietar.\nCurs - BAZE DE DATE 47\n\n3. Sinonime\n➢Un sinonim nu poate fi schimbat odata creat. \n➢El poate sa fie doar distrus. \n➢Distrugerea unui sinonim nu implica si distrugerea \nobiectului de care aliasul este atasat. \n➢Distrugerea unui sinonim este facuta folosind o \ninterogare SQL de tipul urmator:\nDROP [PUBLIC] SYNONYM nume_sinonim\nunde nume_sinonim este numele sinonimului care sa fie \ndistrus.\nCurs - BAZE DE DATE 48\n\n3. Sinonime\n➢Un sinonim de tip public poate sa fie sa fie distrus doar \nde catre un utilizator administrativ. \n➢Sinonimele private trebuie distruse de utilizatorul care \nle-a creat acestea nefiind disponibile in cadrul listei \nnumelor de obiecte a celorlalti utilizatori.\nCurs - BAZE DE DATE 49\n\nBibliografie\nFlorin Rădulescu: Oracle SQL, PL/SQL, Editura \nPrintech, ISBN 973-718-203-02005\nCurs - BAZE DE DATE 50\n\nÎntrebări?\nCurs - BAZE DE DATE 51"", '\n', '10. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n']","instructiunea SQL pentru a selecta coloana ""FirstName"" din tabelul ""Persons"" nu este dată explicit, dar formatul general pentru a selecta o coloană dintr-un tabel este:

```sql
SELECT nume_coloana
FROM nume_tabela;
```

Inlocuind `nume_coloana` cu ""FirstName"" și `nume_tabela` cu ""Persons"", instructiunea devine:

```sql
SELECT FirstName
FROM Persons;
```
Acest format se bazează pe sintaxa generală a comenzii SELECT prezentată in cursurile 3,4,5,6:

```sql
SELECT [DISTINCT] lista_de_expresii
FROM nume_tabela
WHERE conditie_linie
ORDER BY criterii_sortare_rezultat;
```
","Folosind SQL, cum se selectează coloana ""FirstName"" din tabelul ""Persons"" ?","['1. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '2. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '3. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '4. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '5. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '6. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '7. ', ""3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43\n\n3. Sinonime\nPentru crearea sinonimelor este necesara o cerere SQL \ncare are urmatorul format:\nCurs - BAZE DE DATE 44\nCREATE [PUBLIC] SYNONYM nume_sinonim\nFOR nume_obiect;\nPUBLIC\nDefineste faptul ca acest sinonim este accesibil de catre toti \nutilizatorii. Daca nu este precizat atunci sinonimul este disponibil \ndoar pentru utilizatorul curent. Sinonimele publice pot fi create doar \nde catre utilizatorii care au drepturi administrative.\nnume_sinonim Numele sinonimului care va fi creat.\nnume_obiect Identifica obiectul pentru care se doreste crearea sinonimului \n\n3. Sinonime\n➢Daca dorim sa accesam o tabela pe care un alt utilizator \na creat-o in prealabil si careia ii dorim asignarea unui \nsinonim suntem obligati sa introducem inaintea numelui \ntabelei si numele utilizatorului care a creat tabela, in \nfata numelui tabelei, despartite de un punct.\nExemplu 1 - In acest exemplu vom incerca sa cream un \nsinonim pentru tabela departamente care are un nume \ndestul de lung.\nCREATE PUBLIC SYNONYM dep\nFOR dept;\nCurs - BAZE DE DATE 45\n\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46\n\n3. Sinonime\nExista unele restrictii in folosirea sinonimelor:\n➢obiectele respective nu pot sa fie continute intr-un \npachet.\n➢numele sinonimului privat trebuie sa fie unic in cadrul \ngrupului de obiecte pentru care acel user este \nproprietar.\nCurs - BAZE DE DATE 47\n\n3. Sinonime\n➢Un sinonim nu poate fi schimbat odata creat. \n➢El poate sa fie doar distrus. \n➢Distrugerea unui sinonim nu implica si distrugerea \nobiectului de care aliasul este atasat. \n➢Distrugerea unui sinonim este facuta folosind o \ninterogare SQL de tipul urmator:\nDROP [PUBLIC] SYNONYM nume_sinonim\nunde nume_sinonim este numele sinonimului care sa fie \ndistrus.\nCurs - BAZE DE DATE 48\n\n3. Sinonime\n➢Un sinonim de tip public poate sa fie sa fie distrus doar \nde catre un utilizator administrativ. \n➢Sinonimele private trebuie distruse de utilizatorul care \nle-a creat acestea nefiind disponibile in cadrul listei \nnumelor de obiecte a celorlalti utilizatori.\nCurs - BAZE DE DATE 49\n\nBibliografie\nFlorin Rădulescu: Oracle SQL, PL/SQL, Editura \nPrintech, ISBN 973-718-203-02005\nCurs - BAZE DE DATE 50\n\nÎntrebări?\nCurs - BAZE DE DATE 51"", '\n', '8. ', ""3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43\n\n3. Sinonime\nPentru crearea sinonimelor este necesara o cerere SQL \ncare are urmatorul format:\nCurs - BAZE DE DATE 44\nCREATE [PUBLIC] SYNONYM nume_sinonim\nFOR nume_obiect;\nPUBLIC\nDefineste faptul ca acest sinonim este accesibil de catre toti \nutilizatorii. Daca nu este precizat atunci sinonimul este disponibil \ndoar pentru utilizatorul curent. Sinonimele publice pot fi create doar \nde catre utilizatorii care au drepturi administrative.\nnume_sinonim Numele sinonimului care va fi creat.\nnume_obiect Identifica obiectul pentru care se doreste crearea sinonimului \n\n3. Sinonime\n➢Daca dorim sa accesam o tabela pe care un alt utilizator \na creat-o in prealabil si careia ii dorim asignarea unui \nsinonim suntem obligati sa introducem inaintea numelui \ntabelei si numele utilizatorului care a creat tabela, in \nfata numelui tabelei, despartite de un punct.\nExemplu 1 - In acest exemplu vom incerca sa cream un \nsinonim pentru tabela departamente care are un nume \ndestul de lung.\nCREATE PUBLIC SYNONYM dep\nFOR dept;\nCurs - BAZE DE DATE 45\n\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46\n\n3. Sinonime\nExista unele restrictii in folosirea sinonimelor:\n➢obiectele respective nu pot sa fie continute intr-un \npachet.\n➢numele sinonimului privat trebuie sa fie unic in cadrul \ngrupului de obiecte pentru care acel user este \nproprietar.\nCurs - BAZE DE DATE 47\n\n3. Sinonime\n➢Un sinonim nu poate fi schimbat odata creat. \n➢El poate sa fie doar distrus. \n➢Distrugerea unui sinonim nu implica si distrugerea \nobiectului de care aliasul este atasat. \n➢Distrugerea unui sinonim este facuta folosind o \ninterogare SQL de tipul urmator:\nDROP [PUBLIC] SYNONYM nume_sinonim\nunde nume_sinonim este numele sinonimului care sa fie \ndistrus.\nCurs - BAZE DE DATE 48\n\n3. Sinonime\n➢Un sinonim de tip public poate sa fie sa fie distrus doar \nde catre un utilizator administrativ. \n➢Sinonimele private trebuie distruse de utilizatorul care \nle-a creat acestea nefiind disponibile in cadrul listei \nnumelor de obiecte a celorlalti utilizatori.\nCurs - BAZE DE DATE 49\n\nBibliografie\nFlorin Rădulescu: Oracle SQL, PL/SQL, Editura \nPrintech, ISBN 973-718-203-02005\nCurs - BAZE DE DATE 50\n\nÎntrebări?\nCurs - BAZE DE DATE 51"", '\n', '9. ', ""3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43\n\n3. Sinonime\nPentru crearea sinonimelor este necesara o cerere SQL \ncare are urmatorul format:\nCurs - BAZE DE DATE 44\nCREATE [PUBLIC] SYNONYM nume_sinonim\nFOR nume_obiect;\nPUBLIC\nDefineste faptul ca acest sinonim este accesibil de catre toti \nutilizatorii. Daca nu este precizat atunci sinonimul este disponibil \ndoar pentru utilizatorul curent. Sinonimele publice pot fi create doar \nde catre utilizatorii care au drepturi administrative.\nnume_sinonim Numele sinonimului care va fi creat.\nnume_obiect Identifica obiectul pentru care se doreste crearea sinonimului \n\n3. Sinonime\n➢Daca dorim sa accesam o tabela pe care un alt utilizator \na creat-o in prealabil si careia ii dorim asignarea unui \nsinonim suntem obligati sa introducem inaintea numelui \ntabelei si numele utilizatorului care a creat tabela, in \nfata numelui tabelei, despartite de un punct.\nExemplu 1 - In acest exemplu vom incerca sa cream un \nsinonim pentru tabela departamente care are un nume \ndestul de lung.\nCREATE PUBLIC SYNONYM dep\nFOR dept;\nCurs - BAZE DE DATE 45\n\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46\n\n3. Sinonime\nExista unele restrictii in folosirea sinonimelor:\n➢obiectele respective nu pot sa fie continute intr-un \npachet.\n➢numele sinonimului privat trebuie sa fie unic in cadrul \ngrupului de obiecte pentru care acel user este \nproprietar.\nCurs - BAZE DE DATE 47\n\n3. Sinonime\n➢Un sinonim nu poate fi schimbat odata creat. \n➢El poate sa fie doar distrus. \n➢Distrugerea unui sinonim nu implica si distrugerea \nobiectului de care aliasul este atasat. \n➢Distrugerea unui sinonim este facuta folosind o \ninterogare SQL de tipul urmator:\nDROP [PUBLIC] SYNONYM nume_sinonim\nunde nume_sinonim este numele sinonimului care sa fie \ndistrus.\nCurs - BAZE DE DATE 48\n\n3. Sinonime\n➢Un sinonim de tip public poate sa fie sa fie distrus doar \nde catre un utilizator administrativ. \n➢Sinonimele private trebuie distruse de utilizatorul care \nle-a creat acestea nefiind disponibile in cadrul listei \nnumelor de obiecte a celorlalti utilizatori.\nCurs - BAZE DE DATE 49\n\nBibliografie\nFlorin Rădulescu: Oracle SQL, PL/SQL, Editura \nPrintech, ISBN 973-718-203-02005\nCurs - BAZE DE DATE 50\n\nÎntrebări?\nCurs - BAZE DE DATE 51"", '\n', '10. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n']","instructiunea SQL pentru a selecta coloana ""FirstName"" din tabelul ""Persons"" nu este dată explicit, dar formatul general pentru a selecta o coloană dintr-un tabel este:

```sql
SELECT nume_coloana
FROM nume_tabela;
```

Inlocuind `nume_coloana` cu ""FirstName"" și `nume_tabela` cu ""Persons"", instructiunea devine:

```sql
SELECT FirstName
FROM Persons;
```
Acest format se bazează pe sintaxa generală a comenzii SELECT prezentată in cursurile 3,4,5,6:

```sql
SELECT [DISTINCT] lista_de_expresii
FROM nume_tabela
WHERE conditie_linie
ORDER BY criterii_sortare_rezultat;
```
",SELECT FirstName FROM Persons,0.13674560732928445,1.0,0.9070819955724351,1.0,0.017225273334851156,0.0909090909090909,0.33
48,Manual - Test 1,,,7,"Folosind SQL, cum se selectează toate coloanele din tabelul ""Persons""?",SELECT * FROM Persons,Este corect,,"['1. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '2. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '3. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '4. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '5. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '6. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '7. ', 'Curs 4\nLimbajul SQL\nCurs 4 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3\n\nTabela DUAL\nTabela generica DUAL se foloseste pentru a testa \nfunctii si pentru a evalua diferite expresii care nu \nnecesita preluarea datelor dintr-o tabela. \nAceastă tabela este una specială, care conţine o \nsingură coloană numită ”DUMMY” şi o singură linie. \nCurs 4 - BAZE DE DATE 4\n\n\nTabela DUAL\nPutem folosi tabela DUAL si atunci cand vrem sa realizăm \ndiverse calcule.\nExemplu:\nSELECT (12/3 + 10)\nFROM dual;\nCurs 4 - BAZE DE DATE 5\n\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări(linii)\n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 4 - BAZE DE DATE 6\n\nFuncţii referitoare la o singură înregistrare\nIn documentatia ORACLE puteti gasi \nfoarte multe funcţii care pot fi \nutilizate in expresii.\nLista completa a acestor functii este \nla:\nhttps://docs.oracle.com/cloud/help/r\no/analytics-cloud/ACUBI/GUID-\n4CBCE8D4-CF17-43BD-AAEF-\nC5D614A8040A.htm#BILUG779\nCurs 4 - BAZE DE DATE 7\n\n\nFuncţii\nFuncţiile se pot clasifica în două categorii:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 4 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. Funcţii pentru şiruri de caractere\n2. Funcţii de tip numeric\n3. Funcţii de tip dată calendaristică şi oră\n4. Funcţii de conversie dintr-un tip în altul\n5. Funcţii generale\n6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• Funcţii totalizatoare sau funcţii de grup\nCurs 4 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 4 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 4 - BAZE DE DATE 12\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13', '\n', '8. ', 'Curs 4\nLimbajul SQL\nCurs 4 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3\n\nTabela DUAL\nTabela generica DUAL se foloseste pentru a testa \nfunctii si pentru a evalua diferite expresii care nu \nnecesita preluarea datelor dintr-o tabela. \nAceastă tabela este una specială, care conţine o \nsingură coloană numită ”DUMMY” şi o singură linie. \nCurs 4 - BAZE DE DATE 4\n\n\nTabela DUAL\nPutem folosi tabela DUAL si atunci cand vrem sa realizăm \ndiverse calcule.\nExemplu:\nSELECT (12/3 + 10)\nFROM dual;\nCurs 4 - BAZE DE DATE 5\n\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări(linii)\n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 4 - BAZE DE DATE 6\n\nFuncţii referitoare la o singură înregistrare\nIn documentatia ORACLE puteti gasi \nfoarte multe funcţii care pot fi \nutilizate in expresii.\nLista completa a acestor functii este \nla:\nhttps://docs.oracle.com/cloud/help/r\no/analytics-cloud/ACUBI/GUID-\n4CBCE8D4-CF17-43BD-AAEF-\nC5D614A8040A.htm#BILUG779\nCurs 4 - BAZE DE DATE 7\n\n\nFuncţii\nFuncţiile se pot clasifica în două categorii:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 4 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. Funcţii pentru şiruri de caractere\n2. Funcţii de tip numeric\n3. Funcţii de tip dată calendaristică şi oră\n4. Funcţii de conversie dintr-un tip în altul\n5. Funcţii generale\n6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• Funcţii totalizatoare sau funcţii de grup\nCurs 4 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 4 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 4 - BAZE DE DATE 12\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13', '\n', '9. ', 'Curs 4\nLimbajul SQL\nCurs 4 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3\n\nTabela DUAL\nTabela generica DUAL se foloseste pentru a testa \nfunctii si pentru a evalua diferite expresii care nu \nnecesita preluarea datelor dintr-o tabela. \nAceastă tabela este una specială, care conţine o \nsingură coloană numită ”DUMMY” şi o singură linie. \nCurs 4 - BAZE DE DATE 4\n\n\nTabela DUAL\nPutem folosi tabela DUAL si atunci cand vrem sa realizăm \ndiverse calcule.\nExemplu:\nSELECT (12/3 + 10)\nFROM dual;\nCurs 4 - BAZE DE DATE 5\n\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări(linii)\n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 4 - BAZE DE DATE 6\n\nFuncţii referitoare la o singură înregistrare\nIn documentatia ORACLE puteti gasi \nfoarte multe funcţii care pot fi \nutilizate in expresii.\nLista completa a acestor functii este \nla:\nhttps://docs.oracle.com/cloud/help/r\no/analytics-cloud/ACUBI/GUID-\n4CBCE8D4-CF17-43BD-AAEF-\nC5D614A8040A.htm#BILUG779\nCurs 4 - BAZE DE DATE 7\n\n\nFuncţii\nFuncţiile se pot clasifica în două categorii:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 4 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. Funcţii pentru şiruri de caractere\n2. Funcţii de tip numeric\n3. Funcţii de tip dată calendaristică şi oră\n4. Funcţii de conversie dintr-un tip în altul\n5. Funcţii generale\n6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• Funcţii totalizatoare sau funcţii de grup\nCurs 4 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 4 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 4 - BAZE DE DATE 12\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13', '\n', '10. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n']","pentru a selecta toate coloanele din tabelul ""Persons"", poți folosi următoarea instrucțiune SQL, conform sintaxei `SELECT` prezentate:

```sql
SELECT *
FROM Persons;
```
`*` este utilizat pentru a selecta toate coloanele . `FROM` specifică tabela din care se face selecția, adica 'Persons'.
","Folosind SQL, cum se selectează toate coloanele din tabelul ""Persons""?","['1. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '2. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '3. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '4. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '5. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '6. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '7. ', 'Curs 4\nLimbajul SQL\nCurs 4 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3\n\nTabela DUAL\nTabela generica DUAL se foloseste pentru a testa \nfunctii si pentru a evalua diferite expresii care nu \nnecesita preluarea datelor dintr-o tabela. \nAceastă tabela este una specială, care conţine o \nsingură coloană numită ”DUMMY” şi o singură linie. \nCurs 4 - BAZE DE DATE 4\n\n\nTabela DUAL\nPutem folosi tabela DUAL si atunci cand vrem sa realizăm \ndiverse calcule.\nExemplu:\nSELECT (12/3 + 10)\nFROM dual;\nCurs 4 - BAZE DE DATE 5\n\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări(linii)\n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 4 - BAZE DE DATE 6\n\nFuncţii referitoare la o singură înregistrare\nIn documentatia ORACLE puteti gasi \nfoarte multe funcţii care pot fi \nutilizate in expresii.\nLista completa a acestor functii este \nla:\nhttps://docs.oracle.com/cloud/help/r\no/analytics-cloud/ACUBI/GUID-\n4CBCE8D4-CF17-43BD-AAEF-\nC5D614A8040A.htm#BILUG779\nCurs 4 - BAZE DE DATE 7\n\n\nFuncţii\nFuncţiile se pot clasifica în două categorii:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 4 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. Funcţii pentru şiruri de caractere\n2. Funcţii de tip numeric\n3. Funcţii de tip dată calendaristică şi oră\n4. Funcţii de conversie dintr-un tip în altul\n5. Funcţii generale\n6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• Funcţii totalizatoare sau funcţii de grup\nCurs 4 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 4 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 4 - BAZE DE DATE 12\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13', '\n', '8. ', 'Curs 4\nLimbajul SQL\nCurs 4 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3\n\nTabela DUAL\nTabela generica DUAL se foloseste pentru a testa \nfunctii si pentru a evalua diferite expresii care nu \nnecesita preluarea datelor dintr-o tabela. \nAceastă tabela este una specială, care conţine o \nsingură coloană numită ”DUMMY” şi o singură linie. \nCurs 4 - BAZE DE DATE 4\n\n\nTabela DUAL\nPutem folosi tabela DUAL si atunci cand vrem sa realizăm \ndiverse calcule.\nExemplu:\nSELECT (12/3 + 10)\nFROM dual;\nCurs 4 - BAZE DE DATE 5\n\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări(linii)\n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 4 - BAZE DE DATE 6\n\nFuncţii referitoare la o singură înregistrare\nIn documentatia ORACLE puteti gasi \nfoarte multe funcţii care pot fi \nutilizate in expresii.\nLista completa a acestor functii este \nla:\nhttps://docs.oracle.com/cloud/help/r\no/analytics-cloud/ACUBI/GUID-\n4CBCE8D4-CF17-43BD-AAEF-\nC5D614A8040A.htm#BILUG779\nCurs 4 - BAZE DE DATE 7\n\n\nFuncţii\nFuncţiile se pot clasifica în două categorii:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 4 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. Funcţii pentru şiruri de caractere\n2. Funcţii de tip numeric\n3. Funcţii de tip dată calendaristică şi oră\n4. Funcţii de conversie dintr-un tip în altul\n5. Funcţii generale\n6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• Funcţii totalizatoare sau funcţii de grup\nCurs 4 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 4 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 4 - BAZE DE DATE 12\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13', '\n', '9. ', 'Curs 4\nLimbajul SQL\nCurs 4 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3\n\nTabela DUAL\nTabela generica DUAL se foloseste pentru a testa \nfunctii si pentru a evalua diferite expresii care nu \nnecesita preluarea datelor dintr-o tabela. \nAceastă tabela este una specială, care conţine o \nsingură coloană numită ”DUMMY” şi o singură linie. \nCurs 4 - BAZE DE DATE 4\n\n\nTabela DUAL\nPutem folosi tabela DUAL si atunci cand vrem sa realizăm \ndiverse calcule.\nExemplu:\nSELECT (12/3 + 10)\nFROM dual;\nCurs 4 - BAZE DE DATE 5\n\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări(linii)\n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 4 - BAZE DE DATE 6\n\nFuncţii referitoare la o singură înregistrare\nIn documentatia ORACLE puteti gasi \nfoarte multe funcţii care pot fi \nutilizate in expresii.\nLista completa a acestor functii este \nla:\nhttps://docs.oracle.com/cloud/help/r\no/analytics-cloud/ACUBI/GUID-\n4CBCE8D4-CF17-43BD-AAEF-\nC5D614A8040A.htm#BILUG779\nCurs 4 - BAZE DE DATE 7\n\n\nFuncţii\nFuncţiile se pot clasifica în două categorii:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 4 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. Funcţii pentru şiruri de caractere\n2. Funcţii de tip numeric\n3. Funcţii de tip dată calendaristică şi oră\n4. Funcţii de conversie dintr-un tip în altul\n5. Funcţii generale\n6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• Funcţii totalizatoare sau funcţii de grup\nCurs 4 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 4 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 4 - BAZE DE DATE 12\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13', '\n', '10. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n']","pentru a selecta toate coloanele din tabelul ""Persons"", poți folosi următoarea instrucțiune SQL, conform sintaxei `SELECT` prezentate:

```sql
SELECT *
FROM Persons;
```
`*` este utilizat pentru a selecta toate coloanele . `FROM` specifică tabela din care se face selecția, adica 'Persons'.
",SELECT * FROM Persons,0.4249999999858333,1.0,0.9158855643232187,0.0,0.049754222162988714,0.13333333333333333,1.0
49,Manual - Test 1,,,8,"Folosind SQL, cum se selectează toate înregistrările din tabelul ""Persons"" unde valoarea coloanei ""FirstName"" este ""Peter""?",SELECT * FROM Persons WHERE FirstName='Peter',Este corect,,"['1. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '2. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '3. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '4. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '5. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '6. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '7. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '8. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '9. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '10. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n']","```sql
SELECT *
FROM Persons
WHERE FirstName = 'Peter';
```
","Folosind SQL, cum se selectează toate înregistrările din tabelul ""Persons"" unde valoarea coloanei ""FirstName"" este ""Peter""?","['1. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '2. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '3. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '4. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '5. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '6. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '7. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '8. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '9. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '10. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n']","```sql
SELECT *
FROM Persons
WHERE FirstName = 'Peter';
```
",SELECT * FROM Persons WHERE FirstName='Peter',0.08411371237177816,0.0,0.9066067147206214,0.0,0.4428500142691474,0.923076923076923,1.0
50,Manual - Test 1,,,9,"Folosind SQL, cum selectezi toate înregistrările dintr-un tabel numit ""Persons"" unde valoarea coloanei ""FirstName"" începe cu litera ""a""?",SELECT * FROM Persons WHERE FirstName LIKE 'a%',Este corect,,"['1. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '2. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '3. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '4. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '5. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '6. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '7. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '8. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '9. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '10. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n']","```sql
SELECT *
FROM Persons
WHERE FirstName LIKE 'a%';
```
","Folosind SQL, cum selectezi toate înregistrările dintr-un tabel numit ""Persons"" unde valoarea coloanei ""FirstName"" începe cu litera ""a""?","['1. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '2. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '3. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '4. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '5. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '6. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '7. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '8. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '9. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '10. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n']","```sql
SELECT *
FROM Persons
WHERE FirstName LIKE 'a%';
```
",SELECT * FROM Persons WHERE FirstName LIKE 'a%',0.0,0.0,0.8966614372811237,0.0,0.5118285025257893,0.9333333333333333,1.0
51,Manual - Test 1,,,10,Operatorul OR afișează o înregistrare dacă oricare condiție este adevărată; operatorul AND afișează o înregistrare doar dacă toate condițiile sunt adevărate.,Adevărat,Este corect,,"['1. ', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13\n\nFuncţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 15\n\nFuncţii referitoare la o singură înregistrare\n4.2.1. Funcţii pentru şiruri de caractere \nAceste funcţii au ca argumente date de tip \ncaracter şi returnează date de tip VARCHAR2, \nCHAR sau NUMBER.\nCurs 4 - BAZE DE DATE 16\n\n4.2.1. Funcţii pentru şiruri de caractere\nCele mai importante funcţii caracter sunt:\nFunctie Descriere  \nLOWER(column|expression) converteste alfa caracterele din caractere mari in \ncaractere mici  \nUPPER(column|expression) converteste alfa caracterele din caractere mici in \ncaractere mari  \nINITCAP(column|expression) \nconverteste prima litera a fiecarui cuvant in \ncaractere mari si restul cuvantului in caractere \nmici  \nCONCAT(column1|expression1, \ncolumn2|expression2) \nfunctia este echivalentul operatorului de \nconcantenare (||)  \nSUBSTR(column|expression, m [, n]) returneaza un sir de n caractere incepand cu \ncaracterul aflat pe pozitia m  \nLENGTH(column|expression) returneaza numarul de caractere dintr-o expresie  \nINSTR(column|expression, \'string\', \n[m], [n]) \nreturneaza pozitia unui anumit sir, optional se \npoate incepe cautarea cu pozitia m sau cu a n-a \naparitie a sirului. m si n sunt prin definitie 1  \nREPLACE(text, search_string, \nreplacement_ string) \ncauta un anumit text intr-un sir de caractere si \ndaca il gaseste il inlocuieste  \n \nCurs 4 - BAZE DE DATE 17\n\nExemplu de utilizare a \nfuncţiei LENGTH:\nSELECT LENGTH(ename) \nFROM EMP; \nCurs 4 - BAZE DE DATE 18\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu de utilizare a funcţiei LENGTH – rezultatul \nobtinut: \nCurs 4 - BAZE DE DATE 19\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT \'Numele functiei pentru \'||UPPER(ename)||\'este \n\'||LOWER(job) AS ""DETALII ANGAJAT""\nFROM EMP; \nCurs 4 - BAZE DE DATE 20\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = \'MARTIN\';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere', '\n', '2. ', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13\n\nFuncţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 15\n\nFuncţii referitoare la o singură înregistrare\n4.2.1. Funcţii pentru şiruri de caractere \nAceste funcţii au ca argumente date de tip \ncaracter şi returnează date de tip VARCHAR2, \nCHAR sau NUMBER.\nCurs 4 - BAZE DE DATE 16\n\n4.2.1. Funcţii pentru şiruri de caractere\nCele mai importante funcţii caracter sunt:\nFunctie Descriere  \nLOWER(column|expression) converteste alfa caracterele din caractere mari in \ncaractere mici  \nUPPER(column|expression) converteste alfa caracterele din caractere mici in \ncaractere mari  \nINITCAP(column|expression) \nconverteste prima litera a fiecarui cuvant in \ncaractere mari si restul cuvantului in caractere \nmici  \nCONCAT(column1|expression1, \ncolumn2|expression2) \nfunctia este echivalentul operatorului de \nconcantenare (||)  \nSUBSTR(column|expression, m [, n]) returneaza un sir de n caractere incepand cu \ncaracterul aflat pe pozitia m  \nLENGTH(column|expression) returneaza numarul de caractere dintr-o expresie  \nINSTR(column|expression, \'string\', \n[m], [n]) \nreturneaza pozitia unui anumit sir, optional se \npoate incepe cautarea cu pozitia m sau cu a n-a \naparitie a sirului. m si n sunt prin definitie 1  \nREPLACE(text, search_string, \nreplacement_ string) \ncauta un anumit text intr-un sir de caractere si \ndaca il gaseste il inlocuieste  \n \nCurs 4 - BAZE DE DATE 17\n\nExemplu de utilizare a \nfuncţiei LENGTH:\nSELECT LENGTH(ename) \nFROM EMP; \nCurs 4 - BAZE DE DATE 18\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu de utilizare a funcţiei LENGTH – rezultatul \nobtinut: \nCurs 4 - BAZE DE DATE 19\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT \'Numele functiei pentru \'||UPPER(ename)||\'este \n\'||LOWER(job) AS ""DETALII ANGAJAT""\nFROM EMP; \nCurs 4 - BAZE DE DATE 20\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = \'MARTIN\';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere', '\n', '3. ', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13\n\nFuncţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 15\n\nFuncţii referitoare la o singură înregistrare\n4.2.1. Funcţii pentru şiruri de caractere \nAceste funcţii au ca argumente date de tip \ncaracter şi returnează date de tip VARCHAR2, \nCHAR sau NUMBER.\nCurs 4 - BAZE DE DATE 16\n\n4.2.1. Funcţii pentru şiruri de caractere\nCele mai importante funcţii caracter sunt:\nFunctie Descriere  \nLOWER(column|expression) converteste alfa caracterele din caractere mari in \ncaractere mici  \nUPPER(column|expression) converteste alfa caracterele din caractere mici in \ncaractere mari  \nINITCAP(column|expression) \nconverteste prima litera a fiecarui cuvant in \ncaractere mari si restul cuvantului in caractere \nmici  \nCONCAT(column1|expression1, \ncolumn2|expression2) \nfunctia este echivalentul operatorului de \nconcantenare (||)  \nSUBSTR(column|expression, m [, n]) returneaza un sir de n caractere incepand cu \ncaracterul aflat pe pozitia m  \nLENGTH(column|expression) returneaza numarul de caractere dintr-o expresie  \nINSTR(column|expression, \'string\', \n[m], [n]) \nreturneaza pozitia unui anumit sir, optional se \npoate incepe cautarea cu pozitia m sau cu a n-a \naparitie a sirului. m si n sunt prin definitie 1  \nREPLACE(text, search_string, \nreplacement_ string) \ncauta un anumit text intr-un sir de caractere si \ndaca il gaseste il inlocuieste  \n \nCurs 4 - BAZE DE DATE 17\n\nExemplu de utilizare a \nfuncţiei LENGTH:\nSELECT LENGTH(ename) \nFROM EMP; \nCurs 4 - BAZE DE DATE 18\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu de utilizare a funcţiei LENGTH – rezultatul \nobtinut: \nCurs 4 - BAZE DE DATE 19\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT \'Numele functiei pentru \'||UPPER(ename)||\'este \n\'||LOWER(job) AS ""DETALII ANGAJAT""\nFROM EMP; \nCurs 4 - BAZE DE DATE 20\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = \'MARTIN\';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere', '\n', '4. ', '4.3.2. Excluderea grupurilor \n(clauza HAVING)\nRezultatul obtinut - Salariul total pe fiecare funcţie, fără a lua în \ncalcul MANAGERII, excluzând funcţiile cu suma salariilor sub \n6000$ cu ordonare după total.\nCurs 5 - BAZE DE DATE 47\n\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48\n\nOrdinea de executie a functiilor de \ngrup\n Serverul Oracle execută funcţiile de grup într-o \nanumită ordine:\n1. Selecţia rândurilor ce respectă clauza WHERE \n2. Gruparea rândurilor obţinute, respectând clauza \nGROUP BY \n3. Calcularea rezultatelor funcţiilor de grup pentru \nfiecare grup în parte \n4. Eliminarea grupurilor ce nu respectă clauza HAVING \n5. Ordonarea rezultatelor respectând clauza GROUP BY.\nCurs 5 - BAZE DE DATE 49\n\nOrdinea de executie a functiilor de \ngrup\n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei. \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează. \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă. \nCurs 5 - BAZE DE DATE 50\n\n4.3.3. Imbricarea functiilor de grup\nFuncţiile de grup pot fi imbricate cu o adâncime de 2.\nExemplul 14 \nSalariul mediu maxim. \nSELECT MAX(AVG(sal))\nFROM EMP\nGROUP BY deptno;\nCurs 5 - BAZE DE DATE 51\n\n4.3.3. Imbricarea functiilor de grup\nFuncţiile de grup pot fi imbricate cu o adâncime de 2.\nRezultatul obtinut - Salariul mediu maxim. \nCurs 5 - BAZE DE DATE 52\n\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm \n3) https://www.w3resource.com/sql-exercises/ \nCurs 5 - BAZE DE DATE 53\n\nÎntrebări?\nCurs 5 - BAZE DE DATE 54', '\n', '5. ', '4.3.2. Excluderea grupurilor \n(clauza HAVING)\nRezultatul obtinut - Salariul total pe fiecare funcţie, fără a lua în \ncalcul MANAGERII, excluzând funcţiile cu suma salariilor sub \n6000$ cu ordonare după total.\nCurs 5 - BAZE DE DATE 47\n\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48\n\nOrdinea de executie a functiilor de \ngrup\n Serverul Oracle execută funcţiile de grup într-o \nanumită ordine:\n1. Selecţia rândurilor ce respectă clauza WHERE \n2. Gruparea rândurilor obţinute, respectând clauza \nGROUP BY \n3. Calcularea rezultatelor funcţiilor de grup pentru \nfiecare grup în parte \n4. Eliminarea grupurilor ce nu respectă clauza HAVING \n5. Ordonarea rezultatelor respectând clauza GROUP BY.\nCurs 5 - BAZE DE DATE 49\n\nOrdinea de executie a functiilor de \ngrup\n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei. \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează. \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă. \nCurs 5 - BAZE DE DATE 50\n\n4.3.3. Imbricarea functiilor de grup\nFuncţiile de grup pot fi imbricate cu o adâncime de 2.\nExemplul 14 \nSalariul mediu maxim. \nSELECT MAX(AVG(sal))\nFROM EMP\nGROUP BY deptno;\nCurs 5 - BAZE DE DATE 51\n\n4.3.3. Imbricarea functiilor de grup\nFuncţiile de grup pot fi imbricate cu o adâncime de 2.\nRezultatul obtinut - Salariul mediu maxim. \nCurs 5 - BAZE DE DATE 52\n\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm \n3) https://www.w3resource.com/sql-exercises/ \nCurs 5 - BAZE DE DATE 53\n\nÎntrebări?\nCurs 5 - BAZE DE DATE 54', '\n', '6. ', '4.3.2. Excluderea grupurilor \n(clauza HAVING)\nRezultatul obtinut - Salariul total pe fiecare funcţie, fără a lua în \ncalcul MANAGERII, excluzând funcţiile cu suma salariilor sub \n6000$ cu ordonare după total.\nCurs 5 - BAZE DE DATE 47\n\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48\n\nOrdinea de executie a functiilor de \ngrup\n Serverul Oracle execută funcţiile de grup într-o \nanumită ordine:\n1. Selecţia rândurilor ce respectă clauza WHERE \n2. Gruparea rândurilor obţinute, respectând clauza \nGROUP BY \n3. Calcularea rezultatelor funcţiilor de grup pentru \nfiecare grup în parte \n4. Eliminarea grupurilor ce nu respectă clauza HAVING \n5. Ordonarea rezultatelor respectând clauza GROUP BY.\nCurs 5 - BAZE DE DATE 49\n\nOrdinea de executie a functiilor de \ngrup\n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei. \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează. \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă. \nCurs 5 - BAZE DE DATE 50\n\n4.3.3. Imbricarea functiilor de grup\nFuncţiile de grup pot fi imbricate cu o adâncime de 2.\nExemplul 14 \nSalariul mediu maxim. \nSELECT MAX(AVG(sal))\nFROM EMP\nGROUP BY deptno;\nCurs 5 - BAZE DE DATE 51\n\n4.3.3. Imbricarea functiilor de grup\nFuncţiile de grup pot fi imbricate cu o adâncime de 2.\nRezultatul obtinut - Salariul mediu maxim. \nCurs 5 - BAZE DE DATE 52\n\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm \n3) https://www.w3resource.com/sql-exercises/ \nCurs 5 - BAZE DE DATE 53\n\nÎntrebări?\nCurs 5 - BAZE DE DATE 54', '\n', '7. ', '6.2. MULTIPLE ROW SUBQUERIES\nVALORI NULL\n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci:\n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null.\n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic.\nCurs 6 - BAZE DE DATE 35\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi HAVING\n- Pot fi folosite cu subinterogările de tip multiple row.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) < ANY\n          ( SELECT sal\n             FROM EMP\n             WHERE deptno IN (10,20) );\nCurs 6 - BAZE DE DATE 36\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi \nHAVING\n- Pot fi folosite cu \nsubinterogările de tip \nmultiple row.\nCurs 6 - BAZE DE DATE 37\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\n  De asemenea, se poate folosi clauza GROUP BY intr-\no subinterogare\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > ALL\n    (SELECT MIN(sal)\n     FROM EMP\n     WHERE deptno < 40\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 38\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare\nCurs 6 - BAZE DE DATE 39\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi angajaţii ale căror salarii sunt \naceleaşi cu salariul minim din oricare (any) \ndepartament. \nSELECT ename\nFROM EMP\nWHERE sal = ANY\n    (SELECT MIN(sal)\n     FROM EMP\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 40\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi \nangajaţii ale căror salarii \nsunt aceleaşi cu (any) \ndepartament. salariul \nminim din oricare \nCurs 6 - BAZE DE DATE 41\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42\n\n6.2. MULTIPLE ROW SUBQUERIES\nSoluţia corectă este următoarea:\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) <\n  ( SELECT MIN(sal)\n    FROM EMP\n    WHERE deptno = 30);\nCurs 6 - BAZE DE DATE 43\n\nSubcereri multilinie \n• Subcererile multilinie returneaza mai mult decat o \nlinie. \n• Cu astfel de subinterogari trebuie folositi operatori \nmultilinie care pot prelucra una sau mai multe valori. \nOperatorii utilizati sunt: \n1. IN - egal cu oricare dintre membrii unei liste\n2. ANY/SOME - compara o valoare cu fiecare (vreo) \nvaloare returnata de subinterogare\n3. ALL - compara o valoare cu oricare (toate) din \nvalorile returnate de subinterogare\nCurs 6 - BAZE DE DATE 44', '\n', '8. ', '6.2. MULTIPLE ROW SUBQUERIES\nVALORI NULL\n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci:\n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null.\n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic.\nCurs 6 - BAZE DE DATE 35\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi HAVING\n- Pot fi folosite cu subinterogările de tip multiple row.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) < ANY\n          ( SELECT sal\n             FROM EMP\n             WHERE deptno IN (10,20) );\nCurs 6 - BAZE DE DATE 36\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi \nHAVING\n- Pot fi folosite cu \nsubinterogările de tip \nmultiple row.\nCurs 6 - BAZE DE DATE 37\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\n  De asemenea, se poate folosi clauza GROUP BY intr-\no subinterogare\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > ALL\n    (SELECT MIN(sal)\n     FROM EMP\n     WHERE deptno < 40\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 38\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare\nCurs 6 - BAZE DE DATE 39\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi angajaţii ale căror salarii sunt \naceleaşi cu salariul minim din oricare (any) \ndepartament. \nSELECT ename\nFROM EMP\nWHERE sal = ANY\n    (SELECT MIN(sal)\n     FROM EMP\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 40\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi \nangajaţii ale căror salarii \nsunt aceleaşi cu (any) \ndepartament. salariul \nminim din oricare \nCurs 6 - BAZE DE DATE 41\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42\n\n6.2. MULTIPLE ROW SUBQUERIES\nSoluţia corectă este următoarea:\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) <\n  ( SELECT MIN(sal)\n    FROM EMP\n    WHERE deptno = 30);\nCurs 6 - BAZE DE DATE 43\n\nSubcereri multilinie \n• Subcererile multilinie returneaza mai mult decat o \nlinie. \n• Cu astfel de subinterogari trebuie folositi operatori \nmultilinie care pot prelucra una sau mai multe valori. \nOperatorii utilizati sunt: \n1. IN - egal cu oricare dintre membrii unei liste\n2. ANY/SOME - compara o valoare cu fiecare (vreo) \nvaloare returnata de subinterogare\n3. ALL - compara o valoare cu oricare (toate) din \nvalorile returnate de subinterogare\nCurs 6 - BAZE DE DATE 44', '\n', '9. ', '6.2. MULTIPLE ROW SUBQUERIES\nVALORI NULL\n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci:\n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null.\n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic.\nCurs 6 - BAZE DE DATE 35\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi HAVING\n- Pot fi folosite cu subinterogările de tip multiple row.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) < ANY\n          ( SELECT sal\n             FROM EMP\n             WHERE deptno IN (10,20) );\nCurs 6 - BAZE DE DATE 36\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi \nHAVING\n- Pot fi folosite cu \nsubinterogările de tip \nmultiple row.\nCurs 6 - BAZE DE DATE 37\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\n  De asemenea, se poate folosi clauza GROUP BY intr-\no subinterogare\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > ALL\n    (SELECT MIN(sal)\n     FROM EMP\n     WHERE deptno < 40\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 38\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare\nCurs 6 - BAZE DE DATE 39\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi angajaţii ale căror salarii sunt \naceleaşi cu salariul minim din oricare (any) \ndepartament. \nSELECT ename\nFROM EMP\nWHERE sal = ANY\n    (SELECT MIN(sal)\n     FROM EMP\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 40\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi \nangajaţii ale căror salarii \nsunt aceleaşi cu (any) \ndepartament. salariul \nminim din oricare \nCurs 6 - BAZE DE DATE 41\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42\n\n6.2. MULTIPLE ROW SUBQUERIES\nSoluţia corectă este următoarea:\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) <\n  ( SELECT MIN(sal)\n    FROM EMP\n    WHERE deptno = 30);\nCurs 6 - BAZE DE DATE 43\n\nSubcereri multilinie \n• Subcererile multilinie returneaza mai mult decat o \nlinie. \n• Cu astfel de subinterogari trebuie folositi operatori \nmultilinie care pot prelucra una sau mai multe valori. \nOperatorii utilizati sunt: \n1. IN - egal cu oricare dintre membrii unei liste\n2. ANY/SOME - compara o valoare cu fiecare (vreo) \nvaloare returnata de subinterogare\n3. ALL - compara o valoare cu oricare (toate) din \nvalorile returnate de subinterogare\nCurs 6 - BAZE DE DATE 44', '\n', '10. ', 'Exista unele restrictii in cazul alterarii unei secvente deja existe. \nAcestea sunt:\n1. Userul care executa actiunea de alterare trebuie sa aiba \ndrepturile necesare sau sa fie proprietarul secventei.\n2. Numai numerele care vor fi generate in viitor vor fi afectate.\n3. Secventa va trebui distrusa si recreata pentru ca valoarea de \ninceput sa poata fi modificata\n4. Anumite validari logice de genul ca valoarea maxima nou \nsetata trebuie sa nu fie mai mica decat valoarea care exista \ndeja, trebuie indeplinite.\nCurs - BAZE DE DATE 22\n\nStergerea secventelor\n• Stergerea unei secvente se poate efectua cu ajutorul \nurmatoarei cereri SQL:\nDROP SEQUENCE nume_secventa\n• unde nume_secventa este numele secventei care se \ndoreste distrusa. \nCurs - BAZE DE DATE 23\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 24\n\n2. Indecșii\n➢Indecsii sunt niste obiecte de tip schema care \nimbunatatesc timpul de cautare si acces la \ninregistrarile din baza de date. \n➢Indecsii sunt creati in mod explicit sau automat \nin anumite conditii.\nCurs - BAZE DE DATE 25\n\nDe ce folosim indecsii?\n➢Indecsii ofera o metode de acces direct catre \ninregistrarile care se doresc extrase.\n➢Scopul lor este de a diminua operatile de intrare/iesire \ncatre disc prin folosirea unei metode de indexare a \ncailor catre acele date. \n➢Indecsii sunt utilizati si mentinuti de catre serverul \nOracle in mod transparent pentru utilizator care nu \nimplica nici o alta actiune ulterioara.\nCurs - BAZE DE DATE 26\n\n2. Indecșii\n➢Modul in care indecsii sunt conceputi ii fac \nindependent fizic si logic de baza de date ceea ce se \nexprima prin faptul ca ei pot sa fie creati sau distrusi \nin orice moment fara a afecta structura bazei de date \nsau asupra celorlalti indecsi. \n➢De asemenea din partea de management transparent \nface parte si faptul ca daca o baza de date este \ndistrusa atunci si indecsii care au fost creati pentru ea \nsunt de asemenea distrusi.\nCurs - BAZE DE DATE 27\n\nCrearea indecșilor \nIndecsii sunt creati in doua feluri:\n1. Automat: In momentul in care se creaza o cheie \nprimara asupra tabelelor, in momentul in care se creaza \no restrictie ca inregistrarile din baza de date sa fie unice \nsi in alte situatii asemanatoare.\n2. Manual: Se pot defini indecsi manuali care nu trebuie \nsa contina o restrictie cum este cazul indecsilor unici.\nCurs - BAZE DE DATE 28\n\n• Indecsii sunt creati folosind urmatoarea cerere SQL la \nbaza de date:\n• unde numele_index este numele pe care il are \nindexul, numele_tabelei este numele tabelei din baza \nde date pentru a carei campuri indexul va fi creat si \ncamp1, camp2... sunt numele campurilor din tabela \npentru care se creaza acest index. \n• Un index poate fi creat pentru una sau mai multe \ncoloane din aceeasi tabela.\nCREATE INDEX numele_index\nON numele_tabelei (camp1[, camp2].... )\nCurs - BAZE DE DATE 29', '\n']","Subcererile multilinie folosesc operatorii: IN, ANY/SOME, ALL.
",Operatorul OR afișează o înregistrare dacă oricare condiție este adevărată; operatorul AND afișează o înregistrare doar dacă toate condițiile sunt adevărate.,"['1. ', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13\n\nFuncţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 15\n\nFuncţii referitoare la o singură înregistrare\n4.2.1. Funcţii pentru şiruri de caractere \nAceste funcţii au ca argumente date de tip \ncaracter şi returnează date de tip VARCHAR2, \nCHAR sau NUMBER.\nCurs 4 - BAZE DE DATE 16\n\n4.2.1. Funcţii pentru şiruri de caractere\nCele mai importante funcţii caracter sunt:\nFunctie Descriere  \nLOWER(column|expression) converteste alfa caracterele din caractere mari in \ncaractere mici  \nUPPER(column|expression) converteste alfa caracterele din caractere mici in \ncaractere mari  \nINITCAP(column|expression) \nconverteste prima litera a fiecarui cuvant in \ncaractere mari si restul cuvantului in caractere \nmici  \nCONCAT(column1|expression1, \ncolumn2|expression2) \nfunctia este echivalentul operatorului de \nconcantenare (||)  \nSUBSTR(column|expression, m [, n]) returneaza un sir de n caractere incepand cu \ncaracterul aflat pe pozitia m  \nLENGTH(column|expression) returneaza numarul de caractere dintr-o expresie  \nINSTR(column|expression, \'string\', \n[m], [n]) \nreturneaza pozitia unui anumit sir, optional se \npoate incepe cautarea cu pozitia m sau cu a n-a \naparitie a sirului. m si n sunt prin definitie 1  \nREPLACE(text, search_string, \nreplacement_ string) \ncauta un anumit text intr-un sir de caractere si \ndaca il gaseste il inlocuieste  \n \nCurs 4 - BAZE DE DATE 17\n\nExemplu de utilizare a \nfuncţiei LENGTH:\nSELECT LENGTH(ename) \nFROM EMP; \nCurs 4 - BAZE DE DATE 18\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu de utilizare a funcţiei LENGTH – rezultatul \nobtinut: \nCurs 4 - BAZE DE DATE 19\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT \'Numele functiei pentru \'||UPPER(ename)||\'este \n\'||LOWER(job) AS ""DETALII ANGAJAT""\nFROM EMP; \nCurs 4 - BAZE DE DATE 20\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = \'MARTIN\';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere', '\n', '2. ', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13\n\nFuncţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 15\n\nFuncţii referitoare la o singură înregistrare\n4.2.1. Funcţii pentru şiruri de caractere \nAceste funcţii au ca argumente date de tip \ncaracter şi returnează date de tip VARCHAR2, \nCHAR sau NUMBER.\nCurs 4 - BAZE DE DATE 16\n\n4.2.1. Funcţii pentru şiruri de caractere\nCele mai importante funcţii caracter sunt:\nFunctie Descriere  \nLOWER(column|expression) converteste alfa caracterele din caractere mari in \ncaractere mici  \nUPPER(column|expression) converteste alfa caracterele din caractere mici in \ncaractere mari  \nINITCAP(column|expression) \nconverteste prima litera a fiecarui cuvant in \ncaractere mari si restul cuvantului in caractere \nmici  \nCONCAT(column1|expression1, \ncolumn2|expression2) \nfunctia este echivalentul operatorului de \nconcantenare (||)  \nSUBSTR(column|expression, m [, n]) returneaza un sir de n caractere incepand cu \ncaracterul aflat pe pozitia m  \nLENGTH(column|expression) returneaza numarul de caractere dintr-o expresie  \nINSTR(column|expression, \'string\', \n[m], [n]) \nreturneaza pozitia unui anumit sir, optional se \npoate incepe cautarea cu pozitia m sau cu a n-a \naparitie a sirului. m si n sunt prin definitie 1  \nREPLACE(text, search_string, \nreplacement_ string) \ncauta un anumit text intr-un sir de caractere si \ndaca il gaseste il inlocuieste  \n \nCurs 4 - BAZE DE DATE 17\n\nExemplu de utilizare a \nfuncţiei LENGTH:\nSELECT LENGTH(ename) \nFROM EMP; \nCurs 4 - BAZE DE DATE 18\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu de utilizare a funcţiei LENGTH – rezultatul \nobtinut: \nCurs 4 - BAZE DE DATE 19\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT \'Numele functiei pentru \'||UPPER(ename)||\'este \n\'||LOWER(job) AS ""DETALII ANGAJAT""\nFROM EMP; \nCurs 4 - BAZE DE DATE 20\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = \'MARTIN\';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere', '\n', '3. ', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13\n\nFuncţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 15\n\nFuncţii referitoare la o singură înregistrare\n4.2.1. Funcţii pentru şiruri de caractere \nAceste funcţii au ca argumente date de tip \ncaracter şi returnează date de tip VARCHAR2, \nCHAR sau NUMBER.\nCurs 4 - BAZE DE DATE 16\n\n4.2.1. Funcţii pentru şiruri de caractere\nCele mai importante funcţii caracter sunt:\nFunctie Descriere  \nLOWER(column|expression) converteste alfa caracterele din caractere mari in \ncaractere mici  \nUPPER(column|expression) converteste alfa caracterele din caractere mici in \ncaractere mari  \nINITCAP(column|expression) \nconverteste prima litera a fiecarui cuvant in \ncaractere mari si restul cuvantului in caractere \nmici  \nCONCAT(column1|expression1, \ncolumn2|expression2) \nfunctia este echivalentul operatorului de \nconcantenare (||)  \nSUBSTR(column|expression, m [, n]) returneaza un sir de n caractere incepand cu \ncaracterul aflat pe pozitia m  \nLENGTH(column|expression) returneaza numarul de caractere dintr-o expresie  \nINSTR(column|expression, \'string\', \n[m], [n]) \nreturneaza pozitia unui anumit sir, optional se \npoate incepe cautarea cu pozitia m sau cu a n-a \naparitie a sirului. m si n sunt prin definitie 1  \nREPLACE(text, search_string, \nreplacement_ string) \ncauta un anumit text intr-un sir de caractere si \ndaca il gaseste il inlocuieste  \n \nCurs 4 - BAZE DE DATE 17\n\nExemplu de utilizare a \nfuncţiei LENGTH:\nSELECT LENGTH(ename) \nFROM EMP; \nCurs 4 - BAZE DE DATE 18\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu de utilizare a funcţiei LENGTH – rezultatul \nobtinut: \nCurs 4 - BAZE DE DATE 19\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT \'Numele functiei pentru \'||UPPER(ename)||\'este \n\'||LOWER(job) AS ""DETALII ANGAJAT""\nFROM EMP; \nCurs 4 - BAZE DE DATE 20\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = \'MARTIN\';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere', '\n', '4. ', '4.3.2. Excluderea grupurilor \n(clauza HAVING)\nRezultatul obtinut - Salariul total pe fiecare funcţie, fără a lua în \ncalcul MANAGERII, excluzând funcţiile cu suma salariilor sub \n6000$ cu ordonare după total.\nCurs 5 - BAZE DE DATE 47\n\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48\n\nOrdinea de executie a functiilor de \ngrup\n Serverul Oracle execută funcţiile de grup într-o \nanumită ordine:\n1. Selecţia rândurilor ce respectă clauza WHERE \n2. Gruparea rândurilor obţinute, respectând clauza \nGROUP BY \n3. Calcularea rezultatelor funcţiilor de grup pentru \nfiecare grup în parte \n4. Eliminarea grupurilor ce nu respectă clauza HAVING \n5. Ordonarea rezultatelor respectând clauza GROUP BY.\nCurs 5 - BAZE DE DATE 49\n\nOrdinea de executie a functiilor de \ngrup\n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei. \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează. \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă. \nCurs 5 - BAZE DE DATE 50\n\n4.3.3. Imbricarea functiilor de grup\nFuncţiile de grup pot fi imbricate cu o adâncime de 2.\nExemplul 14 \nSalariul mediu maxim. \nSELECT MAX(AVG(sal))\nFROM EMP\nGROUP BY deptno;\nCurs 5 - BAZE DE DATE 51\n\n4.3.3. Imbricarea functiilor de grup\nFuncţiile de grup pot fi imbricate cu o adâncime de 2.\nRezultatul obtinut - Salariul mediu maxim. \nCurs 5 - BAZE DE DATE 52\n\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm \n3) https://www.w3resource.com/sql-exercises/ \nCurs 5 - BAZE DE DATE 53\n\nÎntrebări?\nCurs 5 - BAZE DE DATE 54', '\n', '5. ', '4.3.2. Excluderea grupurilor \n(clauza HAVING)\nRezultatul obtinut - Salariul total pe fiecare funcţie, fără a lua în \ncalcul MANAGERII, excluzând funcţiile cu suma salariilor sub \n6000$ cu ordonare după total.\nCurs 5 - BAZE DE DATE 47\n\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48\n\nOrdinea de executie a functiilor de \ngrup\n Serverul Oracle execută funcţiile de grup într-o \nanumită ordine:\n1. Selecţia rândurilor ce respectă clauza WHERE \n2. Gruparea rândurilor obţinute, respectând clauza \nGROUP BY \n3. Calcularea rezultatelor funcţiilor de grup pentru \nfiecare grup în parte \n4. Eliminarea grupurilor ce nu respectă clauza HAVING \n5. Ordonarea rezultatelor respectând clauza GROUP BY.\nCurs 5 - BAZE DE DATE 49\n\nOrdinea de executie a functiilor de \ngrup\n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei. \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează. \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă. \nCurs 5 - BAZE DE DATE 50\n\n4.3.3. Imbricarea functiilor de grup\nFuncţiile de grup pot fi imbricate cu o adâncime de 2.\nExemplul 14 \nSalariul mediu maxim. \nSELECT MAX(AVG(sal))\nFROM EMP\nGROUP BY deptno;\nCurs 5 - BAZE DE DATE 51\n\n4.3.3. Imbricarea functiilor de grup\nFuncţiile de grup pot fi imbricate cu o adâncime de 2.\nRezultatul obtinut - Salariul mediu maxim. \nCurs 5 - BAZE DE DATE 52\n\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm \n3) https://www.w3resource.com/sql-exercises/ \nCurs 5 - BAZE DE DATE 53\n\nÎntrebări?\nCurs 5 - BAZE DE DATE 54', '\n', '6. ', '4.3.2. Excluderea grupurilor \n(clauza HAVING)\nRezultatul obtinut - Salariul total pe fiecare funcţie, fără a lua în \ncalcul MANAGERII, excluzând funcţiile cu suma salariilor sub \n6000$ cu ordonare după total.\nCurs 5 - BAZE DE DATE 47\n\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48\n\nOrdinea de executie a functiilor de \ngrup\n Serverul Oracle execută funcţiile de grup într-o \nanumită ordine:\n1. Selecţia rândurilor ce respectă clauza WHERE \n2. Gruparea rândurilor obţinute, respectând clauza \nGROUP BY \n3. Calcularea rezultatelor funcţiilor de grup pentru \nfiecare grup în parte \n4. Eliminarea grupurilor ce nu respectă clauza HAVING \n5. Ordonarea rezultatelor respectând clauza GROUP BY.\nCurs 5 - BAZE DE DATE 49\n\nOrdinea de executie a functiilor de \ngrup\n• Ordinea de execuţie are o importanţă foarte mare, \ndeoarece are un impact direct asupra vitezei. \n• Cu cât mai multe înregistrări pot fi eliminate utilizând \nclauza WHERE, cu atât mai puţin va dura gruparea şi \noperaţiile ce urmează. \n• Dacă o cerere SQL este concepută să elimine \nînregistrări/grupuri doar folosind clauza HAVING, \natunci ar fi bine de încercat dacă este posibil şi prin \nclauza WHERE. De obicei, totuşi, această rescriere nu \nva fi posibilă. \nCurs 5 - BAZE DE DATE 50\n\n4.3.3. Imbricarea functiilor de grup\nFuncţiile de grup pot fi imbricate cu o adâncime de 2.\nExemplul 14 \nSalariul mediu maxim. \nSELECT MAX(AVG(sal))\nFROM EMP\nGROUP BY deptno;\nCurs 5 - BAZE DE DATE 51\n\n4.3.3. Imbricarea functiilor de grup\nFuncţiile de grup pot fi imbricate cu o adâncime de 2.\nRezultatul obtinut - Salariul mediu maxim. \nCurs 5 - BAZE DE DATE 52\n\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm \n3) https://www.w3resource.com/sql-exercises/ \nCurs 5 - BAZE DE DATE 53\n\nÎntrebări?\nCurs 5 - BAZE DE DATE 54', '\n', '7. ', '6.2. MULTIPLE ROW SUBQUERIES\nVALORI NULL\n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci:\n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null.\n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic.\nCurs 6 - BAZE DE DATE 35\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi HAVING\n- Pot fi folosite cu subinterogările de tip multiple row.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) < ANY\n          ( SELECT sal\n             FROM EMP\n             WHERE deptno IN (10,20) );\nCurs 6 - BAZE DE DATE 36\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi \nHAVING\n- Pot fi folosite cu \nsubinterogările de tip \nmultiple row.\nCurs 6 - BAZE DE DATE 37\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\n  De asemenea, se poate folosi clauza GROUP BY intr-\no subinterogare\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > ALL\n    (SELECT MIN(sal)\n     FROM EMP\n     WHERE deptno < 40\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 38\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare\nCurs 6 - BAZE DE DATE 39\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi angajaţii ale căror salarii sunt \naceleaşi cu salariul minim din oricare (any) \ndepartament. \nSELECT ename\nFROM EMP\nWHERE sal = ANY\n    (SELECT MIN(sal)\n     FROM EMP\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 40\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi \nangajaţii ale căror salarii \nsunt aceleaşi cu (any) \ndepartament. salariul \nminim din oricare \nCurs 6 - BAZE DE DATE 41\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42\n\n6.2. MULTIPLE ROW SUBQUERIES\nSoluţia corectă este următoarea:\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) <\n  ( SELECT MIN(sal)\n    FROM EMP\n    WHERE deptno = 30);\nCurs 6 - BAZE DE DATE 43\n\nSubcereri multilinie \n• Subcererile multilinie returneaza mai mult decat o \nlinie. \n• Cu astfel de subinterogari trebuie folositi operatori \nmultilinie care pot prelucra una sau mai multe valori. \nOperatorii utilizati sunt: \n1. IN - egal cu oricare dintre membrii unei liste\n2. ANY/SOME - compara o valoare cu fiecare (vreo) \nvaloare returnata de subinterogare\n3. ALL - compara o valoare cu oricare (toate) din \nvalorile returnate de subinterogare\nCurs 6 - BAZE DE DATE 44', '\n', '8. ', '6.2. MULTIPLE ROW SUBQUERIES\nVALORI NULL\n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci:\n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null.\n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic.\nCurs 6 - BAZE DE DATE 35\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi HAVING\n- Pot fi folosite cu subinterogările de tip multiple row.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) < ANY\n          ( SELECT sal\n             FROM EMP\n             WHERE deptno IN (10,20) );\nCurs 6 - BAZE DE DATE 36\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi \nHAVING\n- Pot fi folosite cu \nsubinterogările de tip \nmultiple row.\nCurs 6 - BAZE DE DATE 37\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\n  De asemenea, se poate folosi clauza GROUP BY intr-\no subinterogare\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > ALL\n    (SELECT MIN(sal)\n     FROM EMP\n     WHERE deptno < 40\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 38\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare\nCurs 6 - BAZE DE DATE 39\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi angajaţii ale căror salarii sunt \naceleaşi cu salariul minim din oricare (any) \ndepartament. \nSELECT ename\nFROM EMP\nWHERE sal = ANY\n    (SELECT MIN(sal)\n     FROM EMP\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 40\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi \nangajaţii ale căror salarii \nsunt aceleaşi cu (any) \ndepartament. salariul \nminim din oricare \nCurs 6 - BAZE DE DATE 41\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42\n\n6.2. MULTIPLE ROW SUBQUERIES\nSoluţia corectă este următoarea:\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) <\n  ( SELECT MIN(sal)\n    FROM EMP\n    WHERE deptno = 30);\nCurs 6 - BAZE DE DATE 43\n\nSubcereri multilinie \n• Subcererile multilinie returneaza mai mult decat o \nlinie. \n• Cu astfel de subinterogari trebuie folositi operatori \nmultilinie care pot prelucra una sau mai multe valori. \nOperatorii utilizati sunt: \n1. IN - egal cu oricare dintre membrii unei liste\n2. ANY/SOME - compara o valoare cu fiecare (vreo) \nvaloare returnata de subinterogare\n3. ALL - compara o valoare cu oricare (toate) din \nvalorile returnate de subinterogare\nCurs 6 - BAZE DE DATE 44', '\n', '9. ', '6.2. MULTIPLE ROW SUBQUERIES\nVALORI NULL\n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci:\n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null.\n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic.\nCurs 6 - BAZE DE DATE 35\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi HAVING\n- Pot fi folosite cu subinterogările de tip multiple row.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) < ANY\n          ( SELECT sal\n             FROM EMP\n             WHERE deptno IN (10,20) );\nCurs 6 - BAZE DE DATE 36\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi \nHAVING\n- Pot fi folosite cu \nsubinterogările de tip \nmultiple row.\nCurs 6 - BAZE DE DATE 37\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\n  De asemenea, se poate folosi clauza GROUP BY intr-\no subinterogare\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > ALL\n    (SELECT MIN(sal)\n     FROM EMP\n     WHERE deptno < 40\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 38\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare\nCurs 6 - BAZE DE DATE 39\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi angajaţii ale căror salarii sunt \naceleaşi cu salariul minim din oricare (any) \ndepartament. \nSELECT ename\nFROM EMP\nWHERE sal = ANY\n    (SELECT MIN(sal)\n     FROM EMP\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 40\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi \nangajaţii ale căror salarii \nsunt aceleaşi cu (any) \ndepartament. salariul \nminim din oricare \nCurs 6 - BAZE DE DATE 41\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42\n\n6.2. MULTIPLE ROW SUBQUERIES\nSoluţia corectă este următoarea:\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) <\n  ( SELECT MIN(sal)\n    FROM EMP\n    WHERE deptno = 30);\nCurs 6 - BAZE DE DATE 43\n\nSubcereri multilinie \n• Subcererile multilinie returneaza mai mult decat o \nlinie. \n• Cu astfel de subinterogari trebuie folositi operatori \nmultilinie care pot prelucra una sau mai multe valori. \nOperatorii utilizati sunt: \n1. IN - egal cu oricare dintre membrii unei liste\n2. ANY/SOME - compara o valoare cu fiecare (vreo) \nvaloare returnata de subinterogare\n3. ALL - compara o valoare cu oricare (toate) din \nvalorile returnate de subinterogare\nCurs 6 - BAZE DE DATE 44', '\n', '10. ', 'Exista unele restrictii in cazul alterarii unei secvente deja existe. \nAcestea sunt:\n1. Userul care executa actiunea de alterare trebuie sa aiba \ndrepturile necesare sau sa fie proprietarul secventei.\n2. Numai numerele care vor fi generate in viitor vor fi afectate.\n3. Secventa va trebui distrusa si recreata pentru ca valoarea de \ninceput sa poata fi modificata\n4. Anumite validari logice de genul ca valoarea maxima nou \nsetata trebuie sa nu fie mai mica decat valoarea care exista \ndeja, trebuie indeplinite.\nCurs - BAZE DE DATE 22\n\nStergerea secventelor\n• Stergerea unei secvente se poate efectua cu ajutorul \nurmatoarei cereri SQL:\nDROP SEQUENCE nume_secventa\n• unde nume_secventa este numele secventei care se \ndoreste distrusa. \nCurs - BAZE DE DATE 23\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 24\n\n2. Indecșii\n➢Indecsii sunt niste obiecte de tip schema care \nimbunatatesc timpul de cautare si acces la \ninregistrarile din baza de date. \n➢Indecsii sunt creati in mod explicit sau automat \nin anumite conditii.\nCurs - BAZE DE DATE 25\n\nDe ce folosim indecsii?\n➢Indecsii ofera o metode de acces direct catre \ninregistrarile care se doresc extrase.\n➢Scopul lor este de a diminua operatile de intrare/iesire \ncatre disc prin folosirea unei metode de indexare a \ncailor catre acele date. \n➢Indecsii sunt utilizati si mentinuti de catre serverul \nOracle in mod transparent pentru utilizator care nu \nimplica nici o alta actiune ulterioara.\nCurs - BAZE DE DATE 26\n\n2. Indecșii\n➢Modul in care indecsii sunt conceputi ii fac \nindependent fizic si logic de baza de date ceea ce se \nexprima prin faptul ca ei pot sa fie creati sau distrusi \nin orice moment fara a afecta structura bazei de date \nsau asupra celorlalti indecsi. \n➢De asemenea din partea de management transparent \nface parte si faptul ca daca o baza de date este \ndistrusa atunci si indecsii care au fost creati pentru ea \nsunt de asemenea distrusi.\nCurs - BAZE DE DATE 27\n\nCrearea indecșilor \nIndecsii sunt creati in doua feluri:\n1. Automat: In momentul in care se creaza o cheie \nprimara asupra tabelelor, in momentul in care se creaza \no restrictie ca inregistrarile din baza de date sa fie unice \nsi in alte situatii asemanatoare.\n2. Manual: Se pot defini indecsi manuali care nu trebuie \nsa contina o restrictie cum este cazul indecsilor unici.\nCurs - BAZE DE DATE 28\n\n• Indecsii sunt creati folosind urmatoarea cerere SQL la \nbaza de date:\n• unde numele_index este numele pe care il are \nindexul, numele_tabelei este numele tabelei din baza \nde date pentru a carei campuri indexul va fi creat si \ncamp1, camp2... sunt numele campurilor din tabela \npentru care se creaza acest index. \n• Un index poate fi creat pentru una sau mai multe \ncoloane din aceeasi tabela.\nCREATE INDEX numele_index\nON numele_tabelei (camp1[, camp2].... )\nCurs - BAZE DE DATE 29', '\n']","Subcererile multilinie folosesc operatorii: IN, ANY/SOME, ALL.
",Adevărat,0.0,0.0,0.7379693226973179,0.0,0.0,0.0,0.0
52,Manual - Test 1,,,11,"Folosind SQL, cum selectezi toate înregistrările dintr-un tabel numit ""Persons"" unde valoarea coloanei ""FirstName"" este ""Peter"" și valoarea coloanei ""LastName"" este ""Jackson""?",SELECT * FROM Persons WHERE FirstName='Peter' AND LastName='Jackson',Este corect,,"['1. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '2. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '3. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '4. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '5. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '6. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '7. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '8. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '9. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '10. ', 'Clauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii al căror nume \nîncepe cu litera S. \n 54\n\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au numele de 4 caractere.\nSELECT ename\nFROM EMP\nWHERE ename LIKE \'____\';\n 55\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nnumele de 4 caractere.\n 56\n\n\nClauza WHERE\nExemplu \nListeaza toţi angajaţii care al doilea caracter din nume \n\'O\'. \nSELECT ename, job, hiredate\nFROM EMP\nWHERE ename LIKE \'_O%\';\n 57\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toţi angajaţii care al doilea \ncaracter din nume \'O\'. \n 58\n\n\nClauza WHERE\nESCAPE - când sunt căutate chiar caracterele % sau _. Acesta \nspecifică caracterul care este ""sărit"". \n ESCAPE identifică \'\\\' drept caracterul care trebuie ""sărit"".\n  El precede caracterul \'_\' astfel încât acesta va fi \nconsiderat drept literal.\nSintaxa: \nSELECT coloana\nFROM tabela\nWHERE coloana LIKE \'%sa\\_%\' ESCAPE \'\\\';\n 59\n\nClauza WHERE\n4. Conditia IS NULL \n  Pentru a verifica valorile de tip NULL există condiţia IS \nNULL sau negarea acesteia IS NOT NULL. \nO valoare nulă este o valoare care este sau incorectă, sau \nnecunoscută, sau inaplicabilă de aceea nu poate fi testată cu \n""="". \nO valoare nulă nu este la fel cu ""zero"" care este un \nnumăr.\nDacă valoarea NULL este utilizată într-o comparaţie, \natunci operatorul de comparaţie trebuie să fie IS NULL sau IS \nNOT NULL altfel rezultatul este întotdeauna FALSE. \n 60\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care nu au comision. \nSELECT *\nFROM EMP\nWHERE comm IS NULL;\n 61\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care nu au \ncomision. \n 62\n\n\nClauza WHERE\nOperator Semnificatie\n!= diferit de (pt anumite S.O.)\n^= diferit de (pt anumite S.O.)\n<> diferit de\nNOT BETWEEN nu se afla intre 2 valori date\nNOT IN nu se afla intr-o lista\nNOT LIKE diferit de sirul\nIS NOT NULL nu este o valoare nula\n5.Negarea expresiilor \n 63\n\nClauza WHERE\nOrdinea de execuţie Operator\n1. Operatorii aritmetici\n2. Operatorii de concatenare\n3. Conditiile de comparare\n4. IS [NOT] NULL, LIKE, [NOT] IN\n5. [NOT] BETWEEN\n6. Operatorul logic NOT\n7. Operatorul logic AND\n8. Operatorul logic OR\nD. Prioritatea de execuţie \n 64\n\nClauza WHERE\nExemplu: \nSELECT *\nFROM EMP\nWHERE job = \'MANAGER\' OR job = \'ANALYST\'\nAND sal < 3000; \n 65\n\n\nClauza WHERE\nRezultatul obtinut -\n 66\n\n\nClauza WHERE\nDar ordinea se poate modifica dacă se folosesc \nparanteze. \nSELECT *\nFROM EMP\nWHERE (job = \'MANAGER\' OR job = \'ANALYST\')\nAND sal < 3000;\n 67\n\n\nClauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \n 68\n\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 69', '\n']","instructiunea SQL pentru a selecta toate înregistrările din tabelul ""Persons"" unde ""FirstName"" este ""Peter"" și ""LastName"" este ""Jackson"" este:

```sql
SELECT *
FROM Persons
WHERE FirstName = 'Peter' AND LastName = 'Jackson';
```
Aceasta interogare se bazează pe sintaxa generală a unei comenzi SELECT, si utilizeaza clauza `WHERE` pentru a filtra rezultatele. Sintaxa este descrisa in:

""SINTAXA
SELECT [DISTINCT] lista_de_expresii
FROM nume_tabela
WHERE conditie_linie -- clauza optionala
ORDER BY criterii_sortare_rezultat; -- clauza 
optionala"".
","Folosind SQL, cum selectezi toate înregistrările dintr-un tabel numit ""Persons"" unde valoarea coloanei ""FirstName"" este ""Peter"" și valoarea coloanei ""LastName"" este ""Jackson""?","['1. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '2. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '3. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '4. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '5. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '6. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '7. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '8. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '9. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '10. ', 'Clauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii al căror nume \nîncepe cu litera S. \n 54\n\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au numele de 4 caractere.\nSELECT ename\nFROM EMP\nWHERE ename LIKE \'____\';\n 55\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nnumele de 4 caractere.\n 56\n\n\nClauza WHERE\nExemplu \nListeaza toţi angajaţii care al doilea caracter din nume \n\'O\'. \nSELECT ename, job, hiredate\nFROM EMP\nWHERE ename LIKE \'_O%\';\n 57\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toţi angajaţii care al doilea \ncaracter din nume \'O\'. \n 58\n\n\nClauza WHERE\nESCAPE - când sunt căutate chiar caracterele % sau _. Acesta \nspecifică caracterul care este ""sărit"". \n ESCAPE identifică \'\\\' drept caracterul care trebuie ""sărit"".\n  El precede caracterul \'_\' astfel încât acesta va fi \nconsiderat drept literal.\nSintaxa: \nSELECT coloana\nFROM tabela\nWHERE coloana LIKE \'%sa\\_%\' ESCAPE \'\\\';\n 59\n\nClauza WHERE\n4. Conditia IS NULL \n  Pentru a verifica valorile de tip NULL există condiţia IS \nNULL sau negarea acesteia IS NOT NULL. \nO valoare nulă este o valoare care este sau incorectă, sau \nnecunoscută, sau inaplicabilă de aceea nu poate fi testată cu \n""="". \nO valoare nulă nu este la fel cu ""zero"" care este un \nnumăr.\nDacă valoarea NULL este utilizată într-o comparaţie, \natunci operatorul de comparaţie trebuie să fie IS NULL sau IS \nNOT NULL altfel rezultatul este întotdeauna FALSE. \n 60\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care nu au comision. \nSELECT *\nFROM EMP\nWHERE comm IS NULL;\n 61\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care nu au \ncomision. \n 62\n\n\nClauza WHERE\nOperator Semnificatie\n!= diferit de (pt anumite S.O.)\n^= diferit de (pt anumite S.O.)\n<> diferit de\nNOT BETWEEN nu se afla intre 2 valori date\nNOT IN nu se afla intr-o lista\nNOT LIKE diferit de sirul\nIS NOT NULL nu este o valoare nula\n5.Negarea expresiilor \n 63\n\nClauza WHERE\nOrdinea de execuţie Operator\n1. Operatorii aritmetici\n2. Operatorii de concatenare\n3. Conditiile de comparare\n4. IS [NOT] NULL, LIKE, [NOT] IN\n5. [NOT] BETWEEN\n6. Operatorul logic NOT\n7. Operatorul logic AND\n8. Operatorul logic OR\nD. Prioritatea de execuţie \n 64\n\nClauza WHERE\nExemplu: \nSELECT *\nFROM EMP\nWHERE job = \'MANAGER\' OR job = \'ANALYST\'\nAND sal < 3000; \n 65\n\n\nClauza WHERE\nRezultatul obtinut -\n 66\n\n\nClauza WHERE\nDar ordinea se poate modifica dacă se folosesc \nparanteze. \nSELECT *\nFROM EMP\nWHERE (job = \'MANAGER\' OR job = \'ANALYST\')\nAND sal < 3000;\n 67\n\n\nClauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \n 68\n\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 69', '\n']","instructiunea SQL pentru a selecta toate înregistrările din tabelul ""Persons"" unde ""FirstName"" este ""Peter"" și ""LastName"" este ""Jackson"" este:

```sql
SELECT *
FROM Persons
WHERE FirstName = 'Peter' AND LastName = 'Jackson';
```
Aceasta interogare se bazează pe sintaxa generală a unei comenzi SELECT, si utilizeaza clauza `WHERE` pentru a filtra rezultatele. Sintaxa este descrisa in:

""SINTAXA
SELECT [DISTINCT] lista_de_expresii
FROM nume_tabela
WHERE conditie_linie -- clauza optionala
ORDER BY criterii_sortare_rezultat; -- clauza 
optionala"".
",SELECT * FROM Persons WHERE FirstName='Peter' AND LastName='Jackson',0.09756804289918691,0.0,0.8953823875908111,1.0,0.14810496443393903,0.21686746987951808,0.86
53,Manual - Test 1,,,12,"Folosing SQL, cum se selectează toate înregistrările din tabelul ""Persons"" unde valoarea coloanei ""LastName"" este între ""Hansen"" și ""Pettersen"" (inclusiv)?",SELECT * FROM Persons WHERE LastName BETWEEN 'Hansen' AND 'Pettersen',Este corect,,"['1. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '2. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '3. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '4. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '5. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '6. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '7. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '8. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '9. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '10. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n']","instructiunea SQL pentru a selecta toate înregistrările din tabelul ""Persons"" unde valoarea coloanei ""LastName"" este între ""Hansen"" și ""Pettersen"" (inclusiv) este:
```sql
SELECT *
FROM Persons
WHERE LastName BETWEEN 'Hansen' AND 'Pettersen';

```
Nu exista informatii despre 'BETWEEN' in documentele furnizate, raspunsul fiind standard SQL.
","Folosing SQL, cum se selectează toate înregistrările din tabelul ""Persons"" unde valoarea coloanei ""LastName"" este între ""Hansen"" și ""Pettersen"" (inclusiv)?","['1. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '2. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '3. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '4. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '5. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '6. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '7. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '8. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '9. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '10. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n']","instructiunea SQL pentru a selecta toate înregistrările din tabelul ""Persons"" unde valoarea coloanei ""LastName"" este între ""Hansen"" și ""Pettersen"" (inclusiv) este:
```sql
SELECT *
FROM Persons
WHERE LastName BETWEEN 'Hansen' AND 'Pettersen';

```
Nu exista informatii despre 'BETWEEN' in documentele furnizate, raspunsul fiind standard SQL.
",SELECT * FROM Persons WHERE LastName BETWEEN 'Hansen' AND 'Pettersen',0.06346153845836539,0.0,0.8838839212465941,0.3333333333333333,0.134833287041775,0.339622641509434,0.86
54,Manual - Test 2,,,1,Care instrucțiune SQL este utilizată pentru a returna doar valori diferite?,SELECT DISTINCT,Este corect,,"['1. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '2. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '3. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '4. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '5. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '6. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '7. ', 'Curs 4\nLimbajul SQL\nCurs 4 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3\n\nTabela DUAL\nTabela generica DUAL se foloseste pentru a testa \nfunctii si pentru a evalua diferite expresii care nu \nnecesita preluarea datelor dintr-o tabela. \nAceastă tabela este una specială, care conţine o \nsingură coloană numită ”DUMMY” şi o singură linie. \nCurs 4 - BAZE DE DATE 4\n\n\nTabela DUAL\nPutem folosi tabela DUAL si atunci cand vrem sa realizăm \ndiverse calcule.\nExemplu:\nSELECT (12/3 + 10)\nFROM dual;\nCurs 4 - BAZE DE DATE 5\n\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări(linii)\n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 4 - BAZE DE DATE 6\n\nFuncţii referitoare la o singură înregistrare\nIn documentatia ORACLE puteti gasi \nfoarte multe funcţii care pot fi \nutilizate in expresii.\nLista completa a acestor functii este \nla:\nhttps://docs.oracle.com/cloud/help/r\no/analytics-cloud/ACUBI/GUID-\n4CBCE8D4-CF17-43BD-AAEF-\nC5D614A8040A.htm#BILUG779\nCurs 4 - BAZE DE DATE 7\n\n\nFuncţii\nFuncţiile se pot clasifica în două categorii:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 4 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. Funcţii pentru şiruri de caractere\n2. Funcţii de tip numeric\n3. Funcţii de tip dată calendaristică şi oră\n4. Funcţii de conversie dintr-un tip în altul\n5. Funcţii generale\n6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• Funcţii totalizatoare sau funcţii de grup\nCurs 4 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 4 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 4 - BAZE DE DATE 12\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13', '\n', '8. ', 'Curs 4\nLimbajul SQL\nCurs 4 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3\n\nTabela DUAL\nTabela generica DUAL se foloseste pentru a testa \nfunctii si pentru a evalua diferite expresii care nu \nnecesita preluarea datelor dintr-o tabela. \nAceastă tabela este una specială, care conţine o \nsingură coloană numită ”DUMMY” şi o singură linie. \nCurs 4 - BAZE DE DATE 4\n\n\nTabela DUAL\nPutem folosi tabela DUAL si atunci cand vrem sa realizăm \ndiverse calcule.\nExemplu:\nSELECT (12/3 + 10)\nFROM dual;\nCurs 4 - BAZE DE DATE 5\n\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări(linii)\n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 4 - BAZE DE DATE 6\n\nFuncţii referitoare la o singură înregistrare\nIn documentatia ORACLE puteti gasi \nfoarte multe funcţii care pot fi \nutilizate in expresii.\nLista completa a acestor functii este \nla:\nhttps://docs.oracle.com/cloud/help/r\no/analytics-cloud/ACUBI/GUID-\n4CBCE8D4-CF17-43BD-AAEF-\nC5D614A8040A.htm#BILUG779\nCurs 4 - BAZE DE DATE 7\n\n\nFuncţii\nFuncţiile se pot clasifica în două categorii:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 4 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. Funcţii pentru şiruri de caractere\n2. Funcţii de tip numeric\n3. Funcţii de tip dată calendaristică şi oră\n4. Funcţii de conversie dintr-un tip în altul\n5. Funcţii generale\n6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• Funcţii totalizatoare sau funcţii de grup\nCurs 4 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 4 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 4 - BAZE DE DATE 12\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13', '\n', '9. ', 'Curs 4\nLimbajul SQL\nCurs 4 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3\n\nTabela DUAL\nTabela generica DUAL se foloseste pentru a testa \nfunctii si pentru a evalua diferite expresii care nu \nnecesita preluarea datelor dintr-o tabela. \nAceastă tabela este una specială, care conţine o \nsingură coloană numită ”DUMMY” şi o singură linie. \nCurs 4 - BAZE DE DATE 4\n\n\nTabela DUAL\nPutem folosi tabela DUAL si atunci cand vrem sa realizăm \ndiverse calcule.\nExemplu:\nSELECT (12/3 + 10)\nFROM dual;\nCurs 4 - BAZE DE DATE 5\n\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări(linii)\n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 4 - BAZE DE DATE 6\n\nFuncţii referitoare la o singură înregistrare\nIn documentatia ORACLE puteti gasi \nfoarte multe funcţii care pot fi \nutilizate in expresii.\nLista completa a acestor functii este \nla:\nhttps://docs.oracle.com/cloud/help/r\no/analytics-cloud/ACUBI/GUID-\n4CBCE8D4-CF17-43BD-AAEF-\nC5D614A8040A.htm#BILUG779\nCurs 4 - BAZE DE DATE 7\n\n\nFuncţii\nFuncţiile se pot clasifica în două categorii:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 4 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. Funcţii pentru şiruri de caractere\n2. Funcţii de tip numeric\n3. Funcţii de tip dată calendaristică şi oră\n4. Funcţii de conversie dintr-un tip în altul\n5. Funcţii generale\n6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• Funcţii totalizatoare sau funcţii de grup\nCurs 4 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 4 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 4 - BAZE DE DATE 12\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13', '\n', '10. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n']","comanda SELECT, impreuna cu cuvantul cheie DISTINCT, este utilizata pentru a returna doar valori diferite.
",Care instrucțiune SQL este utilizată pentru a returna doar valori diferite?,"['1. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '2. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '3. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '4. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '5. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '6. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '7. ', 'Curs 4\nLimbajul SQL\nCurs 4 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3\n\nTabela DUAL\nTabela generica DUAL se foloseste pentru a testa \nfunctii si pentru a evalua diferite expresii care nu \nnecesita preluarea datelor dintr-o tabela. \nAceastă tabela este una specială, care conţine o \nsingură coloană numită ”DUMMY” şi o singură linie. \nCurs 4 - BAZE DE DATE 4\n\n\nTabela DUAL\nPutem folosi tabela DUAL si atunci cand vrem sa realizăm \ndiverse calcule.\nExemplu:\nSELECT (12/3 + 10)\nFROM dual;\nCurs 4 - BAZE DE DATE 5\n\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări(linii)\n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 4 - BAZE DE DATE 6\n\nFuncţii referitoare la o singură înregistrare\nIn documentatia ORACLE puteti gasi \nfoarte multe funcţii care pot fi \nutilizate in expresii.\nLista completa a acestor functii este \nla:\nhttps://docs.oracle.com/cloud/help/r\no/analytics-cloud/ACUBI/GUID-\n4CBCE8D4-CF17-43BD-AAEF-\nC5D614A8040A.htm#BILUG779\nCurs 4 - BAZE DE DATE 7\n\n\nFuncţii\nFuncţiile se pot clasifica în două categorii:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 4 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. Funcţii pentru şiruri de caractere\n2. Funcţii de tip numeric\n3. Funcţii de tip dată calendaristică şi oră\n4. Funcţii de conversie dintr-un tip în altul\n5. Funcţii generale\n6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• Funcţii totalizatoare sau funcţii de grup\nCurs 4 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 4 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 4 - BAZE DE DATE 12\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13', '\n', '8. ', 'Curs 4\nLimbajul SQL\nCurs 4 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3\n\nTabela DUAL\nTabela generica DUAL se foloseste pentru a testa \nfunctii si pentru a evalua diferite expresii care nu \nnecesita preluarea datelor dintr-o tabela. \nAceastă tabela este una specială, care conţine o \nsingură coloană numită ”DUMMY” şi o singură linie. \nCurs 4 - BAZE DE DATE 4\n\n\nTabela DUAL\nPutem folosi tabela DUAL si atunci cand vrem sa realizăm \ndiverse calcule.\nExemplu:\nSELECT (12/3 + 10)\nFROM dual;\nCurs 4 - BAZE DE DATE 5\n\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări(linii)\n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 4 - BAZE DE DATE 6\n\nFuncţii referitoare la o singură înregistrare\nIn documentatia ORACLE puteti gasi \nfoarte multe funcţii care pot fi \nutilizate in expresii.\nLista completa a acestor functii este \nla:\nhttps://docs.oracle.com/cloud/help/r\no/analytics-cloud/ACUBI/GUID-\n4CBCE8D4-CF17-43BD-AAEF-\nC5D614A8040A.htm#BILUG779\nCurs 4 - BAZE DE DATE 7\n\n\nFuncţii\nFuncţiile se pot clasifica în două categorii:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 4 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. Funcţii pentru şiruri de caractere\n2. Funcţii de tip numeric\n3. Funcţii de tip dată calendaristică şi oră\n4. Funcţii de conversie dintr-un tip în altul\n5. Funcţii generale\n6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• Funcţii totalizatoare sau funcţii de grup\nCurs 4 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 4 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 4 - BAZE DE DATE 12\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13', '\n', '9. ', 'Curs 4\nLimbajul SQL\nCurs 4 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3\n\nTabela DUAL\nTabela generica DUAL se foloseste pentru a testa \nfunctii si pentru a evalua diferite expresii care nu \nnecesita preluarea datelor dintr-o tabela. \nAceastă tabela este una specială, care conţine o \nsingură coloană numită ”DUMMY” şi o singură linie. \nCurs 4 - BAZE DE DATE 4\n\n\nTabela DUAL\nPutem folosi tabela DUAL si atunci cand vrem sa realizăm \ndiverse calcule.\nExemplu:\nSELECT (12/3 + 10)\nFROM dual;\nCurs 4 - BAZE DE DATE 5\n\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări(linii)\n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 4 - BAZE DE DATE 6\n\nFuncţii referitoare la o singură înregistrare\nIn documentatia ORACLE puteti gasi \nfoarte multe funcţii care pot fi \nutilizate in expresii.\nLista completa a acestor functii este \nla:\nhttps://docs.oracle.com/cloud/help/r\no/analytics-cloud/ACUBI/GUID-\n4CBCE8D4-CF17-43BD-AAEF-\nC5D614A8040A.htm#BILUG779\nCurs 4 - BAZE DE DATE 7\n\n\nFuncţii\nFuncţiile se pot clasifica în două categorii:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 4 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. Funcţii pentru şiruri de caractere\n2. Funcţii de tip numeric\n3. Funcţii de tip dată calendaristică şi oră\n4. Funcţii de conversie dintr-un tip în altul\n5. Funcţii generale\n6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• Funcţii totalizatoare sau funcţii de grup\nCurs 4 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 4 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 4 - BAZE DE DATE 12\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13', '\n', '10. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n']","comanda SELECT, impreuna cu cuvantul cheie DISTINCT, este utilizata pentru a returna doar valori diferite.
",SELECT DISTINCT,0.0,0.0,0.8091334527651798,1.0,0.025540496664715903,0.23529411764705882,0.67
55,Manual - Test 2,,,2,Ce cuvânt cheie SQL este folosit pentru a sorta multimea de rezultate?,ORDER BY,Este corect,,"['1. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '2. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '3. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '4. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '5. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '6. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '7. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '8. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '9. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '10. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n']","cuvântul cheie SQL folosit pentru a sorta setul de rezultate este parte din clauza `ORDER BY`. Sintaxa corectă este:

```sql
SELECT [DISTINCT] lista_de_expresii
FROM nume_tabela
WHERE conditie_linie
ORDER BY criterii_sortare_rezultat;
```
",Ce cuvânt cheie SQL este folosit pentru a sorta multimea de rezultate?,"['1. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '2. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '3. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '4. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '5. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '6. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '7. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '8. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '9. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '10. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n']","cuvântul cheie SQL folosit pentru a sorta setul de rezultate este parte din clauza `ORDER BY`. Sintaxa corectă este:

```sql
SELECT [DISTINCT] lista_de_expresii
FROM nume_tabela
WHERE conditie_linie
ORDER BY criterii_sortare_rezultat;
```
",ORDER BY,0.3532327586118588,1.0,0.8477745569343215,1.0,0.04295382417831811,0.10256410256410257,0.67
56,Manual - Test 2,,,3,"Folosind SQL, cum se pot returna toate înregistrările dintr-un tabel numit ""Persons"" sortate descrescător după ""FirstName""?",SELECT * FROM Persons ORDER BY FirstName DESC,Este corect,,"['1. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '2. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '3. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '4. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '5. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '6. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '7. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '8. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '9. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '10. ', ""3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43\n\n3. Sinonime\nPentru crearea sinonimelor este necesara o cerere SQL \ncare are urmatorul format:\nCurs - BAZE DE DATE 44\nCREATE [PUBLIC] SYNONYM nume_sinonim\nFOR nume_obiect;\nPUBLIC\nDefineste faptul ca acest sinonim este accesibil de catre toti \nutilizatorii. Daca nu este precizat atunci sinonimul este disponibil \ndoar pentru utilizatorul curent. Sinonimele publice pot fi create doar \nde catre utilizatorii care au drepturi administrative.\nnume_sinonim Numele sinonimului care va fi creat.\nnume_obiect Identifica obiectul pentru care se doreste crearea sinonimului \n\n3. Sinonime\n➢Daca dorim sa accesam o tabela pe care un alt utilizator \na creat-o in prealabil si careia ii dorim asignarea unui \nsinonim suntem obligati sa introducem inaintea numelui \ntabelei si numele utilizatorului care a creat tabela, in \nfata numelui tabelei, despartite de un punct.\nExemplu 1 - In acest exemplu vom incerca sa cream un \nsinonim pentru tabela departamente care are un nume \ndestul de lung.\nCREATE PUBLIC SYNONYM dep\nFOR dept;\nCurs - BAZE DE DATE 45\n\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46\n\n3. Sinonime\nExista unele restrictii in folosirea sinonimelor:\n➢obiectele respective nu pot sa fie continute intr-un \npachet.\n➢numele sinonimului privat trebuie sa fie unic in cadrul \ngrupului de obiecte pentru care acel user este \nproprietar.\nCurs - BAZE DE DATE 47\n\n3. Sinonime\n➢Un sinonim nu poate fi schimbat odata creat. \n➢El poate sa fie doar distrus. \n➢Distrugerea unui sinonim nu implica si distrugerea \nobiectului de care aliasul este atasat. \n➢Distrugerea unui sinonim este facuta folosind o \ninterogare SQL de tipul urmator:\nDROP [PUBLIC] SYNONYM nume_sinonim\nunde nume_sinonim este numele sinonimului care sa fie \ndistrus.\nCurs - BAZE DE DATE 48\n\n3. Sinonime\n➢Un sinonim de tip public poate sa fie sa fie distrus doar \nde catre un utilizator administrativ. \n➢Sinonimele private trebuie distruse de utilizatorul care \nle-a creat acestea nefiind disponibile in cadrul listei \nnumelor de obiecte a celorlalti utilizatori.\nCurs - BAZE DE DATE 49\n\nBibliografie\nFlorin Rădulescu: Oracle SQL, PL/SQL, Editura \nPrintech, ISBN 973-718-203-02005\nCurs - BAZE DE DATE 50\n\nÎntrebări?\nCurs - BAZE DE DATE 51"", '\n']","```sql
SELECT *
FROM Persons
ORDER BY FirstName DESC;
```
","Folosind SQL, cum se pot returna toate înregistrările dintr-un tabel numit ""Persons"" sortate descrescător după ""FirstName""?","['1. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '2. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '3. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '4. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '5. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '6. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '7. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '8. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '9. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '10. ', ""3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43\n\n3. Sinonime\nPentru crearea sinonimelor este necesara o cerere SQL \ncare are urmatorul format:\nCurs - BAZE DE DATE 44\nCREATE [PUBLIC] SYNONYM nume_sinonim\nFOR nume_obiect;\nPUBLIC\nDefineste faptul ca acest sinonim este accesibil de catre toti \nutilizatorii. Daca nu este precizat atunci sinonimul este disponibil \ndoar pentru utilizatorul curent. Sinonimele publice pot fi create doar \nde catre utilizatorii care au drepturi administrative.\nnume_sinonim Numele sinonimului care va fi creat.\nnume_obiect Identifica obiectul pentru care se doreste crearea sinonimului \n\n3. Sinonime\n➢Daca dorim sa accesam o tabela pe care un alt utilizator \na creat-o in prealabil si careia ii dorim asignarea unui \nsinonim suntem obligati sa introducem inaintea numelui \ntabelei si numele utilizatorului care a creat tabela, in \nfata numelui tabelei, despartite de un punct.\nExemplu 1 - In acest exemplu vom incerca sa cream un \nsinonim pentru tabela departamente care are un nume \ndestul de lung.\nCREATE PUBLIC SYNONYM dep\nFOR dept;\nCurs - BAZE DE DATE 45\n\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46\n\n3. Sinonime\nExista unele restrictii in folosirea sinonimelor:\n➢obiectele respective nu pot sa fie continute intr-un \npachet.\n➢numele sinonimului privat trebuie sa fie unic in cadrul \ngrupului de obiecte pentru care acel user este \nproprietar.\nCurs - BAZE DE DATE 47\n\n3. Sinonime\n➢Un sinonim nu poate fi schimbat odata creat. \n➢El poate sa fie doar distrus. \n➢Distrugerea unui sinonim nu implica si distrugerea \nobiectului de care aliasul este atasat. \n➢Distrugerea unui sinonim este facuta folosind o \ninterogare SQL de tipul urmator:\nDROP [PUBLIC] SYNONYM nume_sinonim\nunde nume_sinonim este numele sinonimului care sa fie \ndistrus.\nCurs - BAZE DE DATE 48\n\n3. Sinonime\n➢Un sinonim de tip public poate sa fie sa fie distrus doar \nde catre un utilizator administrativ. \n➢Sinonimele private trebuie distruse de utilizatorul care \nle-a creat acestea nefiind disponibile in cadrul listei \nnumelor de obiecte a celorlalti utilizatori.\nCurs - BAZE DE DATE 49\n\nBibliografie\nFlorin Rădulescu: Oracle SQL, PL/SQL, Editura \nPrintech, ISBN 973-718-203-02005\nCurs - BAZE DE DATE 50\n\nÎntrebări?\nCurs - BAZE DE DATE 51"", '\n']","```sql
SELECT *
FROM Persons
ORDER BY FirstName DESC;
```
",SELECT * FROM Persons ORDER BY FirstName DESC,0.08411371237177816,0.0,0.8835402883911941,0.0,0.4428500142691474,0.9333333333333333,1.0
57,Manual - Test 2,,,4,"Folosind SQL, cum se inserează o înregistrare nouă în tabelul ""Persons""?","INSERT INTO Persons VALUES ('Jimmy', 'Jackson')",Este corect,,"['1. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '2. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '3. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '4. ', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13\n\nFuncţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 15\n\nFuncţii referitoare la o singură înregistrare\n4.2.1. Funcţii pentru şiruri de caractere \nAceste funcţii au ca argumente date de tip \ncaracter şi returnează date de tip VARCHAR2, \nCHAR sau NUMBER.\nCurs 4 - BAZE DE DATE 16\n\n4.2.1. Funcţii pentru şiruri de caractere\nCele mai importante funcţii caracter sunt:\nFunctie Descriere  \nLOWER(column|expression) converteste alfa caracterele din caractere mari in \ncaractere mici  \nUPPER(column|expression) converteste alfa caracterele din caractere mici in \ncaractere mari  \nINITCAP(column|expression) \nconverteste prima litera a fiecarui cuvant in \ncaractere mari si restul cuvantului in caractere \nmici  \nCONCAT(column1|expression1, \ncolumn2|expression2) \nfunctia este echivalentul operatorului de \nconcantenare (||)  \nSUBSTR(column|expression, m [, n]) returneaza un sir de n caractere incepand cu \ncaracterul aflat pe pozitia m  \nLENGTH(column|expression) returneaza numarul de caractere dintr-o expresie  \nINSTR(column|expression, \'string\', \n[m], [n]) \nreturneaza pozitia unui anumit sir, optional se \npoate incepe cautarea cu pozitia m sau cu a n-a \naparitie a sirului. m si n sunt prin definitie 1  \nREPLACE(text, search_string, \nreplacement_ string) \ncauta un anumit text intr-un sir de caractere si \ndaca il gaseste il inlocuieste  \n \nCurs 4 - BAZE DE DATE 17\n\nExemplu de utilizare a \nfuncţiei LENGTH:\nSELECT LENGTH(ename) \nFROM EMP; \nCurs 4 - BAZE DE DATE 18\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu de utilizare a funcţiei LENGTH – rezultatul \nobtinut: \nCurs 4 - BAZE DE DATE 19\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT \'Numele functiei pentru \'||UPPER(ename)||\'este \n\'||LOWER(job) AS ""DETALII ANGAJAT""\nFROM EMP; \nCurs 4 - BAZE DE DATE 20\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = \'MARTIN\';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere', '\n', '5. ', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13\n\nFuncţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 15\n\nFuncţii referitoare la o singură înregistrare\n4.2.1. Funcţii pentru şiruri de caractere \nAceste funcţii au ca argumente date de tip \ncaracter şi returnează date de tip VARCHAR2, \nCHAR sau NUMBER.\nCurs 4 - BAZE DE DATE 16\n\n4.2.1. Funcţii pentru şiruri de caractere\nCele mai importante funcţii caracter sunt:\nFunctie Descriere  \nLOWER(column|expression) converteste alfa caracterele din caractere mari in \ncaractere mici  \nUPPER(column|expression) converteste alfa caracterele din caractere mici in \ncaractere mari  \nINITCAP(column|expression) \nconverteste prima litera a fiecarui cuvant in \ncaractere mari si restul cuvantului in caractere \nmici  \nCONCAT(column1|expression1, \ncolumn2|expression2) \nfunctia este echivalentul operatorului de \nconcantenare (||)  \nSUBSTR(column|expression, m [, n]) returneaza un sir de n caractere incepand cu \ncaracterul aflat pe pozitia m  \nLENGTH(column|expression) returneaza numarul de caractere dintr-o expresie  \nINSTR(column|expression, \'string\', \n[m], [n]) \nreturneaza pozitia unui anumit sir, optional se \npoate incepe cautarea cu pozitia m sau cu a n-a \naparitie a sirului. m si n sunt prin definitie 1  \nREPLACE(text, search_string, \nreplacement_ string) \ncauta un anumit text intr-un sir de caractere si \ndaca il gaseste il inlocuieste  \n \nCurs 4 - BAZE DE DATE 17\n\nExemplu de utilizare a \nfuncţiei LENGTH:\nSELECT LENGTH(ename) \nFROM EMP; \nCurs 4 - BAZE DE DATE 18\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu de utilizare a funcţiei LENGTH – rezultatul \nobtinut: \nCurs 4 - BAZE DE DATE 19\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT \'Numele functiei pentru \'||UPPER(ename)||\'este \n\'||LOWER(job) AS ""DETALII ANGAJAT""\nFROM EMP; \nCurs 4 - BAZE DE DATE 20\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = \'MARTIN\';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere', '\n', '6. ', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13\n\nFuncţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 15\n\nFuncţii referitoare la o singură înregistrare\n4.2.1. Funcţii pentru şiruri de caractere \nAceste funcţii au ca argumente date de tip \ncaracter şi returnează date de tip VARCHAR2, \nCHAR sau NUMBER.\nCurs 4 - BAZE DE DATE 16\n\n4.2.1. Funcţii pentru şiruri de caractere\nCele mai importante funcţii caracter sunt:\nFunctie Descriere  \nLOWER(column|expression) converteste alfa caracterele din caractere mari in \ncaractere mici  \nUPPER(column|expression) converteste alfa caracterele din caractere mici in \ncaractere mari  \nINITCAP(column|expression) \nconverteste prima litera a fiecarui cuvant in \ncaractere mari si restul cuvantului in caractere \nmici  \nCONCAT(column1|expression1, \ncolumn2|expression2) \nfunctia este echivalentul operatorului de \nconcantenare (||)  \nSUBSTR(column|expression, m [, n]) returneaza un sir de n caractere incepand cu \ncaracterul aflat pe pozitia m  \nLENGTH(column|expression) returneaza numarul de caractere dintr-o expresie  \nINSTR(column|expression, \'string\', \n[m], [n]) \nreturneaza pozitia unui anumit sir, optional se \npoate incepe cautarea cu pozitia m sau cu a n-a \naparitie a sirului. m si n sunt prin definitie 1  \nREPLACE(text, search_string, \nreplacement_ string) \ncauta un anumit text intr-un sir de caractere si \ndaca il gaseste il inlocuieste  \n \nCurs 4 - BAZE DE DATE 17\n\nExemplu de utilizare a \nfuncţiei LENGTH:\nSELECT LENGTH(ename) \nFROM EMP; \nCurs 4 - BAZE DE DATE 18\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu de utilizare a funcţiei LENGTH – rezultatul \nobtinut: \nCurs 4 - BAZE DE DATE 19\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT \'Numele functiei pentru \'||UPPER(ename)||\'este \n\'||LOWER(job) AS ""DETALII ANGAJAT""\nFROM EMP; \nCurs 4 - BAZE DE DATE 20\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = \'MARTIN\';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere', '\n', '7. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '8. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '9. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '10. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n']","pentru a insera o înregistrare nouă în tabelul ""Persons"", poți folosi următoarea instrucțiune SQL:

```sql
INSERT INTO Persons (coloana1, coloana2, ...)
VALUES (valoare1, valoare2, ...);
```

Unde `coloana1, coloana2, ...` reprezintă numele coloanelor din tabelul ""Persons"", iar `valoare1, valoare2, ...` sunt valorile corespunzătoare pe care vrei să le inserezi.
","Folosind SQL, cum se inserează o înregistrare nouă în tabelul ""Persons""?","['1. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '2. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '3. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '4. ', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13\n\nFuncţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 15\n\nFuncţii referitoare la o singură înregistrare\n4.2.1. Funcţii pentru şiruri de caractere \nAceste funcţii au ca argumente date de tip \ncaracter şi returnează date de tip VARCHAR2, \nCHAR sau NUMBER.\nCurs 4 - BAZE DE DATE 16\n\n4.2.1. Funcţii pentru şiruri de caractere\nCele mai importante funcţii caracter sunt:\nFunctie Descriere  \nLOWER(column|expression) converteste alfa caracterele din caractere mari in \ncaractere mici  \nUPPER(column|expression) converteste alfa caracterele din caractere mici in \ncaractere mari  \nINITCAP(column|expression) \nconverteste prima litera a fiecarui cuvant in \ncaractere mari si restul cuvantului in caractere \nmici  \nCONCAT(column1|expression1, \ncolumn2|expression2) \nfunctia este echivalentul operatorului de \nconcantenare (||)  \nSUBSTR(column|expression, m [, n]) returneaza un sir de n caractere incepand cu \ncaracterul aflat pe pozitia m  \nLENGTH(column|expression) returneaza numarul de caractere dintr-o expresie  \nINSTR(column|expression, \'string\', \n[m], [n]) \nreturneaza pozitia unui anumit sir, optional se \npoate incepe cautarea cu pozitia m sau cu a n-a \naparitie a sirului. m si n sunt prin definitie 1  \nREPLACE(text, search_string, \nreplacement_ string) \ncauta un anumit text intr-un sir de caractere si \ndaca il gaseste il inlocuieste  \n \nCurs 4 - BAZE DE DATE 17\n\nExemplu de utilizare a \nfuncţiei LENGTH:\nSELECT LENGTH(ename) \nFROM EMP; \nCurs 4 - BAZE DE DATE 18\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu de utilizare a funcţiei LENGTH – rezultatul \nobtinut: \nCurs 4 - BAZE DE DATE 19\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT \'Numele functiei pentru \'||UPPER(ename)||\'este \n\'||LOWER(job) AS ""DETALII ANGAJAT""\nFROM EMP; \nCurs 4 - BAZE DE DATE 20\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = \'MARTIN\';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere', '\n', '5. ', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13\n\nFuncţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 15\n\nFuncţii referitoare la o singură înregistrare\n4.2.1. Funcţii pentru şiruri de caractere \nAceste funcţii au ca argumente date de tip \ncaracter şi returnează date de tip VARCHAR2, \nCHAR sau NUMBER.\nCurs 4 - BAZE DE DATE 16\n\n4.2.1. Funcţii pentru şiruri de caractere\nCele mai importante funcţii caracter sunt:\nFunctie Descriere  \nLOWER(column|expression) converteste alfa caracterele din caractere mari in \ncaractere mici  \nUPPER(column|expression) converteste alfa caracterele din caractere mici in \ncaractere mari  \nINITCAP(column|expression) \nconverteste prima litera a fiecarui cuvant in \ncaractere mari si restul cuvantului in caractere \nmici  \nCONCAT(column1|expression1, \ncolumn2|expression2) \nfunctia este echivalentul operatorului de \nconcantenare (||)  \nSUBSTR(column|expression, m [, n]) returneaza un sir de n caractere incepand cu \ncaracterul aflat pe pozitia m  \nLENGTH(column|expression) returneaza numarul de caractere dintr-o expresie  \nINSTR(column|expression, \'string\', \n[m], [n]) \nreturneaza pozitia unui anumit sir, optional se \npoate incepe cautarea cu pozitia m sau cu a n-a \naparitie a sirului. m si n sunt prin definitie 1  \nREPLACE(text, search_string, \nreplacement_ string) \ncauta un anumit text intr-un sir de caractere si \ndaca il gaseste il inlocuieste  \n \nCurs 4 - BAZE DE DATE 17\n\nExemplu de utilizare a \nfuncţiei LENGTH:\nSELECT LENGTH(ename) \nFROM EMP; \nCurs 4 - BAZE DE DATE 18\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu de utilizare a funcţiei LENGTH – rezultatul \nobtinut: \nCurs 4 - BAZE DE DATE 19\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT \'Numele functiei pentru \'||UPPER(ename)||\'este \n\'||LOWER(job) AS ""DETALII ANGAJAT""\nFROM EMP; \nCurs 4 - BAZE DE DATE 20\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = \'MARTIN\';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere', '\n', '6. ', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13\n\nFuncţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 15\n\nFuncţii referitoare la o singură înregistrare\n4.2.1. Funcţii pentru şiruri de caractere \nAceste funcţii au ca argumente date de tip \ncaracter şi returnează date de tip VARCHAR2, \nCHAR sau NUMBER.\nCurs 4 - BAZE DE DATE 16\n\n4.2.1. Funcţii pentru şiruri de caractere\nCele mai importante funcţii caracter sunt:\nFunctie Descriere  \nLOWER(column|expression) converteste alfa caracterele din caractere mari in \ncaractere mici  \nUPPER(column|expression) converteste alfa caracterele din caractere mici in \ncaractere mari  \nINITCAP(column|expression) \nconverteste prima litera a fiecarui cuvant in \ncaractere mari si restul cuvantului in caractere \nmici  \nCONCAT(column1|expression1, \ncolumn2|expression2) \nfunctia este echivalentul operatorului de \nconcantenare (||)  \nSUBSTR(column|expression, m [, n]) returneaza un sir de n caractere incepand cu \ncaracterul aflat pe pozitia m  \nLENGTH(column|expression) returneaza numarul de caractere dintr-o expresie  \nINSTR(column|expression, \'string\', \n[m], [n]) \nreturneaza pozitia unui anumit sir, optional se \npoate incepe cautarea cu pozitia m sau cu a n-a \naparitie a sirului. m si n sunt prin definitie 1  \nREPLACE(text, search_string, \nreplacement_ string) \ncauta un anumit text intr-un sir de caractere si \ndaca il gaseste il inlocuieste  \n \nCurs 4 - BAZE DE DATE 17\n\nExemplu de utilizare a \nfuncţiei LENGTH:\nSELECT LENGTH(ename) \nFROM EMP; \nCurs 4 - BAZE DE DATE 18\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu de utilizare a funcţiei LENGTH – rezultatul \nobtinut: \nCurs 4 - BAZE DE DATE 19\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT \'Numele functiei pentru \'||UPPER(ename)||\'este \n\'||LOWER(job) AS ""DETALII ANGAJAT""\nFROM EMP; \nCurs 4 - BAZE DE DATE 20\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = \'MARTIN\';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere', '\n', '7. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '8. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '9. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '10. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n']","pentru a insera o înregistrare nouă în tabelul ""Persons"", poți folosi următoarea instrucțiune SQL:

```sql
INSERT INTO Persons (coloana1, coloana2, ...)
VALUES (valoare1, valoare2, ...);
```

Unde `coloana1, coloana2, ...` reprezintă numele coloanelor din tabelul ""Persons"", iar `valoare1, valoare2, ...` sunt valorile corespunzătoare pe care vrei să le inserezi.
","INSERT INTO Persons VALUES ('Jimmy', 'Jackson')",0.4249999999858333,1.0,0.9114467386795964,1.0,0.021055635114676598,0.14814814814814814,0.33
58,Manual - Test 2,,,5,"Folosind SQL, cum se inserează ""Olsen"" ca ""LastName"" în tabelul ""Persons""?",INSERT INTO Persons (LastName) VALUES ('Olsen'),Este corect,,"['1. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '2. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '3. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '4. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '5. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '6. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '7. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '8. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '9. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '10. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n']","```sql
INSERT INTO Persons (LastName) VALUES ('Olsen');
```
","Folosind SQL, cum se inserează ""Olsen"" ca ""LastName"" în tabelul ""Persons""?","['1. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '2. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '3. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '4. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '5. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '6. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '7. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '8. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '9. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '10. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n']","```sql
INSERT INTO Persons (LastName) VALUES ('Olsen');
```
",INSERT INTO Persons (LastName) VALUES ('Olsen'),0.0,0.0,0.8170217362406569,0.0,0.5118285025257893,0.923076923076923,1.0
59,Manual - Test 2,,,6,"Cum se poate schimba ""Hansen"" în ""Nilsen"" în coloana ""LastName"" din tabelul ""Persons""?",UPDATE Persons SET LastName='Nilsen' WHERE LastName='Hansen',Este corect,,"['1. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n', '2. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n', '3. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n', '4. ', 'Clauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii al căror nume \nîncepe cu litera S. \n 54\n\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au numele de 4 caractere.\nSELECT ename\nFROM EMP\nWHERE ename LIKE \'____\';\n 55\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nnumele de 4 caractere.\n 56\n\n\nClauza WHERE\nExemplu \nListeaza toţi angajaţii care al doilea caracter din nume \n\'O\'. \nSELECT ename, job, hiredate\nFROM EMP\nWHERE ename LIKE \'_O%\';\n 57\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toţi angajaţii care al doilea \ncaracter din nume \'O\'. \n 58\n\n\nClauza WHERE\nESCAPE - când sunt căutate chiar caracterele % sau _. Acesta \nspecifică caracterul care este ""sărit"". \n ESCAPE identifică \'\\\' drept caracterul care trebuie ""sărit"".\n  El precede caracterul \'_\' astfel încât acesta va fi \nconsiderat drept literal.\nSintaxa: \nSELECT coloana\nFROM tabela\nWHERE coloana LIKE \'%sa\\_%\' ESCAPE \'\\\';\n 59\n\nClauza WHERE\n4. Conditia IS NULL \n  Pentru a verifica valorile de tip NULL există condiţia IS \nNULL sau negarea acesteia IS NOT NULL. \nO valoare nulă este o valoare care este sau incorectă, sau \nnecunoscută, sau inaplicabilă de aceea nu poate fi testată cu \n""="". \nO valoare nulă nu este la fel cu ""zero"" care este un \nnumăr.\nDacă valoarea NULL este utilizată într-o comparaţie, \natunci operatorul de comparaţie trebuie să fie IS NULL sau IS \nNOT NULL altfel rezultatul este întotdeauna FALSE. \n 60\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care nu au comision. \nSELECT *\nFROM EMP\nWHERE comm IS NULL;\n 61\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care nu au \ncomision. \n 62\n\n\nClauza WHERE\nOperator Semnificatie\n!= diferit de (pt anumite S.O.)\n^= diferit de (pt anumite S.O.)\n<> diferit de\nNOT BETWEEN nu se afla intre 2 valori date\nNOT IN nu se afla intr-o lista\nNOT LIKE diferit de sirul\nIS NOT NULL nu este o valoare nula\n5.Negarea expresiilor \n 63\n\nClauza WHERE\nOrdinea de execuţie Operator\n1. Operatorii aritmetici\n2. Operatorii de concatenare\n3. Conditiile de comparare\n4. IS [NOT] NULL, LIKE, [NOT] IN\n5. [NOT] BETWEEN\n6. Operatorul logic NOT\n7. Operatorul logic AND\n8. Operatorul logic OR\nD. Prioritatea de execuţie \n 64\n\nClauza WHERE\nExemplu: \nSELECT *\nFROM EMP\nWHERE job = \'MANAGER\' OR job = \'ANALYST\'\nAND sal < 3000; \n 65\n\n\nClauza WHERE\nRezultatul obtinut -\n 66\n\n\nClauza WHERE\nDar ordinea se poate modifica dacă se folosesc \nparanteze. \nSELECT *\nFROM EMP\nWHERE (job = \'MANAGER\' OR job = \'ANALYST\')\nAND sal < 3000;\n 67\n\n\nClauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \n 68\n\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 69', '\n', '5. ', 'Clauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii al căror nume \nîncepe cu litera S. \n 54\n\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au numele de 4 caractere.\nSELECT ename\nFROM EMP\nWHERE ename LIKE \'____\';\n 55\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nnumele de 4 caractere.\n 56\n\n\nClauza WHERE\nExemplu \nListeaza toţi angajaţii care al doilea caracter din nume \n\'O\'. \nSELECT ename, job, hiredate\nFROM EMP\nWHERE ename LIKE \'_O%\';\n 57\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toţi angajaţii care al doilea \ncaracter din nume \'O\'. \n 58\n\n\nClauza WHERE\nESCAPE - când sunt căutate chiar caracterele % sau _. Acesta \nspecifică caracterul care este ""sărit"". \n ESCAPE identifică \'\\\' drept caracterul care trebuie ""sărit"".\n  El precede caracterul \'_\' astfel încât acesta va fi \nconsiderat drept literal.\nSintaxa: \nSELECT coloana\nFROM tabela\nWHERE coloana LIKE \'%sa\\_%\' ESCAPE \'\\\';\n 59\n\nClauza WHERE\n4. Conditia IS NULL \n  Pentru a verifica valorile de tip NULL există condiţia IS \nNULL sau negarea acesteia IS NOT NULL. \nO valoare nulă este o valoare care este sau incorectă, sau \nnecunoscută, sau inaplicabilă de aceea nu poate fi testată cu \n""="". \nO valoare nulă nu este la fel cu ""zero"" care este un \nnumăr.\nDacă valoarea NULL este utilizată într-o comparaţie, \natunci operatorul de comparaţie trebuie să fie IS NULL sau IS \nNOT NULL altfel rezultatul este întotdeauna FALSE. \n 60\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care nu au comision. \nSELECT *\nFROM EMP\nWHERE comm IS NULL;\n 61\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care nu au \ncomision. \n 62\n\n\nClauza WHERE\nOperator Semnificatie\n!= diferit de (pt anumite S.O.)\n^= diferit de (pt anumite S.O.)\n<> diferit de\nNOT BETWEEN nu se afla intre 2 valori date\nNOT IN nu se afla intr-o lista\nNOT LIKE diferit de sirul\nIS NOT NULL nu este o valoare nula\n5.Negarea expresiilor \n 63\n\nClauza WHERE\nOrdinea de execuţie Operator\n1. Operatorii aritmetici\n2. Operatorii de concatenare\n3. Conditiile de comparare\n4. IS [NOT] NULL, LIKE, [NOT] IN\n5. [NOT] BETWEEN\n6. Operatorul logic NOT\n7. Operatorul logic AND\n8. Operatorul logic OR\nD. Prioritatea de execuţie \n 64\n\nClauza WHERE\nExemplu: \nSELECT *\nFROM EMP\nWHERE job = \'MANAGER\' OR job = \'ANALYST\'\nAND sal < 3000; \n 65\n\n\nClauza WHERE\nRezultatul obtinut -\n 66\n\n\nClauza WHERE\nDar ordinea se poate modifica dacă se folosesc \nparanteze. \nSELECT *\nFROM EMP\nWHERE (job = \'MANAGER\' OR job = \'ANALYST\')\nAND sal < 3000;\n 67\n\n\nClauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \n 68\n\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 69', '\n', '6. ', 'Clauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii al căror nume \nîncepe cu litera S. \n 54\n\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au numele de 4 caractere.\nSELECT ename\nFROM EMP\nWHERE ename LIKE \'____\';\n 55\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nnumele de 4 caractere.\n 56\n\n\nClauza WHERE\nExemplu \nListeaza toţi angajaţii care al doilea caracter din nume \n\'O\'. \nSELECT ename, job, hiredate\nFROM EMP\nWHERE ename LIKE \'_O%\';\n 57\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toţi angajaţii care al doilea \ncaracter din nume \'O\'. \n 58\n\n\nClauza WHERE\nESCAPE - când sunt căutate chiar caracterele % sau _. Acesta \nspecifică caracterul care este ""sărit"". \n ESCAPE identifică \'\\\' drept caracterul care trebuie ""sărit"".\n  El precede caracterul \'_\' astfel încât acesta va fi \nconsiderat drept literal.\nSintaxa: \nSELECT coloana\nFROM tabela\nWHERE coloana LIKE \'%sa\\_%\' ESCAPE \'\\\';\n 59\n\nClauza WHERE\n4. Conditia IS NULL \n  Pentru a verifica valorile de tip NULL există condiţia IS \nNULL sau negarea acesteia IS NOT NULL. \nO valoare nulă este o valoare care este sau incorectă, sau \nnecunoscută, sau inaplicabilă de aceea nu poate fi testată cu \n""="". \nO valoare nulă nu este la fel cu ""zero"" care este un \nnumăr.\nDacă valoarea NULL este utilizată într-o comparaţie, \natunci operatorul de comparaţie trebuie să fie IS NULL sau IS \nNOT NULL altfel rezultatul este întotdeauna FALSE. \n 60\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care nu au comision. \nSELECT *\nFROM EMP\nWHERE comm IS NULL;\n 61\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care nu au \ncomision. \n 62\n\n\nClauza WHERE\nOperator Semnificatie\n!= diferit de (pt anumite S.O.)\n^= diferit de (pt anumite S.O.)\n<> diferit de\nNOT BETWEEN nu se afla intre 2 valori date\nNOT IN nu se afla intr-o lista\nNOT LIKE diferit de sirul\nIS NOT NULL nu este o valoare nula\n5.Negarea expresiilor \n 63\n\nClauza WHERE\nOrdinea de execuţie Operator\n1. Operatorii aritmetici\n2. Operatorii de concatenare\n3. Conditiile de comparare\n4. IS [NOT] NULL, LIKE, [NOT] IN\n5. [NOT] BETWEEN\n6. Operatorul logic NOT\n7. Operatorul logic AND\n8. Operatorul logic OR\nD. Prioritatea de execuţie \n 64\n\nClauza WHERE\nExemplu: \nSELECT *\nFROM EMP\nWHERE job = \'MANAGER\' OR job = \'ANALYST\'\nAND sal < 3000; \n 65\n\n\nClauza WHERE\nRezultatul obtinut -\n 66\n\n\nClauza WHERE\nDar ordinea se poate modifica dacă se folosesc \nparanteze. \nSELECT *\nFROM EMP\nWHERE (job = \'MANAGER\' OR job = \'ANALYST\')\nAND sal < 3000;\n 67\n\n\nClauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \n 68\n\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 69', '\n']","pentru a schimba ""Hansen"" în ""Nilsen"" în coloana ""LastName"" din tabelul ""Persons"", poți folosi următoarea instrucțiune SQL, bazată pe sintaxa `UPDATE` prezentată:

```sql
UPDATE Persons
SET LastName = 'Nilsen'
WHERE LastName = 'Hansen';
```
Această instrucțiune identifică înregistrările unde `LastName` este 'Hansen' și le actualizează cu valoarea 'Nilsen', asa cum este specificat in ""7.1.2. Actualizarea datelor dintr-o tabelă"".
","Cum se poate schimba ""Hansen"" în ""Nilsen"" în coloana ""LastName"" din tabelul ""Persons""?","['1. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n', '2. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n', '3. ', ""7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nÎn sintaxă: \n• tabela - numele tabelei \n• coloana - numele coloanei în care vor fi introduse \ndatele \n• valoare - valoarea corespunzătoare din subquery \n(subinterogare)\n• condiţie- identificarea câmpurilor care vor fi \nactualizate\nCurs 7 - BAZE DE DATE 22\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nNotă:\n• În general se foloseşte cheia primară pentru a \nidentifica o linie. \n• Utilizarea altei coloane poate duce la actualizarea \nmai multor linii.\n• De exemplu într-o relaţie numita persoane putem \navea de două sau mai multe persoane cu acelasi \nnume. \nCurs 7 - BAZE DE DATE 23\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 1\nUPDATE   EMP\nSET job ='SALESMAN', hiredate = SYSDATE \nWHERE    ename = 'IONESCU';\nS-au modificat câmpurile \njob și hiredate pentru \nangajatul cu numele \nspecificat\nCurs 7 - BAZE DE DATE 24\n\n\n7.1.2. Actualizarea datelor dintr-o tabelă\nExemplu 2\nUPDATE EMP\nSET deptno = 99\nWHERE empno = 7499;\nS-a modificat deptno \npentru angajatul cu \nempno specificat\nCurs 7 - BAZE DE DATE 25\n\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 26\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nSe pot şterge tupluri dintr-o tabelă \nutilizând clauza DELETE.\nSintaxa \nDELETE [FROM] tabela\n[WHERE conditie];\nCurs 7 - BAZE DE DATE 27\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn sintaxa:\n• tabela - numele tabelei\n• condiţie - identifică liniile care trebuie şterse \nşi este compusă din:\n1. nume de câmpuri\n2. expresii\n3. constante\n4. subquery-uri\n5. şi operatori de comparaţie\nCurs 7 - BAZE DE DATE 28\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Şterge anumite tupluri dintr-o tabelă \nspecificând clauza WHERE în declaraţia funcţiei \nDELETE. \n• Se poate confirma operaţia de ştergere prin \nafişarea tuplurilor şterse cu ajutorul declaraţiei \nlui SELECT. \nCurs 7 - BAZE DE DATE 29\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\nÎn exemplul următor şterge angajaţii care \nlucrează în departamenul 10 din tabela Angajati. \nDELETE  FROM emp\nWHERE deptno = 10;\nCurs 7 - BAZE DE DATE 30\n\n\n7.1.3. Ştergerea tuplurilor dintr-o tabelă\n• Dacă se omite clauza WHERE \ntoate câmpurile din tabelă vor \nfi şterse. \n• Al doilea exemplu şterge toate \ntuplurile(înregistrările) din \ntabela Copy_emp deoarece nu \na fost specificată clauza \nWHERE. \nDELETE  FROM copy_emp;\nCurs 7 - BAZE DE DATE 31"", '\n', '4. ', 'Clauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii al căror nume \nîncepe cu litera S. \n 54\n\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au numele de 4 caractere.\nSELECT ename\nFROM EMP\nWHERE ename LIKE \'____\';\n 55\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nnumele de 4 caractere.\n 56\n\n\nClauza WHERE\nExemplu \nListeaza toţi angajaţii care al doilea caracter din nume \n\'O\'. \nSELECT ename, job, hiredate\nFROM EMP\nWHERE ename LIKE \'_O%\';\n 57\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toţi angajaţii care al doilea \ncaracter din nume \'O\'. \n 58\n\n\nClauza WHERE\nESCAPE - când sunt căutate chiar caracterele % sau _. Acesta \nspecifică caracterul care este ""sărit"". \n ESCAPE identifică \'\\\' drept caracterul care trebuie ""sărit"".\n  El precede caracterul \'_\' astfel încât acesta va fi \nconsiderat drept literal.\nSintaxa: \nSELECT coloana\nFROM tabela\nWHERE coloana LIKE \'%sa\\_%\' ESCAPE \'\\\';\n 59\n\nClauza WHERE\n4. Conditia IS NULL \n  Pentru a verifica valorile de tip NULL există condiţia IS \nNULL sau negarea acesteia IS NOT NULL. \nO valoare nulă este o valoare care este sau incorectă, sau \nnecunoscută, sau inaplicabilă de aceea nu poate fi testată cu \n""="". \nO valoare nulă nu este la fel cu ""zero"" care este un \nnumăr.\nDacă valoarea NULL este utilizată într-o comparaţie, \natunci operatorul de comparaţie trebuie să fie IS NULL sau IS \nNOT NULL altfel rezultatul este întotdeauna FALSE. \n 60\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care nu au comision. \nSELECT *\nFROM EMP\nWHERE comm IS NULL;\n 61\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care nu au \ncomision. \n 62\n\n\nClauza WHERE\nOperator Semnificatie\n!= diferit de (pt anumite S.O.)\n^= diferit de (pt anumite S.O.)\n<> diferit de\nNOT BETWEEN nu se afla intre 2 valori date\nNOT IN nu se afla intr-o lista\nNOT LIKE diferit de sirul\nIS NOT NULL nu este o valoare nula\n5.Negarea expresiilor \n 63\n\nClauza WHERE\nOrdinea de execuţie Operator\n1. Operatorii aritmetici\n2. Operatorii de concatenare\n3. Conditiile de comparare\n4. IS [NOT] NULL, LIKE, [NOT] IN\n5. [NOT] BETWEEN\n6. Operatorul logic NOT\n7. Operatorul logic AND\n8. Operatorul logic OR\nD. Prioritatea de execuţie \n 64\n\nClauza WHERE\nExemplu: \nSELECT *\nFROM EMP\nWHERE job = \'MANAGER\' OR job = \'ANALYST\'\nAND sal < 3000; \n 65\n\n\nClauza WHERE\nRezultatul obtinut -\n 66\n\n\nClauza WHERE\nDar ordinea se poate modifica dacă se folosesc \nparanteze. \nSELECT *\nFROM EMP\nWHERE (job = \'MANAGER\' OR job = \'ANALYST\')\nAND sal < 3000;\n 67\n\n\nClauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \n 68\n\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 69', '\n', '5. ', 'Clauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii al căror nume \nîncepe cu litera S. \n 54\n\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au numele de 4 caractere.\nSELECT ename\nFROM EMP\nWHERE ename LIKE \'____\';\n 55\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nnumele de 4 caractere.\n 56\n\n\nClauza WHERE\nExemplu \nListeaza toţi angajaţii care al doilea caracter din nume \n\'O\'. \nSELECT ename, job, hiredate\nFROM EMP\nWHERE ename LIKE \'_O%\';\n 57\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toţi angajaţii care al doilea \ncaracter din nume \'O\'. \n 58\n\n\nClauza WHERE\nESCAPE - când sunt căutate chiar caracterele % sau _. Acesta \nspecifică caracterul care este ""sărit"". \n ESCAPE identifică \'\\\' drept caracterul care trebuie ""sărit"".\n  El precede caracterul \'_\' astfel încât acesta va fi \nconsiderat drept literal.\nSintaxa: \nSELECT coloana\nFROM tabela\nWHERE coloana LIKE \'%sa\\_%\' ESCAPE \'\\\';\n 59\n\nClauza WHERE\n4. Conditia IS NULL \n  Pentru a verifica valorile de tip NULL există condiţia IS \nNULL sau negarea acesteia IS NOT NULL. \nO valoare nulă este o valoare care este sau incorectă, sau \nnecunoscută, sau inaplicabilă de aceea nu poate fi testată cu \n""="". \nO valoare nulă nu este la fel cu ""zero"" care este un \nnumăr.\nDacă valoarea NULL este utilizată într-o comparaţie, \natunci operatorul de comparaţie trebuie să fie IS NULL sau IS \nNOT NULL altfel rezultatul este întotdeauna FALSE. \n 60\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care nu au comision. \nSELECT *\nFROM EMP\nWHERE comm IS NULL;\n 61\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care nu au \ncomision. \n 62\n\n\nClauza WHERE\nOperator Semnificatie\n!= diferit de (pt anumite S.O.)\n^= diferit de (pt anumite S.O.)\n<> diferit de\nNOT BETWEEN nu se afla intre 2 valori date\nNOT IN nu se afla intr-o lista\nNOT LIKE diferit de sirul\nIS NOT NULL nu este o valoare nula\n5.Negarea expresiilor \n 63\n\nClauza WHERE\nOrdinea de execuţie Operator\n1. Operatorii aritmetici\n2. Operatorii de concatenare\n3. Conditiile de comparare\n4. IS [NOT] NULL, LIKE, [NOT] IN\n5. [NOT] BETWEEN\n6. Operatorul logic NOT\n7. Operatorul logic AND\n8. Operatorul logic OR\nD. Prioritatea de execuţie \n 64\n\nClauza WHERE\nExemplu: \nSELECT *\nFROM EMP\nWHERE job = \'MANAGER\' OR job = \'ANALYST\'\nAND sal < 3000; \n 65\n\n\nClauza WHERE\nRezultatul obtinut -\n 66\n\n\nClauza WHERE\nDar ordinea se poate modifica dacă se folosesc \nparanteze. \nSELECT *\nFROM EMP\nWHERE (job = \'MANAGER\' OR job = \'ANALYST\')\nAND sal < 3000;\n 67\n\n\nClauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \n 68\n\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 69', '\n', '6. ', 'Clauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii al căror nume \nîncepe cu litera S. \n 54\n\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au numele de 4 caractere.\nSELECT ename\nFROM EMP\nWHERE ename LIKE \'____\';\n 55\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nnumele de 4 caractere.\n 56\n\n\nClauza WHERE\nExemplu \nListeaza toţi angajaţii care al doilea caracter din nume \n\'O\'. \nSELECT ename, job, hiredate\nFROM EMP\nWHERE ename LIKE \'_O%\';\n 57\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toţi angajaţii care al doilea \ncaracter din nume \'O\'. \n 58\n\n\nClauza WHERE\nESCAPE - când sunt căutate chiar caracterele % sau _. Acesta \nspecifică caracterul care este ""sărit"". \n ESCAPE identifică \'\\\' drept caracterul care trebuie ""sărit"".\n  El precede caracterul \'_\' astfel încât acesta va fi \nconsiderat drept literal.\nSintaxa: \nSELECT coloana\nFROM tabela\nWHERE coloana LIKE \'%sa\\_%\' ESCAPE \'\\\';\n 59\n\nClauza WHERE\n4. Conditia IS NULL \n  Pentru a verifica valorile de tip NULL există condiţia IS \nNULL sau negarea acesteia IS NOT NULL. \nO valoare nulă este o valoare care este sau incorectă, sau \nnecunoscută, sau inaplicabilă de aceea nu poate fi testată cu \n""="". \nO valoare nulă nu este la fel cu ""zero"" care este un \nnumăr.\nDacă valoarea NULL este utilizată într-o comparaţie, \natunci operatorul de comparaţie trebuie să fie IS NULL sau IS \nNOT NULL altfel rezultatul este întotdeauna FALSE. \n 60\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care nu au comision. \nSELECT *\nFROM EMP\nWHERE comm IS NULL;\n 61\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care nu au \ncomision. \n 62\n\n\nClauza WHERE\nOperator Semnificatie\n!= diferit de (pt anumite S.O.)\n^= diferit de (pt anumite S.O.)\n<> diferit de\nNOT BETWEEN nu se afla intre 2 valori date\nNOT IN nu se afla intr-o lista\nNOT LIKE diferit de sirul\nIS NOT NULL nu este o valoare nula\n5.Negarea expresiilor \n 63\n\nClauza WHERE\nOrdinea de execuţie Operator\n1. Operatorii aritmetici\n2. Operatorii de concatenare\n3. Conditiile de comparare\n4. IS [NOT] NULL, LIKE, [NOT] IN\n5. [NOT] BETWEEN\n6. Operatorul logic NOT\n7. Operatorul logic AND\n8. Operatorul logic OR\nD. Prioritatea de execuţie \n 64\n\nClauza WHERE\nExemplu: \nSELECT *\nFROM EMP\nWHERE job = \'MANAGER\' OR job = \'ANALYST\'\nAND sal < 3000; \n 65\n\n\nClauza WHERE\nRezultatul obtinut -\n 66\n\n\nClauza WHERE\nDar ordinea se poate modifica dacă se folosesc \nparanteze. \nSELECT *\nFROM EMP\nWHERE (job = \'MANAGER\' OR job = \'ANALYST\')\nAND sal < 3000;\n 67\n\n\nClauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \n 68\n\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 69', '\n']","pentru a schimba ""Hansen"" în ""Nilsen"" în coloana ""LastName"" din tabelul ""Persons"", poți folosi următoarea instrucțiune SQL, bazată pe sintaxa `UPDATE` prezentată:

```sql
UPDATE Persons
SET LastName = 'Nilsen'
WHERE LastName = 'Hansen';
```
Această instrucțiune identifică înregistrările unde `LastName` este 'Hansen' și le actualizează cu valoarea 'Nilsen', asa cum este specificat in ""7.1.2. Actualizarea datelor dintr-o tabelă"".
",UPDATE Persons SET LastName='Nilsen' WHERE LastName='Hansen',0.4249999999858333,1.0,0.8997430949163321,0.5,0.11161133657801557,0.22535211267605632,0.86
60,Manual - Test 2,,,7,"Folosind SQL, cum se șterg înregistrările din tabelul ""Persons"" unde ""FirstName"" este ""Peter""?",DELETE FROM Persons WHERE FirstName = 'Peter',Este corect,,"['1. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '2. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '3. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '4. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '5. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '6. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '7. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '8. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '9. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '10. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n']","DELETE FROM Persons WHERE FirstName = 'Peter';
","Folosind SQL, cum se șterg înregistrările din tabelul ""Persons"" unde ""FirstName"" este ""Peter""?","['1. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '2. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '3. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '4. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '5. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '6. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n', '7. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '8. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '9. ', ""2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16\n\nExista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17\n\nExemplu 2 - Utilizarea unei secvente: \n• Pentru inserarea in baza de date in tabela de \ndepartamente vom folosi in cererea noastra SQL \nsecventa pe care am creat-o mai inainte. \n• Pentru inserare se va folosi cererea urmatoare:\nINSERT INTO dept(deptno, dname, loc)\nVALUES (dept_seq_1.NEXTVAL, 'Support', 'Timisoara');\nCurs - BAZE DE DATE 18\n\n\n1. Secventele\n• Pentru a putea sa vedem valoarea inserata se poate \nfolosi urmatoarea cerere:\nSELECT dept_seq_1.NEXTVAL \nFROM dual;\nCurs - BAZE DE DATE 19\n\n\n• Folosirea secventelor cu incarcare in prealabil in \nmemorie are avantajul ca viteza de raspuns creste din \npartea bazei de date. \n• Din pacate apar cu ocazia aceasta si unele probleme: \n– In momentul unei erori fizice a masinii pe care ruleaza baza \nde date informatiile care sunt pastrate in memorie sunt \npierdute si apar asa numitele gauri in secventa. \n– Astfel de gauri in secventa mai pot aparea in cazul in care se \nsterg inregistrari din baza de date, in cazul in care o cerere a \nesuat si sistemul trebuie sa se intoarca la valorile precedente \n(actiune de Rollback) sau in momentul in care o secventa este \nutilizata pentru mai multe tabele.\nCurs - BAZE DE DATE 20\n\nModificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21"", '\n', '10. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n']","DELETE FROM Persons WHERE FirstName = 'Peter';
",DELETE FROM Persons WHERE FirstName = 'Peter',0.0,0.0,0.8561205143717081,0.0,0.8408964152537145,1.0,
61,Manual - Test 2,,,8,"Folosind SQL, cum se returnează numărul de înregistrări din tabelul ""Persons""?",SELECT COUNT(*) FROM Persons,Este corect,,"['1. ', ""- SQL echivalent: SELECT * FROM Student JOIN Inscriere ON Student.ID = \nInscriere.StudentID; \n \n \n2.2 Studiu de caz: Utilizarea algebrei relaționale într-o companie de livrări \nO companie de livrări utilizează o bază de date relațională pentru a gestiona comenzile, clienții și \nlivratorii. Relațiile cheie sunt: \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    Status V ARCHAR(20), \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE Livrator ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \nInterogări pentru monitorizarea livrărilor: \nSELECT Client.Nume, Comanda.Status \nFROM Client \nJOIN Comanda ON Client.ID = Comanda.ClientID; \n \n \n \n2.3. SQL - Limbajul interogărilor \nLimbajul SQL (Structured Query Language) este standardul pentru interacțiunea cu bazele de \ndate relaționale. \n \n2.3.1 Crearea bazelor de date și a tabelelor \nCREATE DATABASE Universitate; \nUSE Universitate; \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Prenume V ARCHAR(50), \n    An INT \n); \n \nCREATE TABLE Curs ( \n\n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n2.3.2 Inserarea datelor \nINSERT INTO Student (ID, Nume, Prenume, An) V ALUES (1, 'Popescu', 'Ion', 2); \nINSERT INTO Curs (Cod, Denumire) V ALUES (101, 'Baze de date'); \nINSERT INTO Inscriere (StudentID, CursCod) V ALUES (1, 101); \n \n2.3.3 Interogarea bazelor de date \n-- Selectarea tuturor studenților \nSELECT * FROM Student; \n \n-- Selectarea studenților de anul 2 \nSELECT * FROM Student WHERE An = 2; \n \n-- Afișarea cursurilor la care este înscris un student \nSELECT Curs.Denumire  \nFROM Curs  \nJOIN Inscriere ON Curs.Cod = Inscriere.CursCod  \nWHERE Inscriere.StudentID = 1; \n \n \n3. Integritatea datelor \nIntegritatea datelor asigură corectitudinea și consistența acestora în cadrul bazei de date. Tipurile \nprincipale sunt: \n \n1. Integritatea entităților: Fiecare tabel trebuie să aibă un identificator unic. \n2. Integritatea referențială: Relațiile dintre tabele trebuie să fie menținute corect prin chei primare \nși străine. \n3. Integritatea domeniului: Valorile din coloane trebuie să respecte tipul de date definit."", '\n', '2. ', ""- SQL echivalent: SELECT * FROM Student JOIN Inscriere ON Student.ID = \nInscriere.StudentID; \n \n \n2.2 Studiu de caz: Utilizarea algebrei relaționale într-o companie de livrări \nO companie de livrări utilizează o bază de date relațională pentru a gestiona comenzile, clienții și \nlivratorii. Relațiile cheie sunt: \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    Status V ARCHAR(20), \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE Livrator ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \nInterogări pentru monitorizarea livrărilor: \nSELECT Client.Nume, Comanda.Status \nFROM Client \nJOIN Comanda ON Client.ID = Comanda.ClientID; \n \n \n \n2.3. SQL - Limbajul interogărilor \nLimbajul SQL (Structured Query Language) este standardul pentru interacțiunea cu bazele de \ndate relaționale. \n \n2.3.1 Crearea bazelor de date și a tabelelor \nCREATE DATABASE Universitate; \nUSE Universitate; \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Prenume V ARCHAR(50), \n    An INT \n); \n \nCREATE TABLE Curs ( \n\n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n2.3.2 Inserarea datelor \nINSERT INTO Student (ID, Nume, Prenume, An) V ALUES (1, 'Popescu', 'Ion', 2); \nINSERT INTO Curs (Cod, Denumire) V ALUES (101, 'Baze de date'); \nINSERT INTO Inscriere (StudentID, CursCod) V ALUES (1, 101); \n \n2.3.3 Interogarea bazelor de date \n-- Selectarea tuturor studenților \nSELECT * FROM Student; \n \n-- Selectarea studenților de anul 2 \nSELECT * FROM Student WHERE An = 2; \n \n-- Afișarea cursurilor la care este înscris un student \nSELECT Curs.Denumire  \nFROM Curs  \nJOIN Inscriere ON Curs.Cod = Inscriere.CursCod  \nWHERE Inscriere.StudentID = 1; \n \n \n3. Integritatea datelor \nIntegritatea datelor asigură corectitudinea și consistența acestora în cadrul bazei de date. Tipurile \nprincipale sunt: \n \n1. Integritatea entităților: Fiecare tabel trebuie să aibă un identificator unic. \n2. Integritatea referențială: Relațiile dintre tabele trebuie să fie menținute corect prin chei primare \nși străine. \n3. Integritatea domeniului: Valorile din coloane trebuie să respecte tipul de date definit."", '\n', '3. ', ""- SQL echivalent: SELECT * FROM Student JOIN Inscriere ON Student.ID = \nInscriere.StudentID; \n \n \n2.2 Studiu de caz: Utilizarea algebrei relaționale într-o companie de livrări \nO companie de livrări utilizează o bază de date relațională pentru a gestiona comenzile, clienții și \nlivratorii. Relațiile cheie sunt: \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    Status V ARCHAR(20), \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE Livrator ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \nInterogări pentru monitorizarea livrărilor: \nSELECT Client.Nume, Comanda.Status \nFROM Client \nJOIN Comanda ON Client.ID = Comanda.ClientID; \n \n \n \n2.3. SQL - Limbajul interogărilor \nLimbajul SQL (Structured Query Language) este standardul pentru interacțiunea cu bazele de \ndate relaționale. \n \n2.3.1 Crearea bazelor de date și a tabelelor \nCREATE DATABASE Universitate; \nUSE Universitate; \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Prenume V ARCHAR(50), \n    An INT \n); \n \nCREATE TABLE Curs ( \n\n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n2.3.2 Inserarea datelor \nINSERT INTO Student (ID, Nume, Prenume, An) V ALUES (1, 'Popescu', 'Ion', 2); \nINSERT INTO Curs (Cod, Denumire) V ALUES (101, 'Baze de date'); \nINSERT INTO Inscriere (StudentID, CursCod) V ALUES (1, 101); \n \n2.3.3 Interogarea bazelor de date \n-- Selectarea tuturor studenților \nSELECT * FROM Student; \n \n-- Selectarea studenților de anul 2 \nSELECT * FROM Student WHERE An = 2; \n \n-- Afișarea cursurilor la care este înscris un student \nSELECT Curs.Denumire  \nFROM Curs  \nJOIN Inscriere ON Curs.Cod = Inscriere.CursCod  \nWHERE Inscriere.StudentID = 1; \n \n \n3. Integritatea datelor \nIntegritatea datelor asigură corectitudinea și consistența acestora în cadrul bazei de date. Tipurile \nprincipale sunt: \n \n1. Integritatea entităților: Fiecare tabel trebuie să aibă un identificator unic. \n2. Integritatea referențială: Relațiile dintre tabele trebuie să fie menținute corect prin chei primare \nși străine. \n3. Integritatea domeniului: Valorile din coloane trebuie să respecte tipul de date definit."", '\n', '4. ', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13\n\nFuncţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 15\n\nFuncţii referitoare la o singură înregistrare\n4.2.1. Funcţii pentru şiruri de caractere \nAceste funcţii au ca argumente date de tip \ncaracter şi returnează date de tip VARCHAR2, \nCHAR sau NUMBER.\nCurs 4 - BAZE DE DATE 16\n\n4.2.1. Funcţii pentru şiruri de caractere\nCele mai importante funcţii caracter sunt:\nFunctie Descriere  \nLOWER(column|expression) converteste alfa caracterele din caractere mari in \ncaractere mici  \nUPPER(column|expression) converteste alfa caracterele din caractere mici in \ncaractere mari  \nINITCAP(column|expression) \nconverteste prima litera a fiecarui cuvant in \ncaractere mari si restul cuvantului in caractere \nmici  \nCONCAT(column1|expression1, \ncolumn2|expression2) \nfunctia este echivalentul operatorului de \nconcantenare (||)  \nSUBSTR(column|expression, m [, n]) returneaza un sir de n caractere incepand cu \ncaracterul aflat pe pozitia m  \nLENGTH(column|expression) returneaza numarul de caractere dintr-o expresie  \nINSTR(column|expression, \'string\', \n[m], [n]) \nreturneaza pozitia unui anumit sir, optional se \npoate incepe cautarea cu pozitia m sau cu a n-a \naparitie a sirului. m si n sunt prin definitie 1  \nREPLACE(text, search_string, \nreplacement_ string) \ncauta un anumit text intr-un sir de caractere si \ndaca il gaseste il inlocuieste  \n \nCurs 4 - BAZE DE DATE 17\n\nExemplu de utilizare a \nfuncţiei LENGTH:\nSELECT LENGTH(ename) \nFROM EMP; \nCurs 4 - BAZE DE DATE 18\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu de utilizare a funcţiei LENGTH – rezultatul \nobtinut: \nCurs 4 - BAZE DE DATE 19\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT \'Numele functiei pentru \'||UPPER(ename)||\'este \n\'||LOWER(job) AS ""DETALII ANGAJAT""\nFROM EMP; \nCurs 4 - BAZE DE DATE 20\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = \'MARTIN\';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere', '\n', '5. ', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13\n\nFuncţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 15\n\nFuncţii referitoare la o singură înregistrare\n4.2.1. Funcţii pentru şiruri de caractere \nAceste funcţii au ca argumente date de tip \ncaracter şi returnează date de tip VARCHAR2, \nCHAR sau NUMBER.\nCurs 4 - BAZE DE DATE 16\n\n4.2.1. Funcţii pentru şiruri de caractere\nCele mai importante funcţii caracter sunt:\nFunctie Descriere  \nLOWER(column|expression) converteste alfa caracterele din caractere mari in \ncaractere mici  \nUPPER(column|expression) converteste alfa caracterele din caractere mici in \ncaractere mari  \nINITCAP(column|expression) \nconverteste prima litera a fiecarui cuvant in \ncaractere mari si restul cuvantului in caractere \nmici  \nCONCAT(column1|expression1, \ncolumn2|expression2) \nfunctia este echivalentul operatorului de \nconcantenare (||)  \nSUBSTR(column|expression, m [, n]) returneaza un sir de n caractere incepand cu \ncaracterul aflat pe pozitia m  \nLENGTH(column|expression) returneaza numarul de caractere dintr-o expresie  \nINSTR(column|expression, \'string\', \n[m], [n]) \nreturneaza pozitia unui anumit sir, optional se \npoate incepe cautarea cu pozitia m sau cu a n-a \naparitie a sirului. m si n sunt prin definitie 1  \nREPLACE(text, search_string, \nreplacement_ string) \ncauta un anumit text intr-un sir de caractere si \ndaca il gaseste il inlocuieste  \n \nCurs 4 - BAZE DE DATE 17\n\nExemplu de utilizare a \nfuncţiei LENGTH:\nSELECT LENGTH(ename) \nFROM EMP; \nCurs 4 - BAZE DE DATE 18\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu de utilizare a funcţiei LENGTH – rezultatul \nobtinut: \nCurs 4 - BAZE DE DATE 19\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT \'Numele functiei pentru \'||UPPER(ename)||\'este \n\'||LOWER(job) AS ""DETALII ANGAJAT""\nFROM EMP; \nCurs 4 - BAZE DE DATE 20\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = \'MARTIN\';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere', '\n', '6. ', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13\n\nFuncţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 15\n\nFuncţii referitoare la o singură înregistrare\n4.2.1. Funcţii pentru şiruri de caractere \nAceste funcţii au ca argumente date de tip \ncaracter şi returnează date de tip VARCHAR2, \nCHAR sau NUMBER.\nCurs 4 - BAZE DE DATE 16\n\n4.2.1. Funcţii pentru şiruri de caractere\nCele mai importante funcţii caracter sunt:\nFunctie Descriere  \nLOWER(column|expression) converteste alfa caracterele din caractere mari in \ncaractere mici  \nUPPER(column|expression) converteste alfa caracterele din caractere mici in \ncaractere mari  \nINITCAP(column|expression) \nconverteste prima litera a fiecarui cuvant in \ncaractere mari si restul cuvantului in caractere \nmici  \nCONCAT(column1|expression1, \ncolumn2|expression2) \nfunctia este echivalentul operatorului de \nconcantenare (||)  \nSUBSTR(column|expression, m [, n]) returneaza un sir de n caractere incepand cu \ncaracterul aflat pe pozitia m  \nLENGTH(column|expression) returneaza numarul de caractere dintr-o expresie  \nINSTR(column|expression, \'string\', \n[m], [n]) \nreturneaza pozitia unui anumit sir, optional se \npoate incepe cautarea cu pozitia m sau cu a n-a \naparitie a sirului. m si n sunt prin definitie 1  \nREPLACE(text, search_string, \nreplacement_ string) \ncauta un anumit text intr-un sir de caractere si \ndaca il gaseste il inlocuieste  \n \nCurs 4 - BAZE DE DATE 17\n\nExemplu de utilizare a \nfuncţiei LENGTH:\nSELECT LENGTH(ename) \nFROM EMP; \nCurs 4 - BAZE DE DATE 18\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu de utilizare a funcţiei LENGTH – rezultatul \nobtinut: \nCurs 4 - BAZE DE DATE 19\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT \'Numele functiei pentru \'||UPPER(ename)||\'este \n\'||LOWER(job) AS ""DETALII ANGAJAT""\nFROM EMP; \nCurs 4 - BAZE DE DATE 20\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = \'MARTIN\';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere', '\n', '7. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '8. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '9. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '10. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n']","pentru a returna numărul de înregistrări din tabelul ""Persons"", poți folosi o interogare SELECT, dar nu ai informații despre structura exactă a acestui tabel sau despre o funcție specifică de agregare (cum ar fi COUNT) în contextul furnizat. Totuși, pentru a selecta toate înregistrările poți folosi `SELECT * FROM Student;`. Pentru a afla numărul de înregistrări, îți trebuie o funcție de agregare care nu se afla in contextul dat.
","Folosind SQL, cum se returnează numărul de înregistrări din tabelul ""Persons""?","['1. ', ""- SQL echivalent: SELECT * FROM Student JOIN Inscriere ON Student.ID = \nInscriere.StudentID; \n \n \n2.2 Studiu de caz: Utilizarea algebrei relaționale într-o companie de livrări \nO companie de livrări utilizează o bază de date relațională pentru a gestiona comenzile, clienții și \nlivratorii. Relațiile cheie sunt: \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    Status V ARCHAR(20), \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE Livrator ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \nInterogări pentru monitorizarea livrărilor: \nSELECT Client.Nume, Comanda.Status \nFROM Client \nJOIN Comanda ON Client.ID = Comanda.ClientID; \n \n \n \n2.3. SQL - Limbajul interogărilor \nLimbajul SQL (Structured Query Language) este standardul pentru interacțiunea cu bazele de \ndate relaționale. \n \n2.3.1 Crearea bazelor de date și a tabelelor \nCREATE DATABASE Universitate; \nUSE Universitate; \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Prenume V ARCHAR(50), \n    An INT \n); \n \nCREATE TABLE Curs ( \n\n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n2.3.2 Inserarea datelor \nINSERT INTO Student (ID, Nume, Prenume, An) V ALUES (1, 'Popescu', 'Ion', 2); \nINSERT INTO Curs (Cod, Denumire) V ALUES (101, 'Baze de date'); \nINSERT INTO Inscriere (StudentID, CursCod) V ALUES (1, 101); \n \n2.3.3 Interogarea bazelor de date \n-- Selectarea tuturor studenților \nSELECT * FROM Student; \n \n-- Selectarea studenților de anul 2 \nSELECT * FROM Student WHERE An = 2; \n \n-- Afișarea cursurilor la care este înscris un student \nSELECT Curs.Denumire  \nFROM Curs  \nJOIN Inscriere ON Curs.Cod = Inscriere.CursCod  \nWHERE Inscriere.StudentID = 1; \n \n \n3. Integritatea datelor \nIntegritatea datelor asigură corectitudinea și consistența acestora în cadrul bazei de date. Tipurile \nprincipale sunt: \n \n1. Integritatea entităților: Fiecare tabel trebuie să aibă un identificator unic. \n2. Integritatea referențială: Relațiile dintre tabele trebuie să fie menținute corect prin chei primare \nși străine. \n3. Integritatea domeniului: Valorile din coloane trebuie să respecte tipul de date definit."", '\n', '2. ', ""- SQL echivalent: SELECT * FROM Student JOIN Inscriere ON Student.ID = \nInscriere.StudentID; \n \n \n2.2 Studiu de caz: Utilizarea algebrei relaționale într-o companie de livrări \nO companie de livrări utilizează o bază de date relațională pentru a gestiona comenzile, clienții și \nlivratorii. Relațiile cheie sunt: \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    Status V ARCHAR(20), \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE Livrator ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \nInterogări pentru monitorizarea livrărilor: \nSELECT Client.Nume, Comanda.Status \nFROM Client \nJOIN Comanda ON Client.ID = Comanda.ClientID; \n \n \n \n2.3. SQL - Limbajul interogărilor \nLimbajul SQL (Structured Query Language) este standardul pentru interacțiunea cu bazele de \ndate relaționale. \n \n2.3.1 Crearea bazelor de date și a tabelelor \nCREATE DATABASE Universitate; \nUSE Universitate; \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Prenume V ARCHAR(50), \n    An INT \n); \n \nCREATE TABLE Curs ( \n\n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n2.3.2 Inserarea datelor \nINSERT INTO Student (ID, Nume, Prenume, An) V ALUES (1, 'Popescu', 'Ion', 2); \nINSERT INTO Curs (Cod, Denumire) V ALUES (101, 'Baze de date'); \nINSERT INTO Inscriere (StudentID, CursCod) V ALUES (1, 101); \n \n2.3.3 Interogarea bazelor de date \n-- Selectarea tuturor studenților \nSELECT * FROM Student; \n \n-- Selectarea studenților de anul 2 \nSELECT * FROM Student WHERE An = 2; \n \n-- Afișarea cursurilor la care este înscris un student \nSELECT Curs.Denumire  \nFROM Curs  \nJOIN Inscriere ON Curs.Cod = Inscriere.CursCod  \nWHERE Inscriere.StudentID = 1; \n \n \n3. Integritatea datelor \nIntegritatea datelor asigură corectitudinea și consistența acestora în cadrul bazei de date. Tipurile \nprincipale sunt: \n \n1. Integritatea entităților: Fiecare tabel trebuie să aibă un identificator unic. \n2. Integritatea referențială: Relațiile dintre tabele trebuie să fie menținute corect prin chei primare \nși străine. \n3. Integritatea domeniului: Valorile din coloane trebuie să respecte tipul de date definit."", '\n', '3. ', ""- SQL echivalent: SELECT * FROM Student JOIN Inscriere ON Student.ID = \nInscriere.StudentID; \n \n \n2.2 Studiu de caz: Utilizarea algebrei relaționale într-o companie de livrări \nO companie de livrări utilizează o bază de date relațională pentru a gestiona comenzile, clienții și \nlivratorii. Relațiile cheie sunt: \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    Status V ARCHAR(20), \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE Livrator ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \nInterogări pentru monitorizarea livrărilor: \nSELECT Client.Nume, Comanda.Status \nFROM Client \nJOIN Comanda ON Client.ID = Comanda.ClientID; \n \n \n \n2.3. SQL - Limbajul interogărilor \nLimbajul SQL (Structured Query Language) este standardul pentru interacțiunea cu bazele de \ndate relaționale. \n \n2.3.1 Crearea bazelor de date și a tabelelor \nCREATE DATABASE Universitate; \nUSE Universitate; \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Prenume V ARCHAR(50), \n    An INT \n); \n \nCREATE TABLE Curs ( \n\n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n2.3.2 Inserarea datelor \nINSERT INTO Student (ID, Nume, Prenume, An) V ALUES (1, 'Popescu', 'Ion', 2); \nINSERT INTO Curs (Cod, Denumire) V ALUES (101, 'Baze de date'); \nINSERT INTO Inscriere (StudentID, CursCod) V ALUES (1, 101); \n \n2.3.3 Interogarea bazelor de date \n-- Selectarea tuturor studenților \nSELECT * FROM Student; \n \n-- Selectarea studenților de anul 2 \nSELECT * FROM Student WHERE An = 2; \n \n-- Afișarea cursurilor la care este înscris un student \nSELECT Curs.Denumire  \nFROM Curs  \nJOIN Inscriere ON Curs.Cod = Inscriere.CursCod  \nWHERE Inscriere.StudentID = 1; \n \n \n3. Integritatea datelor \nIntegritatea datelor asigură corectitudinea și consistența acestora în cadrul bazei de date. Tipurile \nprincipale sunt: \n \n1. Integritatea entităților: Fiecare tabel trebuie să aibă un identificator unic. \n2. Integritatea referențială: Relațiile dintre tabele trebuie să fie menținute corect prin chei primare \nși străine. \n3. Integritatea domeniului: Valorile din coloane trebuie să respecte tipul de date definit."", '\n', '4. ', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13\n\nFuncţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 15\n\nFuncţii referitoare la o singură înregistrare\n4.2.1. Funcţii pentru şiruri de caractere \nAceste funcţii au ca argumente date de tip \ncaracter şi returnează date de tip VARCHAR2, \nCHAR sau NUMBER.\nCurs 4 - BAZE DE DATE 16\n\n4.2.1. Funcţii pentru şiruri de caractere\nCele mai importante funcţii caracter sunt:\nFunctie Descriere  \nLOWER(column|expression) converteste alfa caracterele din caractere mari in \ncaractere mici  \nUPPER(column|expression) converteste alfa caracterele din caractere mici in \ncaractere mari  \nINITCAP(column|expression) \nconverteste prima litera a fiecarui cuvant in \ncaractere mari si restul cuvantului in caractere \nmici  \nCONCAT(column1|expression1, \ncolumn2|expression2) \nfunctia este echivalentul operatorului de \nconcantenare (||)  \nSUBSTR(column|expression, m [, n]) returneaza un sir de n caractere incepand cu \ncaracterul aflat pe pozitia m  \nLENGTH(column|expression) returneaza numarul de caractere dintr-o expresie  \nINSTR(column|expression, \'string\', \n[m], [n]) \nreturneaza pozitia unui anumit sir, optional se \npoate incepe cautarea cu pozitia m sau cu a n-a \naparitie a sirului. m si n sunt prin definitie 1  \nREPLACE(text, search_string, \nreplacement_ string) \ncauta un anumit text intr-un sir de caractere si \ndaca il gaseste il inlocuieste  \n \nCurs 4 - BAZE DE DATE 17\n\nExemplu de utilizare a \nfuncţiei LENGTH:\nSELECT LENGTH(ename) \nFROM EMP; \nCurs 4 - BAZE DE DATE 18\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu de utilizare a funcţiei LENGTH – rezultatul \nobtinut: \nCurs 4 - BAZE DE DATE 19\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT \'Numele functiei pentru \'||UPPER(ename)||\'este \n\'||LOWER(job) AS ""DETALII ANGAJAT""\nFROM EMP; \nCurs 4 - BAZE DE DATE 20\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = \'MARTIN\';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere', '\n', '5. ', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13\n\nFuncţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 15\n\nFuncţii referitoare la o singură înregistrare\n4.2.1. Funcţii pentru şiruri de caractere \nAceste funcţii au ca argumente date de tip \ncaracter şi returnează date de tip VARCHAR2, \nCHAR sau NUMBER.\nCurs 4 - BAZE DE DATE 16\n\n4.2.1. Funcţii pentru şiruri de caractere\nCele mai importante funcţii caracter sunt:\nFunctie Descriere  \nLOWER(column|expression) converteste alfa caracterele din caractere mari in \ncaractere mici  \nUPPER(column|expression) converteste alfa caracterele din caractere mici in \ncaractere mari  \nINITCAP(column|expression) \nconverteste prima litera a fiecarui cuvant in \ncaractere mari si restul cuvantului in caractere \nmici  \nCONCAT(column1|expression1, \ncolumn2|expression2) \nfunctia este echivalentul operatorului de \nconcantenare (||)  \nSUBSTR(column|expression, m [, n]) returneaza un sir de n caractere incepand cu \ncaracterul aflat pe pozitia m  \nLENGTH(column|expression) returneaza numarul de caractere dintr-o expresie  \nINSTR(column|expression, \'string\', \n[m], [n]) \nreturneaza pozitia unui anumit sir, optional se \npoate incepe cautarea cu pozitia m sau cu a n-a \naparitie a sirului. m si n sunt prin definitie 1  \nREPLACE(text, search_string, \nreplacement_ string) \ncauta un anumit text intr-un sir de caractere si \ndaca il gaseste il inlocuieste  \n \nCurs 4 - BAZE DE DATE 17\n\nExemplu de utilizare a \nfuncţiei LENGTH:\nSELECT LENGTH(ename) \nFROM EMP; \nCurs 4 - BAZE DE DATE 18\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu de utilizare a funcţiei LENGTH – rezultatul \nobtinut: \nCurs 4 - BAZE DE DATE 19\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT \'Numele functiei pentru \'||UPPER(ename)||\'este \n\'||LOWER(job) AS ""DETALII ANGAJAT""\nFROM EMP; \nCurs 4 - BAZE DE DATE 20\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = \'MARTIN\';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere', '\n', '6. ', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 13\n\nFuncţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 15\n\nFuncţii referitoare la o singură înregistrare\n4.2.1. Funcţii pentru şiruri de caractere \nAceste funcţii au ca argumente date de tip \ncaracter şi returnează date de tip VARCHAR2, \nCHAR sau NUMBER.\nCurs 4 - BAZE DE DATE 16\n\n4.2.1. Funcţii pentru şiruri de caractere\nCele mai importante funcţii caracter sunt:\nFunctie Descriere  \nLOWER(column|expression) converteste alfa caracterele din caractere mari in \ncaractere mici  \nUPPER(column|expression) converteste alfa caracterele din caractere mici in \ncaractere mari  \nINITCAP(column|expression) \nconverteste prima litera a fiecarui cuvant in \ncaractere mari si restul cuvantului in caractere \nmici  \nCONCAT(column1|expression1, \ncolumn2|expression2) \nfunctia este echivalentul operatorului de \nconcantenare (||)  \nSUBSTR(column|expression, m [, n]) returneaza un sir de n caractere incepand cu \ncaracterul aflat pe pozitia m  \nLENGTH(column|expression) returneaza numarul de caractere dintr-o expresie  \nINSTR(column|expression, \'string\', \n[m], [n]) \nreturneaza pozitia unui anumit sir, optional se \npoate incepe cautarea cu pozitia m sau cu a n-a \naparitie a sirului. m si n sunt prin definitie 1  \nREPLACE(text, search_string, \nreplacement_ string) \ncauta un anumit text intr-un sir de caractere si \ndaca il gaseste il inlocuieste  \n \nCurs 4 - BAZE DE DATE 17\n\nExemplu de utilizare a \nfuncţiei LENGTH:\nSELECT LENGTH(ename) \nFROM EMP; \nCurs 4 - BAZE DE DATE 18\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu de utilizare a funcţiei LENGTH – rezultatul \nobtinut: \nCurs 4 - BAZE DE DATE 19\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT \'Numele functiei pentru \'||UPPER(ename)||\'este \n\'||LOWER(job) AS ""DETALII ANGAJAT""\nFROM EMP; \nCurs 4 - BAZE DE DATE 20\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = \'MARTIN\';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere', '\n', '7. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '8. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '9. ', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36\n\nIndecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37\n\n2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38\n\nDistrugerea indecșilor \n➢Indecsii pot fi distrusi relativ usor pentru ca nu este \nafectata structura sau datele bazei de date. \n➢Singura conditie necesara este ca userul care incearca \nsa execute aceasta actiune trebuie sa fie proprietarul \nindexului. \n➢De asemenea trebuie ca utilizatorul sa aiba dreptul de \nDROP ANY INDEX in cadrul sistemului de securitate. \n➢Distrugerea indecsilor este realizata utilizand \nurmatoarea interogare SQL:\nDROP INDEX nume_index; \nunde nume_index reprezinta numele indexului.\nCurs - BAZE DE DATE 39\n\n2. Indecșii\nIndecsii nu pot modificati. Din aceasta cauza in \nmomentul in care este necesara modificarea unui index \neste necesara distrugerea lui prealabila.\nExemplu - Distrugerea indexului creat\n➢Pentru distrugerea indexului pe care l-am creat intr-un \nexemplu anterior va trebui sa folosim urmatoarea \ncerere:\nDROP INDEX employees_name;\nCurs - BAZE DE DATE 40\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 41\n\n3. Sinonime\n➢Sinonimele sunt niste aliasuri pe care le putem \nadauga oricarui obiect din baza de date pentru a \nsimplifica accesul la aceasta resursa. \n➢Sinonimele sunt folosite pentru cazul in care exista in \ndiferite scheme din baza de date tabele cu mai multe \ndenumiri, cand denumirile obiectelor sunt foarte \nlungi si/sau greu de tinut minte de catre \nprogramatorul care trebuie sa le foloseasca si in alte \ncazuri. \nCurs - BAZE DE DATE 42\n\n3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43', '\n', '10. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n']","pentru a returna numărul de înregistrări din tabelul ""Persons"", poți folosi o interogare SELECT, dar nu ai informații despre structura exactă a acestui tabel sau despre o funcție specifică de agregare (cum ar fi COUNT) în contextul furnizat. Totuși, pentru a selecta toate înregistrările poți folosi `SELECT * FROM Student;`. Pentru a afla numărul de înregistrări, îți trebuie o funcție de agregare care nu se afla in contextul dat.
",SELECT COUNT(*) FROM Persons,0.0,0.0,0.0,0.6666666666666666,0.012443969494386206,0.07228915662650602,0.57
62,Manual - Test 2,,,9,Care este cel mai cunoscut tip de join?,INNER JOIN,Este corect,,"['1. ', ""6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 25\n\n\n6.1. SINGLE ROW SUBQUERIES\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nSELECT ename, sal\nFROM EMP\nWHERE deptno =\n    ( SELECT deptno\n       FROM DEPT\n       WHERE dname = 'RESEARCH' );\nCurs 6 - BAZE DE DATE 26\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 27\n\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n \n 6.1. SINGLE ROW SUBQUERIES\n \n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 28\n\n6.2. MULTIPLE ROW SUBQUERIES\n Sunt acele subinterogări care dau ca rezultat \nmai multe valori.\nFolosesc operatorii multiple row: \n1. IN\n2. ANY\n3. ALL\n  Operatorul NOT poate fi folosit în \ncombinaţie cu oricare dintre aceştia.\nCurs 6 - BAZE DE DATE 29\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât cel puţin o valoare dintre cele \nextrase de subquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate < ANY \n      ( SELECT hiredate\n          FROM EMP\n          GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 32\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY - Acest operator este \nfolosit atunci când dorim ca \ninterogarea exterioară să selecteze \nvalori egale, mai mici sau mai mari \ndecât cel puţin o valoare dintre cele \nextrase de subquery.\nCurs 6 - BAZE DE DATE 33\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n3. Operatorul ALL\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât toate valorile extrase de \nsubquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate > ALL \n     ( SELECT hiredate\n       FROM EMP\n       GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 34"", '\n', '2. ', ""6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 25\n\n\n6.1. SINGLE ROW SUBQUERIES\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nSELECT ename, sal\nFROM EMP\nWHERE deptno =\n    ( SELECT deptno\n       FROM DEPT\n       WHERE dname = 'RESEARCH' );\nCurs 6 - BAZE DE DATE 26\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 27\n\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n \n 6.1. SINGLE ROW SUBQUERIES\n \n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 28\n\n6.2. MULTIPLE ROW SUBQUERIES\n Sunt acele subinterogări care dau ca rezultat \nmai multe valori.\nFolosesc operatorii multiple row: \n1. IN\n2. ANY\n3. ALL\n  Operatorul NOT poate fi folosit în \ncombinaţie cu oricare dintre aceştia.\nCurs 6 - BAZE DE DATE 29\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât cel puţin o valoare dintre cele \nextrase de subquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate < ANY \n      ( SELECT hiredate\n          FROM EMP\n          GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 32\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY - Acest operator este \nfolosit atunci când dorim ca \ninterogarea exterioară să selecteze \nvalori egale, mai mici sau mai mari \ndecât cel puţin o valoare dintre cele \nextrase de subquery.\nCurs 6 - BAZE DE DATE 33\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n3. Operatorul ALL\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât toate valorile extrase de \nsubquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate > ALL \n     ( SELECT hiredate\n       FROM EMP\n       GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 34"", '\n', '3. ', ""6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 25\n\n\n6.1. SINGLE ROW SUBQUERIES\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nSELECT ename, sal\nFROM EMP\nWHERE deptno =\n    ( SELECT deptno\n       FROM DEPT\n       WHERE dname = 'RESEARCH' );\nCurs 6 - BAZE DE DATE 26\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 27\n\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n \n 6.1. SINGLE ROW SUBQUERIES\n \n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 28\n\n6.2. MULTIPLE ROW SUBQUERIES\n Sunt acele subinterogări care dau ca rezultat \nmai multe valori.\nFolosesc operatorii multiple row: \n1. IN\n2. ANY\n3. ALL\n  Operatorul NOT poate fi folosit în \ncombinaţie cu oricare dintre aceştia.\nCurs 6 - BAZE DE DATE 29\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât cel puţin o valoare dintre cele \nextrase de subquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate < ANY \n      ( SELECT hiredate\n          FROM EMP\n          GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 32\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY - Acest operator este \nfolosit atunci când dorim ca \ninterogarea exterioară să selecteze \nvalori egale, mai mici sau mai mari \ndecât cel puţin o valoare dintre cele \nextrase de subquery.\nCurs 6 - BAZE DE DATE 33\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n3. Operatorul ALL\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât toate valorile extrase de \nsubquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate > ALL \n     ( SELECT hiredate\n       FROM EMP\n       GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 34"", '\n']","cursurile menționează SINGLE ROW SUBQUERIES și MULTIPLE ROW SUBQUERIES, care folosesc operatorii IN, ANY, și ALL. Nu se specifica un anume tip ca fiid ""cel mai cunoscut""
",Care este cel mai cunoscut tip de join?,"['1. ', ""6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 25\n\n\n6.1. SINGLE ROW SUBQUERIES\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nSELECT ename, sal\nFROM EMP\nWHERE deptno =\n    ( SELECT deptno\n       FROM DEPT\n       WHERE dname = 'RESEARCH' );\nCurs 6 - BAZE DE DATE 26\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 27\n\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n \n 6.1. SINGLE ROW SUBQUERIES\n \n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 28\n\n6.2. MULTIPLE ROW SUBQUERIES\n Sunt acele subinterogări care dau ca rezultat \nmai multe valori.\nFolosesc operatorii multiple row: \n1. IN\n2. ANY\n3. ALL\n  Operatorul NOT poate fi folosit în \ncombinaţie cu oricare dintre aceştia.\nCurs 6 - BAZE DE DATE 29\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât cel puţin o valoare dintre cele \nextrase de subquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate < ANY \n      ( SELECT hiredate\n          FROM EMP\n          GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 32\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY - Acest operator este \nfolosit atunci când dorim ca \ninterogarea exterioară să selecteze \nvalori egale, mai mici sau mai mari \ndecât cel puţin o valoare dintre cele \nextrase de subquery.\nCurs 6 - BAZE DE DATE 33\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n3. Operatorul ALL\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât toate valorile extrase de \nsubquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate > ALL \n     ( SELECT hiredate\n       FROM EMP\n       GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 34"", '\n', '2. ', ""6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 25\n\n\n6.1. SINGLE ROW SUBQUERIES\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nSELECT ename, sal\nFROM EMP\nWHERE deptno =\n    ( SELECT deptno\n       FROM DEPT\n       WHERE dname = 'RESEARCH' );\nCurs 6 - BAZE DE DATE 26\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 27\n\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n \n 6.1. SINGLE ROW SUBQUERIES\n \n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 28\n\n6.2. MULTIPLE ROW SUBQUERIES\n Sunt acele subinterogări care dau ca rezultat \nmai multe valori.\nFolosesc operatorii multiple row: \n1. IN\n2. ANY\n3. ALL\n  Operatorul NOT poate fi folosit în \ncombinaţie cu oricare dintre aceştia.\nCurs 6 - BAZE DE DATE 29\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât cel puţin o valoare dintre cele \nextrase de subquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate < ANY \n      ( SELECT hiredate\n          FROM EMP\n          GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 32\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY - Acest operator este \nfolosit atunci când dorim ca \ninterogarea exterioară să selecteze \nvalori egale, mai mici sau mai mari \ndecât cel puţin o valoare dintre cele \nextrase de subquery.\nCurs 6 - BAZE DE DATE 33\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n3. Operatorul ALL\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât toate valorile extrase de \nsubquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate > ALL \n     ( SELECT hiredate\n       FROM EMP\n       GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 34"", '\n', '3. ', ""6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 25\n\n\n6.1. SINGLE ROW SUBQUERIES\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nSELECT ename, sal\nFROM EMP\nWHERE deptno =\n    ( SELECT deptno\n       FROM DEPT\n       WHERE dname = 'RESEARCH' );\nCurs 6 - BAZE DE DATE 26\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 27\n\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n \n 6.1. SINGLE ROW SUBQUERIES\n \n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 28\n\n6.2. MULTIPLE ROW SUBQUERIES\n Sunt acele subinterogări care dau ca rezultat \nmai multe valori.\nFolosesc operatorii multiple row: \n1. IN\n2. ANY\n3. ALL\n  Operatorul NOT poate fi folosit în \ncombinaţie cu oricare dintre aceştia.\nCurs 6 - BAZE DE DATE 29\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât cel puţin o valoare dintre cele \nextrase de subquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate < ANY \n      ( SELECT hiredate\n          FROM EMP\n          GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 32\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY - Acest operator este \nfolosit atunci când dorim ca \ninterogarea exterioară să selecteze \nvalori egale, mai mici sau mai mari \ndecât cel puţin o valoare dintre cele \nextrase de subquery.\nCurs 6 - BAZE DE DATE 33\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n3. Operatorul ALL\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât toate valorile extrase de \nsubquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate > ALL \n     ( SELECT hiredate\n       FROM EMP\n       GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 34"", '\n']","cursurile menționează SINGLE ROW SUBQUERIES și MULTIPLE ROW SUBQUERIES, care folosesc operatorii IN, ANY, și ALL. Nu se specifica un anume tip ca fiid ""cel mai cunoscut""
",INNER JOIN,0.0,0.0,0.0,0.75,0.0,0.0,0.4
63,Manual - Test 2,,,10,Ce operator este folosit pentru a selecta valori dintr-un interval?,BETWEEN,Este corect,,"['1. ', '6.2. MULTIPLE ROW SUBQUERIES\nVALORI NULL\n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci:\n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null.\n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic.\nCurs 6 - BAZE DE DATE 35\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi HAVING\n- Pot fi folosite cu subinterogările de tip multiple row.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) < ANY\n          ( SELECT sal\n             FROM EMP\n             WHERE deptno IN (10,20) );\nCurs 6 - BAZE DE DATE 36\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi \nHAVING\n- Pot fi folosite cu \nsubinterogările de tip \nmultiple row.\nCurs 6 - BAZE DE DATE 37\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\n  De asemenea, se poate folosi clauza GROUP BY intr-\no subinterogare\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > ALL\n    (SELECT MIN(sal)\n     FROM EMP\n     WHERE deptno < 40\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 38\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare\nCurs 6 - BAZE DE DATE 39\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi angajaţii ale căror salarii sunt \naceleaşi cu salariul minim din oricare (any) \ndepartament. \nSELECT ename\nFROM EMP\nWHERE sal = ANY\n    (SELECT MIN(sal)\n     FROM EMP\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 40\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi \nangajaţii ale căror salarii \nsunt aceleaşi cu (any) \ndepartament. salariul \nminim din oricare \nCurs 6 - BAZE DE DATE 41\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42\n\n6.2. MULTIPLE ROW SUBQUERIES\nSoluţia corectă este următoarea:\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) <\n  ( SELECT MIN(sal)\n    FROM EMP\n    WHERE deptno = 30);\nCurs 6 - BAZE DE DATE 43\n\nSubcereri multilinie \n• Subcererile multilinie returneaza mai mult decat o \nlinie. \n• Cu astfel de subinterogari trebuie folositi operatori \nmultilinie care pot prelucra una sau mai multe valori. \nOperatorii utilizati sunt: \n1. IN - egal cu oricare dintre membrii unei liste\n2. ANY/SOME - compara o valoare cu fiecare (vreo) \nvaloare returnata de subinterogare\n3. ALL - compara o valoare cu oricare (toate) din \nvalorile returnate de subinterogare\nCurs 6 - BAZE DE DATE 44', '\n', '2. ', '6.2. MULTIPLE ROW SUBQUERIES\nVALORI NULL\n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci:\n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null.\n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic.\nCurs 6 - BAZE DE DATE 35\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi HAVING\n- Pot fi folosite cu subinterogările de tip multiple row.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) < ANY\n          ( SELECT sal\n             FROM EMP\n             WHERE deptno IN (10,20) );\nCurs 6 - BAZE DE DATE 36\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi \nHAVING\n- Pot fi folosite cu \nsubinterogările de tip \nmultiple row.\nCurs 6 - BAZE DE DATE 37\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\n  De asemenea, se poate folosi clauza GROUP BY intr-\no subinterogare\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > ALL\n    (SELECT MIN(sal)\n     FROM EMP\n     WHERE deptno < 40\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 38\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare\nCurs 6 - BAZE DE DATE 39\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi angajaţii ale căror salarii sunt \naceleaşi cu salariul minim din oricare (any) \ndepartament. \nSELECT ename\nFROM EMP\nWHERE sal = ANY\n    (SELECT MIN(sal)\n     FROM EMP\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 40\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi \nangajaţii ale căror salarii \nsunt aceleaşi cu (any) \ndepartament. salariul \nminim din oricare \nCurs 6 - BAZE DE DATE 41\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42\n\n6.2. MULTIPLE ROW SUBQUERIES\nSoluţia corectă este următoarea:\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) <\n  ( SELECT MIN(sal)\n    FROM EMP\n    WHERE deptno = 30);\nCurs 6 - BAZE DE DATE 43\n\nSubcereri multilinie \n• Subcererile multilinie returneaza mai mult decat o \nlinie. \n• Cu astfel de subinterogari trebuie folositi operatori \nmultilinie care pot prelucra una sau mai multe valori. \nOperatorii utilizati sunt: \n1. IN - egal cu oricare dintre membrii unei liste\n2. ANY/SOME - compara o valoare cu fiecare (vreo) \nvaloare returnata de subinterogare\n3. ALL - compara o valoare cu oricare (toate) din \nvalorile returnate de subinterogare\nCurs 6 - BAZE DE DATE 44', '\n', '3. ', '6.2. MULTIPLE ROW SUBQUERIES\nVALORI NULL\n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci:\n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null.\n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic.\nCurs 6 - BAZE DE DATE 35\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi HAVING\n- Pot fi folosite cu subinterogările de tip multiple row.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) < ANY\n          ( SELECT sal\n             FROM EMP\n             WHERE deptno IN (10,20) );\nCurs 6 - BAZE DE DATE 36\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi \nHAVING\n- Pot fi folosite cu \nsubinterogările de tip \nmultiple row.\nCurs 6 - BAZE DE DATE 37\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\n  De asemenea, se poate folosi clauza GROUP BY intr-\no subinterogare\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > ALL\n    (SELECT MIN(sal)\n     FROM EMP\n     WHERE deptno < 40\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 38\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare\nCurs 6 - BAZE DE DATE 39\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi angajaţii ale căror salarii sunt \naceleaşi cu salariul minim din oricare (any) \ndepartament. \nSELECT ename\nFROM EMP\nWHERE sal = ANY\n    (SELECT MIN(sal)\n     FROM EMP\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 40\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi \nangajaţii ale căror salarii \nsunt aceleaşi cu (any) \ndepartament. salariul \nminim din oricare \nCurs 6 - BAZE DE DATE 41\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42\n\n6.2. MULTIPLE ROW SUBQUERIES\nSoluţia corectă este următoarea:\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) <\n  ( SELECT MIN(sal)\n    FROM EMP\n    WHERE deptno = 30);\nCurs 6 - BAZE DE DATE 43\n\nSubcereri multilinie \n• Subcererile multilinie returneaza mai mult decat o \nlinie. \n• Cu astfel de subinterogari trebuie folositi operatori \nmultilinie care pot prelucra una sau mai multe valori. \nOperatorii utilizati sunt: \n1. IN - egal cu oricare dintre membrii unei liste\n2. ANY/SOME - compara o valoare cu fiecare (vreo) \nvaloare returnata de subinterogare\n3. ALL - compara o valoare cu oricare (toate) din \nvalorile returnate de subinterogare\nCurs 6 - BAZE DE DATE 44', '\n', '4. ', 'Numarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55\n\n\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56\n\nExemplu \n Gasiti angajatii care au un salariu superior \nsalariului mediu al departamentului lor.\nSELECT ename, sal, deptno\nFROM EMP E\nWHERE sal >\n            ( SELECT AVG(sal)\n             FROM EMP\n             WHERE ( deptno = E.deptno ) )\nORDER BY deptno;\nCurs 6 - BAZE DE DATE 57\n\nExemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n\n\nValori de NULL intr-o subinterogare \n• In cazul in care subinterogarea returneaza \nvreuna din valori NULL si interogarea \nprincipala are operator NOT IN, atunci \ninterogarea principala nu va returna niciun \nrand. \n• Motivul este ca o comparatie cu NULL conduce \nla un rezultat NULL. \nCurs 6 - BAZE DE DATE 59\n\nExemplu \nGasiti angajatii care nu au subordonati. \nSELECT ename \nFROM EMP \nWHERE empno NOT IN\n                    ( SELECT mgr\n                         FROM EMP );\nCurs 6 - BAZE DE DATE 60\n\nExemplu \nGasiti angajatii care nu au \nsubordonati. \nCurs 6 - BAZE DE DATE 61\n\n\n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN. \n• De fapt operatorul NOT IN este echivalent cu <> ALL.\n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL). \nCurs 6 - BAZE DE DATE 62\n\nExemplu\nGasiti angajatii care au subordonati.\nSELECT ename\nFROM EMP \nWHERE empno IN\n               ( SELECT mgr\n                  FROM EMP );\nCurs 6 - BAZE DE DATE 63\n\nExemplu \nGasiti angajatii care au \nsubordonati.\nCurs 6 - BAZE DE DATE 64\n\n\n• In cazul utilizarii operatorului NOT IN in interogarea \nprincipala trebuie avut grija sa se excluda valorile NULL\ndin raspunsurile subcererii.\nExemplu \nGasiti angajatii care nu au subordonati. \nCurs 6 - BAZE DE DATE 65\n\nSELECT ename \n  FROM EMP \n  WHERE empno NOT IN\n                  ( SELECT mgr\n                    FROM EMP\n                    WHERE mgr IS NOT NULL );\nCurs 6 - BAZE DE DATE 66\n\n\nSfaturi în utilizarea subinterogarilor\n1. Includerea subinterogarilor în paranteze\n2. Plasarea subinterogarilor în partea dreapta a \noperatorului de comparare\n3. A nu se adauga clauza ORDER BY într-o \nsubinterogare\n4. Folosirea operatorilor single-row în subinterogari \nsingle-row\n5. Folosirea operatorilor multiple-row în \nsubinterogari multiple-row\nCurs 6 - BAZE DE DATE 67', '\n', '5. ', 'Numarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55\n\n\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56\n\nExemplu \n Gasiti angajatii care au un salariu superior \nsalariului mediu al departamentului lor.\nSELECT ename, sal, deptno\nFROM EMP E\nWHERE sal >\n            ( SELECT AVG(sal)\n             FROM EMP\n             WHERE ( deptno = E.deptno ) )\nORDER BY deptno;\nCurs 6 - BAZE DE DATE 57\n\nExemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n\n\nValori de NULL intr-o subinterogare \n• In cazul in care subinterogarea returneaza \nvreuna din valori NULL si interogarea \nprincipala are operator NOT IN, atunci \ninterogarea principala nu va returna niciun \nrand. \n• Motivul este ca o comparatie cu NULL conduce \nla un rezultat NULL. \nCurs 6 - BAZE DE DATE 59\n\nExemplu \nGasiti angajatii care nu au subordonati. \nSELECT ename \nFROM EMP \nWHERE empno NOT IN\n                    ( SELECT mgr\n                         FROM EMP );\nCurs 6 - BAZE DE DATE 60\n\nExemplu \nGasiti angajatii care nu au \nsubordonati. \nCurs 6 - BAZE DE DATE 61\n\n\n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN. \n• De fapt operatorul NOT IN este echivalent cu <> ALL.\n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL). \nCurs 6 - BAZE DE DATE 62\n\nExemplu\nGasiti angajatii care au subordonati.\nSELECT ename\nFROM EMP \nWHERE empno IN\n               ( SELECT mgr\n                  FROM EMP );\nCurs 6 - BAZE DE DATE 63\n\nExemplu \nGasiti angajatii care au \nsubordonati.\nCurs 6 - BAZE DE DATE 64\n\n\n• In cazul utilizarii operatorului NOT IN in interogarea \nprincipala trebuie avut grija sa se excluda valorile NULL\ndin raspunsurile subcererii.\nExemplu \nGasiti angajatii care nu au subordonati. \nCurs 6 - BAZE DE DATE 65\n\nSELECT ename \n  FROM EMP \n  WHERE empno NOT IN\n                  ( SELECT mgr\n                    FROM EMP\n                    WHERE mgr IS NOT NULL );\nCurs 6 - BAZE DE DATE 66\n\n\nSfaturi în utilizarea subinterogarilor\n1. Includerea subinterogarilor în paranteze\n2. Plasarea subinterogarilor în partea dreapta a \noperatorului de comparare\n3. A nu se adauga clauza ORDER BY într-o \nsubinterogare\n4. Folosirea operatorilor single-row în subinterogari \nsingle-row\n5. Folosirea operatorilor multiple-row în \nsubinterogari multiple-row\nCurs 6 - BAZE DE DATE 67', '\n', '6. ', 'Numarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55\n\n\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56\n\nExemplu \n Gasiti angajatii care au un salariu superior \nsalariului mediu al departamentului lor.\nSELECT ename, sal, deptno\nFROM EMP E\nWHERE sal >\n            ( SELECT AVG(sal)\n             FROM EMP\n             WHERE ( deptno = E.deptno ) )\nORDER BY deptno;\nCurs 6 - BAZE DE DATE 57\n\nExemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n\n\nValori de NULL intr-o subinterogare \n• In cazul in care subinterogarea returneaza \nvreuna din valori NULL si interogarea \nprincipala are operator NOT IN, atunci \ninterogarea principala nu va returna niciun \nrand. \n• Motivul este ca o comparatie cu NULL conduce \nla un rezultat NULL. \nCurs 6 - BAZE DE DATE 59\n\nExemplu \nGasiti angajatii care nu au subordonati. \nSELECT ename \nFROM EMP \nWHERE empno NOT IN\n                    ( SELECT mgr\n                         FROM EMP );\nCurs 6 - BAZE DE DATE 60\n\nExemplu \nGasiti angajatii care nu au \nsubordonati. \nCurs 6 - BAZE DE DATE 61\n\n\n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN. \n• De fapt operatorul NOT IN este echivalent cu <> ALL.\n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL). \nCurs 6 - BAZE DE DATE 62\n\nExemplu\nGasiti angajatii care au subordonati.\nSELECT ename\nFROM EMP \nWHERE empno IN\n               ( SELECT mgr\n                  FROM EMP );\nCurs 6 - BAZE DE DATE 63\n\nExemplu \nGasiti angajatii care au \nsubordonati.\nCurs 6 - BAZE DE DATE 64\n\n\n• In cazul utilizarii operatorului NOT IN in interogarea \nprincipala trebuie avut grija sa se excluda valorile NULL\ndin raspunsurile subcererii.\nExemplu \nGasiti angajatii care nu au subordonati. \nCurs 6 - BAZE DE DATE 65\n\nSELECT ename \n  FROM EMP \n  WHERE empno NOT IN\n                  ( SELECT mgr\n                    FROM EMP\n                    WHERE mgr IS NOT NULL );\nCurs 6 - BAZE DE DATE 66\n\n\nSfaturi în utilizarea subinterogarilor\n1. Includerea subinterogarilor în paranteze\n2. Plasarea subinterogarilor în partea dreapta a \noperatorului de comparare\n3. A nu se adauga clauza ORDER BY într-o \nsubinterogare\n4. Folosirea operatorilor single-row în subinterogari \nsingle-row\n5. Folosirea operatorilor multiple-row în \nsubinterogari multiple-row\nCurs 6 - BAZE DE DATE 67', '\n', '7. ', 'ROUND(a, b) - rotunjeşte valoarea lui a la un număr de cifre \nprecizat prin parametrul b. \nDacă al doilea parametru este un număr pozitiv, atunci se vor \npăstra din a primele b zecimale, ultima dintre aceste cifre fiind \nrotunjită, în funcţie de următoarea zecimală. \nAl doilea argument poate fi o valoare negativă, rotunjirea \nfăcându-se la stânga punctului zecimal. \nCifra a |b|+1 din faţa punctului zecimal (numărând de la punctul \nzecimal spre stânga începând cu 1) va fi rotunjită în funcţie \ncifra aflată imediat la dreapta ei. \nPrimele |b| cifre din stânga punctului zecimal vor deveni 0. Cel \nde al doilea argument este opţional, în cazul în care nu se \nprecizează, este considerată implicit valoarea 0.\nCurs 4 - BAZE DE DATE 43\n4.2.2. Funcţii de tip numeric\n\nExemple:\nselect round(789.123,2), round(789.126,2), round(789.126,-1), \nround(789.126,-2), round(789.126,-3), round(789.126,-4), \nround(789.126,0), round(789.826,0), round(789.826)\nfrom dual\nCurs 4 - BAZE DE DATE 44\n4.2.2. Funcţii de tip numeric\n\nTRUNC(a, b) - este asemănătoare cu funcţia ROUND, fără a \nrotunji ultima cifră.\nExemple:\nselect trunc(789.123,2), trunc(789.126,2), trunc(789.126,-1), \ntrunc(789.126,-2), trunc(789.126,-3), trunc(789.126,-4), \ntrunc(789.126,0), trunc(789.826,0), trunc(789.826)\nfrom dual\nCurs 4 - BAZE DE DATE 45\n4.2.2. Funcţii de tip numeric\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 46\n\nAceste funcţii au ca argumente date de tip \nDATE şi returnează date de tip DATE.\nCurs 4 - BAZE DE DATE 47\n4.2.3. Funcţii de tip dată calendaristică şi oră\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nCele mai importante funcţii de tip data calendaristica si timp sunt:\n \nCurs 4 - BAZE DE DATE 48\nhttps://docs.oracle.com/cloud/help/ro/analytics-cloud/ACUBI/GUID-4CBCE8D4-CF17-43BD-AAEF-C5D614A8040A.htm#GUID-1A697795-7D1E-\n4296-961A-1002FDBD4F47\nFunctie Descriere \nADD_MONTHS(column|expression, n) Adauga un numar n de luni unei date \ncalendaristice \nLAST_DAY(column|expression) Determina care este ultima zi dintr-o luna \nMONTHS_BETWEEN(data_inceput, data_sfarsit) Determina cate luni sunt intre doua date \ncalendaristice \nNEXT_DAY(column|expression, char) Returneaza ziua urmatoare datei transmise ca\nargument pe baza char\nROUND(column|expression) Rotunjeste data calendaristica\nTRUNC(column|expression) Trunchiaza data calendaristica\nSYSDATE Returneaza data calendaristica curenta\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia ADD_MONTHS - exemplu:\nSELECT ADD_MONTHS(SYSDATE,3)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 49\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia LAST_DAY- exemplu:\nSELECT LAST_DAY(SYSDATE)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 50', '\n', '8. ', 'ROUND(a, b) - rotunjeşte valoarea lui a la un număr de cifre \nprecizat prin parametrul b. \nDacă al doilea parametru este un număr pozitiv, atunci se vor \npăstra din a primele b zecimale, ultima dintre aceste cifre fiind \nrotunjită, în funcţie de următoarea zecimală. \nAl doilea argument poate fi o valoare negativă, rotunjirea \nfăcându-se la stânga punctului zecimal. \nCifra a |b|+1 din faţa punctului zecimal (numărând de la punctul \nzecimal spre stânga începând cu 1) va fi rotunjită în funcţie \ncifra aflată imediat la dreapta ei. \nPrimele |b| cifre din stânga punctului zecimal vor deveni 0. Cel \nde al doilea argument este opţional, în cazul în care nu se \nprecizează, este considerată implicit valoarea 0.\nCurs 4 - BAZE DE DATE 43\n4.2.2. Funcţii de tip numeric\n\nExemple:\nselect round(789.123,2), round(789.126,2), round(789.126,-1), \nround(789.126,-2), round(789.126,-3), round(789.126,-4), \nround(789.126,0), round(789.826,0), round(789.826)\nfrom dual\nCurs 4 - BAZE DE DATE 44\n4.2.2. Funcţii de tip numeric\n\nTRUNC(a, b) - este asemănătoare cu funcţia ROUND, fără a \nrotunji ultima cifră.\nExemple:\nselect trunc(789.123,2), trunc(789.126,2), trunc(789.126,-1), \ntrunc(789.126,-2), trunc(789.126,-3), trunc(789.126,-4), \ntrunc(789.126,0), trunc(789.826,0), trunc(789.826)\nfrom dual\nCurs 4 - BAZE DE DATE 45\n4.2.2. Funcţii de tip numeric\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 46\n\nAceste funcţii au ca argumente date de tip \nDATE şi returnează date de tip DATE.\nCurs 4 - BAZE DE DATE 47\n4.2.3. Funcţii de tip dată calendaristică şi oră\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nCele mai importante funcţii de tip data calendaristica si timp sunt:\n \nCurs 4 - BAZE DE DATE 48\nhttps://docs.oracle.com/cloud/help/ro/analytics-cloud/ACUBI/GUID-4CBCE8D4-CF17-43BD-AAEF-C5D614A8040A.htm#GUID-1A697795-7D1E-\n4296-961A-1002FDBD4F47\nFunctie Descriere \nADD_MONTHS(column|expression, n) Adauga un numar n de luni unei date \ncalendaristice \nLAST_DAY(column|expression) Determina care este ultima zi dintr-o luna \nMONTHS_BETWEEN(data_inceput, data_sfarsit) Determina cate luni sunt intre doua date \ncalendaristice \nNEXT_DAY(column|expression, char) Returneaza ziua urmatoare datei transmise ca\nargument pe baza char\nROUND(column|expression) Rotunjeste data calendaristica\nTRUNC(column|expression) Trunchiaza data calendaristica\nSYSDATE Returneaza data calendaristica curenta\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia ADD_MONTHS - exemplu:\nSELECT ADD_MONTHS(SYSDATE,3)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 49\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia LAST_DAY- exemplu:\nSELECT LAST_DAY(SYSDATE)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 50', '\n', '9. ', 'ROUND(a, b) - rotunjeşte valoarea lui a la un număr de cifre \nprecizat prin parametrul b. \nDacă al doilea parametru este un număr pozitiv, atunci se vor \npăstra din a primele b zecimale, ultima dintre aceste cifre fiind \nrotunjită, în funcţie de următoarea zecimală. \nAl doilea argument poate fi o valoare negativă, rotunjirea \nfăcându-se la stânga punctului zecimal. \nCifra a |b|+1 din faţa punctului zecimal (numărând de la punctul \nzecimal spre stânga începând cu 1) va fi rotunjită în funcţie \ncifra aflată imediat la dreapta ei. \nPrimele |b| cifre din stânga punctului zecimal vor deveni 0. Cel \nde al doilea argument este opţional, în cazul în care nu se \nprecizează, este considerată implicit valoarea 0.\nCurs 4 - BAZE DE DATE 43\n4.2.2. Funcţii de tip numeric\n\nExemple:\nselect round(789.123,2), round(789.126,2), round(789.126,-1), \nround(789.126,-2), round(789.126,-3), round(789.126,-4), \nround(789.126,0), round(789.826,0), round(789.826)\nfrom dual\nCurs 4 - BAZE DE DATE 44\n4.2.2. Funcţii de tip numeric\n\nTRUNC(a, b) - este asemănătoare cu funcţia ROUND, fără a \nrotunji ultima cifră.\nExemple:\nselect trunc(789.123,2), trunc(789.126,2), trunc(789.126,-1), \ntrunc(789.126,-2), trunc(789.126,-3), trunc(789.126,-4), \ntrunc(789.126,0), trunc(789.826,0), trunc(789.826)\nfrom dual\nCurs 4 - BAZE DE DATE 45\n4.2.2. Funcţii de tip numeric\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 46\n\nAceste funcţii au ca argumente date de tip \nDATE şi returnează date de tip DATE.\nCurs 4 - BAZE DE DATE 47\n4.2.3. Funcţii de tip dată calendaristică şi oră\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nCele mai importante funcţii de tip data calendaristica si timp sunt:\n \nCurs 4 - BAZE DE DATE 48\nhttps://docs.oracle.com/cloud/help/ro/analytics-cloud/ACUBI/GUID-4CBCE8D4-CF17-43BD-AAEF-C5D614A8040A.htm#GUID-1A697795-7D1E-\n4296-961A-1002FDBD4F47\nFunctie Descriere \nADD_MONTHS(column|expression, n) Adauga un numar n de luni unei date \ncalendaristice \nLAST_DAY(column|expression) Determina care este ultima zi dintr-o luna \nMONTHS_BETWEEN(data_inceput, data_sfarsit) Determina cate luni sunt intre doua date \ncalendaristice \nNEXT_DAY(column|expression, char) Returneaza ziua urmatoare datei transmise ca\nargument pe baza char\nROUND(column|expression) Rotunjeste data calendaristica\nTRUNC(column|expression) Trunchiaza data calendaristica\nSYSDATE Returneaza data calendaristica curenta\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia ADD_MONTHS - exemplu:\nSELECT ADD_MONTHS(SYSDATE,3)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 49\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia LAST_DAY- exemplu:\nSELECT LAST_DAY(SYSDATE)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 50', '\n', '10. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n']","operatorii utilizați pentru a selecta valori dintr-un interval sunt: IN, ANY/SOME, ALL.
",Ce operator este folosit pentru a selecta valori dintr-un interval?,"['1. ', '6.2. MULTIPLE ROW SUBQUERIES\nVALORI NULL\n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci:\n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null.\n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic.\nCurs 6 - BAZE DE DATE 35\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi HAVING\n- Pot fi folosite cu subinterogările de tip multiple row.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) < ANY\n          ( SELECT sal\n             FROM EMP\n             WHERE deptno IN (10,20) );\nCurs 6 - BAZE DE DATE 36\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi \nHAVING\n- Pot fi folosite cu \nsubinterogările de tip \nmultiple row.\nCurs 6 - BAZE DE DATE 37\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\n  De asemenea, se poate folosi clauza GROUP BY intr-\no subinterogare\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > ALL\n    (SELECT MIN(sal)\n     FROM EMP\n     WHERE deptno < 40\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 38\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare\nCurs 6 - BAZE DE DATE 39\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi angajaţii ale căror salarii sunt \naceleaşi cu salariul minim din oricare (any) \ndepartament. \nSELECT ename\nFROM EMP\nWHERE sal = ANY\n    (SELECT MIN(sal)\n     FROM EMP\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 40\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi \nangajaţii ale căror salarii \nsunt aceleaşi cu (any) \ndepartament. salariul \nminim din oricare \nCurs 6 - BAZE DE DATE 41\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42\n\n6.2. MULTIPLE ROW SUBQUERIES\nSoluţia corectă este următoarea:\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) <\n  ( SELECT MIN(sal)\n    FROM EMP\n    WHERE deptno = 30);\nCurs 6 - BAZE DE DATE 43\n\nSubcereri multilinie \n• Subcererile multilinie returneaza mai mult decat o \nlinie. \n• Cu astfel de subinterogari trebuie folositi operatori \nmultilinie care pot prelucra una sau mai multe valori. \nOperatorii utilizati sunt: \n1. IN - egal cu oricare dintre membrii unei liste\n2. ANY/SOME - compara o valoare cu fiecare (vreo) \nvaloare returnata de subinterogare\n3. ALL - compara o valoare cu oricare (toate) din \nvalorile returnate de subinterogare\nCurs 6 - BAZE DE DATE 44', '\n', '2. ', '6.2. MULTIPLE ROW SUBQUERIES\nVALORI NULL\n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci:\n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null.\n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic.\nCurs 6 - BAZE DE DATE 35\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi HAVING\n- Pot fi folosite cu subinterogările de tip multiple row.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) < ANY\n          ( SELECT sal\n             FROM EMP\n             WHERE deptno IN (10,20) );\nCurs 6 - BAZE DE DATE 36\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi \nHAVING\n- Pot fi folosite cu \nsubinterogările de tip \nmultiple row.\nCurs 6 - BAZE DE DATE 37\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\n  De asemenea, se poate folosi clauza GROUP BY intr-\no subinterogare\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > ALL\n    (SELECT MIN(sal)\n     FROM EMP\n     WHERE deptno < 40\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 38\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare\nCurs 6 - BAZE DE DATE 39\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi angajaţii ale căror salarii sunt \naceleaşi cu salariul minim din oricare (any) \ndepartament. \nSELECT ename\nFROM EMP\nWHERE sal = ANY\n    (SELECT MIN(sal)\n     FROM EMP\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 40\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi \nangajaţii ale căror salarii \nsunt aceleaşi cu (any) \ndepartament. salariul \nminim din oricare \nCurs 6 - BAZE DE DATE 41\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42\n\n6.2. MULTIPLE ROW SUBQUERIES\nSoluţia corectă este următoarea:\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) <\n  ( SELECT MIN(sal)\n    FROM EMP\n    WHERE deptno = 30);\nCurs 6 - BAZE DE DATE 43\n\nSubcereri multilinie \n• Subcererile multilinie returneaza mai mult decat o \nlinie. \n• Cu astfel de subinterogari trebuie folositi operatori \nmultilinie care pot prelucra una sau mai multe valori. \nOperatorii utilizati sunt: \n1. IN - egal cu oricare dintre membrii unei liste\n2. ANY/SOME - compara o valoare cu fiecare (vreo) \nvaloare returnata de subinterogare\n3. ALL - compara o valoare cu oricare (toate) din \nvalorile returnate de subinterogare\nCurs 6 - BAZE DE DATE 44', '\n', '3. ', '6.2. MULTIPLE ROW SUBQUERIES\nVALORI NULL\n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci:\n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null.\n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic.\nCurs 6 - BAZE DE DATE 35\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi HAVING\n- Pot fi folosite cu subinterogările de tip multiple row.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) < ANY\n          ( SELECT sal\n             FROM EMP\n             WHERE deptno IN (10,20) );\nCurs 6 - BAZE DE DATE 36\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi \nHAVING\n- Pot fi folosite cu \nsubinterogările de tip \nmultiple row.\nCurs 6 - BAZE DE DATE 37\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\n  De asemenea, se poate folosi clauza GROUP BY intr-\no subinterogare\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > ALL\n    (SELECT MIN(sal)\n     FROM EMP\n     WHERE deptno < 40\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 38\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare\nCurs 6 - BAZE DE DATE 39\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi angajaţii ale căror salarii sunt \naceleaşi cu salariul minim din oricare (any) \ndepartament. \nSELECT ename\nFROM EMP\nWHERE sal = ANY\n    (SELECT MIN(sal)\n     FROM EMP\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 40\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi \nangajaţii ale căror salarii \nsunt aceleaşi cu (any) \ndepartament. salariul \nminim din oricare \nCurs 6 - BAZE DE DATE 41\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42\n\n6.2. MULTIPLE ROW SUBQUERIES\nSoluţia corectă este următoarea:\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) <\n  ( SELECT MIN(sal)\n    FROM EMP\n    WHERE deptno = 30);\nCurs 6 - BAZE DE DATE 43\n\nSubcereri multilinie \n• Subcererile multilinie returneaza mai mult decat o \nlinie. \n• Cu astfel de subinterogari trebuie folositi operatori \nmultilinie care pot prelucra una sau mai multe valori. \nOperatorii utilizati sunt: \n1. IN - egal cu oricare dintre membrii unei liste\n2. ANY/SOME - compara o valoare cu fiecare (vreo) \nvaloare returnata de subinterogare\n3. ALL - compara o valoare cu oricare (toate) din \nvalorile returnate de subinterogare\nCurs 6 - BAZE DE DATE 44', '\n', '4. ', 'Numarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55\n\n\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56\n\nExemplu \n Gasiti angajatii care au un salariu superior \nsalariului mediu al departamentului lor.\nSELECT ename, sal, deptno\nFROM EMP E\nWHERE sal >\n            ( SELECT AVG(sal)\n             FROM EMP\n             WHERE ( deptno = E.deptno ) )\nORDER BY deptno;\nCurs 6 - BAZE DE DATE 57\n\nExemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n\n\nValori de NULL intr-o subinterogare \n• In cazul in care subinterogarea returneaza \nvreuna din valori NULL si interogarea \nprincipala are operator NOT IN, atunci \ninterogarea principala nu va returna niciun \nrand. \n• Motivul este ca o comparatie cu NULL conduce \nla un rezultat NULL. \nCurs 6 - BAZE DE DATE 59\n\nExemplu \nGasiti angajatii care nu au subordonati. \nSELECT ename \nFROM EMP \nWHERE empno NOT IN\n                    ( SELECT mgr\n                         FROM EMP );\nCurs 6 - BAZE DE DATE 60\n\nExemplu \nGasiti angajatii care nu au \nsubordonati. \nCurs 6 - BAZE DE DATE 61\n\n\n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN. \n• De fapt operatorul NOT IN este echivalent cu <> ALL.\n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL). \nCurs 6 - BAZE DE DATE 62\n\nExemplu\nGasiti angajatii care au subordonati.\nSELECT ename\nFROM EMP \nWHERE empno IN\n               ( SELECT mgr\n                  FROM EMP );\nCurs 6 - BAZE DE DATE 63\n\nExemplu \nGasiti angajatii care au \nsubordonati.\nCurs 6 - BAZE DE DATE 64\n\n\n• In cazul utilizarii operatorului NOT IN in interogarea \nprincipala trebuie avut grija sa se excluda valorile NULL\ndin raspunsurile subcererii.\nExemplu \nGasiti angajatii care nu au subordonati. \nCurs 6 - BAZE DE DATE 65\n\nSELECT ename \n  FROM EMP \n  WHERE empno NOT IN\n                  ( SELECT mgr\n                    FROM EMP\n                    WHERE mgr IS NOT NULL );\nCurs 6 - BAZE DE DATE 66\n\n\nSfaturi în utilizarea subinterogarilor\n1. Includerea subinterogarilor în paranteze\n2. Plasarea subinterogarilor în partea dreapta a \noperatorului de comparare\n3. A nu se adauga clauza ORDER BY într-o \nsubinterogare\n4. Folosirea operatorilor single-row în subinterogari \nsingle-row\n5. Folosirea operatorilor multiple-row în \nsubinterogari multiple-row\nCurs 6 - BAZE DE DATE 67', '\n', '5. ', 'Numarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55\n\n\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56\n\nExemplu \n Gasiti angajatii care au un salariu superior \nsalariului mediu al departamentului lor.\nSELECT ename, sal, deptno\nFROM EMP E\nWHERE sal >\n            ( SELECT AVG(sal)\n             FROM EMP\n             WHERE ( deptno = E.deptno ) )\nORDER BY deptno;\nCurs 6 - BAZE DE DATE 57\n\nExemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n\n\nValori de NULL intr-o subinterogare \n• In cazul in care subinterogarea returneaza \nvreuna din valori NULL si interogarea \nprincipala are operator NOT IN, atunci \ninterogarea principala nu va returna niciun \nrand. \n• Motivul este ca o comparatie cu NULL conduce \nla un rezultat NULL. \nCurs 6 - BAZE DE DATE 59\n\nExemplu \nGasiti angajatii care nu au subordonati. \nSELECT ename \nFROM EMP \nWHERE empno NOT IN\n                    ( SELECT mgr\n                         FROM EMP );\nCurs 6 - BAZE DE DATE 60\n\nExemplu \nGasiti angajatii care nu au \nsubordonati. \nCurs 6 - BAZE DE DATE 61\n\n\n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN. \n• De fapt operatorul NOT IN este echivalent cu <> ALL.\n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL). \nCurs 6 - BAZE DE DATE 62\n\nExemplu\nGasiti angajatii care au subordonati.\nSELECT ename\nFROM EMP \nWHERE empno IN\n               ( SELECT mgr\n                  FROM EMP );\nCurs 6 - BAZE DE DATE 63\n\nExemplu \nGasiti angajatii care au \nsubordonati.\nCurs 6 - BAZE DE DATE 64\n\n\n• In cazul utilizarii operatorului NOT IN in interogarea \nprincipala trebuie avut grija sa se excluda valorile NULL\ndin raspunsurile subcererii.\nExemplu \nGasiti angajatii care nu au subordonati. \nCurs 6 - BAZE DE DATE 65\n\nSELECT ename \n  FROM EMP \n  WHERE empno NOT IN\n                  ( SELECT mgr\n                    FROM EMP\n                    WHERE mgr IS NOT NULL );\nCurs 6 - BAZE DE DATE 66\n\n\nSfaturi în utilizarea subinterogarilor\n1. Includerea subinterogarilor în paranteze\n2. Plasarea subinterogarilor în partea dreapta a \noperatorului de comparare\n3. A nu se adauga clauza ORDER BY într-o \nsubinterogare\n4. Folosirea operatorilor single-row în subinterogari \nsingle-row\n5. Folosirea operatorilor multiple-row în \nsubinterogari multiple-row\nCurs 6 - BAZE DE DATE 67', '\n', '6. ', 'Numarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55\n\n\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56\n\nExemplu \n Gasiti angajatii care au un salariu superior \nsalariului mediu al departamentului lor.\nSELECT ename, sal, deptno\nFROM EMP E\nWHERE sal >\n            ( SELECT AVG(sal)\n             FROM EMP\n             WHERE ( deptno = E.deptno ) )\nORDER BY deptno;\nCurs 6 - BAZE DE DATE 57\n\nExemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n\n\nValori de NULL intr-o subinterogare \n• In cazul in care subinterogarea returneaza \nvreuna din valori NULL si interogarea \nprincipala are operator NOT IN, atunci \ninterogarea principala nu va returna niciun \nrand. \n• Motivul este ca o comparatie cu NULL conduce \nla un rezultat NULL. \nCurs 6 - BAZE DE DATE 59\n\nExemplu \nGasiti angajatii care nu au subordonati. \nSELECT ename \nFROM EMP \nWHERE empno NOT IN\n                    ( SELECT mgr\n                         FROM EMP );\nCurs 6 - BAZE DE DATE 60\n\nExemplu \nGasiti angajatii care nu au \nsubordonati. \nCurs 6 - BAZE DE DATE 61\n\n\n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN. \n• De fapt operatorul NOT IN este echivalent cu <> ALL.\n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL). \nCurs 6 - BAZE DE DATE 62\n\nExemplu\nGasiti angajatii care au subordonati.\nSELECT ename\nFROM EMP \nWHERE empno IN\n               ( SELECT mgr\n                  FROM EMP );\nCurs 6 - BAZE DE DATE 63\n\nExemplu \nGasiti angajatii care au \nsubordonati.\nCurs 6 - BAZE DE DATE 64\n\n\n• In cazul utilizarii operatorului NOT IN in interogarea \nprincipala trebuie avut grija sa se excluda valorile NULL\ndin raspunsurile subcererii.\nExemplu \nGasiti angajatii care nu au subordonati. \nCurs 6 - BAZE DE DATE 65\n\nSELECT ename \n  FROM EMP \n  WHERE empno NOT IN\n                  ( SELECT mgr\n                    FROM EMP\n                    WHERE mgr IS NOT NULL );\nCurs 6 - BAZE DE DATE 66\n\n\nSfaturi în utilizarea subinterogarilor\n1. Includerea subinterogarilor în paranteze\n2. Plasarea subinterogarilor în partea dreapta a \noperatorului de comparare\n3. A nu se adauga clauza ORDER BY într-o \nsubinterogare\n4. Folosirea operatorilor single-row în subinterogari \nsingle-row\n5. Folosirea operatorilor multiple-row în \nsubinterogari multiple-row\nCurs 6 - BAZE DE DATE 67', '\n', '7. ', 'ROUND(a, b) - rotunjeşte valoarea lui a la un număr de cifre \nprecizat prin parametrul b. \nDacă al doilea parametru este un număr pozitiv, atunci se vor \npăstra din a primele b zecimale, ultima dintre aceste cifre fiind \nrotunjită, în funcţie de următoarea zecimală. \nAl doilea argument poate fi o valoare negativă, rotunjirea \nfăcându-se la stânga punctului zecimal. \nCifra a |b|+1 din faţa punctului zecimal (numărând de la punctul \nzecimal spre stânga începând cu 1) va fi rotunjită în funcţie \ncifra aflată imediat la dreapta ei. \nPrimele |b| cifre din stânga punctului zecimal vor deveni 0. Cel \nde al doilea argument este opţional, în cazul în care nu se \nprecizează, este considerată implicit valoarea 0.\nCurs 4 - BAZE DE DATE 43\n4.2.2. Funcţii de tip numeric\n\nExemple:\nselect round(789.123,2), round(789.126,2), round(789.126,-1), \nround(789.126,-2), round(789.126,-3), round(789.126,-4), \nround(789.126,0), round(789.826,0), round(789.826)\nfrom dual\nCurs 4 - BAZE DE DATE 44\n4.2.2. Funcţii de tip numeric\n\nTRUNC(a, b) - este asemănătoare cu funcţia ROUND, fără a \nrotunji ultima cifră.\nExemple:\nselect trunc(789.123,2), trunc(789.126,2), trunc(789.126,-1), \ntrunc(789.126,-2), trunc(789.126,-3), trunc(789.126,-4), \ntrunc(789.126,0), trunc(789.826,0), trunc(789.826)\nfrom dual\nCurs 4 - BAZE DE DATE 45\n4.2.2. Funcţii de tip numeric\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 46\n\nAceste funcţii au ca argumente date de tip \nDATE şi returnează date de tip DATE.\nCurs 4 - BAZE DE DATE 47\n4.2.3. Funcţii de tip dată calendaristică şi oră\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nCele mai importante funcţii de tip data calendaristica si timp sunt:\n \nCurs 4 - BAZE DE DATE 48\nhttps://docs.oracle.com/cloud/help/ro/analytics-cloud/ACUBI/GUID-4CBCE8D4-CF17-43BD-AAEF-C5D614A8040A.htm#GUID-1A697795-7D1E-\n4296-961A-1002FDBD4F47\nFunctie Descriere \nADD_MONTHS(column|expression, n) Adauga un numar n de luni unei date \ncalendaristice \nLAST_DAY(column|expression) Determina care este ultima zi dintr-o luna \nMONTHS_BETWEEN(data_inceput, data_sfarsit) Determina cate luni sunt intre doua date \ncalendaristice \nNEXT_DAY(column|expression, char) Returneaza ziua urmatoare datei transmise ca\nargument pe baza char\nROUND(column|expression) Rotunjeste data calendaristica\nTRUNC(column|expression) Trunchiaza data calendaristica\nSYSDATE Returneaza data calendaristica curenta\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia ADD_MONTHS - exemplu:\nSELECT ADD_MONTHS(SYSDATE,3)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 49\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia LAST_DAY- exemplu:\nSELECT LAST_DAY(SYSDATE)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 50', '\n', '8. ', 'ROUND(a, b) - rotunjeşte valoarea lui a la un număr de cifre \nprecizat prin parametrul b. \nDacă al doilea parametru este un număr pozitiv, atunci se vor \npăstra din a primele b zecimale, ultima dintre aceste cifre fiind \nrotunjită, în funcţie de următoarea zecimală. \nAl doilea argument poate fi o valoare negativă, rotunjirea \nfăcându-se la stânga punctului zecimal. \nCifra a |b|+1 din faţa punctului zecimal (numărând de la punctul \nzecimal spre stânga începând cu 1) va fi rotunjită în funcţie \ncifra aflată imediat la dreapta ei. \nPrimele |b| cifre din stânga punctului zecimal vor deveni 0. Cel \nde al doilea argument este opţional, în cazul în care nu se \nprecizează, este considerată implicit valoarea 0.\nCurs 4 - BAZE DE DATE 43\n4.2.2. Funcţii de tip numeric\n\nExemple:\nselect round(789.123,2), round(789.126,2), round(789.126,-1), \nround(789.126,-2), round(789.126,-3), round(789.126,-4), \nround(789.126,0), round(789.826,0), round(789.826)\nfrom dual\nCurs 4 - BAZE DE DATE 44\n4.2.2. Funcţii de tip numeric\n\nTRUNC(a, b) - este asemănătoare cu funcţia ROUND, fără a \nrotunji ultima cifră.\nExemple:\nselect trunc(789.123,2), trunc(789.126,2), trunc(789.126,-1), \ntrunc(789.126,-2), trunc(789.126,-3), trunc(789.126,-4), \ntrunc(789.126,0), trunc(789.826,0), trunc(789.826)\nfrom dual\nCurs 4 - BAZE DE DATE 45\n4.2.2. Funcţii de tip numeric\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 46\n\nAceste funcţii au ca argumente date de tip \nDATE şi returnează date de tip DATE.\nCurs 4 - BAZE DE DATE 47\n4.2.3. Funcţii de tip dată calendaristică şi oră\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nCele mai importante funcţii de tip data calendaristica si timp sunt:\n \nCurs 4 - BAZE DE DATE 48\nhttps://docs.oracle.com/cloud/help/ro/analytics-cloud/ACUBI/GUID-4CBCE8D4-CF17-43BD-AAEF-C5D614A8040A.htm#GUID-1A697795-7D1E-\n4296-961A-1002FDBD4F47\nFunctie Descriere \nADD_MONTHS(column|expression, n) Adauga un numar n de luni unei date \ncalendaristice \nLAST_DAY(column|expression) Determina care este ultima zi dintr-o luna \nMONTHS_BETWEEN(data_inceput, data_sfarsit) Determina cate luni sunt intre doua date \ncalendaristice \nNEXT_DAY(column|expression, char) Returneaza ziua urmatoare datei transmise ca\nargument pe baza char\nROUND(column|expression) Rotunjeste data calendaristica\nTRUNC(column|expression) Trunchiaza data calendaristica\nSYSDATE Returneaza data calendaristica curenta\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia ADD_MONTHS - exemplu:\nSELECT ADD_MONTHS(SYSDATE,3)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 49\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia LAST_DAY- exemplu:\nSELECT LAST_DAY(SYSDATE)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 50', '\n', '9. ', 'ROUND(a, b) - rotunjeşte valoarea lui a la un număr de cifre \nprecizat prin parametrul b. \nDacă al doilea parametru este un număr pozitiv, atunci se vor \npăstra din a primele b zecimale, ultima dintre aceste cifre fiind \nrotunjită, în funcţie de următoarea zecimală. \nAl doilea argument poate fi o valoare negativă, rotunjirea \nfăcându-se la stânga punctului zecimal. \nCifra a |b|+1 din faţa punctului zecimal (numărând de la punctul \nzecimal spre stânga începând cu 1) va fi rotunjită în funcţie \ncifra aflată imediat la dreapta ei. \nPrimele |b| cifre din stânga punctului zecimal vor deveni 0. Cel \nde al doilea argument este opţional, în cazul în care nu se \nprecizează, este considerată implicit valoarea 0.\nCurs 4 - BAZE DE DATE 43\n4.2.2. Funcţii de tip numeric\n\nExemple:\nselect round(789.123,2), round(789.126,2), round(789.126,-1), \nround(789.126,-2), round(789.126,-3), round(789.126,-4), \nround(789.126,0), round(789.826,0), round(789.826)\nfrom dual\nCurs 4 - BAZE DE DATE 44\n4.2.2. Funcţii de tip numeric\n\nTRUNC(a, b) - este asemănătoare cu funcţia ROUND, fără a \nrotunji ultima cifră.\nExemple:\nselect trunc(789.123,2), trunc(789.126,2), trunc(789.126,-1), \ntrunc(789.126,-2), trunc(789.126,-3), trunc(789.126,-4), \ntrunc(789.126,0), trunc(789.826,0), trunc(789.826)\nfrom dual\nCurs 4 - BAZE DE DATE 45\n4.2.2. Funcţii de tip numeric\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 46\n\nAceste funcţii au ca argumente date de tip \nDATE şi returnează date de tip DATE.\nCurs 4 - BAZE DE DATE 47\n4.2.3. Funcţii de tip dată calendaristică şi oră\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nCele mai importante funcţii de tip data calendaristica si timp sunt:\n \nCurs 4 - BAZE DE DATE 48\nhttps://docs.oracle.com/cloud/help/ro/analytics-cloud/ACUBI/GUID-4CBCE8D4-CF17-43BD-AAEF-C5D614A8040A.htm#GUID-1A697795-7D1E-\n4296-961A-1002FDBD4F47\nFunctie Descriere \nADD_MONTHS(column|expression, n) Adauga un numar n de luni unei date \ncalendaristice \nLAST_DAY(column|expression) Determina care este ultima zi dintr-o luna \nMONTHS_BETWEEN(data_inceput, data_sfarsit) Determina cate luni sunt intre doua date \ncalendaristice \nNEXT_DAY(column|expression, char) Returneaza ziua urmatoare datei transmise ca\nargument pe baza char\nROUND(column|expression) Rotunjeste data calendaristica\nTRUNC(column|expression) Trunchiaza data calendaristica\nSYSDATE Returneaza data calendaristica curenta\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia ADD_MONTHS - exemplu:\nSELECT ADD_MONTHS(SYSDATE,3)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 49\n\n\n4.2.3. Funcţii de tip dată calendaristică şi oră\nFunctia LAST_DAY- exemplu:\nSELECT LAST_DAY(SYSDATE)\nFROM DUAL;\n \nCurs 4 - BAZE DE DATE 50', '\n', '10. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n']","operatorii utilizați pentru a selecta valori dintr-un interval sunt: IN, ANY/SOME, ALL.
",BETWEEN,0.0,0.0,0.8858945862580492,1.0,0.0,0.0,0.0
64,Manual - Test 2,,,11,Constrângerea NOT NULL impune ca o coloană să nu accepte valori NULL.,Adevărat,Este corect,,"['1. ', 'CREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15\n\n\nAcum vom încerca să inserăm valori doar în coloanele \nEMPNO, SAL, COMM, dar la execuție ne va da eroare \npentru că ENAME şi HIREDATE au valori nule iar \nconstrângerile ne obligă să le atribuim o valoare.\nINSERT INTO emp_new(EMPNO, SAL, COMM)\nVALUES(50, 200, 5);\nCurs 8 - BAZE DE DATE 16\n\n\nConstrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17\n\nExemplu\n⮚În exemplul de mai jos se aplică constrângerea UNIQUE\ncoloanei JOB a tabelei emp_new1.\n⮚Numele constrângerii este UNIQUE.\nCREATE TABLE emp_new1(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nJOB varchar2(20) UNIQUE,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4)  NOT NULL );\nCurs 8 - BAZE DE DATE 18\n\n\nConstrângerea Cheie Primară\n• Constrângerea CHEIE PRIMARĂ(PRIMARY KEY)\ncreează o cheie primară pentru tabela. \n• Numai o singură cheie poate fi creată pentru fiecare \ntabela. \n• Această constrângere este o coloană sau un set de \ncoloane care identifică în mod unic fiecare rând al \ntabelului.\n• Nici o coloană care face parte din cheia primară nu \npoate conţine valoarea nulă. \n• Poate fi definită la nivel de coloană sau tabela. \nCurs 8 - BAZE DE DATE 19\n\nO tabela poate avea o singură cheie primară dar poate avea \nmai multe constrângeri de tip UNIQUE.\nExemplu\nÎn exemplul de mai jos este definită o constrângere de tip \ncheie primară la nivelul coloanei DEPTNO a tabelei DEPT1. \nNumele constrângerii este PRIMARY KEY.\nCREATE TABLE DEPT1 (\nDEPTNO number(6),\nDNAME varchar2(10), \nMGR number(6),\nPRIMARY KEY(DEPTNO) );\nCurs 8 - BAZE DE DATE 20\n\n\nConstrângerea FOREIGN KEY\n• Constrângerea FOREIGN KEY defineşte o coloană \nsau o combinaţie de coloane ca foreign key şi \nstabileşte o relaţie între o cheie primară şi una unică \nîn aceeaşi tabela sau în tabele diferite. \n• O valoare care apare într-o tabela trebuie să se \nregăsească şi în cea de-a 2-a tabela, pe coloana \nunde formează cheia primară. \n• Constrângerile de tip FOREIGN KEY pot fi definite la \nnivel de coloană sau tabela.\nCurs 8 - BAZE DE DATE 21\n\nExemplu\nÎn următorul exemplu se defineşte o constrângere \nde tip FOREIGN KEY coloanei DEPTNO a tabelei \nEMP_NEW2 utilizând sintaxa la nivel de tabela. \nCREATE TABLE EMP_NEW2(\nEMPNO number(6),\nENAME varchar2(10), \nSAL number(4),\nCOM number(4),\nJOB varchar2(25) UNIQUE,\nDEPTNO number(4), \nFOREIGN KEY(DEPTNO) REFERENCES DEPT (DEPTNO) );\nCurs 8 - BAZE DE DATE 22', '\n', '2. ', 'CREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15\n\n\nAcum vom încerca să inserăm valori doar în coloanele \nEMPNO, SAL, COMM, dar la execuție ne va da eroare \npentru că ENAME şi HIREDATE au valori nule iar \nconstrângerile ne obligă să le atribuim o valoare.\nINSERT INTO emp_new(EMPNO, SAL, COMM)\nVALUES(50, 200, 5);\nCurs 8 - BAZE DE DATE 16\n\n\nConstrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17\n\nExemplu\n⮚În exemplul de mai jos se aplică constrângerea UNIQUE\ncoloanei JOB a tabelei emp_new1.\n⮚Numele constrângerii este UNIQUE.\nCREATE TABLE emp_new1(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nJOB varchar2(20) UNIQUE,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4)  NOT NULL );\nCurs 8 - BAZE DE DATE 18\n\n\nConstrângerea Cheie Primară\n• Constrângerea CHEIE PRIMARĂ(PRIMARY KEY)\ncreează o cheie primară pentru tabela. \n• Numai o singură cheie poate fi creată pentru fiecare \ntabela. \n• Această constrângere este o coloană sau un set de \ncoloane care identifică în mod unic fiecare rând al \ntabelului.\n• Nici o coloană care face parte din cheia primară nu \npoate conţine valoarea nulă. \n• Poate fi definită la nivel de coloană sau tabela. \nCurs 8 - BAZE DE DATE 19\n\nO tabela poate avea o singură cheie primară dar poate avea \nmai multe constrângeri de tip UNIQUE.\nExemplu\nÎn exemplul de mai jos este definită o constrângere de tip \ncheie primară la nivelul coloanei DEPTNO a tabelei DEPT1. \nNumele constrângerii este PRIMARY KEY.\nCREATE TABLE DEPT1 (\nDEPTNO number(6),\nDNAME varchar2(10), \nMGR number(6),\nPRIMARY KEY(DEPTNO) );\nCurs 8 - BAZE DE DATE 20\n\n\nConstrângerea FOREIGN KEY\n• Constrângerea FOREIGN KEY defineşte o coloană \nsau o combinaţie de coloane ca foreign key şi \nstabileşte o relaţie între o cheie primară şi una unică \nîn aceeaşi tabela sau în tabele diferite. \n• O valoare care apare într-o tabela trebuie să se \nregăsească şi în cea de-a 2-a tabela, pe coloana \nunde formează cheia primară. \n• Constrângerile de tip FOREIGN KEY pot fi definite la \nnivel de coloană sau tabela.\nCurs 8 - BAZE DE DATE 21\n\nExemplu\nÎn următorul exemplu se defineşte o constrângere \nde tip FOREIGN KEY coloanei DEPTNO a tabelei \nEMP_NEW2 utilizând sintaxa la nivel de tabela. \nCREATE TABLE EMP_NEW2(\nEMPNO number(6),\nENAME varchar2(10), \nSAL number(4),\nCOM number(4),\nJOB varchar2(25) UNIQUE,\nDEPTNO number(4), \nFOREIGN KEY(DEPTNO) REFERENCES DEPT (DEPTNO) );\nCurs 8 - BAZE DE DATE 22', '\n', '3. ', 'CREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15\n\n\nAcum vom încerca să inserăm valori doar în coloanele \nEMPNO, SAL, COMM, dar la execuție ne va da eroare \npentru că ENAME şi HIREDATE au valori nule iar \nconstrângerile ne obligă să le atribuim o valoare.\nINSERT INTO emp_new(EMPNO, SAL, COMM)\nVALUES(50, 200, 5);\nCurs 8 - BAZE DE DATE 16\n\n\nConstrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17\n\nExemplu\n⮚În exemplul de mai jos se aplică constrângerea UNIQUE\ncoloanei JOB a tabelei emp_new1.\n⮚Numele constrângerii este UNIQUE.\nCREATE TABLE emp_new1(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nJOB varchar2(20) UNIQUE,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4)  NOT NULL );\nCurs 8 - BAZE DE DATE 18\n\n\nConstrângerea Cheie Primară\n• Constrângerea CHEIE PRIMARĂ(PRIMARY KEY)\ncreează o cheie primară pentru tabela. \n• Numai o singură cheie poate fi creată pentru fiecare \ntabela. \n• Această constrângere este o coloană sau un set de \ncoloane care identifică în mod unic fiecare rând al \ntabelului.\n• Nici o coloană care face parte din cheia primară nu \npoate conţine valoarea nulă. \n• Poate fi definită la nivel de coloană sau tabela. \nCurs 8 - BAZE DE DATE 19\n\nO tabela poate avea o singură cheie primară dar poate avea \nmai multe constrângeri de tip UNIQUE.\nExemplu\nÎn exemplul de mai jos este definită o constrângere de tip \ncheie primară la nivelul coloanei DEPTNO a tabelei DEPT1. \nNumele constrângerii este PRIMARY KEY.\nCREATE TABLE DEPT1 (\nDEPTNO number(6),\nDNAME varchar2(10), \nMGR number(6),\nPRIMARY KEY(DEPTNO) );\nCurs 8 - BAZE DE DATE 20\n\n\nConstrângerea FOREIGN KEY\n• Constrângerea FOREIGN KEY defineşte o coloană \nsau o combinaţie de coloane ca foreign key şi \nstabileşte o relaţie între o cheie primară şi una unică \nîn aceeaşi tabela sau în tabele diferite. \n• O valoare care apare într-o tabela trebuie să se \nregăsească şi în cea de-a 2-a tabela, pe coloana \nunde formează cheia primară. \n• Constrângerile de tip FOREIGN KEY pot fi definite la \nnivel de coloană sau tabela.\nCurs 8 - BAZE DE DATE 21\n\nExemplu\nÎn următorul exemplu se defineşte o constrângere \nde tip FOREIGN KEY coloanei DEPTNO a tabelei \nEMP_NEW2 utilizând sintaxa la nivel de tabela. \nCREATE TABLE EMP_NEW2(\nEMPNO number(6),\nENAME varchar2(10), \nSAL number(4),\nCOM number(4),\nJOB varchar2(25) UNIQUE,\nDEPTNO number(4), \nFOREIGN KEY(DEPTNO) REFERENCES DEPT (DEPTNO) );\nCurs 8 - BAZE DE DATE 22', '\n', '4. ', '6.2. MULTIPLE ROW SUBQUERIES\nVALORI NULL\n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci:\n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null.\n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic.\nCurs 6 - BAZE DE DATE 35\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi HAVING\n- Pot fi folosite cu subinterogările de tip multiple row.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) < ANY\n          ( SELECT sal\n             FROM EMP\n             WHERE deptno IN (10,20) );\nCurs 6 - BAZE DE DATE 36\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi \nHAVING\n- Pot fi folosite cu \nsubinterogările de tip \nmultiple row.\nCurs 6 - BAZE DE DATE 37\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\n  De asemenea, se poate folosi clauza GROUP BY intr-\no subinterogare\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > ALL\n    (SELECT MIN(sal)\n     FROM EMP\n     WHERE deptno < 40\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 38\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare\nCurs 6 - BAZE DE DATE 39\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi angajaţii ale căror salarii sunt \naceleaşi cu salariul minim din oricare (any) \ndepartament. \nSELECT ename\nFROM EMP\nWHERE sal = ANY\n    (SELECT MIN(sal)\n     FROM EMP\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 40\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi \nangajaţii ale căror salarii \nsunt aceleaşi cu (any) \ndepartament. salariul \nminim din oricare \nCurs 6 - BAZE DE DATE 41\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42\n\n6.2. MULTIPLE ROW SUBQUERIES\nSoluţia corectă este următoarea:\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) <\n  ( SELECT MIN(sal)\n    FROM EMP\n    WHERE deptno = 30);\nCurs 6 - BAZE DE DATE 43\n\nSubcereri multilinie \n• Subcererile multilinie returneaza mai mult decat o \nlinie. \n• Cu astfel de subinterogari trebuie folositi operatori \nmultilinie care pot prelucra una sau mai multe valori. \nOperatorii utilizati sunt: \n1. IN - egal cu oricare dintre membrii unei liste\n2. ANY/SOME - compara o valoare cu fiecare (vreo) \nvaloare returnata de subinterogare\n3. ALL - compara o valoare cu oricare (toate) din \nvalorile returnate de subinterogare\nCurs 6 - BAZE DE DATE 44', '\n', '5. ', '6.2. MULTIPLE ROW SUBQUERIES\nVALORI NULL\n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci:\n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null.\n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic.\nCurs 6 - BAZE DE DATE 35\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi HAVING\n- Pot fi folosite cu subinterogările de tip multiple row.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) < ANY\n          ( SELECT sal\n             FROM EMP\n             WHERE deptno IN (10,20) );\nCurs 6 - BAZE DE DATE 36\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi \nHAVING\n- Pot fi folosite cu \nsubinterogările de tip \nmultiple row.\nCurs 6 - BAZE DE DATE 37\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\n  De asemenea, se poate folosi clauza GROUP BY intr-\no subinterogare\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > ALL\n    (SELECT MIN(sal)\n     FROM EMP\n     WHERE deptno < 40\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 38\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare\nCurs 6 - BAZE DE DATE 39\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi angajaţii ale căror salarii sunt \naceleaşi cu salariul minim din oricare (any) \ndepartament. \nSELECT ename\nFROM EMP\nWHERE sal = ANY\n    (SELECT MIN(sal)\n     FROM EMP\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 40\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi \nangajaţii ale căror salarii \nsunt aceleaşi cu (any) \ndepartament. salariul \nminim din oricare \nCurs 6 - BAZE DE DATE 41\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42\n\n6.2. MULTIPLE ROW SUBQUERIES\nSoluţia corectă este următoarea:\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) <\n  ( SELECT MIN(sal)\n    FROM EMP\n    WHERE deptno = 30);\nCurs 6 - BAZE DE DATE 43\n\nSubcereri multilinie \n• Subcererile multilinie returneaza mai mult decat o \nlinie. \n• Cu astfel de subinterogari trebuie folositi operatori \nmultilinie care pot prelucra una sau mai multe valori. \nOperatorii utilizati sunt: \n1. IN - egal cu oricare dintre membrii unei liste\n2. ANY/SOME - compara o valoare cu fiecare (vreo) \nvaloare returnata de subinterogare\n3. ALL - compara o valoare cu oricare (toate) din \nvalorile returnate de subinterogare\nCurs 6 - BAZE DE DATE 44', '\n', '6. ', '6.2. MULTIPLE ROW SUBQUERIES\nVALORI NULL\n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci:\n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null.\n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic.\nCurs 6 - BAZE DE DATE 35\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi HAVING\n- Pot fi folosite cu subinterogările de tip multiple row.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) < ANY\n          ( SELECT sal\n             FROM EMP\n             WHERE deptno IN (10,20) );\nCurs 6 - BAZE DE DATE 36\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi \nHAVING\n- Pot fi folosite cu \nsubinterogările de tip \nmultiple row.\nCurs 6 - BAZE DE DATE 37\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\n  De asemenea, se poate folosi clauza GROUP BY intr-\no subinterogare\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > ALL\n    (SELECT MIN(sal)\n     FROM EMP\n     WHERE deptno < 40\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 38\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare\nCurs 6 - BAZE DE DATE 39\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi angajaţii ale căror salarii sunt \naceleaşi cu salariul minim din oricare (any) \ndepartament. \nSELECT ename\nFROM EMP\nWHERE sal = ANY\n    (SELECT MIN(sal)\n     FROM EMP\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 40\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi \nangajaţii ale căror salarii \nsunt aceleaşi cu (any) \ndepartament. salariul \nminim din oricare \nCurs 6 - BAZE DE DATE 41\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42\n\n6.2. MULTIPLE ROW SUBQUERIES\nSoluţia corectă este următoarea:\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) <\n  ( SELECT MIN(sal)\n    FROM EMP\n    WHERE deptno = 30);\nCurs 6 - BAZE DE DATE 43\n\nSubcereri multilinie \n• Subcererile multilinie returneaza mai mult decat o \nlinie. \n• Cu astfel de subinterogari trebuie folositi operatori \nmultilinie care pot prelucra una sau mai multe valori. \nOperatorii utilizati sunt: \n1. IN - egal cu oricare dintre membrii unei liste\n2. ANY/SOME - compara o valoare cu fiecare (vreo) \nvaloare returnata de subinterogare\n3. ALL - compara o valoare cu oricare (toate) din \nvalorile returnate de subinterogare\nCurs 6 - BAZE DE DATE 44', '\n', '7. ', 'Acordarea privilegiilor de obiect\nGRANT  object_priv  [ (columns) ]\nON          object\nTO           { user | role |  PUBLIC }\n[WITH GRANT OPTION];\nCurs - BAZE DE DATE 31\n\nAcordarea privilegiilor de obiect\nÎn sintaxa:\nobject_priv este un privilegiu de obiect ce va fi acordat.\nALL  toate privilegiile de obiect.\ncolumns specifica coloana dintr-o tabela sau o      \nimagine în care privilegiile sunt acordate.\nON object  este obiectul asupra caruia privilegiile sunt \nacordate.\nTO         identifica cui îi este acordat privilegiul.\nPUBLIC     acorda privilegii de obiect tuturor   utilizatorilor.\nWITH GRANT OPTION da dreptul detinatorului sa \nacorde mai departe privilegii de obiect altor utilizatori sau \nroluri. Curs - BAZE DE DATE 32\n\nAcordarea privilegiilor de obiect\nExemplu: \nAcordarea privilegiilor de interogare în tabela \nEMP .\nGRANT  select\nON          emp\nTO           sue, rich;\nGrant succeeded.\nCurs - BAZE DE DATE 33\n\nAcordarea privilegiilor de obiect\nExemplu:\nAcordarea privilegiilor de actualizare a anumitor \ncoloane utilizatorilor si rolurilor.\nGRANT   update (dname, loc)\nON           dept\nTO            scott, manager;\nGrant succeeded.\nCurs - BAZE DE DATE 34\n\nAcordarea privilegiilor de obiect\nÎn primul exemplu de mai sus se acorda \nutilizatorilor  Sue si Rich privilegiul de a interoga \ntabela EMP . \nÎn al doilea exemplu se acorda privilegii de \nactualizare a anumitor coloane în tabela DEPT \nutilizatorului Scott si rolului de „manager”.\nNota: DBA acorda în general privilegii de sistem; \norice utilizator ce detine un obiect  poate acorda \nprivilegii de obiect.\nCurs - BAZE DE DATE 35\n\nAcordarea privilegiilor de obiect\nPrecizari\n➢Pentru a putea acorda privilegii asupra unui obiect, \ncel ce vrea sa acorde privilegii  trebuie sa detina \nobiectul în schema sa sau trebuie sa detina privilegii \nde obiect WITH GRANT OPTION.\n➢Un proprietar de obiect  poate acorda orice privilegii \nde obiect asupra obiectului sau oricarui utilizator sau \nrol din baza de date.\n➢Proprietarul unui obiect  câstiga automat toate \nprivilegiile de obiect asupra acestuia.\nCurs - BAZE DE DATE 36\n\ntt\n➢Folosirea cuvintelor cheie WITH GRANT \nOPTION si PUBLIC\n➢Acordarea dreptului de a acorda mai departe \nprivilegiile altui utilizator.\nExemplu:\nGRANT   select, insert\nON           dept\nTO            scott\nWITH GRANT OPTION;\nGrant succeeded.\nCurs - BAZE DE DATE 37\n\nCuvântul cheie WITH GRANT \nOPTION\n➢Un privilegiu ce este acordat WITH GRANT OPTION \npoate fi transmis mai departe altor utilizatori, de catre \ncel ce are acest privilegiu. \n➢Privilegiile de obiect acordate WITH GRANT OPTION \nsunt retrase când privilegiul de a putea acorda privilegii \neste retras.\n➢În exemplul anterior se acorda dreptul utilizatorului \nScott de a accesa tabela DEPT cu privilegiul de a adauga \nacesteia noi rânduri. \n➢De asemenea se acorda dreptul lui Scott de a acorda \nmai departe aceste privilegii.\nCurs - BAZE DE DATE 38', '\n', '8. ', 'Acordarea privilegiilor de obiect\nGRANT  object_priv  [ (columns) ]\nON          object\nTO           { user | role |  PUBLIC }\n[WITH GRANT OPTION];\nCurs - BAZE DE DATE 31\n\nAcordarea privilegiilor de obiect\nÎn sintaxa:\nobject_priv este un privilegiu de obiect ce va fi acordat.\nALL  toate privilegiile de obiect.\ncolumns specifica coloana dintr-o tabela sau o      \nimagine în care privilegiile sunt acordate.\nON object  este obiectul asupra caruia privilegiile sunt \nacordate.\nTO         identifica cui îi este acordat privilegiul.\nPUBLIC     acorda privilegii de obiect tuturor   utilizatorilor.\nWITH GRANT OPTION da dreptul detinatorului sa \nacorde mai departe privilegii de obiect altor utilizatori sau \nroluri. Curs - BAZE DE DATE 32\n\nAcordarea privilegiilor de obiect\nExemplu: \nAcordarea privilegiilor de interogare în tabela \nEMP .\nGRANT  select\nON          emp\nTO           sue, rich;\nGrant succeeded.\nCurs - BAZE DE DATE 33\n\nAcordarea privilegiilor de obiect\nExemplu:\nAcordarea privilegiilor de actualizare a anumitor \ncoloane utilizatorilor si rolurilor.\nGRANT   update (dname, loc)\nON           dept\nTO            scott, manager;\nGrant succeeded.\nCurs - BAZE DE DATE 34\n\nAcordarea privilegiilor de obiect\nÎn primul exemplu de mai sus se acorda \nutilizatorilor  Sue si Rich privilegiul de a interoga \ntabela EMP . \nÎn al doilea exemplu se acorda privilegii de \nactualizare a anumitor coloane în tabela DEPT \nutilizatorului Scott si rolului de „manager”.\nNota: DBA acorda în general privilegii de sistem; \norice utilizator ce detine un obiect  poate acorda \nprivilegii de obiect.\nCurs - BAZE DE DATE 35\n\nAcordarea privilegiilor de obiect\nPrecizari\n➢Pentru a putea acorda privilegii asupra unui obiect, \ncel ce vrea sa acorde privilegii  trebuie sa detina \nobiectul în schema sa sau trebuie sa detina privilegii \nde obiect WITH GRANT OPTION.\n➢Un proprietar de obiect  poate acorda orice privilegii \nde obiect asupra obiectului sau oricarui utilizator sau \nrol din baza de date.\n➢Proprietarul unui obiect  câstiga automat toate \nprivilegiile de obiect asupra acestuia.\nCurs - BAZE DE DATE 36\n\ntt\n➢Folosirea cuvintelor cheie WITH GRANT \nOPTION si PUBLIC\n➢Acordarea dreptului de a acorda mai departe \nprivilegiile altui utilizator.\nExemplu:\nGRANT   select, insert\nON           dept\nTO            scott\nWITH GRANT OPTION;\nGrant succeeded.\nCurs - BAZE DE DATE 37\n\nCuvântul cheie WITH GRANT \nOPTION\n➢Un privilegiu ce este acordat WITH GRANT OPTION \npoate fi transmis mai departe altor utilizatori, de catre \ncel ce are acest privilegiu. \n➢Privilegiile de obiect acordate WITH GRANT OPTION \nsunt retrase când privilegiul de a putea acorda privilegii \neste retras.\n➢În exemplul anterior se acorda dreptul utilizatorului \nScott de a accesa tabela DEPT cu privilegiul de a adauga \nacesteia noi rânduri. \n➢De asemenea se acorda dreptul lui Scott de a acorda \nmai departe aceste privilegii.\nCurs - BAZE DE DATE 38', '\n', '9. ', 'Acordarea privilegiilor de obiect\nGRANT  object_priv  [ (columns) ]\nON          object\nTO           { user | role |  PUBLIC }\n[WITH GRANT OPTION];\nCurs - BAZE DE DATE 31\n\nAcordarea privilegiilor de obiect\nÎn sintaxa:\nobject_priv este un privilegiu de obiect ce va fi acordat.\nALL  toate privilegiile de obiect.\ncolumns specifica coloana dintr-o tabela sau o      \nimagine în care privilegiile sunt acordate.\nON object  este obiectul asupra caruia privilegiile sunt \nacordate.\nTO         identifica cui îi este acordat privilegiul.\nPUBLIC     acorda privilegii de obiect tuturor   utilizatorilor.\nWITH GRANT OPTION da dreptul detinatorului sa \nacorde mai departe privilegii de obiect altor utilizatori sau \nroluri. Curs - BAZE DE DATE 32\n\nAcordarea privilegiilor de obiect\nExemplu: \nAcordarea privilegiilor de interogare în tabela \nEMP .\nGRANT  select\nON          emp\nTO           sue, rich;\nGrant succeeded.\nCurs - BAZE DE DATE 33\n\nAcordarea privilegiilor de obiect\nExemplu:\nAcordarea privilegiilor de actualizare a anumitor \ncoloane utilizatorilor si rolurilor.\nGRANT   update (dname, loc)\nON           dept\nTO            scott, manager;\nGrant succeeded.\nCurs - BAZE DE DATE 34\n\nAcordarea privilegiilor de obiect\nÎn primul exemplu de mai sus se acorda \nutilizatorilor  Sue si Rich privilegiul de a interoga \ntabela EMP . \nÎn al doilea exemplu se acorda privilegii de \nactualizare a anumitor coloane în tabela DEPT \nutilizatorului Scott si rolului de „manager”.\nNota: DBA acorda în general privilegii de sistem; \norice utilizator ce detine un obiect  poate acorda \nprivilegii de obiect.\nCurs - BAZE DE DATE 35\n\nAcordarea privilegiilor de obiect\nPrecizari\n➢Pentru a putea acorda privilegii asupra unui obiect, \ncel ce vrea sa acorde privilegii  trebuie sa detina \nobiectul în schema sa sau trebuie sa detina privilegii \nde obiect WITH GRANT OPTION.\n➢Un proprietar de obiect  poate acorda orice privilegii \nde obiect asupra obiectului sau oricarui utilizator sau \nrol din baza de date.\n➢Proprietarul unui obiect  câstiga automat toate \nprivilegiile de obiect asupra acestuia.\nCurs - BAZE DE DATE 36\n\ntt\n➢Folosirea cuvintelor cheie WITH GRANT \nOPTION si PUBLIC\n➢Acordarea dreptului de a acorda mai departe \nprivilegiile altui utilizator.\nExemplu:\nGRANT   select, insert\nON           dept\nTO            scott\nWITH GRANT OPTION;\nGrant succeeded.\nCurs - BAZE DE DATE 37\n\nCuvântul cheie WITH GRANT \nOPTION\n➢Un privilegiu ce este acordat WITH GRANT OPTION \npoate fi transmis mai departe altor utilizatori, de catre \ncel ce are acest privilegiu. \n➢Privilegiile de obiect acordate WITH GRANT OPTION \nsunt retrase când privilegiul de a putea acorda privilegii \neste retras.\n➢În exemplul anterior se acorda dreptul utilizatorului \nScott de a accesa tabela DEPT cu privilegiul de a adauga \nacesteia noi rânduri. \n➢De asemenea se acorda dreptul lui Scott de a acorda \nmai departe aceste privilegii.\nCurs - BAZE DE DATE 38', '\n', '10. ', '4.3. Funcții de grup\n• În contrast, funcţia COUNT(expr) întoarce numărul \nde valori nenule din coloana specificată de expr.\n• COUNT(DISTINCT expr) returnează numărul de valori \ndistincte, nenule din coloana specificată de expr.\nCurs 5 - BAZE DE DATE 23\n\n4.3. Funcții de grup\nExemplul 4 \nNumărul angajaţilor din departamentul cu id-ul 30. \nSELECT COUNT(*)\nFROM EMP\nWHERE deptno = 30;\nCurs 5 - BAZE DE DATE 24\n\n\n4.3. Funcții de grup\nRezultatul obtinut - Numărul angajaţilor din departamentul cu id-\nul 30. \nCurs 5 - BAZE DE DATE 25\n\n\n4.3. Funcții de grup\nExemplul 5 \nNumărul angajaţilor care iau comision din \ndepartamentul 30.\nSELECT COUNT(comm)\nFROM EMP\nWHERE deptno = 30; \nCurs 5 - BAZE DE DATE 26\n\n4.3. Funcții de grup\nRezultatul obtinut - Numărul angajaţilor care iau comision din \ndepartamentul 30:\n \nCurs 5 - BAZE DE DATE 27\n\n\n4.3. Funcții de grup\nExemplul 6 - Numărul de departamente din firma \n(varianta incorectă şi varianta corectă). \nSELECT COUNT(deptno), COUNT(DISTINCT deptno)\nFROM EMP;\nCurs 5 - BAZE DE DATE 28\n\n\n4.3. Funcții de grup\nExemplul 7 - Comisionul mediu în departamentul 30 \n(ignorând sau nu valorile nule): \nSELECT AVG(comm), AVG(NVL(comm, 0))\nFROM EMP\nWHERE deptno = 30;\nCurs 5 - BAZE DE DATE 29\n\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 30\n\n4.3.1. Clauza GROUP BY\n➢Până acum toate funcţiile de grup au fost aplicate \nîntregii tabele. \n \n➢Pentru a putea împărţi tabela în grupuri mai mici se \nfoloseşte clauza GROUP BY. \n➢Folosirea acesteia returnează informaţii sumare despre \nfiecare grup. \nCurs 5 - BAZE DE DATE 31\n\n4.3.1. Clauza GROUP BY\n➢Folosind GROUP BY nu se pot extrage şi coloane \nindividuale, ci doar coloane ce rămân identice în tot \ngrupul.\n➢Folosind WHERE se pot exclude rânduri, înaintea \nîmpărţirii lor în grupuri.\n➢Nu pot fi folosite aliasuri de coloane în clauza GROUP \nBY.\n➢Implicit, rândurile sunt sortate crescător după coloana \n(coloanele) specificate în GROUP BY. \n➢Acest lucru poate fi schimbat folosind ORDER BY.\nCurs 5 - BAZE DE DATE 32\n\n4.3.1. Clauza GROUP BY\nExemplul 8 - Salariul mediu pe fiecare department:\nSELECT deptno, AVG(sal)\nFROM EMP\nGROUP BY deptno; \nCurs 5 - BAZE DE DATE 33\n\n\n4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul mediu pe fiecare department:\nCurs 5 - BAZE DE DATE 34\n\n\n4.3.1. Clauza GROUP BY\nExemplul 9 \nSalariul mediu pe fiecare departament, iar \nrezultatele ordonate după salariul mediu pe \ndepartament. \nSELECT deptno, AVG(sal)\nFROM EMP\nGROUP BY deptno\nORDER BY AVG(sal);\nCurs 5 - BAZE DE DATE 35\n\n4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul mediu pe fiecare departament, iar \nrezultatele ordonate după salariul mediu pe departament. \nCurs 5 - BAZE DE DATE 36', '\n']","constrângerea NOT NULL, ilustrată în exemplul `CREATE TABLE emp_new` (Curs 8 - BAZE DE DATE 15), impune ca o coloană, cum ar fi `ENAME` și `HIREDATE`, să nu accepte valori NULL. Încercarea de a insera o înregistrare cu valori NULL în aceste coloane, așa cum se arată în comanda `INSERT INTO emp_new(EMPNO, SAL, COMM) VALUES(50, 200, 5);`, va genera o eroare (Curs 8 - BAZE DE DATE 16).
",Constrângerea NOT NULL impune ca o coloană să nu accepte valori NULL.,"['1. ', 'CREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15\n\n\nAcum vom încerca să inserăm valori doar în coloanele \nEMPNO, SAL, COMM, dar la execuție ne va da eroare \npentru că ENAME şi HIREDATE au valori nule iar \nconstrângerile ne obligă să le atribuim o valoare.\nINSERT INTO emp_new(EMPNO, SAL, COMM)\nVALUES(50, 200, 5);\nCurs 8 - BAZE DE DATE 16\n\n\nConstrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17\n\nExemplu\n⮚În exemplul de mai jos se aplică constrângerea UNIQUE\ncoloanei JOB a tabelei emp_new1.\n⮚Numele constrângerii este UNIQUE.\nCREATE TABLE emp_new1(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nJOB varchar2(20) UNIQUE,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4)  NOT NULL );\nCurs 8 - BAZE DE DATE 18\n\n\nConstrângerea Cheie Primară\n• Constrângerea CHEIE PRIMARĂ(PRIMARY KEY)\ncreează o cheie primară pentru tabela. \n• Numai o singură cheie poate fi creată pentru fiecare \ntabela. \n• Această constrângere este o coloană sau un set de \ncoloane care identifică în mod unic fiecare rând al \ntabelului.\n• Nici o coloană care face parte din cheia primară nu \npoate conţine valoarea nulă. \n• Poate fi definită la nivel de coloană sau tabela. \nCurs 8 - BAZE DE DATE 19\n\nO tabela poate avea o singură cheie primară dar poate avea \nmai multe constrângeri de tip UNIQUE.\nExemplu\nÎn exemplul de mai jos este definită o constrângere de tip \ncheie primară la nivelul coloanei DEPTNO a tabelei DEPT1. \nNumele constrângerii este PRIMARY KEY.\nCREATE TABLE DEPT1 (\nDEPTNO number(6),\nDNAME varchar2(10), \nMGR number(6),\nPRIMARY KEY(DEPTNO) );\nCurs 8 - BAZE DE DATE 20\n\n\nConstrângerea FOREIGN KEY\n• Constrângerea FOREIGN KEY defineşte o coloană \nsau o combinaţie de coloane ca foreign key şi \nstabileşte o relaţie între o cheie primară şi una unică \nîn aceeaşi tabela sau în tabele diferite. \n• O valoare care apare într-o tabela trebuie să se \nregăsească şi în cea de-a 2-a tabela, pe coloana \nunde formează cheia primară. \n• Constrângerile de tip FOREIGN KEY pot fi definite la \nnivel de coloană sau tabela.\nCurs 8 - BAZE DE DATE 21\n\nExemplu\nÎn următorul exemplu se defineşte o constrângere \nde tip FOREIGN KEY coloanei DEPTNO a tabelei \nEMP_NEW2 utilizând sintaxa la nivel de tabela. \nCREATE TABLE EMP_NEW2(\nEMPNO number(6),\nENAME varchar2(10), \nSAL number(4),\nCOM number(4),\nJOB varchar2(25) UNIQUE,\nDEPTNO number(4), \nFOREIGN KEY(DEPTNO) REFERENCES DEPT (DEPTNO) );\nCurs 8 - BAZE DE DATE 22', '\n', '2. ', 'CREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15\n\n\nAcum vom încerca să inserăm valori doar în coloanele \nEMPNO, SAL, COMM, dar la execuție ne va da eroare \npentru că ENAME şi HIREDATE au valori nule iar \nconstrângerile ne obligă să le atribuim o valoare.\nINSERT INTO emp_new(EMPNO, SAL, COMM)\nVALUES(50, 200, 5);\nCurs 8 - BAZE DE DATE 16\n\n\nConstrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17\n\nExemplu\n⮚În exemplul de mai jos se aplică constrângerea UNIQUE\ncoloanei JOB a tabelei emp_new1.\n⮚Numele constrângerii este UNIQUE.\nCREATE TABLE emp_new1(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nJOB varchar2(20) UNIQUE,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4)  NOT NULL );\nCurs 8 - BAZE DE DATE 18\n\n\nConstrângerea Cheie Primară\n• Constrângerea CHEIE PRIMARĂ(PRIMARY KEY)\ncreează o cheie primară pentru tabela. \n• Numai o singură cheie poate fi creată pentru fiecare \ntabela. \n• Această constrângere este o coloană sau un set de \ncoloane care identifică în mod unic fiecare rând al \ntabelului.\n• Nici o coloană care face parte din cheia primară nu \npoate conţine valoarea nulă. \n• Poate fi definită la nivel de coloană sau tabela. \nCurs 8 - BAZE DE DATE 19\n\nO tabela poate avea o singură cheie primară dar poate avea \nmai multe constrângeri de tip UNIQUE.\nExemplu\nÎn exemplul de mai jos este definită o constrângere de tip \ncheie primară la nivelul coloanei DEPTNO a tabelei DEPT1. \nNumele constrângerii este PRIMARY KEY.\nCREATE TABLE DEPT1 (\nDEPTNO number(6),\nDNAME varchar2(10), \nMGR number(6),\nPRIMARY KEY(DEPTNO) );\nCurs 8 - BAZE DE DATE 20\n\n\nConstrângerea FOREIGN KEY\n• Constrângerea FOREIGN KEY defineşte o coloană \nsau o combinaţie de coloane ca foreign key şi \nstabileşte o relaţie între o cheie primară şi una unică \nîn aceeaşi tabela sau în tabele diferite. \n• O valoare care apare într-o tabela trebuie să se \nregăsească şi în cea de-a 2-a tabela, pe coloana \nunde formează cheia primară. \n• Constrângerile de tip FOREIGN KEY pot fi definite la \nnivel de coloană sau tabela.\nCurs 8 - BAZE DE DATE 21\n\nExemplu\nÎn următorul exemplu se defineşte o constrângere \nde tip FOREIGN KEY coloanei DEPTNO a tabelei \nEMP_NEW2 utilizând sintaxa la nivel de tabela. \nCREATE TABLE EMP_NEW2(\nEMPNO number(6),\nENAME varchar2(10), \nSAL number(4),\nCOM number(4),\nJOB varchar2(25) UNIQUE,\nDEPTNO number(4), \nFOREIGN KEY(DEPTNO) REFERENCES DEPT (DEPTNO) );\nCurs 8 - BAZE DE DATE 22', '\n', '3. ', 'CREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15\n\n\nAcum vom încerca să inserăm valori doar în coloanele \nEMPNO, SAL, COMM, dar la execuție ne va da eroare \npentru că ENAME şi HIREDATE au valori nule iar \nconstrângerile ne obligă să le atribuim o valoare.\nINSERT INTO emp_new(EMPNO, SAL, COMM)\nVALUES(50, 200, 5);\nCurs 8 - BAZE DE DATE 16\n\n\nConstrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17\n\nExemplu\n⮚În exemplul de mai jos se aplică constrângerea UNIQUE\ncoloanei JOB a tabelei emp_new1.\n⮚Numele constrângerii este UNIQUE.\nCREATE TABLE emp_new1(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nJOB varchar2(20) UNIQUE,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4)  NOT NULL );\nCurs 8 - BAZE DE DATE 18\n\n\nConstrângerea Cheie Primară\n• Constrângerea CHEIE PRIMARĂ(PRIMARY KEY)\ncreează o cheie primară pentru tabela. \n• Numai o singură cheie poate fi creată pentru fiecare \ntabela. \n• Această constrângere este o coloană sau un set de \ncoloane care identifică în mod unic fiecare rând al \ntabelului.\n• Nici o coloană care face parte din cheia primară nu \npoate conţine valoarea nulă. \n• Poate fi definită la nivel de coloană sau tabela. \nCurs 8 - BAZE DE DATE 19\n\nO tabela poate avea o singură cheie primară dar poate avea \nmai multe constrângeri de tip UNIQUE.\nExemplu\nÎn exemplul de mai jos este definită o constrângere de tip \ncheie primară la nivelul coloanei DEPTNO a tabelei DEPT1. \nNumele constrângerii este PRIMARY KEY.\nCREATE TABLE DEPT1 (\nDEPTNO number(6),\nDNAME varchar2(10), \nMGR number(6),\nPRIMARY KEY(DEPTNO) );\nCurs 8 - BAZE DE DATE 20\n\n\nConstrângerea FOREIGN KEY\n• Constrângerea FOREIGN KEY defineşte o coloană \nsau o combinaţie de coloane ca foreign key şi \nstabileşte o relaţie între o cheie primară şi una unică \nîn aceeaşi tabela sau în tabele diferite. \n• O valoare care apare într-o tabela trebuie să se \nregăsească şi în cea de-a 2-a tabela, pe coloana \nunde formează cheia primară. \n• Constrângerile de tip FOREIGN KEY pot fi definite la \nnivel de coloană sau tabela.\nCurs 8 - BAZE DE DATE 21\n\nExemplu\nÎn următorul exemplu se defineşte o constrângere \nde tip FOREIGN KEY coloanei DEPTNO a tabelei \nEMP_NEW2 utilizând sintaxa la nivel de tabela. \nCREATE TABLE EMP_NEW2(\nEMPNO number(6),\nENAME varchar2(10), \nSAL number(4),\nCOM number(4),\nJOB varchar2(25) UNIQUE,\nDEPTNO number(4), \nFOREIGN KEY(DEPTNO) REFERENCES DEPT (DEPTNO) );\nCurs 8 - BAZE DE DATE 22', '\n', '4. ', '6.2. MULTIPLE ROW SUBQUERIES\nVALORI NULL\n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci:\n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null.\n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic.\nCurs 6 - BAZE DE DATE 35\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi HAVING\n- Pot fi folosite cu subinterogările de tip multiple row.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) < ANY\n          ( SELECT sal\n             FROM EMP\n             WHERE deptno IN (10,20) );\nCurs 6 - BAZE DE DATE 36\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi \nHAVING\n- Pot fi folosite cu \nsubinterogările de tip \nmultiple row.\nCurs 6 - BAZE DE DATE 37\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\n  De asemenea, se poate folosi clauza GROUP BY intr-\no subinterogare\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > ALL\n    (SELECT MIN(sal)\n     FROM EMP\n     WHERE deptno < 40\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 38\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare\nCurs 6 - BAZE DE DATE 39\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi angajaţii ale căror salarii sunt \naceleaşi cu salariul minim din oricare (any) \ndepartament. \nSELECT ename\nFROM EMP\nWHERE sal = ANY\n    (SELECT MIN(sal)\n     FROM EMP\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 40\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi \nangajaţii ale căror salarii \nsunt aceleaşi cu (any) \ndepartament. salariul \nminim din oricare \nCurs 6 - BAZE DE DATE 41\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42\n\n6.2. MULTIPLE ROW SUBQUERIES\nSoluţia corectă este următoarea:\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) <\n  ( SELECT MIN(sal)\n    FROM EMP\n    WHERE deptno = 30);\nCurs 6 - BAZE DE DATE 43\n\nSubcereri multilinie \n• Subcererile multilinie returneaza mai mult decat o \nlinie. \n• Cu astfel de subinterogari trebuie folositi operatori \nmultilinie care pot prelucra una sau mai multe valori. \nOperatorii utilizati sunt: \n1. IN - egal cu oricare dintre membrii unei liste\n2. ANY/SOME - compara o valoare cu fiecare (vreo) \nvaloare returnata de subinterogare\n3. ALL - compara o valoare cu oricare (toate) din \nvalorile returnate de subinterogare\nCurs 6 - BAZE DE DATE 44', '\n', '5. ', '6.2. MULTIPLE ROW SUBQUERIES\nVALORI NULL\n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci:\n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null.\n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic.\nCurs 6 - BAZE DE DATE 35\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi HAVING\n- Pot fi folosite cu subinterogările de tip multiple row.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) < ANY\n          ( SELECT sal\n             FROM EMP\n             WHERE deptno IN (10,20) );\nCurs 6 - BAZE DE DATE 36\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi \nHAVING\n- Pot fi folosite cu \nsubinterogările de tip \nmultiple row.\nCurs 6 - BAZE DE DATE 37\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\n  De asemenea, se poate folosi clauza GROUP BY intr-\no subinterogare\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > ALL\n    (SELECT MIN(sal)\n     FROM EMP\n     WHERE deptno < 40\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 38\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare\nCurs 6 - BAZE DE DATE 39\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi angajaţii ale căror salarii sunt \naceleaşi cu salariul minim din oricare (any) \ndepartament. \nSELECT ename\nFROM EMP\nWHERE sal = ANY\n    (SELECT MIN(sal)\n     FROM EMP\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 40\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi \nangajaţii ale căror salarii \nsunt aceleaşi cu (any) \ndepartament. salariul \nminim din oricare \nCurs 6 - BAZE DE DATE 41\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42\n\n6.2. MULTIPLE ROW SUBQUERIES\nSoluţia corectă este următoarea:\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) <\n  ( SELECT MIN(sal)\n    FROM EMP\n    WHERE deptno = 30);\nCurs 6 - BAZE DE DATE 43\n\nSubcereri multilinie \n• Subcererile multilinie returneaza mai mult decat o \nlinie. \n• Cu astfel de subinterogari trebuie folositi operatori \nmultilinie care pot prelucra una sau mai multe valori. \nOperatorii utilizati sunt: \n1. IN - egal cu oricare dintre membrii unei liste\n2. ANY/SOME - compara o valoare cu fiecare (vreo) \nvaloare returnata de subinterogare\n3. ALL - compara o valoare cu oricare (toate) din \nvalorile returnate de subinterogare\nCurs 6 - BAZE DE DATE 44', '\n', '6. ', '6.2. MULTIPLE ROW SUBQUERIES\nVALORI NULL\n  Dacă una dintre valorile returnate de \nsubinterogarea multiple row este null, dar celelalte \nvalori nu sunt null, atunci:\n• Dacă sunt folosiţi operatorii IN sau ANY, interogarea \nexterioară va returna liniile care se potrivesc cu valorile \nnon-null.\n• Dacă este folosit operatorul ALL, interogarea exterioară \nnu va returna nimic.\nCurs 6 - BAZE DE DATE 35\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi HAVING\n- Pot fi folosite cu subinterogările de tip multiple row.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) < ANY\n          ( SELECT sal\n             FROM EMP\n             WHERE deptno IN (10,20) );\nCurs 6 - BAZE DE DATE 36\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY şi \nHAVING\n- Pot fi folosite cu \nsubinterogările de tip \nmultiple row.\nCurs 6 - BAZE DE DATE 37\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\n  De asemenea, se poate folosi clauza GROUP BY intr-\no subinterogare\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > ALL\n    (SELECT MIN(sal)\n     FROM EMP\n     WHERE deptno < 40\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 38\n\n6.2. MULTIPLE ROW SUBQUERIES\nClauzele GROUP BY si HAVING\nDe asemenea, se poate folosi clauza GROUP BY intr-o \nsubinterogare\nCurs 6 - BAZE DE DATE 39\n\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi angajaţii ale căror salarii sunt \naceleaşi cu salariul minim din oricare (any) \ndepartament. \nSELECT ename\nFROM EMP\nWHERE sal = ANY\n    (SELECT MIN(sal)\n     FROM EMP\n     GROUP BY deptno);\nCurs 6 - BAZE DE DATE 40\n\n6.2. MULTIPLE ROW SUBQUERIES\nAplicatii rezolvate:\n1) Găsiţi numele pentru toţi \nangajaţii ale căror salarii \nsunt aceleaşi cu (any) \ndepartament. salariul \nminim din oricare \nCurs 6 - BAZE DE DATE 41\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42\n\n6.2. MULTIPLE ROW SUBQUERIES\nSoluţia corectă este următoarea:\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) <\n  ( SELECT MIN(sal)\n    FROM EMP\n    WHERE deptno = 30);\nCurs 6 - BAZE DE DATE 43\n\nSubcereri multilinie \n• Subcererile multilinie returneaza mai mult decat o \nlinie. \n• Cu astfel de subinterogari trebuie folositi operatori \nmultilinie care pot prelucra una sau mai multe valori. \nOperatorii utilizati sunt: \n1. IN - egal cu oricare dintre membrii unei liste\n2. ANY/SOME - compara o valoare cu fiecare (vreo) \nvaloare returnata de subinterogare\n3. ALL - compara o valoare cu oricare (toate) din \nvalorile returnate de subinterogare\nCurs 6 - BAZE DE DATE 44', '\n', '7. ', 'Acordarea privilegiilor de obiect\nGRANT  object_priv  [ (columns) ]\nON          object\nTO           { user | role |  PUBLIC }\n[WITH GRANT OPTION];\nCurs - BAZE DE DATE 31\n\nAcordarea privilegiilor de obiect\nÎn sintaxa:\nobject_priv este un privilegiu de obiect ce va fi acordat.\nALL  toate privilegiile de obiect.\ncolumns specifica coloana dintr-o tabela sau o      \nimagine în care privilegiile sunt acordate.\nON object  este obiectul asupra caruia privilegiile sunt \nacordate.\nTO         identifica cui îi este acordat privilegiul.\nPUBLIC     acorda privilegii de obiect tuturor   utilizatorilor.\nWITH GRANT OPTION da dreptul detinatorului sa \nacorde mai departe privilegii de obiect altor utilizatori sau \nroluri. Curs - BAZE DE DATE 32\n\nAcordarea privilegiilor de obiect\nExemplu: \nAcordarea privilegiilor de interogare în tabela \nEMP .\nGRANT  select\nON          emp\nTO           sue, rich;\nGrant succeeded.\nCurs - BAZE DE DATE 33\n\nAcordarea privilegiilor de obiect\nExemplu:\nAcordarea privilegiilor de actualizare a anumitor \ncoloane utilizatorilor si rolurilor.\nGRANT   update (dname, loc)\nON           dept\nTO            scott, manager;\nGrant succeeded.\nCurs - BAZE DE DATE 34\n\nAcordarea privilegiilor de obiect\nÎn primul exemplu de mai sus se acorda \nutilizatorilor  Sue si Rich privilegiul de a interoga \ntabela EMP . \nÎn al doilea exemplu se acorda privilegii de \nactualizare a anumitor coloane în tabela DEPT \nutilizatorului Scott si rolului de „manager”.\nNota: DBA acorda în general privilegii de sistem; \norice utilizator ce detine un obiect  poate acorda \nprivilegii de obiect.\nCurs - BAZE DE DATE 35\n\nAcordarea privilegiilor de obiect\nPrecizari\n➢Pentru a putea acorda privilegii asupra unui obiect, \ncel ce vrea sa acorde privilegii  trebuie sa detina \nobiectul în schema sa sau trebuie sa detina privilegii \nde obiect WITH GRANT OPTION.\n➢Un proprietar de obiect  poate acorda orice privilegii \nde obiect asupra obiectului sau oricarui utilizator sau \nrol din baza de date.\n➢Proprietarul unui obiect  câstiga automat toate \nprivilegiile de obiect asupra acestuia.\nCurs - BAZE DE DATE 36\n\ntt\n➢Folosirea cuvintelor cheie WITH GRANT \nOPTION si PUBLIC\n➢Acordarea dreptului de a acorda mai departe \nprivilegiile altui utilizator.\nExemplu:\nGRANT   select, insert\nON           dept\nTO            scott\nWITH GRANT OPTION;\nGrant succeeded.\nCurs - BAZE DE DATE 37\n\nCuvântul cheie WITH GRANT \nOPTION\n➢Un privilegiu ce este acordat WITH GRANT OPTION \npoate fi transmis mai departe altor utilizatori, de catre \ncel ce are acest privilegiu. \n➢Privilegiile de obiect acordate WITH GRANT OPTION \nsunt retrase când privilegiul de a putea acorda privilegii \neste retras.\n➢În exemplul anterior se acorda dreptul utilizatorului \nScott de a accesa tabela DEPT cu privilegiul de a adauga \nacesteia noi rânduri. \n➢De asemenea se acorda dreptul lui Scott de a acorda \nmai departe aceste privilegii.\nCurs - BAZE DE DATE 38', '\n', '8. ', 'Acordarea privilegiilor de obiect\nGRANT  object_priv  [ (columns) ]\nON          object\nTO           { user | role |  PUBLIC }\n[WITH GRANT OPTION];\nCurs - BAZE DE DATE 31\n\nAcordarea privilegiilor de obiect\nÎn sintaxa:\nobject_priv este un privilegiu de obiect ce va fi acordat.\nALL  toate privilegiile de obiect.\ncolumns specifica coloana dintr-o tabela sau o      \nimagine în care privilegiile sunt acordate.\nON object  este obiectul asupra caruia privilegiile sunt \nacordate.\nTO         identifica cui îi este acordat privilegiul.\nPUBLIC     acorda privilegii de obiect tuturor   utilizatorilor.\nWITH GRANT OPTION da dreptul detinatorului sa \nacorde mai departe privilegii de obiect altor utilizatori sau \nroluri. Curs - BAZE DE DATE 32\n\nAcordarea privilegiilor de obiect\nExemplu: \nAcordarea privilegiilor de interogare în tabela \nEMP .\nGRANT  select\nON          emp\nTO           sue, rich;\nGrant succeeded.\nCurs - BAZE DE DATE 33\n\nAcordarea privilegiilor de obiect\nExemplu:\nAcordarea privilegiilor de actualizare a anumitor \ncoloane utilizatorilor si rolurilor.\nGRANT   update (dname, loc)\nON           dept\nTO            scott, manager;\nGrant succeeded.\nCurs - BAZE DE DATE 34\n\nAcordarea privilegiilor de obiect\nÎn primul exemplu de mai sus se acorda \nutilizatorilor  Sue si Rich privilegiul de a interoga \ntabela EMP . \nÎn al doilea exemplu se acorda privilegii de \nactualizare a anumitor coloane în tabela DEPT \nutilizatorului Scott si rolului de „manager”.\nNota: DBA acorda în general privilegii de sistem; \norice utilizator ce detine un obiect  poate acorda \nprivilegii de obiect.\nCurs - BAZE DE DATE 35\n\nAcordarea privilegiilor de obiect\nPrecizari\n➢Pentru a putea acorda privilegii asupra unui obiect, \ncel ce vrea sa acorde privilegii  trebuie sa detina \nobiectul în schema sa sau trebuie sa detina privilegii \nde obiect WITH GRANT OPTION.\n➢Un proprietar de obiect  poate acorda orice privilegii \nde obiect asupra obiectului sau oricarui utilizator sau \nrol din baza de date.\n➢Proprietarul unui obiect  câstiga automat toate \nprivilegiile de obiect asupra acestuia.\nCurs - BAZE DE DATE 36\n\ntt\n➢Folosirea cuvintelor cheie WITH GRANT \nOPTION si PUBLIC\n➢Acordarea dreptului de a acorda mai departe \nprivilegiile altui utilizator.\nExemplu:\nGRANT   select, insert\nON           dept\nTO            scott\nWITH GRANT OPTION;\nGrant succeeded.\nCurs - BAZE DE DATE 37\n\nCuvântul cheie WITH GRANT \nOPTION\n➢Un privilegiu ce este acordat WITH GRANT OPTION \npoate fi transmis mai departe altor utilizatori, de catre \ncel ce are acest privilegiu. \n➢Privilegiile de obiect acordate WITH GRANT OPTION \nsunt retrase când privilegiul de a putea acorda privilegii \neste retras.\n➢În exemplul anterior se acorda dreptul utilizatorului \nScott de a accesa tabela DEPT cu privilegiul de a adauga \nacesteia noi rânduri. \n➢De asemenea se acorda dreptul lui Scott de a acorda \nmai departe aceste privilegii.\nCurs - BAZE DE DATE 38', '\n', '9. ', 'Acordarea privilegiilor de obiect\nGRANT  object_priv  [ (columns) ]\nON          object\nTO           { user | role |  PUBLIC }\n[WITH GRANT OPTION];\nCurs - BAZE DE DATE 31\n\nAcordarea privilegiilor de obiect\nÎn sintaxa:\nobject_priv este un privilegiu de obiect ce va fi acordat.\nALL  toate privilegiile de obiect.\ncolumns specifica coloana dintr-o tabela sau o      \nimagine în care privilegiile sunt acordate.\nON object  este obiectul asupra caruia privilegiile sunt \nacordate.\nTO         identifica cui îi este acordat privilegiul.\nPUBLIC     acorda privilegii de obiect tuturor   utilizatorilor.\nWITH GRANT OPTION da dreptul detinatorului sa \nacorde mai departe privilegii de obiect altor utilizatori sau \nroluri. Curs - BAZE DE DATE 32\n\nAcordarea privilegiilor de obiect\nExemplu: \nAcordarea privilegiilor de interogare în tabela \nEMP .\nGRANT  select\nON          emp\nTO           sue, rich;\nGrant succeeded.\nCurs - BAZE DE DATE 33\n\nAcordarea privilegiilor de obiect\nExemplu:\nAcordarea privilegiilor de actualizare a anumitor \ncoloane utilizatorilor si rolurilor.\nGRANT   update (dname, loc)\nON           dept\nTO            scott, manager;\nGrant succeeded.\nCurs - BAZE DE DATE 34\n\nAcordarea privilegiilor de obiect\nÎn primul exemplu de mai sus se acorda \nutilizatorilor  Sue si Rich privilegiul de a interoga \ntabela EMP . \nÎn al doilea exemplu se acorda privilegii de \nactualizare a anumitor coloane în tabela DEPT \nutilizatorului Scott si rolului de „manager”.\nNota: DBA acorda în general privilegii de sistem; \norice utilizator ce detine un obiect  poate acorda \nprivilegii de obiect.\nCurs - BAZE DE DATE 35\n\nAcordarea privilegiilor de obiect\nPrecizari\n➢Pentru a putea acorda privilegii asupra unui obiect, \ncel ce vrea sa acorde privilegii  trebuie sa detina \nobiectul în schema sa sau trebuie sa detina privilegii \nde obiect WITH GRANT OPTION.\n➢Un proprietar de obiect  poate acorda orice privilegii \nde obiect asupra obiectului sau oricarui utilizator sau \nrol din baza de date.\n➢Proprietarul unui obiect  câstiga automat toate \nprivilegiile de obiect asupra acestuia.\nCurs - BAZE DE DATE 36\n\ntt\n➢Folosirea cuvintelor cheie WITH GRANT \nOPTION si PUBLIC\n➢Acordarea dreptului de a acorda mai departe \nprivilegiile altui utilizator.\nExemplu:\nGRANT   select, insert\nON           dept\nTO            scott\nWITH GRANT OPTION;\nGrant succeeded.\nCurs - BAZE DE DATE 37\n\nCuvântul cheie WITH GRANT \nOPTION\n➢Un privilegiu ce este acordat WITH GRANT OPTION \npoate fi transmis mai departe altor utilizatori, de catre \ncel ce are acest privilegiu. \n➢Privilegiile de obiect acordate WITH GRANT OPTION \nsunt retrase când privilegiul de a putea acorda privilegii \neste retras.\n➢În exemplul anterior se acorda dreptul utilizatorului \nScott de a accesa tabela DEPT cu privilegiul de a adauga \nacesteia noi rânduri. \n➢De asemenea se acorda dreptul lui Scott de a acorda \nmai departe aceste privilegii.\nCurs - BAZE DE DATE 38', '\n', '10. ', '4.3. Funcții de grup\n• În contrast, funcţia COUNT(expr) întoarce numărul \nde valori nenule din coloana specificată de expr.\n• COUNT(DISTINCT expr) returnează numărul de valori \ndistincte, nenule din coloana specificată de expr.\nCurs 5 - BAZE DE DATE 23\n\n4.3. Funcții de grup\nExemplul 4 \nNumărul angajaţilor din departamentul cu id-ul 30. \nSELECT COUNT(*)\nFROM EMP\nWHERE deptno = 30;\nCurs 5 - BAZE DE DATE 24\n\n\n4.3. Funcții de grup\nRezultatul obtinut - Numărul angajaţilor din departamentul cu id-\nul 30. \nCurs 5 - BAZE DE DATE 25\n\n\n4.3. Funcții de grup\nExemplul 5 \nNumărul angajaţilor care iau comision din \ndepartamentul 30.\nSELECT COUNT(comm)\nFROM EMP\nWHERE deptno = 30; \nCurs 5 - BAZE DE DATE 26\n\n4.3. Funcții de grup\nRezultatul obtinut - Numărul angajaţilor care iau comision din \ndepartamentul 30:\n \nCurs 5 - BAZE DE DATE 27\n\n\n4.3. Funcții de grup\nExemplul 6 - Numărul de departamente din firma \n(varianta incorectă şi varianta corectă). \nSELECT COUNT(deptno), COUNT(DISTINCT deptno)\nFROM EMP;\nCurs 5 - BAZE DE DATE 28\n\n\n4.3. Funcții de grup\nExemplul 7 - Comisionul mediu în departamentul 30 \n(ignorând sau nu valorile nule): \nSELECT AVG(comm), AVG(NVL(comm, 0))\nFROM EMP\nWHERE deptno = 30;\nCurs 5 - BAZE DE DATE 29\n\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 30\n\n4.3.1. Clauza GROUP BY\n➢Până acum toate funcţiile de grup au fost aplicate \nîntregii tabele. \n \n➢Pentru a putea împărţi tabela în grupuri mai mici se \nfoloseşte clauza GROUP BY. \n➢Folosirea acesteia returnează informaţii sumare despre \nfiecare grup. \nCurs 5 - BAZE DE DATE 31\n\n4.3.1. Clauza GROUP BY\n➢Folosind GROUP BY nu se pot extrage şi coloane \nindividuale, ci doar coloane ce rămân identice în tot \ngrupul.\n➢Folosind WHERE se pot exclude rânduri, înaintea \nîmpărţirii lor în grupuri.\n➢Nu pot fi folosite aliasuri de coloane în clauza GROUP \nBY.\n➢Implicit, rândurile sunt sortate crescător după coloana \n(coloanele) specificate în GROUP BY. \n➢Acest lucru poate fi schimbat folosind ORDER BY.\nCurs 5 - BAZE DE DATE 32\n\n4.3.1. Clauza GROUP BY\nExemplul 8 - Salariul mediu pe fiecare department:\nSELECT deptno, AVG(sal)\nFROM EMP\nGROUP BY deptno; \nCurs 5 - BAZE DE DATE 33\n\n\n4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul mediu pe fiecare department:\nCurs 5 - BAZE DE DATE 34\n\n\n4.3.1. Clauza GROUP BY\nExemplul 9 \nSalariul mediu pe fiecare departament, iar \nrezultatele ordonate după salariul mediu pe \ndepartament. \nSELECT deptno, AVG(sal)\nFROM EMP\nGROUP BY deptno\nORDER BY AVG(sal);\nCurs 5 - BAZE DE DATE 35\n\n4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul mediu pe fiecare departament, iar \nrezultatele ordonate după salariul mediu pe departament. \nCurs 5 - BAZE DE DATE 36', '\n']","constrângerea NOT NULL, ilustrată în exemplul `CREATE TABLE emp_new` (Curs 8 - BAZE DE DATE 15), impune ca o coloană, cum ar fi `ENAME` și `HIREDATE`, să nu accepte valori NULL. Încercarea de a insera o înregistrare cu valori NULL în aceste coloane, așa cum se arată în comanda `INSERT INTO emp_new(EMPNO, SAL, COMM) VALUES(50, 200, 5);`, va genera o eroare (Curs 8 - BAZE DE DATE 16).
",Adevărat,0.4249999999858333,0.0,0.7909171716702819,1.0,0.0,0.0,0.0
65,Manual - Test 2,,,12,Ce operator este folosit pentru a căuta un model specificat într-o coloană?,LIKE,Este corect,,"['1. ', 'Numarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55\n\n\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56\n\nExemplu \n Gasiti angajatii care au un salariu superior \nsalariului mediu al departamentului lor.\nSELECT ename, sal, deptno\nFROM EMP E\nWHERE sal >\n            ( SELECT AVG(sal)\n             FROM EMP\n             WHERE ( deptno = E.deptno ) )\nORDER BY deptno;\nCurs 6 - BAZE DE DATE 57\n\nExemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n\n\nValori de NULL intr-o subinterogare \n• In cazul in care subinterogarea returneaza \nvreuna din valori NULL si interogarea \nprincipala are operator NOT IN, atunci \ninterogarea principala nu va returna niciun \nrand. \n• Motivul este ca o comparatie cu NULL conduce \nla un rezultat NULL. \nCurs 6 - BAZE DE DATE 59\n\nExemplu \nGasiti angajatii care nu au subordonati. \nSELECT ename \nFROM EMP \nWHERE empno NOT IN\n                    ( SELECT mgr\n                         FROM EMP );\nCurs 6 - BAZE DE DATE 60\n\nExemplu \nGasiti angajatii care nu au \nsubordonati. \nCurs 6 - BAZE DE DATE 61\n\n\n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN. \n• De fapt operatorul NOT IN este echivalent cu <> ALL.\n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL). \nCurs 6 - BAZE DE DATE 62\n\nExemplu\nGasiti angajatii care au subordonati.\nSELECT ename\nFROM EMP \nWHERE empno IN\n               ( SELECT mgr\n                  FROM EMP );\nCurs 6 - BAZE DE DATE 63\n\nExemplu \nGasiti angajatii care au \nsubordonati.\nCurs 6 - BAZE DE DATE 64\n\n\n• In cazul utilizarii operatorului NOT IN in interogarea \nprincipala trebuie avut grija sa se excluda valorile NULL\ndin raspunsurile subcererii.\nExemplu \nGasiti angajatii care nu au subordonati. \nCurs 6 - BAZE DE DATE 65\n\nSELECT ename \n  FROM EMP \n  WHERE empno NOT IN\n                  ( SELECT mgr\n                    FROM EMP\n                    WHERE mgr IS NOT NULL );\nCurs 6 - BAZE DE DATE 66\n\n\nSfaturi în utilizarea subinterogarilor\n1. Includerea subinterogarilor în paranteze\n2. Plasarea subinterogarilor în partea dreapta a \noperatorului de comparare\n3. A nu se adauga clauza ORDER BY într-o \nsubinterogare\n4. Folosirea operatorilor single-row în subinterogari \nsingle-row\n5. Folosirea operatorilor multiple-row în \nsubinterogari multiple-row\nCurs 6 - BAZE DE DATE 67', '\n', '2. ', 'Numarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55\n\n\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56\n\nExemplu \n Gasiti angajatii care au un salariu superior \nsalariului mediu al departamentului lor.\nSELECT ename, sal, deptno\nFROM EMP E\nWHERE sal >\n            ( SELECT AVG(sal)\n             FROM EMP\n             WHERE ( deptno = E.deptno ) )\nORDER BY deptno;\nCurs 6 - BAZE DE DATE 57\n\nExemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n\n\nValori de NULL intr-o subinterogare \n• In cazul in care subinterogarea returneaza \nvreuna din valori NULL si interogarea \nprincipala are operator NOT IN, atunci \ninterogarea principala nu va returna niciun \nrand. \n• Motivul este ca o comparatie cu NULL conduce \nla un rezultat NULL. \nCurs 6 - BAZE DE DATE 59\n\nExemplu \nGasiti angajatii care nu au subordonati. \nSELECT ename \nFROM EMP \nWHERE empno NOT IN\n                    ( SELECT mgr\n                         FROM EMP );\nCurs 6 - BAZE DE DATE 60\n\nExemplu \nGasiti angajatii care nu au \nsubordonati. \nCurs 6 - BAZE DE DATE 61\n\n\n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN. \n• De fapt operatorul NOT IN este echivalent cu <> ALL.\n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL). \nCurs 6 - BAZE DE DATE 62\n\nExemplu\nGasiti angajatii care au subordonati.\nSELECT ename\nFROM EMP \nWHERE empno IN\n               ( SELECT mgr\n                  FROM EMP );\nCurs 6 - BAZE DE DATE 63\n\nExemplu \nGasiti angajatii care au \nsubordonati.\nCurs 6 - BAZE DE DATE 64\n\n\n• In cazul utilizarii operatorului NOT IN in interogarea \nprincipala trebuie avut grija sa se excluda valorile NULL\ndin raspunsurile subcererii.\nExemplu \nGasiti angajatii care nu au subordonati. \nCurs 6 - BAZE DE DATE 65\n\nSELECT ename \n  FROM EMP \n  WHERE empno NOT IN\n                  ( SELECT mgr\n                    FROM EMP\n                    WHERE mgr IS NOT NULL );\nCurs 6 - BAZE DE DATE 66\n\n\nSfaturi în utilizarea subinterogarilor\n1. Includerea subinterogarilor în paranteze\n2. Plasarea subinterogarilor în partea dreapta a \noperatorului de comparare\n3. A nu se adauga clauza ORDER BY într-o \nsubinterogare\n4. Folosirea operatorilor single-row în subinterogari \nsingle-row\n5. Folosirea operatorilor multiple-row în \nsubinterogari multiple-row\nCurs 6 - BAZE DE DATE 67', '\n', '3. ', 'Numarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55\n\n\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56\n\nExemplu \n Gasiti angajatii care au un salariu superior \nsalariului mediu al departamentului lor.\nSELECT ename, sal, deptno\nFROM EMP E\nWHERE sal >\n            ( SELECT AVG(sal)\n             FROM EMP\n             WHERE ( deptno = E.deptno ) )\nORDER BY deptno;\nCurs 6 - BAZE DE DATE 57\n\nExemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n\n\nValori de NULL intr-o subinterogare \n• In cazul in care subinterogarea returneaza \nvreuna din valori NULL si interogarea \nprincipala are operator NOT IN, atunci \ninterogarea principala nu va returna niciun \nrand. \n• Motivul este ca o comparatie cu NULL conduce \nla un rezultat NULL. \nCurs 6 - BAZE DE DATE 59\n\nExemplu \nGasiti angajatii care nu au subordonati. \nSELECT ename \nFROM EMP \nWHERE empno NOT IN\n                    ( SELECT mgr\n                         FROM EMP );\nCurs 6 - BAZE DE DATE 60\n\nExemplu \nGasiti angajatii care nu au \nsubordonati. \nCurs 6 - BAZE DE DATE 61\n\n\n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN. \n• De fapt operatorul NOT IN este echivalent cu <> ALL.\n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL). \nCurs 6 - BAZE DE DATE 62\n\nExemplu\nGasiti angajatii care au subordonati.\nSELECT ename\nFROM EMP \nWHERE empno IN\n               ( SELECT mgr\n                  FROM EMP );\nCurs 6 - BAZE DE DATE 63\n\nExemplu \nGasiti angajatii care au \nsubordonati.\nCurs 6 - BAZE DE DATE 64\n\n\n• In cazul utilizarii operatorului NOT IN in interogarea \nprincipala trebuie avut grija sa se excluda valorile NULL\ndin raspunsurile subcererii.\nExemplu \nGasiti angajatii care nu au subordonati. \nCurs 6 - BAZE DE DATE 65\n\nSELECT ename \n  FROM EMP \n  WHERE empno NOT IN\n                  ( SELECT mgr\n                    FROM EMP\n                    WHERE mgr IS NOT NULL );\nCurs 6 - BAZE DE DATE 66\n\n\nSfaturi în utilizarea subinterogarilor\n1. Includerea subinterogarilor în paranteze\n2. Plasarea subinterogarilor în partea dreapta a \noperatorului de comparare\n3. A nu se adauga clauza ORDER BY într-o \nsubinterogare\n4. Folosirea operatorilor single-row în subinterogari \nsingle-row\n5. Folosirea operatorilor multiple-row în \nsubinterogari multiple-row\nCurs 6 - BAZE DE DATE 67', '\n', '4. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '5. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '6. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '7. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '8. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '9. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '10. ', 'Acordarea privilegiilor de obiect\nGRANT  object_priv  [ (columns) ]\nON          object\nTO           { user | role |  PUBLIC }\n[WITH GRANT OPTION];\nCurs - BAZE DE DATE 31\n\nAcordarea privilegiilor de obiect\nÎn sintaxa:\nobject_priv este un privilegiu de obiect ce va fi acordat.\nALL  toate privilegiile de obiect.\ncolumns specifica coloana dintr-o tabela sau o      \nimagine în care privilegiile sunt acordate.\nON object  este obiectul asupra caruia privilegiile sunt \nacordate.\nTO         identifica cui îi este acordat privilegiul.\nPUBLIC     acorda privilegii de obiect tuturor   utilizatorilor.\nWITH GRANT OPTION da dreptul detinatorului sa \nacorde mai departe privilegii de obiect altor utilizatori sau \nroluri. Curs - BAZE DE DATE 32\n\nAcordarea privilegiilor de obiect\nExemplu: \nAcordarea privilegiilor de interogare în tabela \nEMP .\nGRANT  select\nON          emp\nTO           sue, rich;\nGrant succeeded.\nCurs - BAZE DE DATE 33\n\nAcordarea privilegiilor de obiect\nExemplu:\nAcordarea privilegiilor de actualizare a anumitor \ncoloane utilizatorilor si rolurilor.\nGRANT   update (dname, loc)\nON           dept\nTO            scott, manager;\nGrant succeeded.\nCurs - BAZE DE DATE 34\n\nAcordarea privilegiilor de obiect\nÎn primul exemplu de mai sus se acorda \nutilizatorilor  Sue si Rich privilegiul de a interoga \ntabela EMP . \nÎn al doilea exemplu se acorda privilegii de \nactualizare a anumitor coloane în tabela DEPT \nutilizatorului Scott si rolului de „manager”.\nNota: DBA acorda în general privilegii de sistem; \norice utilizator ce detine un obiect  poate acorda \nprivilegii de obiect.\nCurs - BAZE DE DATE 35\n\nAcordarea privilegiilor de obiect\nPrecizari\n➢Pentru a putea acorda privilegii asupra unui obiect, \ncel ce vrea sa acorde privilegii  trebuie sa detina \nobiectul în schema sa sau trebuie sa detina privilegii \nde obiect WITH GRANT OPTION.\n➢Un proprietar de obiect  poate acorda orice privilegii \nde obiect asupra obiectului sau oricarui utilizator sau \nrol din baza de date.\n➢Proprietarul unui obiect  câstiga automat toate \nprivilegiile de obiect asupra acestuia.\nCurs - BAZE DE DATE 36\n\ntt\n➢Folosirea cuvintelor cheie WITH GRANT \nOPTION si PUBLIC\n➢Acordarea dreptului de a acorda mai departe \nprivilegiile altui utilizator.\nExemplu:\nGRANT   select, insert\nON           dept\nTO            scott\nWITH GRANT OPTION;\nGrant succeeded.\nCurs - BAZE DE DATE 37\n\nCuvântul cheie WITH GRANT \nOPTION\n➢Un privilegiu ce este acordat WITH GRANT OPTION \npoate fi transmis mai departe altor utilizatori, de catre \ncel ce are acest privilegiu. \n➢Privilegiile de obiect acordate WITH GRANT OPTION \nsunt retrase când privilegiul de a putea acorda privilegii \neste retras.\n➢În exemplul anterior se acorda dreptul utilizatorului \nScott de a accesa tabela DEPT cu privilegiul de a adauga \nacesteia noi rânduri. \n➢De asemenea se acorda dreptul lui Scott de a acorda \nmai departe aceste privilegii.\nCurs - BAZE DE DATE 38', '\n']","operatorii multiple-row precum: IN, ANY sau ALL; operatorii single-row, precum: =, <>, >, >=, < sau <=;
",Ce operator este folosit pentru a căuta un model specificat într-o coloană?,"['1. ', 'Numarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55\n\n\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56\n\nExemplu \n Gasiti angajatii care au un salariu superior \nsalariului mediu al departamentului lor.\nSELECT ename, sal, deptno\nFROM EMP E\nWHERE sal >\n            ( SELECT AVG(sal)\n             FROM EMP\n             WHERE ( deptno = E.deptno ) )\nORDER BY deptno;\nCurs 6 - BAZE DE DATE 57\n\nExemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n\n\nValori de NULL intr-o subinterogare \n• In cazul in care subinterogarea returneaza \nvreuna din valori NULL si interogarea \nprincipala are operator NOT IN, atunci \ninterogarea principala nu va returna niciun \nrand. \n• Motivul este ca o comparatie cu NULL conduce \nla un rezultat NULL. \nCurs 6 - BAZE DE DATE 59\n\nExemplu \nGasiti angajatii care nu au subordonati. \nSELECT ename \nFROM EMP \nWHERE empno NOT IN\n                    ( SELECT mgr\n                         FROM EMP );\nCurs 6 - BAZE DE DATE 60\n\nExemplu \nGasiti angajatii care nu au \nsubordonati. \nCurs 6 - BAZE DE DATE 61\n\n\n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN. \n• De fapt operatorul NOT IN este echivalent cu <> ALL.\n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL). \nCurs 6 - BAZE DE DATE 62\n\nExemplu\nGasiti angajatii care au subordonati.\nSELECT ename\nFROM EMP \nWHERE empno IN\n               ( SELECT mgr\n                  FROM EMP );\nCurs 6 - BAZE DE DATE 63\n\nExemplu \nGasiti angajatii care au \nsubordonati.\nCurs 6 - BAZE DE DATE 64\n\n\n• In cazul utilizarii operatorului NOT IN in interogarea \nprincipala trebuie avut grija sa se excluda valorile NULL\ndin raspunsurile subcererii.\nExemplu \nGasiti angajatii care nu au subordonati. \nCurs 6 - BAZE DE DATE 65\n\nSELECT ename \n  FROM EMP \n  WHERE empno NOT IN\n                  ( SELECT mgr\n                    FROM EMP\n                    WHERE mgr IS NOT NULL );\nCurs 6 - BAZE DE DATE 66\n\n\nSfaturi în utilizarea subinterogarilor\n1. Includerea subinterogarilor în paranteze\n2. Plasarea subinterogarilor în partea dreapta a \noperatorului de comparare\n3. A nu se adauga clauza ORDER BY într-o \nsubinterogare\n4. Folosirea operatorilor single-row în subinterogari \nsingle-row\n5. Folosirea operatorilor multiple-row în \nsubinterogari multiple-row\nCurs 6 - BAZE DE DATE 67', '\n', '2. ', 'Numarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55\n\n\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56\n\nExemplu \n Gasiti angajatii care au un salariu superior \nsalariului mediu al departamentului lor.\nSELECT ename, sal, deptno\nFROM EMP E\nWHERE sal >\n            ( SELECT AVG(sal)\n             FROM EMP\n             WHERE ( deptno = E.deptno ) )\nORDER BY deptno;\nCurs 6 - BAZE DE DATE 57\n\nExemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n\n\nValori de NULL intr-o subinterogare \n• In cazul in care subinterogarea returneaza \nvreuna din valori NULL si interogarea \nprincipala are operator NOT IN, atunci \ninterogarea principala nu va returna niciun \nrand. \n• Motivul este ca o comparatie cu NULL conduce \nla un rezultat NULL. \nCurs 6 - BAZE DE DATE 59\n\nExemplu \nGasiti angajatii care nu au subordonati. \nSELECT ename \nFROM EMP \nWHERE empno NOT IN\n                    ( SELECT mgr\n                         FROM EMP );\nCurs 6 - BAZE DE DATE 60\n\nExemplu \nGasiti angajatii care nu au \nsubordonati. \nCurs 6 - BAZE DE DATE 61\n\n\n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN. \n• De fapt operatorul NOT IN este echivalent cu <> ALL.\n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL). \nCurs 6 - BAZE DE DATE 62\n\nExemplu\nGasiti angajatii care au subordonati.\nSELECT ename\nFROM EMP \nWHERE empno IN\n               ( SELECT mgr\n                  FROM EMP );\nCurs 6 - BAZE DE DATE 63\n\nExemplu \nGasiti angajatii care au \nsubordonati.\nCurs 6 - BAZE DE DATE 64\n\n\n• In cazul utilizarii operatorului NOT IN in interogarea \nprincipala trebuie avut grija sa se excluda valorile NULL\ndin raspunsurile subcererii.\nExemplu \nGasiti angajatii care nu au subordonati. \nCurs 6 - BAZE DE DATE 65\n\nSELECT ename \n  FROM EMP \n  WHERE empno NOT IN\n                  ( SELECT mgr\n                    FROM EMP\n                    WHERE mgr IS NOT NULL );\nCurs 6 - BAZE DE DATE 66\n\n\nSfaturi în utilizarea subinterogarilor\n1. Includerea subinterogarilor în paranteze\n2. Plasarea subinterogarilor în partea dreapta a \noperatorului de comparare\n3. A nu se adauga clauza ORDER BY într-o \nsubinterogare\n4. Folosirea operatorilor single-row în subinterogari \nsingle-row\n5. Folosirea operatorilor multiple-row în \nsubinterogari multiple-row\nCurs 6 - BAZE DE DATE 67', '\n', '3. ', 'Numarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55\n\n\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56\n\nExemplu \n Gasiti angajatii care au un salariu superior \nsalariului mediu al departamentului lor.\nSELECT ename, sal, deptno\nFROM EMP E\nWHERE sal >\n            ( SELECT AVG(sal)\n             FROM EMP\n             WHERE ( deptno = E.deptno ) )\nORDER BY deptno;\nCurs 6 - BAZE DE DATE 57\n\nExemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n\n\nValori de NULL intr-o subinterogare \n• In cazul in care subinterogarea returneaza \nvreuna din valori NULL si interogarea \nprincipala are operator NOT IN, atunci \ninterogarea principala nu va returna niciun \nrand. \n• Motivul este ca o comparatie cu NULL conduce \nla un rezultat NULL. \nCurs 6 - BAZE DE DATE 59\n\nExemplu \nGasiti angajatii care nu au subordonati. \nSELECT ename \nFROM EMP \nWHERE empno NOT IN\n                    ( SELECT mgr\n                         FROM EMP );\nCurs 6 - BAZE DE DATE 60\n\nExemplu \nGasiti angajatii care nu au \nsubordonati. \nCurs 6 - BAZE DE DATE 61\n\n\n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN. \n• De fapt operatorul NOT IN este echivalent cu <> ALL.\n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL). \nCurs 6 - BAZE DE DATE 62\n\nExemplu\nGasiti angajatii care au subordonati.\nSELECT ename\nFROM EMP \nWHERE empno IN\n               ( SELECT mgr\n                  FROM EMP );\nCurs 6 - BAZE DE DATE 63\n\nExemplu \nGasiti angajatii care au \nsubordonati.\nCurs 6 - BAZE DE DATE 64\n\n\n• In cazul utilizarii operatorului NOT IN in interogarea \nprincipala trebuie avut grija sa se excluda valorile NULL\ndin raspunsurile subcererii.\nExemplu \nGasiti angajatii care nu au subordonati. \nCurs 6 - BAZE DE DATE 65\n\nSELECT ename \n  FROM EMP \n  WHERE empno NOT IN\n                  ( SELECT mgr\n                    FROM EMP\n                    WHERE mgr IS NOT NULL );\nCurs 6 - BAZE DE DATE 66\n\n\nSfaturi în utilizarea subinterogarilor\n1. Includerea subinterogarilor în paranteze\n2. Plasarea subinterogarilor în partea dreapta a \noperatorului de comparare\n3. A nu se adauga clauza ORDER BY într-o \nsubinterogare\n4. Folosirea operatorilor single-row în subinterogari \nsingle-row\n5. Folosirea operatorilor multiple-row în \nsubinterogari multiple-row\nCurs 6 - BAZE DE DATE 67', '\n', '4. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '5. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '6. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '7. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '8. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '9. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '10. ', 'Acordarea privilegiilor de obiect\nGRANT  object_priv  [ (columns) ]\nON          object\nTO           { user | role |  PUBLIC }\n[WITH GRANT OPTION];\nCurs - BAZE DE DATE 31\n\nAcordarea privilegiilor de obiect\nÎn sintaxa:\nobject_priv este un privilegiu de obiect ce va fi acordat.\nALL  toate privilegiile de obiect.\ncolumns specifica coloana dintr-o tabela sau o      \nimagine în care privilegiile sunt acordate.\nON object  este obiectul asupra caruia privilegiile sunt \nacordate.\nTO         identifica cui îi este acordat privilegiul.\nPUBLIC     acorda privilegii de obiect tuturor   utilizatorilor.\nWITH GRANT OPTION da dreptul detinatorului sa \nacorde mai departe privilegii de obiect altor utilizatori sau \nroluri. Curs - BAZE DE DATE 32\n\nAcordarea privilegiilor de obiect\nExemplu: \nAcordarea privilegiilor de interogare în tabela \nEMP .\nGRANT  select\nON          emp\nTO           sue, rich;\nGrant succeeded.\nCurs - BAZE DE DATE 33\n\nAcordarea privilegiilor de obiect\nExemplu:\nAcordarea privilegiilor de actualizare a anumitor \ncoloane utilizatorilor si rolurilor.\nGRANT   update (dname, loc)\nON           dept\nTO            scott, manager;\nGrant succeeded.\nCurs - BAZE DE DATE 34\n\nAcordarea privilegiilor de obiect\nÎn primul exemplu de mai sus se acorda \nutilizatorilor  Sue si Rich privilegiul de a interoga \ntabela EMP . \nÎn al doilea exemplu se acorda privilegii de \nactualizare a anumitor coloane în tabela DEPT \nutilizatorului Scott si rolului de „manager”.\nNota: DBA acorda în general privilegii de sistem; \norice utilizator ce detine un obiect  poate acorda \nprivilegii de obiect.\nCurs - BAZE DE DATE 35\n\nAcordarea privilegiilor de obiect\nPrecizari\n➢Pentru a putea acorda privilegii asupra unui obiect, \ncel ce vrea sa acorde privilegii  trebuie sa detina \nobiectul în schema sa sau trebuie sa detina privilegii \nde obiect WITH GRANT OPTION.\n➢Un proprietar de obiect  poate acorda orice privilegii \nde obiect asupra obiectului sau oricarui utilizator sau \nrol din baza de date.\n➢Proprietarul unui obiect  câstiga automat toate \nprivilegiile de obiect asupra acestuia.\nCurs - BAZE DE DATE 36\n\ntt\n➢Folosirea cuvintelor cheie WITH GRANT \nOPTION si PUBLIC\n➢Acordarea dreptului de a acorda mai departe \nprivilegiile altui utilizator.\nExemplu:\nGRANT   select, insert\nON           dept\nTO            scott\nWITH GRANT OPTION;\nGrant succeeded.\nCurs - BAZE DE DATE 37\n\nCuvântul cheie WITH GRANT \nOPTION\n➢Un privilegiu ce este acordat WITH GRANT OPTION \npoate fi transmis mai departe altor utilizatori, de catre \ncel ce are acest privilegiu. \n➢Privilegiile de obiect acordate WITH GRANT OPTION \nsunt retrase când privilegiul de a putea acorda privilegii \neste retras.\n➢În exemplul anterior se acorda dreptul utilizatorului \nScott de a accesa tabela DEPT cu privilegiul de a adauga \nacesteia noi rânduri. \n➢De asemenea se acorda dreptul lui Scott de a acorda \nmai departe aceste privilegii.\nCurs - BAZE DE DATE 38', '\n']","operatorii multiple-row precum: IN, ANY sau ALL; operatorii single-row, precum: =, <>, >, >=, < sau <=;
",LIKE,0.0,0.0,0.7769543821085815,0.0,0.0,0.0,0.0
66,Manual - Test 2,,,13,"Ce instrucțiune SQL este folosită pentru a crea un tabel de bază de date numit ""Customers""?",CREATE TABLE Customers,Este corect,,"['1. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '2. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '3. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '4. ', ""- SQL echivalent: SELECT * FROM Student JOIN Inscriere ON Student.ID = \nInscriere.StudentID; \n \n \n2.2 Studiu de caz: Utilizarea algebrei relaționale într-o companie de livrări \nO companie de livrări utilizează o bază de date relațională pentru a gestiona comenzile, clienții și \nlivratorii. Relațiile cheie sunt: \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    Status V ARCHAR(20), \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE Livrator ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \nInterogări pentru monitorizarea livrărilor: \nSELECT Client.Nume, Comanda.Status \nFROM Client \nJOIN Comanda ON Client.ID = Comanda.ClientID; \n \n \n \n2.3. SQL - Limbajul interogărilor \nLimbajul SQL (Structured Query Language) este standardul pentru interacțiunea cu bazele de \ndate relaționale. \n \n2.3.1 Crearea bazelor de date și a tabelelor \nCREATE DATABASE Universitate; \nUSE Universitate; \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Prenume V ARCHAR(50), \n    An INT \n); \n \nCREATE TABLE Curs ( \n\n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n2.3.2 Inserarea datelor \nINSERT INTO Student (ID, Nume, Prenume, An) V ALUES (1, 'Popescu', 'Ion', 2); \nINSERT INTO Curs (Cod, Denumire) V ALUES (101, 'Baze de date'); \nINSERT INTO Inscriere (StudentID, CursCod) V ALUES (1, 101); \n \n2.3.3 Interogarea bazelor de date \n-- Selectarea tuturor studenților \nSELECT * FROM Student; \n \n-- Selectarea studenților de anul 2 \nSELECT * FROM Student WHERE An = 2; \n \n-- Afișarea cursurilor la care este înscris un student \nSELECT Curs.Denumire  \nFROM Curs  \nJOIN Inscriere ON Curs.Cod = Inscriere.CursCod  \nWHERE Inscriere.StudentID = 1; \n \n \n3. Integritatea datelor \nIntegritatea datelor asigură corectitudinea și consistența acestora în cadrul bazei de date. Tipurile \nprincipale sunt: \n \n1. Integritatea entităților: Fiecare tabel trebuie să aibă un identificator unic. \n2. Integritatea referențială: Relațiile dintre tabele trebuie să fie menținute corect prin chei primare \nși străine. \n3. Integritatea domeniului: Valorile din coloane trebuie să respecte tipul de date definit."", '\n', '5. ', ""- SQL echivalent: SELECT * FROM Student JOIN Inscriere ON Student.ID = \nInscriere.StudentID; \n \n \n2.2 Studiu de caz: Utilizarea algebrei relaționale într-o companie de livrări \nO companie de livrări utilizează o bază de date relațională pentru a gestiona comenzile, clienții și \nlivratorii. Relațiile cheie sunt: \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    Status V ARCHAR(20), \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE Livrator ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \nInterogări pentru monitorizarea livrărilor: \nSELECT Client.Nume, Comanda.Status \nFROM Client \nJOIN Comanda ON Client.ID = Comanda.ClientID; \n \n \n \n2.3. SQL - Limbajul interogărilor \nLimbajul SQL (Structured Query Language) este standardul pentru interacțiunea cu bazele de \ndate relaționale. \n \n2.3.1 Crearea bazelor de date și a tabelelor \nCREATE DATABASE Universitate; \nUSE Universitate; \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Prenume V ARCHAR(50), \n    An INT \n); \n \nCREATE TABLE Curs ( \n\n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n2.3.2 Inserarea datelor \nINSERT INTO Student (ID, Nume, Prenume, An) V ALUES (1, 'Popescu', 'Ion', 2); \nINSERT INTO Curs (Cod, Denumire) V ALUES (101, 'Baze de date'); \nINSERT INTO Inscriere (StudentID, CursCod) V ALUES (1, 101); \n \n2.3.3 Interogarea bazelor de date \n-- Selectarea tuturor studenților \nSELECT * FROM Student; \n \n-- Selectarea studenților de anul 2 \nSELECT * FROM Student WHERE An = 2; \n \n-- Afișarea cursurilor la care este înscris un student \nSELECT Curs.Denumire  \nFROM Curs  \nJOIN Inscriere ON Curs.Cod = Inscriere.CursCod  \nWHERE Inscriere.StudentID = 1; \n \n \n3. Integritatea datelor \nIntegritatea datelor asigură corectitudinea și consistența acestora în cadrul bazei de date. Tipurile \nprincipale sunt: \n \n1. Integritatea entităților: Fiecare tabel trebuie să aibă un identificator unic. \n2. Integritatea referențială: Relațiile dintre tabele trebuie să fie menținute corect prin chei primare \nși străine. \n3. Integritatea domeniului: Valorile din coloane trebuie să respecte tipul de date definit."", '\n', '6. ', ""- SQL echivalent: SELECT * FROM Student JOIN Inscriere ON Student.ID = \nInscriere.StudentID; \n \n \n2.2 Studiu de caz: Utilizarea algebrei relaționale într-o companie de livrări \nO companie de livrări utilizează o bază de date relațională pentru a gestiona comenzile, clienții și \nlivratorii. Relațiile cheie sunt: \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    Status V ARCHAR(20), \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE Livrator ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \nInterogări pentru monitorizarea livrărilor: \nSELECT Client.Nume, Comanda.Status \nFROM Client \nJOIN Comanda ON Client.ID = Comanda.ClientID; \n \n \n \n2.3. SQL - Limbajul interogărilor \nLimbajul SQL (Structured Query Language) este standardul pentru interacțiunea cu bazele de \ndate relaționale. \n \n2.3.1 Crearea bazelor de date și a tabelelor \nCREATE DATABASE Universitate; \nUSE Universitate; \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Prenume V ARCHAR(50), \n    An INT \n); \n \nCREATE TABLE Curs ( \n\n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n2.3.2 Inserarea datelor \nINSERT INTO Student (ID, Nume, Prenume, An) V ALUES (1, 'Popescu', 'Ion', 2); \nINSERT INTO Curs (Cod, Denumire) V ALUES (101, 'Baze de date'); \nINSERT INTO Inscriere (StudentID, CursCod) V ALUES (1, 101); \n \n2.3.3 Interogarea bazelor de date \n-- Selectarea tuturor studenților \nSELECT * FROM Student; \n \n-- Selectarea studenților de anul 2 \nSELECT * FROM Student WHERE An = 2; \n \n-- Afișarea cursurilor la care este înscris un student \nSELECT Curs.Denumire  \nFROM Curs  \nJOIN Inscriere ON Curs.Cod = Inscriere.CursCod  \nWHERE Inscriere.StudentID = 1; \n \n \n3. Integritatea datelor \nIntegritatea datelor asigură corectitudinea și consistența acestora în cadrul bazei de date. Tipurile \nprincipale sunt: \n \n1. Integritatea entităților: Fiecare tabel trebuie să aibă un identificator unic. \n2. Integritatea referențială: Relațiile dintre tabele trebuie să fie menținute corect prin chei primare \nși străine. \n3. Integritatea domeniului: Valorile din coloane trebuie să respecte tipul de date definit."", '\n', '7. ', ""3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43\n\n3. Sinonime\nPentru crearea sinonimelor este necesara o cerere SQL \ncare are urmatorul format:\nCurs - BAZE DE DATE 44\nCREATE [PUBLIC] SYNONYM nume_sinonim\nFOR nume_obiect;\nPUBLIC\nDefineste faptul ca acest sinonim este accesibil de catre toti \nutilizatorii. Daca nu este precizat atunci sinonimul este disponibil \ndoar pentru utilizatorul curent. Sinonimele publice pot fi create doar \nde catre utilizatorii care au drepturi administrative.\nnume_sinonim Numele sinonimului care va fi creat.\nnume_obiect Identifica obiectul pentru care se doreste crearea sinonimului \n\n3. Sinonime\n➢Daca dorim sa accesam o tabela pe care un alt utilizator \na creat-o in prealabil si careia ii dorim asignarea unui \nsinonim suntem obligati sa introducem inaintea numelui \ntabelei si numele utilizatorului care a creat tabela, in \nfata numelui tabelei, despartite de un punct.\nExemplu 1 - In acest exemplu vom incerca sa cream un \nsinonim pentru tabela departamente care are un nume \ndestul de lung.\nCREATE PUBLIC SYNONYM dep\nFOR dept;\nCurs - BAZE DE DATE 45\n\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46\n\n3. Sinonime\nExista unele restrictii in folosirea sinonimelor:\n➢obiectele respective nu pot sa fie continute intr-un \npachet.\n➢numele sinonimului privat trebuie sa fie unic in cadrul \ngrupului de obiecte pentru care acel user este \nproprietar.\nCurs - BAZE DE DATE 47\n\n3. Sinonime\n➢Un sinonim nu poate fi schimbat odata creat. \n➢El poate sa fie doar distrus. \n➢Distrugerea unui sinonim nu implica si distrugerea \nobiectului de care aliasul este atasat. \n➢Distrugerea unui sinonim este facuta folosind o \ninterogare SQL de tipul urmator:\nDROP [PUBLIC] SYNONYM nume_sinonim\nunde nume_sinonim este numele sinonimului care sa fie \ndistrus.\nCurs - BAZE DE DATE 48\n\n3. Sinonime\n➢Un sinonim de tip public poate sa fie sa fie distrus doar \nde catre un utilizator administrativ. \n➢Sinonimele private trebuie distruse de utilizatorul care \nle-a creat acestea nefiind disponibile in cadrul listei \nnumelor de obiecte a celorlalti utilizatori.\nCurs - BAZE DE DATE 49\n\nBibliografie\nFlorin Rădulescu: Oracle SQL, PL/SQL, Editura \nPrintech, ISBN 973-718-203-02005\nCurs - BAZE DE DATE 50\n\nÎntrebări?\nCurs - BAZE DE DATE 51"", '\n', '8. ', ""3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43\n\n3. Sinonime\nPentru crearea sinonimelor este necesara o cerere SQL \ncare are urmatorul format:\nCurs - BAZE DE DATE 44\nCREATE [PUBLIC] SYNONYM nume_sinonim\nFOR nume_obiect;\nPUBLIC\nDefineste faptul ca acest sinonim este accesibil de catre toti \nutilizatorii. Daca nu este precizat atunci sinonimul este disponibil \ndoar pentru utilizatorul curent. Sinonimele publice pot fi create doar \nde catre utilizatorii care au drepturi administrative.\nnume_sinonim Numele sinonimului care va fi creat.\nnume_obiect Identifica obiectul pentru care se doreste crearea sinonimului \n\n3. Sinonime\n➢Daca dorim sa accesam o tabela pe care un alt utilizator \na creat-o in prealabil si careia ii dorim asignarea unui \nsinonim suntem obligati sa introducem inaintea numelui \ntabelei si numele utilizatorului care a creat tabela, in \nfata numelui tabelei, despartite de un punct.\nExemplu 1 - In acest exemplu vom incerca sa cream un \nsinonim pentru tabela departamente care are un nume \ndestul de lung.\nCREATE PUBLIC SYNONYM dep\nFOR dept;\nCurs - BAZE DE DATE 45\n\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46\n\n3. Sinonime\nExista unele restrictii in folosirea sinonimelor:\n➢obiectele respective nu pot sa fie continute intr-un \npachet.\n➢numele sinonimului privat trebuie sa fie unic in cadrul \ngrupului de obiecte pentru care acel user este \nproprietar.\nCurs - BAZE DE DATE 47\n\n3. Sinonime\n➢Un sinonim nu poate fi schimbat odata creat. \n➢El poate sa fie doar distrus. \n➢Distrugerea unui sinonim nu implica si distrugerea \nobiectului de care aliasul este atasat. \n➢Distrugerea unui sinonim este facuta folosind o \ninterogare SQL de tipul urmator:\nDROP [PUBLIC] SYNONYM nume_sinonim\nunde nume_sinonim este numele sinonimului care sa fie \ndistrus.\nCurs - BAZE DE DATE 48\n\n3. Sinonime\n➢Un sinonim de tip public poate sa fie sa fie distrus doar \nde catre un utilizator administrativ. \n➢Sinonimele private trebuie distruse de utilizatorul care \nle-a creat acestea nefiind disponibile in cadrul listei \nnumelor de obiecte a celorlalti utilizatori.\nCurs - BAZE DE DATE 49\n\nBibliografie\nFlorin Rădulescu: Oracle SQL, PL/SQL, Editura \nPrintech, ISBN 973-718-203-02005\nCurs - BAZE DE DATE 50\n\nÎntrebări?\nCurs - BAZE DE DATE 51"", '\n', '9. ', ""3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43\n\n3. Sinonime\nPentru crearea sinonimelor este necesara o cerere SQL \ncare are urmatorul format:\nCurs - BAZE DE DATE 44\nCREATE [PUBLIC] SYNONYM nume_sinonim\nFOR nume_obiect;\nPUBLIC\nDefineste faptul ca acest sinonim este accesibil de catre toti \nutilizatorii. Daca nu este precizat atunci sinonimul este disponibil \ndoar pentru utilizatorul curent. Sinonimele publice pot fi create doar \nde catre utilizatorii care au drepturi administrative.\nnume_sinonim Numele sinonimului care va fi creat.\nnume_obiect Identifica obiectul pentru care se doreste crearea sinonimului \n\n3. Sinonime\n➢Daca dorim sa accesam o tabela pe care un alt utilizator \na creat-o in prealabil si careia ii dorim asignarea unui \nsinonim suntem obligati sa introducem inaintea numelui \ntabelei si numele utilizatorului care a creat tabela, in \nfata numelui tabelei, despartite de un punct.\nExemplu 1 - In acest exemplu vom incerca sa cream un \nsinonim pentru tabela departamente care are un nume \ndestul de lung.\nCREATE PUBLIC SYNONYM dep\nFOR dept;\nCurs - BAZE DE DATE 45\n\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46\n\n3. Sinonime\nExista unele restrictii in folosirea sinonimelor:\n➢obiectele respective nu pot sa fie continute intr-un \npachet.\n➢numele sinonimului privat trebuie sa fie unic in cadrul \ngrupului de obiecte pentru care acel user este \nproprietar.\nCurs - BAZE DE DATE 47\n\n3. Sinonime\n➢Un sinonim nu poate fi schimbat odata creat. \n➢El poate sa fie doar distrus. \n➢Distrugerea unui sinonim nu implica si distrugerea \nobiectului de care aliasul este atasat. \n➢Distrugerea unui sinonim este facuta folosind o \ninterogare SQL de tipul urmator:\nDROP [PUBLIC] SYNONYM nume_sinonim\nunde nume_sinonim este numele sinonimului care sa fie \ndistrus.\nCurs - BAZE DE DATE 48\n\n3. Sinonime\n➢Un sinonim de tip public poate sa fie sa fie distrus doar \nde catre un utilizator administrativ. \n➢Sinonimele private trebuie distruse de utilizatorul care \nle-a creat acestea nefiind disponibile in cadrul listei \nnumelor de obiecte a celorlalti utilizatori.\nCurs - BAZE DE DATE 49\n\nBibliografie\nFlorin Rădulescu: Oracle SQL, PL/SQL, Editura \nPrintech, ISBN 973-718-203-02005\nCurs - BAZE DE DATE 50\n\nÎntrebări?\nCurs - BAZE DE DATE 51"", '\n', '10. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n']","comanda SQL pentru a crea un tabel de bază de date numit ""Customers"" este: `CREATE TABLE Customers`. Aceasta se bazează pe faptul că ""CREATE"" este comanda utilizată pentru crearea structurii unei tabele, conform secțiunii despre Limbajul de definire a datelor (LDD).
","Ce instrucțiune SQL este folosită pentru a crea un tabel de bază de date numit ""Customers""?","['1. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '2. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '3. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '4. ', ""- SQL echivalent: SELECT * FROM Student JOIN Inscriere ON Student.ID = \nInscriere.StudentID; \n \n \n2.2 Studiu de caz: Utilizarea algebrei relaționale într-o companie de livrări \nO companie de livrări utilizează o bază de date relațională pentru a gestiona comenzile, clienții și \nlivratorii. Relațiile cheie sunt: \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    Status V ARCHAR(20), \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE Livrator ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \nInterogări pentru monitorizarea livrărilor: \nSELECT Client.Nume, Comanda.Status \nFROM Client \nJOIN Comanda ON Client.ID = Comanda.ClientID; \n \n \n \n2.3. SQL - Limbajul interogărilor \nLimbajul SQL (Structured Query Language) este standardul pentru interacțiunea cu bazele de \ndate relaționale. \n \n2.3.1 Crearea bazelor de date și a tabelelor \nCREATE DATABASE Universitate; \nUSE Universitate; \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Prenume V ARCHAR(50), \n    An INT \n); \n \nCREATE TABLE Curs ( \n\n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n2.3.2 Inserarea datelor \nINSERT INTO Student (ID, Nume, Prenume, An) V ALUES (1, 'Popescu', 'Ion', 2); \nINSERT INTO Curs (Cod, Denumire) V ALUES (101, 'Baze de date'); \nINSERT INTO Inscriere (StudentID, CursCod) V ALUES (1, 101); \n \n2.3.3 Interogarea bazelor de date \n-- Selectarea tuturor studenților \nSELECT * FROM Student; \n \n-- Selectarea studenților de anul 2 \nSELECT * FROM Student WHERE An = 2; \n \n-- Afișarea cursurilor la care este înscris un student \nSELECT Curs.Denumire  \nFROM Curs  \nJOIN Inscriere ON Curs.Cod = Inscriere.CursCod  \nWHERE Inscriere.StudentID = 1; \n \n \n3. Integritatea datelor \nIntegritatea datelor asigură corectitudinea și consistența acestora în cadrul bazei de date. Tipurile \nprincipale sunt: \n \n1. Integritatea entităților: Fiecare tabel trebuie să aibă un identificator unic. \n2. Integritatea referențială: Relațiile dintre tabele trebuie să fie menținute corect prin chei primare \nși străine. \n3. Integritatea domeniului: Valorile din coloane trebuie să respecte tipul de date definit."", '\n', '5. ', ""- SQL echivalent: SELECT * FROM Student JOIN Inscriere ON Student.ID = \nInscriere.StudentID; \n \n \n2.2 Studiu de caz: Utilizarea algebrei relaționale într-o companie de livrări \nO companie de livrări utilizează o bază de date relațională pentru a gestiona comenzile, clienții și \nlivratorii. Relațiile cheie sunt: \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    Status V ARCHAR(20), \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE Livrator ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \nInterogări pentru monitorizarea livrărilor: \nSELECT Client.Nume, Comanda.Status \nFROM Client \nJOIN Comanda ON Client.ID = Comanda.ClientID; \n \n \n \n2.3. SQL - Limbajul interogărilor \nLimbajul SQL (Structured Query Language) este standardul pentru interacțiunea cu bazele de \ndate relaționale. \n \n2.3.1 Crearea bazelor de date și a tabelelor \nCREATE DATABASE Universitate; \nUSE Universitate; \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Prenume V ARCHAR(50), \n    An INT \n); \n \nCREATE TABLE Curs ( \n\n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n2.3.2 Inserarea datelor \nINSERT INTO Student (ID, Nume, Prenume, An) V ALUES (1, 'Popescu', 'Ion', 2); \nINSERT INTO Curs (Cod, Denumire) V ALUES (101, 'Baze de date'); \nINSERT INTO Inscriere (StudentID, CursCod) V ALUES (1, 101); \n \n2.3.3 Interogarea bazelor de date \n-- Selectarea tuturor studenților \nSELECT * FROM Student; \n \n-- Selectarea studenților de anul 2 \nSELECT * FROM Student WHERE An = 2; \n \n-- Afișarea cursurilor la care este înscris un student \nSELECT Curs.Denumire  \nFROM Curs  \nJOIN Inscriere ON Curs.Cod = Inscriere.CursCod  \nWHERE Inscriere.StudentID = 1; \n \n \n3. Integritatea datelor \nIntegritatea datelor asigură corectitudinea și consistența acestora în cadrul bazei de date. Tipurile \nprincipale sunt: \n \n1. Integritatea entităților: Fiecare tabel trebuie să aibă un identificator unic. \n2. Integritatea referențială: Relațiile dintre tabele trebuie să fie menținute corect prin chei primare \nși străine. \n3. Integritatea domeniului: Valorile din coloane trebuie să respecte tipul de date definit."", '\n', '6. ', ""- SQL echivalent: SELECT * FROM Student JOIN Inscriere ON Student.ID = \nInscriere.StudentID; \n \n \n2.2 Studiu de caz: Utilizarea algebrei relaționale într-o companie de livrări \nO companie de livrări utilizează o bază de date relațională pentru a gestiona comenzile, clienții și \nlivratorii. Relațiile cheie sunt: \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    Status V ARCHAR(20), \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE Livrator ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \nInterogări pentru monitorizarea livrărilor: \nSELECT Client.Nume, Comanda.Status \nFROM Client \nJOIN Comanda ON Client.ID = Comanda.ClientID; \n \n \n \n2.3. SQL - Limbajul interogărilor \nLimbajul SQL (Structured Query Language) este standardul pentru interacțiunea cu bazele de \ndate relaționale. \n \n2.3.1 Crearea bazelor de date și a tabelelor \nCREATE DATABASE Universitate; \nUSE Universitate; \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Prenume V ARCHAR(50), \n    An INT \n); \n \nCREATE TABLE Curs ( \n\n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n2.3.2 Inserarea datelor \nINSERT INTO Student (ID, Nume, Prenume, An) V ALUES (1, 'Popescu', 'Ion', 2); \nINSERT INTO Curs (Cod, Denumire) V ALUES (101, 'Baze de date'); \nINSERT INTO Inscriere (StudentID, CursCod) V ALUES (1, 101); \n \n2.3.3 Interogarea bazelor de date \n-- Selectarea tuturor studenților \nSELECT * FROM Student; \n \n-- Selectarea studenților de anul 2 \nSELECT * FROM Student WHERE An = 2; \n \n-- Afișarea cursurilor la care este înscris un student \nSELECT Curs.Denumire  \nFROM Curs  \nJOIN Inscriere ON Curs.Cod = Inscriere.CursCod  \nWHERE Inscriere.StudentID = 1; \n \n \n3. Integritatea datelor \nIntegritatea datelor asigură corectitudinea și consistența acestora în cadrul bazei de date. Tipurile \nprincipale sunt: \n \n1. Integritatea entităților: Fiecare tabel trebuie să aibă un identificator unic. \n2. Integritatea referențială: Relațiile dintre tabele trebuie să fie menținute corect prin chei primare \nși străine. \n3. Integritatea domeniului: Valorile din coloane trebuie să respecte tipul de date definit."", '\n', '7. ', ""3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43\n\n3. Sinonime\nPentru crearea sinonimelor este necesara o cerere SQL \ncare are urmatorul format:\nCurs - BAZE DE DATE 44\nCREATE [PUBLIC] SYNONYM nume_sinonim\nFOR nume_obiect;\nPUBLIC\nDefineste faptul ca acest sinonim este accesibil de catre toti \nutilizatorii. Daca nu este precizat atunci sinonimul este disponibil \ndoar pentru utilizatorul curent. Sinonimele publice pot fi create doar \nde catre utilizatorii care au drepturi administrative.\nnume_sinonim Numele sinonimului care va fi creat.\nnume_obiect Identifica obiectul pentru care se doreste crearea sinonimului \n\n3. Sinonime\n➢Daca dorim sa accesam o tabela pe care un alt utilizator \na creat-o in prealabil si careia ii dorim asignarea unui \nsinonim suntem obligati sa introducem inaintea numelui \ntabelei si numele utilizatorului care a creat tabela, in \nfata numelui tabelei, despartite de un punct.\nExemplu 1 - In acest exemplu vom incerca sa cream un \nsinonim pentru tabela departamente care are un nume \ndestul de lung.\nCREATE PUBLIC SYNONYM dep\nFOR dept;\nCurs - BAZE DE DATE 45\n\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46\n\n3. Sinonime\nExista unele restrictii in folosirea sinonimelor:\n➢obiectele respective nu pot sa fie continute intr-un \npachet.\n➢numele sinonimului privat trebuie sa fie unic in cadrul \ngrupului de obiecte pentru care acel user este \nproprietar.\nCurs - BAZE DE DATE 47\n\n3. Sinonime\n➢Un sinonim nu poate fi schimbat odata creat. \n➢El poate sa fie doar distrus. \n➢Distrugerea unui sinonim nu implica si distrugerea \nobiectului de care aliasul este atasat. \n➢Distrugerea unui sinonim este facuta folosind o \ninterogare SQL de tipul urmator:\nDROP [PUBLIC] SYNONYM nume_sinonim\nunde nume_sinonim este numele sinonimului care sa fie \ndistrus.\nCurs - BAZE DE DATE 48\n\n3. Sinonime\n➢Un sinonim de tip public poate sa fie sa fie distrus doar \nde catre un utilizator administrativ. \n➢Sinonimele private trebuie distruse de utilizatorul care \nle-a creat acestea nefiind disponibile in cadrul listei \nnumelor de obiecte a celorlalti utilizatori.\nCurs - BAZE DE DATE 49\n\nBibliografie\nFlorin Rădulescu: Oracle SQL, PL/SQL, Editura \nPrintech, ISBN 973-718-203-02005\nCurs - BAZE DE DATE 50\n\nÎntrebări?\nCurs - BAZE DE DATE 51"", '\n', '8. ', ""3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43\n\n3. Sinonime\nPentru crearea sinonimelor este necesara o cerere SQL \ncare are urmatorul format:\nCurs - BAZE DE DATE 44\nCREATE [PUBLIC] SYNONYM nume_sinonim\nFOR nume_obiect;\nPUBLIC\nDefineste faptul ca acest sinonim este accesibil de catre toti \nutilizatorii. Daca nu este precizat atunci sinonimul este disponibil \ndoar pentru utilizatorul curent. Sinonimele publice pot fi create doar \nde catre utilizatorii care au drepturi administrative.\nnume_sinonim Numele sinonimului care va fi creat.\nnume_obiect Identifica obiectul pentru care se doreste crearea sinonimului \n\n3. Sinonime\n➢Daca dorim sa accesam o tabela pe care un alt utilizator \na creat-o in prealabil si careia ii dorim asignarea unui \nsinonim suntem obligati sa introducem inaintea numelui \ntabelei si numele utilizatorului care a creat tabela, in \nfata numelui tabelei, despartite de un punct.\nExemplu 1 - In acest exemplu vom incerca sa cream un \nsinonim pentru tabela departamente care are un nume \ndestul de lung.\nCREATE PUBLIC SYNONYM dep\nFOR dept;\nCurs - BAZE DE DATE 45\n\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46\n\n3. Sinonime\nExista unele restrictii in folosirea sinonimelor:\n➢obiectele respective nu pot sa fie continute intr-un \npachet.\n➢numele sinonimului privat trebuie sa fie unic in cadrul \ngrupului de obiecte pentru care acel user este \nproprietar.\nCurs - BAZE DE DATE 47\n\n3. Sinonime\n➢Un sinonim nu poate fi schimbat odata creat. \n➢El poate sa fie doar distrus. \n➢Distrugerea unui sinonim nu implica si distrugerea \nobiectului de care aliasul este atasat. \n➢Distrugerea unui sinonim este facuta folosind o \ninterogare SQL de tipul urmator:\nDROP [PUBLIC] SYNONYM nume_sinonim\nunde nume_sinonim este numele sinonimului care sa fie \ndistrus.\nCurs - BAZE DE DATE 48\n\n3. Sinonime\n➢Un sinonim de tip public poate sa fie sa fie distrus doar \nde catre un utilizator administrativ. \n➢Sinonimele private trebuie distruse de utilizatorul care \nle-a creat acestea nefiind disponibile in cadrul listei \nnumelor de obiecte a celorlalti utilizatori.\nCurs - BAZE DE DATE 49\n\nBibliografie\nFlorin Rădulescu: Oracle SQL, PL/SQL, Editura \nPrintech, ISBN 973-718-203-02005\nCurs - BAZE DE DATE 50\n\nÎntrebări?\nCurs - BAZE DE DATE 51"", '\n', '9. ', ""3. Sinonime\n➢Principalul avantaj al utilizarii lor este pentru \nmicsorarea timpul necesar din partea utilizatorilor \npentru a-si crea cererile SQL. \n➢In felul acesta tabelele, vederile, secventele, \nprocedurile sau alte obiecte au un nume alternativ \npentru acces.\nCurs - BAZE DE DATE 43\n\n3. Sinonime\nPentru crearea sinonimelor este necesara o cerere SQL \ncare are urmatorul format:\nCurs - BAZE DE DATE 44\nCREATE [PUBLIC] SYNONYM nume_sinonim\nFOR nume_obiect;\nPUBLIC\nDefineste faptul ca acest sinonim este accesibil de catre toti \nutilizatorii. Daca nu este precizat atunci sinonimul este disponibil \ndoar pentru utilizatorul curent. Sinonimele publice pot fi create doar \nde catre utilizatorii care au drepturi administrative.\nnume_sinonim Numele sinonimului care va fi creat.\nnume_obiect Identifica obiectul pentru care se doreste crearea sinonimului \n\n3. Sinonime\n➢Daca dorim sa accesam o tabela pe care un alt utilizator \na creat-o in prealabil si careia ii dorim asignarea unui \nsinonim suntem obligati sa introducem inaintea numelui \ntabelei si numele utilizatorului care a creat tabela, in \nfata numelui tabelei, despartite de un punct.\nExemplu 1 - In acest exemplu vom incerca sa cream un \nsinonim pentru tabela departamente care are un nume \ndestul de lung.\nCREATE PUBLIC SYNONYM dep\nFOR dept;\nCurs - BAZE DE DATE 45\n\n3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46\n\n3. Sinonime\nExista unele restrictii in folosirea sinonimelor:\n➢obiectele respective nu pot sa fie continute intr-un \npachet.\n➢numele sinonimului privat trebuie sa fie unic in cadrul \ngrupului de obiecte pentru care acel user este \nproprietar.\nCurs - BAZE DE DATE 47\n\n3. Sinonime\n➢Un sinonim nu poate fi schimbat odata creat. \n➢El poate sa fie doar distrus. \n➢Distrugerea unui sinonim nu implica si distrugerea \nobiectului de care aliasul este atasat. \n➢Distrugerea unui sinonim este facuta folosind o \ninterogare SQL de tipul urmator:\nDROP [PUBLIC] SYNONYM nume_sinonim\nunde nume_sinonim este numele sinonimului care sa fie \ndistrus.\nCurs - BAZE DE DATE 48\n\n3. Sinonime\n➢Un sinonim de tip public poate sa fie sa fie distrus doar \nde catre un utilizator administrativ. \n➢Sinonimele private trebuie distruse de utilizatorul care \nle-a creat acestea nefiind disponibile in cadrul listei \nnumelor de obiecte a celorlalti utilizatori.\nCurs - BAZE DE DATE 49\n\nBibliografie\nFlorin Rădulescu: Oracle SQL, PL/SQL, Editura \nPrintech, ISBN 973-718-203-02005\nCurs - BAZE DE DATE 50\n\nÎntrebări?\nCurs - BAZE DE DATE 51"", '\n', '10. ', ""Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10\n\nParametru Descriere\nnume_secventa este numele generatorului de secventa care trebuie sa fie unic in cadrul \nlistei de secvente existente\nINCREMENT BY n\naceasta optiune specifica un intreg n cu care ultima intrare in secventa va \nfi incrementata pentru obtinerea unei noi valori. (daca optiunea nu este \nspecificata se foloseste 1)\nSTART WITH n precizeaza primul numar care va fi generat in cadrul secventei (daca \nacesta nu este specificat valoarea implicita este 1)\nMAXVALUE n specifica daca valoarea maxima pe care o secventa o poate genera\nNOMAXVALUE\nspecifica o valoare maxima pe care o secventa o poate genera egala cu \n1027 pentru o secventa incrementala sau -1 pentru o secventa \ndecrementala. (aceasta este optiunea folosita daca nu este specificata o \nvaloare maxima)\nMINVALUE n specifica valoarea minima pe care o secventa o poate genera.\nNOMINVALUE\nspecifica o valoare minima de 1 pentru o secventa ascendenta sau de -\n1026 pentru o secventa descendenta. (optiunea aceasta este folosita in \ncazul in care nu este specificat un minim)\nCYCLE | NOCYCLE specifica daca secventa va continua generarea de numere in cazul in care \nsecventa si-a atins limitele (NOCYCLE este optiunea implicita)\nCACHE n | NOCACHE precizeaza cate valori sunt tinute in memorie de catre serverul Oracle \n(implicit valoarea este de 20)\nParametrii utilizati:\nCurs - BAZE DE DATE 11\n\n1. Secventele\nExemplul 1 - Crearea unei secvente \nin cadrul tabelei departamente \npentru a fi folosita de cheia \nprimara.\nSa ne asiguram ca aceasta secventa \nnu exista deja:\nSELECT * \nFROM user_sequences \nWHERE sequence_name = \n'dept_seq1'; \nCurs - BAZE DE DATE 12\n\n\nAcum sa o cream avand optiunile urmatoare: \n• incepe la 120 \n• creste cu 10 unitati\n• valoare maxima este 9999 \n• fara ciclu \n• si fara cache\nCREATE SEQUENCE dept_seq_1\n  INCREMENT BY 1\n  START WITH 70\n  MAXVALUE 99\n  NOCACHE\n  NOCYCLE; \nCurs - BAZE DE DATE 13\n\n\nPseudocoloanele NEXTVAL si CURRVAL\n• Acestea se folosesc pentru a putea accesa valorile \nunei secvente. \n• Denumirile lor sunt sugestive:\n1. NEXTVAL = valoarea urmatoare\n2. CURRVAL = valoarea curenta\nCurs - BAZE DE DATE 14\n\n1. NEXTVAL este o pseudocoloana care este utilizata \npentru a putea extrage valoarea urmatoare dintr-o \nsecventa. \n➢Aceasta se foloseste intr-un SELECT impreuna cu \nnumele secventei din care se doreste extragerea \nvalorii. \n➢Daca sintaxa cererii SQL contine formatul \nnume_secventa.NEXTVAL atunci secventa este \nincrementata, valoarea curenta din NEXTVAL este \nplasata in CURRVAL si NEXTVAL va contine urmatorul \nnumar din secventa.\nCurs - BAZE DE DATE 15"", '\n']","comanda SQL pentru a crea un tabel de bază de date numit ""Customers"" este: `CREATE TABLE Customers`. Aceasta se bazează pe faptul că ""CREATE"" este comanda utilizată pentru crearea structurii unei tabele, conform secțiunii despre Limbajul de definire a datelor (LDD).
",CREATE TABLE Customers,0.3709663865472025,0.0,0.8809004907398528,0.6666666666666666,0.06429451441231725,0.13333333333333333,0.8
67,Manual - Test 3,Hard,,1,Care interogare actualizează salariul tuturor angajaților din departamentul 10 astfel încât să fie mărit cu 10% din salariul mediu al companiei?,UPDATE EMP SET SAL = SAL + 0.10 * (SELECT AVG(SAL) FROM EMP) WHERE DEPTNO = 10;,Este corect,,"['1. ', 'Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981. \n 39\n\n\nClauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10.\n 41\n\n\nClauza WHERE\n Atenţie! \n  Contează dacă caracterele sunt scrise cu litere \nmari sau cu litere mici.\n  Datele calendaristice sunt înregistrate în baza de \ndate într-un format numeric intern: \n secol, an, luna, ziua, ora, minute, secunde\n  Formatul de afişare este: DD-MON-RR. \nAcesta poate fi schimbat (vedeţi în alt curs). \n 42\n\nClauza WHERE\nC. Condiţii de comparare \n  În SQL sunt 4 operatori care pot fi folosiţi pentru \ntoate tipurile de date: \nOperator Semnificaţie\nBETWEEN...AND... între 2 valori (inclusiv)\nIN (lista) compară cu o listă de valori\nLIKE compară cu un model de tip caracter\nIS NULL este o valoare nulă\n 43\n\nClauza WHERE\n1. BETWEEN...AND... \nCondiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie).\nIntervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată\ntrebuie să fie limita inferioară. \n 44\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au salariul între 1000 şi 3000. \nSELECT *\nFROM EMP\nWHERE sal BETWEEN 1000 AND 3000;\n 45\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul între 1000 şi 3000. \n 46\n\n\nClauza WHERE\n2. IN \n  Condiţia IN testează valorile dintr-o listă \nspecificată.\n  Pot fi folosite orice tipuri de date, cu precizarea \ncă pentru şirurile de caractere şi date calendaristice \ntrebuie folosite ghilimelele simple (\' \'). \n 47\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au salariul în lista (1250, \n2450, 3000, 5000).\nSELECT ename, job, sal\nFROM EMP\nWHERE sal IN (1250, 2450, 3000, 5000);\n 48\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\n 49\n\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au numele în lista \'ALLEN\', \n\'WARD\', \'FORD\'. \nSELECT *\nFROM EMP\nWHERE ename IN (\'ALLEN\', \'WARD\', \'FORD\');\n 50\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista \'ALLEN\', \'WARD\', \'FORD\'. \n 51\n\n\nClauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53', '\n', '2. ', 'Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981. \n 39\n\n\nClauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10.\n 41\n\n\nClauza WHERE\n Atenţie! \n  Contează dacă caracterele sunt scrise cu litere \nmari sau cu litere mici.\n  Datele calendaristice sunt înregistrate în baza de \ndate într-un format numeric intern: \n secol, an, luna, ziua, ora, minute, secunde\n  Formatul de afişare este: DD-MON-RR. \nAcesta poate fi schimbat (vedeţi în alt curs). \n 42\n\nClauza WHERE\nC. Condiţii de comparare \n  În SQL sunt 4 operatori care pot fi folosiţi pentru \ntoate tipurile de date: \nOperator Semnificaţie\nBETWEEN...AND... între 2 valori (inclusiv)\nIN (lista) compară cu o listă de valori\nLIKE compară cu un model de tip caracter\nIS NULL este o valoare nulă\n 43\n\nClauza WHERE\n1. BETWEEN...AND... \nCondiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie).\nIntervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată\ntrebuie să fie limita inferioară. \n 44\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au salariul între 1000 şi 3000. \nSELECT *\nFROM EMP\nWHERE sal BETWEEN 1000 AND 3000;\n 45\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul între 1000 şi 3000. \n 46\n\n\nClauza WHERE\n2. IN \n  Condiţia IN testează valorile dintr-o listă \nspecificată.\n  Pot fi folosite orice tipuri de date, cu precizarea \ncă pentru şirurile de caractere şi date calendaristice \ntrebuie folosite ghilimelele simple (\' \'). \n 47\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au salariul în lista (1250, \n2450, 3000, 5000).\nSELECT ename, job, sal\nFROM EMP\nWHERE sal IN (1250, 2450, 3000, 5000);\n 48\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\n 49\n\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au numele în lista \'ALLEN\', \n\'WARD\', \'FORD\'. \nSELECT *\nFROM EMP\nWHERE ename IN (\'ALLEN\', \'WARD\', \'FORD\');\n 50\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista \'ALLEN\', \'WARD\', \'FORD\'. \n 51\n\n\nClauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53', '\n', '3. ', 'Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981. \n 39\n\n\nClauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10.\n 41\n\n\nClauza WHERE\n Atenţie! \n  Contează dacă caracterele sunt scrise cu litere \nmari sau cu litere mici.\n  Datele calendaristice sunt înregistrate în baza de \ndate într-un format numeric intern: \n secol, an, luna, ziua, ora, minute, secunde\n  Formatul de afişare este: DD-MON-RR. \nAcesta poate fi schimbat (vedeţi în alt curs). \n 42\n\nClauza WHERE\nC. Condiţii de comparare \n  În SQL sunt 4 operatori care pot fi folosiţi pentru \ntoate tipurile de date: \nOperator Semnificaţie\nBETWEEN...AND... între 2 valori (inclusiv)\nIN (lista) compară cu o listă de valori\nLIKE compară cu un model de tip caracter\nIS NULL este o valoare nulă\n 43\n\nClauza WHERE\n1. BETWEEN...AND... \nCondiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie).\nIntervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată\ntrebuie să fie limita inferioară. \n 44\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au salariul între 1000 şi 3000. \nSELECT *\nFROM EMP\nWHERE sal BETWEEN 1000 AND 3000;\n 45\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul între 1000 şi 3000. \n 46\n\n\nClauza WHERE\n2. IN \n  Condiţia IN testează valorile dintr-o listă \nspecificată.\n  Pot fi folosite orice tipuri de date, cu precizarea \ncă pentru şirurile de caractere şi date calendaristice \ntrebuie folosite ghilimelele simple (\' \'). \n 47\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au salariul în lista (1250, \n2450, 3000, 5000).\nSELECT ename, job, sal\nFROM EMP\nWHERE sal IN (1250, 2450, 3000, 5000);\n 48\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\n 49\n\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au numele în lista \'ALLEN\', \n\'WARD\', \'FORD\'. \nSELECT *\nFROM EMP\nWHERE ename IN (\'ALLEN\', \'WARD\', \'FORD\');\n 50\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista \'ALLEN\', \'WARD\', \'FORD\'. \n 51\n\n\nClauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53', '\n', '4. ', ""Exemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45\n\nExemplu IN - Aflati angajatii \ncare au salariul egal cu salariul \ncel mai mare din fiecare \ndepartament \nCurs 6 - BAZE DE DATE 46\n\n\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47\n\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n\n\nOperatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare.\nAstfel, \n < ANY inseamna mai mic decat maximul \n ANY inseamna mai mare decat minimul\n = ANY este echivalent cu IN\nCurs 6 - BAZE DE DATE 49\n\nExemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50\n\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n\n\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52\n\nImbricarea subcererilor \n Subcererile pot fi folosite si in interiorul altor \nsubinterogari. \n Exemplu \n Gasiti numele, functia, data angajarii si salariul \nangajatilor al caror salariu este superior celui mai mare \nsalariu al vreunei persoane angajate dupa data de \n12/09/1982.\nCurs 6 - BAZE DE DATE 53\n\nSELECT ename, job, hiredate, sal\nFROM EMP\nWHERE sal >\n          ( SELECT MAX(sal)\n          FROM EMP\n          WHERE hiredate IN \n                           ( SELECT hiredate\n                           FROM EMP\n                           WHERE hiredate > '12/09/1982' ) );\nNumarul maxim de imbricari pentru o subinterogare este de \n255.\nCurs 6 - BAZE DE DATE 54\n\nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55"", '\n', '5. ', ""Exemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45\n\nExemplu IN - Aflati angajatii \ncare au salariul egal cu salariul \ncel mai mare din fiecare \ndepartament \nCurs 6 - BAZE DE DATE 46\n\n\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47\n\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n\n\nOperatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare.\nAstfel, \n < ANY inseamna mai mic decat maximul \n ANY inseamna mai mare decat minimul\n = ANY este echivalent cu IN\nCurs 6 - BAZE DE DATE 49\n\nExemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50\n\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n\n\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52\n\nImbricarea subcererilor \n Subcererile pot fi folosite si in interiorul altor \nsubinterogari. \n Exemplu \n Gasiti numele, functia, data angajarii si salariul \nangajatilor al caror salariu este superior celui mai mare \nsalariu al vreunei persoane angajate dupa data de \n12/09/1982.\nCurs 6 - BAZE DE DATE 53\n\nSELECT ename, job, hiredate, sal\nFROM EMP\nWHERE sal >\n          ( SELECT MAX(sal)\n          FROM EMP\n          WHERE hiredate IN \n                           ( SELECT hiredate\n                           FROM EMP\n                           WHERE hiredate > '12/09/1982' ) );\nNumarul maxim de imbricari pentru o subinterogare este de \n255.\nCurs 6 - BAZE DE DATE 54\n\nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55"", '\n', '6. ', ""Exemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45\n\nExemplu IN - Aflati angajatii \ncare au salariul egal cu salariul \ncel mai mare din fiecare \ndepartament \nCurs 6 - BAZE DE DATE 46\n\n\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47\n\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n\n\nOperatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare.\nAstfel, \n < ANY inseamna mai mic decat maximul \n ANY inseamna mai mare decat minimul\n = ANY este echivalent cu IN\nCurs 6 - BAZE DE DATE 49\n\nExemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50\n\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n\n\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52\n\nImbricarea subcererilor \n Subcererile pot fi folosite si in interiorul altor \nsubinterogari. \n Exemplu \n Gasiti numele, functia, data angajarii si salariul \nangajatilor al caror salariu este superior celui mai mare \nsalariu al vreunei persoane angajate dupa data de \n12/09/1982.\nCurs 6 - BAZE DE DATE 53\n\nSELECT ename, job, hiredate, sal\nFROM EMP\nWHERE sal >\n          ( SELECT MAX(sal)\n          FROM EMP\n          WHERE hiredate IN \n                           ( SELECT hiredate\n                           FROM EMP\n                           WHERE hiredate > '12/09/1982' ) );\nNumarul maxim de imbricari pentru o subinterogare este de \n255.\nCurs 6 - BAZE DE DATE 54\n\nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55"", '\n', '7. ', ""6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 25\n\n\n6.1. SINGLE ROW SUBQUERIES\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nSELECT ename, sal\nFROM EMP\nWHERE deptno =\n    ( SELECT deptno\n       FROM DEPT\n       WHERE dname = 'RESEARCH' );\nCurs 6 - BAZE DE DATE 26\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 27\n\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n \n 6.1. SINGLE ROW SUBQUERIES\n \n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 28\n\n6.2. MULTIPLE ROW SUBQUERIES\n Sunt acele subinterogări care dau ca rezultat \nmai multe valori.\nFolosesc operatorii multiple row: \n1. IN\n2. ANY\n3. ALL\n  Operatorul NOT poate fi folosit în \ncombinaţie cu oricare dintre aceştia.\nCurs 6 - BAZE DE DATE 29\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât cel puţin o valoare dintre cele \nextrase de subquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate < ANY \n      ( SELECT hiredate\n          FROM EMP\n          GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 32\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY - Acest operator este \nfolosit atunci când dorim ca \ninterogarea exterioară să selecteze \nvalori egale, mai mici sau mai mari \ndecât cel puţin o valoare dintre cele \nextrase de subquery.\nCurs 6 - BAZE DE DATE 33\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n3. Operatorul ALL\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât toate valorile extrase de \nsubquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate > ALL \n     ( SELECT hiredate\n       FROM EMP\n       GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 34"", '\n', '8. ', ""6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 25\n\n\n6.1. SINGLE ROW SUBQUERIES\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nSELECT ename, sal\nFROM EMP\nWHERE deptno =\n    ( SELECT deptno\n       FROM DEPT\n       WHERE dname = 'RESEARCH' );\nCurs 6 - BAZE DE DATE 26\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 27\n\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n \n 6.1. SINGLE ROW SUBQUERIES\n \n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 28\n\n6.2. MULTIPLE ROW SUBQUERIES\n Sunt acele subinterogări care dau ca rezultat \nmai multe valori.\nFolosesc operatorii multiple row: \n1. IN\n2. ANY\n3. ALL\n  Operatorul NOT poate fi folosit în \ncombinaţie cu oricare dintre aceştia.\nCurs 6 - BAZE DE DATE 29\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât cel puţin o valoare dintre cele \nextrase de subquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate < ANY \n      ( SELECT hiredate\n          FROM EMP\n          GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 32\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY - Acest operator este \nfolosit atunci când dorim ca \ninterogarea exterioară să selecteze \nvalori egale, mai mici sau mai mari \ndecât cel puţin o valoare dintre cele \nextrase de subquery.\nCurs 6 - BAZE DE DATE 33\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n3. Operatorul ALL\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât toate valorile extrase de \nsubquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate > ALL \n     ( SELECT hiredate\n       FROM EMP\n       GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 34"", '\n', '9. ', ""6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 25\n\n\n6.1. SINGLE ROW SUBQUERIES\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nSELECT ename, sal\nFROM EMP\nWHERE deptno =\n    ( SELECT deptno\n       FROM DEPT\n       WHERE dname = 'RESEARCH' );\nCurs 6 - BAZE DE DATE 26\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 27\n\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n \n 6.1. SINGLE ROW SUBQUERIES\n \n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 28\n\n6.2. MULTIPLE ROW SUBQUERIES\n Sunt acele subinterogări care dau ca rezultat \nmai multe valori.\nFolosesc operatorii multiple row: \n1. IN\n2. ANY\n3. ALL\n  Operatorul NOT poate fi folosit în \ncombinaţie cu oricare dintre aceştia.\nCurs 6 - BAZE DE DATE 29\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât cel puţin o valoare dintre cele \nextrase de subquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate < ANY \n      ( SELECT hiredate\n          FROM EMP\n          GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 32\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY - Acest operator este \nfolosit atunci când dorim ca \ninterogarea exterioară să selecteze \nvalori egale, mai mici sau mai mari \ndecât cel puţin o valoare dintre cele \nextrase de subquery.\nCurs 6 - BAZE DE DATE 33\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n3. Operatorul ALL\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât toate valorile extrase de \nsubquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate > ALL \n     ( SELECT hiredate\n       FROM EMP\n       GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 34"", '\n', '10. ', 'Clauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82\n\n\nExercitii\n1. Listaţi toţi angajaţii care au salariul între 1500 \nşi 3000. \n2. Listaţi numele angajaţilor ordonându-i în \nordine alfabetică.\n3. Listaţi toţi angajaţii ai căror nume conţin LL sau \nTT în interior. \n4. Listaţi toţi angajaţii care nu au manager. \n 83\n\nExercitii\n5. Listaţi toţi angajaţii care au fost angajaţi în anul 1981. \n6. Afişaţi numele, salariul anual şi comisionul pentru toţi \nvânzătorii ai căror salariu lunar este mai mare decât \ncomisionul lor. \n- Ieşirea va fi ordonată după salariu, cele mai mari \nprimele. \n- Dacă doi sau mai mulţi angajaţi au acelaşi salariu \ntrebuie sortaţi după nume în ordinea celor mai mari \nsalarii.\n 84\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm\n3) https://www.w3resource.com/sql-exercises/\nCurs 4 - BAZE DE DATE 85\n\nÎntrebări?\n 86', '\n']","

```sql
UPDATE EMP
SET sal = sal + (SELECT AVG(sal) FROM EMP) * 0.1
WHERE deptno = 10;

```
",Care interogare actualizează salariul tuturor angajaților din departamentul 10 astfel încât să fie mărit cu 10% din salariul mediu al companiei?,"['1. ', 'Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981. \n 39\n\n\nClauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10.\n 41\n\n\nClauza WHERE\n Atenţie! \n  Contează dacă caracterele sunt scrise cu litere \nmari sau cu litere mici.\n  Datele calendaristice sunt înregistrate în baza de \ndate într-un format numeric intern: \n secol, an, luna, ziua, ora, minute, secunde\n  Formatul de afişare este: DD-MON-RR. \nAcesta poate fi schimbat (vedeţi în alt curs). \n 42\n\nClauza WHERE\nC. Condiţii de comparare \n  În SQL sunt 4 operatori care pot fi folosiţi pentru \ntoate tipurile de date: \nOperator Semnificaţie\nBETWEEN...AND... între 2 valori (inclusiv)\nIN (lista) compară cu o listă de valori\nLIKE compară cu un model de tip caracter\nIS NULL este o valoare nulă\n 43\n\nClauza WHERE\n1. BETWEEN...AND... \nCondiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie).\nIntervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată\ntrebuie să fie limita inferioară. \n 44\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au salariul între 1000 şi 3000. \nSELECT *\nFROM EMP\nWHERE sal BETWEEN 1000 AND 3000;\n 45\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul între 1000 şi 3000. \n 46\n\n\nClauza WHERE\n2. IN \n  Condiţia IN testează valorile dintr-o listă \nspecificată.\n  Pot fi folosite orice tipuri de date, cu precizarea \ncă pentru şirurile de caractere şi date calendaristice \ntrebuie folosite ghilimelele simple (\' \'). \n 47\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au salariul în lista (1250, \n2450, 3000, 5000).\nSELECT ename, job, sal\nFROM EMP\nWHERE sal IN (1250, 2450, 3000, 5000);\n 48\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\n 49\n\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au numele în lista \'ALLEN\', \n\'WARD\', \'FORD\'. \nSELECT *\nFROM EMP\nWHERE ename IN (\'ALLEN\', \'WARD\', \'FORD\');\n 50\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista \'ALLEN\', \'WARD\', \'FORD\'. \n 51\n\n\nClauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53', '\n', '2. ', 'Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981. \n 39\n\n\nClauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10.\n 41\n\n\nClauza WHERE\n Atenţie! \n  Contează dacă caracterele sunt scrise cu litere \nmari sau cu litere mici.\n  Datele calendaristice sunt înregistrate în baza de \ndate într-un format numeric intern: \n secol, an, luna, ziua, ora, minute, secunde\n  Formatul de afişare este: DD-MON-RR. \nAcesta poate fi schimbat (vedeţi în alt curs). \n 42\n\nClauza WHERE\nC. Condiţii de comparare \n  În SQL sunt 4 operatori care pot fi folosiţi pentru \ntoate tipurile de date: \nOperator Semnificaţie\nBETWEEN...AND... între 2 valori (inclusiv)\nIN (lista) compară cu o listă de valori\nLIKE compară cu un model de tip caracter\nIS NULL este o valoare nulă\n 43\n\nClauza WHERE\n1. BETWEEN...AND... \nCondiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie).\nIntervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată\ntrebuie să fie limita inferioară. \n 44\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au salariul între 1000 şi 3000. \nSELECT *\nFROM EMP\nWHERE sal BETWEEN 1000 AND 3000;\n 45\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul între 1000 şi 3000. \n 46\n\n\nClauza WHERE\n2. IN \n  Condiţia IN testează valorile dintr-o listă \nspecificată.\n  Pot fi folosite orice tipuri de date, cu precizarea \ncă pentru şirurile de caractere şi date calendaristice \ntrebuie folosite ghilimelele simple (\' \'). \n 47\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au salariul în lista (1250, \n2450, 3000, 5000).\nSELECT ename, job, sal\nFROM EMP\nWHERE sal IN (1250, 2450, 3000, 5000);\n 48\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\n 49\n\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au numele în lista \'ALLEN\', \n\'WARD\', \'FORD\'. \nSELECT *\nFROM EMP\nWHERE ename IN (\'ALLEN\', \'WARD\', \'FORD\');\n 50\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista \'ALLEN\', \'WARD\', \'FORD\'. \n 51\n\n\nClauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53', '\n', '3. ', 'Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981. \n 39\n\n\nClauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10.\n 41\n\n\nClauza WHERE\n Atenţie! \n  Contează dacă caracterele sunt scrise cu litere \nmari sau cu litere mici.\n  Datele calendaristice sunt înregistrate în baza de \ndate într-un format numeric intern: \n secol, an, luna, ziua, ora, minute, secunde\n  Formatul de afişare este: DD-MON-RR. \nAcesta poate fi schimbat (vedeţi în alt curs). \n 42\n\nClauza WHERE\nC. Condiţii de comparare \n  În SQL sunt 4 operatori care pot fi folosiţi pentru \ntoate tipurile de date: \nOperator Semnificaţie\nBETWEEN...AND... între 2 valori (inclusiv)\nIN (lista) compară cu o listă de valori\nLIKE compară cu un model de tip caracter\nIS NULL este o valoare nulă\n 43\n\nClauza WHERE\n1. BETWEEN...AND... \nCondiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie).\nIntervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată\ntrebuie să fie limita inferioară. \n 44\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au salariul între 1000 şi 3000. \nSELECT *\nFROM EMP\nWHERE sal BETWEEN 1000 AND 3000;\n 45\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul între 1000 şi 3000. \n 46\n\n\nClauza WHERE\n2. IN \n  Condiţia IN testează valorile dintr-o listă \nspecificată.\n  Pot fi folosite orice tipuri de date, cu precizarea \ncă pentru şirurile de caractere şi date calendaristice \ntrebuie folosite ghilimelele simple (\' \'). \n 47\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au salariul în lista (1250, \n2450, 3000, 5000).\nSELECT ename, job, sal\nFROM EMP\nWHERE sal IN (1250, 2450, 3000, 5000);\n 48\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\n 49\n\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au numele în lista \'ALLEN\', \n\'WARD\', \'FORD\'. \nSELECT *\nFROM EMP\nWHERE ename IN (\'ALLEN\', \'WARD\', \'FORD\');\n 50\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista \'ALLEN\', \'WARD\', \'FORD\'. \n 51\n\n\nClauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53', '\n', '4. ', ""Exemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45\n\nExemplu IN - Aflati angajatii \ncare au salariul egal cu salariul \ncel mai mare din fiecare \ndepartament \nCurs 6 - BAZE DE DATE 46\n\n\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47\n\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n\n\nOperatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare.\nAstfel, \n < ANY inseamna mai mic decat maximul \n ANY inseamna mai mare decat minimul\n = ANY este echivalent cu IN\nCurs 6 - BAZE DE DATE 49\n\nExemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50\n\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n\n\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52\n\nImbricarea subcererilor \n Subcererile pot fi folosite si in interiorul altor \nsubinterogari. \n Exemplu \n Gasiti numele, functia, data angajarii si salariul \nangajatilor al caror salariu este superior celui mai mare \nsalariu al vreunei persoane angajate dupa data de \n12/09/1982.\nCurs 6 - BAZE DE DATE 53\n\nSELECT ename, job, hiredate, sal\nFROM EMP\nWHERE sal >\n          ( SELECT MAX(sal)\n          FROM EMP\n          WHERE hiredate IN \n                           ( SELECT hiredate\n                           FROM EMP\n                           WHERE hiredate > '12/09/1982' ) );\nNumarul maxim de imbricari pentru o subinterogare este de \n255.\nCurs 6 - BAZE DE DATE 54\n\nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55"", '\n', '5. ', ""Exemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45\n\nExemplu IN - Aflati angajatii \ncare au salariul egal cu salariul \ncel mai mare din fiecare \ndepartament \nCurs 6 - BAZE DE DATE 46\n\n\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47\n\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n\n\nOperatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare.\nAstfel, \n < ANY inseamna mai mic decat maximul \n ANY inseamna mai mare decat minimul\n = ANY este echivalent cu IN\nCurs 6 - BAZE DE DATE 49\n\nExemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50\n\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n\n\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52\n\nImbricarea subcererilor \n Subcererile pot fi folosite si in interiorul altor \nsubinterogari. \n Exemplu \n Gasiti numele, functia, data angajarii si salariul \nangajatilor al caror salariu este superior celui mai mare \nsalariu al vreunei persoane angajate dupa data de \n12/09/1982.\nCurs 6 - BAZE DE DATE 53\n\nSELECT ename, job, hiredate, sal\nFROM EMP\nWHERE sal >\n          ( SELECT MAX(sal)\n          FROM EMP\n          WHERE hiredate IN \n                           ( SELECT hiredate\n                           FROM EMP\n                           WHERE hiredate > '12/09/1982' ) );\nNumarul maxim de imbricari pentru o subinterogare este de \n255.\nCurs 6 - BAZE DE DATE 54\n\nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55"", '\n', '6. ', ""Exemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45\n\nExemplu IN - Aflati angajatii \ncare au salariul egal cu salariul \ncel mai mare din fiecare \ndepartament \nCurs 6 - BAZE DE DATE 46\n\n\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47\n\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n\n\nOperatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare.\nAstfel, \n < ANY inseamna mai mic decat maximul \n ANY inseamna mai mare decat minimul\n = ANY este echivalent cu IN\nCurs 6 - BAZE DE DATE 49\n\nExemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50\n\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n\n\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52\n\nImbricarea subcererilor \n Subcererile pot fi folosite si in interiorul altor \nsubinterogari. \n Exemplu \n Gasiti numele, functia, data angajarii si salariul \nangajatilor al caror salariu este superior celui mai mare \nsalariu al vreunei persoane angajate dupa data de \n12/09/1982.\nCurs 6 - BAZE DE DATE 53\n\nSELECT ename, job, hiredate, sal\nFROM EMP\nWHERE sal >\n          ( SELECT MAX(sal)\n          FROM EMP\n          WHERE hiredate IN \n                           ( SELECT hiredate\n                           FROM EMP\n                           WHERE hiredate > '12/09/1982' ) );\nNumarul maxim de imbricari pentru o subinterogare este de \n255.\nCurs 6 - BAZE DE DATE 54\n\nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55"", '\n', '7. ', ""6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 25\n\n\n6.1. SINGLE ROW SUBQUERIES\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nSELECT ename, sal\nFROM EMP\nWHERE deptno =\n    ( SELECT deptno\n       FROM DEPT\n       WHERE dname = 'RESEARCH' );\nCurs 6 - BAZE DE DATE 26\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 27\n\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n \n 6.1. SINGLE ROW SUBQUERIES\n \n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 28\n\n6.2. MULTIPLE ROW SUBQUERIES\n Sunt acele subinterogări care dau ca rezultat \nmai multe valori.\nFolosesc operatorii multiple row: \n1. IN\n2. ANY\n3. ALL\n  Operatorul NOT poate fi folosit în \ncombinaţie cu oricare dintre aceştia.\nCurs 6 - BAZE DE DATE 29\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât cel puţin o valoare dintre cele \nextrase de subquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate < ANY \n      ( SELECT hiredate\n          FROM EMP\n          GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 32\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY - Acest operator este \nfolosit atunci când dorim ca \ninterogarea exterioară să selecteze \nvalori egale, mai mici sau mai mari \ndecât cel puţin o valoare dintre cele \nextrase de subquery.\nCurs 6 - BAZE DE DATE 33\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n3. Operatorul ALL\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât toate valorile extrase de \nsubquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate > ALL \n     ( SELECT hiredate\n       FROM EMP\n       GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 34"", '\n', '8. ', ""6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 25\n\n\n6.1. SINGLE ROW SUBQUERIES\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nSELECT ename, sal\nFROM EMP\nWHERE deptno =\n    ( SELECT deptno\n       FROM DEPT\n       WHERE dname = 'RESEARCH' );\nCurs 6 - BAZE DE DATE 26\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 27\n\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n \n 6.1. SINGLE ROW SUBQUERIES\n \n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 28\n\n6.2. MULTIPLE ROW SUBQUERIES\n Sunt acele subinterogări care dau ca rezultat \nmai multe valori.\nFolosesc operatorii multiple row: \n1. IN\n2. ANY\n3. ALL\n  Operatorul NOT poate fi folosit în \ncombinaţie cu oricare dintre aceştia.\nCurs 6 - BAZE DE DATE 29\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât cel puţin o valoare dintre cele \nextrase de subquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate < ANY \n      ( SELECT hiredate\n          FROM EMP\n          GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 32\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY - Acest operator este \nfolosit atunci când dorim ca \ninterogarea exterioară să selecteze \nvalori egale, mai mici sau mai mari \ndecât cel puţin o valoare dintre cele \nextrase de subquery.\nCurs 6 - BAZE DE DATE 33\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n3. Operatorul ALL\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât toate valorile extrase de \nsubquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate > ALL \n     ( SELECT hiredate\n       FROM EMP\n       GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 34"", '\n', '9. ', ""6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 25\n\n\n6.1. SINGLE ROW SUBQUERIES\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nSELECT ename, sal\nFROM EMP\nWHERE deptno =\n    ( SELECT deptno\n       FROM DEPT\n       WHERE dname = 'RESEARCH' );\nCurs 6 - BAZE DE DATE 26\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 27\n\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n \n 6.1. SINGLE ROW SUBQUERIES\n \n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 28\n\n6.2. MULTIPLE ROW SUBQUERIES\n Sunt acele subinterogări care dau ca rezultat \nmai multe valori.\nFolosesc operatorii multiple row: \n1. IN\n2. ANY\n3. ALL\n  Operatorul NOT poate fi folosit în \ncombinaţie cu oricare dintre aceştia.\nCurs 6 - BAZE DE DATE 29\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât cel puţin o valoare dintre cele \nextrase de subquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate < ANY \n      ( SELECT hiredate\n          FROM EMP\n          GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 32\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY - Acest operator este \nfolosit atunci când dorim ca \ninterogarea exterioară să selecteze \nvalori egale, mai mici sau mai mari \ndecât cel puţin o valoare dintre cele \nextrase de subquery.\nCurs 6 - BAZE DE DATE 33\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n3. Operatorul ALL\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât toate valorile extrase de \nsubquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate > ALL \n     ( SELECT hiredate\n       FROM EMP\n       GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 34"", '\n', '10. ', 'Clauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82\n\n\nExercitii\n1. Listaţi toţi angajaţii care au salariul între 1500 \nşi 3000. \n2. Listaţi numele angajaţilor ordonându-i în \nordine alfabetică.\n3. Listaţi toţi angajaţii ai căror nume conţin LL sau \nTT în interior. \n4. Listaţi toţi angajaţii care nu au manager. \n 83\n\nExercitii\n5. Listaţi toţi angajaţii care au fost angajaţi în anul 1981. \n6. Afişaţi numele, salariul anual şi comisionul pentru toţi \nvânzătorii ai căror salariu lunar este mai mare decât \ncomisionul lor. \n- Ieşirea va fi ordonată după salariu, cele mai mari \nprimele. \n- Dacă doi sau mai mulţi angajaţi au acelaşi salariu \ntrebuie sortaţi după nume în ordinea celor mai mari \nsalarii.\n 84\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm\n3) https://www.w3resource.com/sql-exercises/\nCurs 4 - BAZE DE DATE 85\n\nÎntrebări?\n 86', '\n']","

```sql
UPDATE EMP
SET sal = sal + (SELECT AVG(sal) FROM EMP) * 0.1
WHERE deptno = 10;

```
",UPDATE EMP SET SAL = SAL + 0.10 * (SELECT AVG(SAL) FROM EMP) WHERE DEPTNO = 10;,0.0,0.0,0.8281475865303599,0.0,0.2393884406276236,0.8387096774193549,1.0
68,Manual - Test 3,Hard,,,Care interogare șterge angajații al căror salariu este mai mic decât salariul mediu al departamentului lor și returnează numărul de rânduri afectate?,DELETE FROM EMP WHERE SAL < (SELECT AVG(SAL) FROM EMP WHERE DEPTNO = EMP.DEPTNO);,Este corect,,"['1. ', ""Exemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45\n\nExemplu IN - Aflati angajatii \ncare au salariul egal cu salariul \ncel mai mare din fiecare \ndepartament \nCurs 6 - BAZE DE DATE 46\n\n\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47\n\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n\n\nOperatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare.\nAstfel, \n < ANY inseamna mai mic decat maximul \n ANY inseamna mai mare decat minimul\n = ANY este echivalent cu IN\nCurs 6 - BAZE DE DATE 49\n\nExemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50\n\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n\n\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52\n\nImbricarea subcererilor \n Subcererile pot fi folosite si in interiorul altor \nsubinterogari. \n Exemplu \n Gasiti numele, functia, data angajarii si salariul \nangajatilor al caror salariu este superior celui mai mare \nsalariu al vreunei persoane angajate dupa data de \n12/09/1982.\nCurs 6 - BAZE DE DATE 53\n\nSELECT ename, job, hiredate, sal\nFROM EMP\nWHERE sal >\n          ( SELECT MAX(sal)\n          FROM EMP\n          WHERE hiredate IN \n                           ( SELECT hiredate\n                           FROM EMP\n                           WHERE hiredate > '12/09/1982' ) );\nNumarul maxim de imbricari pentru o subinterogare este de \n255.\nCurs 6 - BAZE DE DATE 54\n\nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55"", '\n', '2. ', ""Exemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45\n\nExemplu IN - Aflati angajatii \ncare au salariul egal cu salariul \ncel mai mare din fiecare \ndepartament \nCurs 6 - BAZE DE DATE 46\n\n\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47\n\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n\n\nOperatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare.\nAstfel, \n < ANY inseamna mai mic decat maximul \n ANY inseamna mai mare decat minimul\n = ANY este echivalent cu IN\nCurs 6 - BAZE DE DATE 49\n\nExemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50\n\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n\n\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52\n\nImbricarea subcererilor \n Subcererile pot fi folosite si in interiorul altor \nsubinterogari. \n Exemplu \n Gasiti numele, functia, data angajarii si salariul \nangajatilor al caror salariu este superior celui mai mare \nsalariu al vreunei persoane angajate dupa data de \n12/09/1982.\nCurs 6 - BAZE DE DATE 53\n\nSELECT ename, job, hiredate, sal\nFROM EMP\nWHERE sal >\n          ( SELECT MAX(sal)\n          FROM EMP\n          WHERE hiredate IN \n                           ( SELECT hiredate\n                           FROM EMP\n                           WHERE hiredate > '12/09/1982' ) );\nNumarul maxim de imbricari pentru o subinterogare este de \n255.\nCurs 6 - BAZE DE DATE 54\n\nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55"", '\n', '3. ', ""Exemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45\n\nExemplu IN - Aflati angajatii \ncare au salariul egal cu salariul \ncel mai mare din fiecare \ndepartament \nCurs 6 - BAZE DE DATE 46\n\n\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47\n\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n\n\nOperatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare.\nAstfel, \n < ANY inseamna mai mic decat maximul \n ANY inseamna mai mare decat minimul\n = ANY este echivalent cu IN\nCurs 6 - BAZE DE DATE 49\n\nExemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50\n\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n\n\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52\n\nImbricarea subcererilor \n Subcererile pot fi folosite si in interiorul altor \nsubinterogari. \n Exemplu \n Gasiti numele, functia, data angajarii si salariul \nangajatilor al caror salariu este superior celui mai mare \nsalariu al vreunei persoane angajate dupa data de \n12/09/1982.\nCurs 6 - BAZE DE DATE 53\n\nSELECT ename, job, hiredate, sal\nFROM EMP\nWHERE sal >\n          ( SELECT MAX(sal)\n          FROM EMP\n          WHERE hiredate IN \n                           ( SELECT hiredate\n                           FROM EMP\n                           WHERE hiredate > '12/09/1982' ) );\nNumarul maxim de imbricari pentru o subinterogare este de \n255.\nCurs 6 - BAZE DE DATE 54\n\nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55"", '\n', '4. ', ""6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 25\n\n\n6.1. SINGLE ROW SUBQUERIES\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nSELECT ename, sal\nFROM EMP\nWHERE deptno =\n    ( SELECT deptno\n       FROM DEPT\n       WHERE dname = 'RESEARCH' );\nCurs 6 - BAZE DE DATE 26\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 27\n\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n \n 6.1. SINGLE ROW SUBQUERIES\n \n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 28\n\n6.2. MULTIPLE ROW SUBQUERIES\n Sunt acele subinterogări care dau ca rezultat \nmai multe valori.\nFolosesc operatorii multiple row: \n1. IN\n2. ANY\n3. ALL\n  Operatorul NOT poate fi folosit în \ncombinaţie cu oricare dintre aceştia.\nCurs 6 - BAZE DE DATE 29\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât cel puţin o valoare dintre cele \nextrase de subquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate < ANY \n      ( SELECT hiredate\n          FROM EMP\n          GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 32\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY - Acest operator este \nfolosit atunci când dorim ca \ninterogarea exterioară să selecteze \nvalori egale, mai mici sau mai mari \ndecât cel puţin o valoare dintre cele \nextrase de subquery.\nCurs 6 - BAZE DE DATE 33\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n3. Operatorul ALL\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât toate valorile extrase de \nsubquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate > ALL \n     ( SELECT hiredate\n       FROM EMP\n       GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 34"", '\n', '5. ', ""6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 25\n\n\n6.1. SINGLE ROW SUBQUERIES\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nSELECT ename, sal\nFROM EMP\nWHERE deptno =\n    ( SELECT deptno\n       FROM DEPT\n       WHERE dname = 'RESEARCH' );\nCurs 6 - BAZE DE DATE 26\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 27\n\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n \n 6.1. SINGLE ROW SUBQUERIES\n \n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 28\n\n6.2. MULTIPLE ROW SUBQUERIES\n Sunt acele subinterogări care dau ca rezultat \nmai multe valori.\nFolosesc operatorii multiple row: \n1. IN\n2. ANY\n3. ALL\n  Operatorul NOT poate fi folosit în \ncombinaţie cu oricare dintre aceştia.\nCurs 6 - BAZE DE DATE 29\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât cel puţin o valoare dintre cele \nextrase de subquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate < ANY \n      ( SELECT hiredate\n          FROM EMP\n          GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 32\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY - Acest operator este \nfolosit atunci când dorim ca \ninterogarea exterioară să selecteze \nvalori egale, mai mici sau mai mari \ndecât cel puţin o valoare dintre cele \nextrase de subquery.\nCurs 6 - BAZE DE DATE 33\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n3. Operatorul ALL\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât toate valorile extrase de \nsubquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate > ALL \n     ( SELECT hiredate\n       FROM EMP\n       GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 34"", '\n', '6. ', ""6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 25\n\n\n6.1. SINGLE ROW SUBQUERIES\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nSELECT ename, sal\nFROM EMP\nWHERE deptno =\n    ( SELECT deptno\n       FROM DEPT\n       WHERE dname = 'RESEARCH' );\nCurs 6 - BAZE DE DATE 26\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 27\n\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n \n 6.1. SINGLE ROW SUBQUERIES\n \n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 28\n\n6.2. MULTIPLE ROW SUBQUERIES\n Sunt acele subinterogări care dau ca rezultat \nmai multe valori.\nFolosesc operatorii multiple row: \n1. IN\n2. ANY\n3. ALL\n  Operatorul NOT poate fi folosit în \ncombinaţie cu oricare dintre aceştia.\nCurs 6 - BAZE DE DATE 29\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât cel puţin o valoare dintre cele \nextrase de subquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate < ANY \n      ( SELECT hiredate\n          FROM EMP\n          GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 32\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY - Acest operator este \nfolosit atunci când dorim ca \ninterogarea exterioară să selecteze \nvalori egale, mai mici sau mai mari \ndecât cel puţin o valoare dintre cele \nextrase de subquery.\nCurs 6 - BAZE DE DATE 33\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n3. Operatorul ALL\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât toate valorile extrase de \nsubquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate > ALL \n     ( SELECT hiredate\n       FROM EMP\n       GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 34"", '\n', '7. ', 'Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981. \n 39\n\n\nClauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10.\n 41\n\n\nClauza WHERE\n Atenţie! \n  Contează dacă caracterele sunt scrise cu litere \nmari sau cu litere mici.\n  Datele calendaristice sunt înregistrate în baza de \ndate într-un format numeric intern: \n secol, an, luna, ziua, ora, minute, secunde\n  Formatul de afişare este: DD-MON-RR. \nAcesta poate fi schimbat (vedeţi în alt curs). \n 42\n\nClauza WHERE\nC. Condiţii de comparare \n  În SQL sunt 4 operatori care pot fi folosiţi pentru \ntoate tipurile de date: \nOperator Semnificaţie\nBETWEEN...AND... între 2 valori (inclusiv)\nIN (lista) compară cu o listă de valori\nLIKE compară cu un model de tip caracter\nIS NULL este o valoare nulă\n 43\n\nClauza WHERE\n1. BETWEEN...AND... \nCondiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie).\nIntervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată\ntrebuie să fie limita inferioară. \n 44\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au salariul între 1000 şi 3000. \nSELECT *\nFROM EMP\nWHERE sal BETWEEN 1000 AND 3000;\n 45\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul între 1000 şi 3000. \n 46\n\n\nClauza WHERE\n2. IN \n  Condiţia IN testează valorile dintr-o listă \nspecificată.\n  Pot fi folosite orice tipuri de date, cu precizarea \ncă pentru şirurile de caractere şi date calendaristice \ntrebuie folosite ghilimelele simple (\' \'). \n 47\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au salariul în lista (1250, \n2450, 3000, 5000).\nSELECT ename, job, sal\nFROM EMP\nWHERE sal IN (1250, 2450, 3000, 5000);\n 48\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\n 49\n\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au numele în lista \'ALLEN\', \n\'WARD\', \'FORD\'. \nSELECT *\nFROM EMP\nWHERE ename IN (\'ALLEN\', \'WARD\', \'FORD\');\n 50\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista \'ALLEN\', \'WARD\', \'FORD\'. \n 51\n\n\nClauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53', '\n', '8. ', 'Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981. \n 39\n\n\nClauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10.\n 41\n\n\nClauza WHERE\n Atenţie! \n  Contează dacă caracterele sunt scrise cu litere \nmari sau cu litere mici.\n  Datele calendaristice sunt înregistrate în baza de \ndate într-un format numeric intern: \n secol, an, luna, ziua, ora, minute, secunde\n  Formatul de afişare este: DD-MON-RR. \nAcesta poate fi schimbat (vedeţi în alt curs). \n 42\n\nClauza WHERE\nC. Condiţii de comparare \n  În SQL sunt 4 operatori care pot fi folosiţi pentru \ntoate tipurile de date: \nOperator Semnificaţie\nBETWEEN...AND... între 2 valori (inclusiv)\nIN (lista) compară cu o listă de valori\nLIKE compară cu un model de tip caracter\nIS NULL este o valoare nulă\n 43\n\nClauza WHERE\n1. BETWEEN...AND... \nCondiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie).\nIntervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată\ntrebuie să fie limita inferioară. \n 44\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au salariul între 1000 şi 3000. \nSELECT *\nFROM EMP\nWHERE sal BETWEEN 1000 AND 3000;\n 45\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul între 1000 şi 3000. \n 46\n\n\nClauza WHERE\n2. IN \n  Condiţia IN testează valorile dintr-o listă \nspecificată.\n  Pot fi folosite orice tipuri de date, cu precizarea \ncă pentru şirurile de caractere şi date calendaristice \ntrebuie folosite ghilimelele simple (\' \'). \n 47\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au salariul în lista (1250, \n2450, 3000, 5000).\nSELECT ename, job, sal\nFROM EMP\nWHERE sal IN (1250, 2450, 3000, 5000);\n 48\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\n 49\n\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au numele în lista \'ALLEN\', \n\'WARD\', \'FORD\'. \nSELECT *\nFROM EMP\nWHERE ename IN (\'ALLEN\', \'WARD\', \'FORD\');\n 50\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista \'ALLEN\', \'WARD\', \'FORD\'. \n 51\n\n\nClauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53', '\n', '9. ', 'Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981. \n 39\n\n\nClauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10.\n 41\n\n\nClauza WHERE\n Atenţie! \n  Contează dacă caracterele sunt scrise cu litere \nmari sau cu litere mici.\n  Datele calendaristice sunt înregistrate în baza de \ndate într-un format numeric intern: \n secol, an, luna, ziua, ora, minute, secunde\n  Formatul de afişare este: DD-MON-RR. \nAcesta poate fi schimbat (vedeţi în alt curs). \n 42\n\nClauza WHERE\nC. Condiţii de comparare \n  În SQL sunt 4 operatori care pot fi folosiţi pentru \ntoate tipurile de date: \nOperator Semnificaţie\nBETWEEN...AND... între 2 valori (inclusiv)\nIN (lista) compară cu o listă de valori\nLIKE compară cu un model de tip caracter\nIS NULL este o valoare nulă\n 43\n\nClauza WHERE\n1. BETWEEN...AND... \nCondiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie).\nIntervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată\ntrebuie să fie limita inferioară. \n 44\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au salariul între 1000 şi 3000. \nSELECT *\nFROM EMP\nWHERE sal BETWEEN 1000 AND 3000;\n 45\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul între 1000 şi 3000. \n 46\n\n\nClauza WHERE\n2. IN \n  Condiţia IN testează valorile dintr-o listă \nspecificată.\n  Pot fi folosite orice tipuri de date, cu precizarea \ncă pentru şirurile de caractere şi date calendaristice \ntrebuie folosite ghilimelele simple (\' \'). \n 47\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au salariul în lista (1250, \n2450, 3000, 5000).\nSELECT ename, job, sal\nFROM EMP\nWHERE sal IN (1250, 2450, 3000, 5000);\n 48\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\n 49\n\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au numele în lista \'ALLEN\', \n\'WARD\', \'FORD\'. \nSELECT *\nFROM EMP\nWHERE ename IN (\'ALLEN\', \'WARD\', \'FORD\');\n 50\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista \'ALLEN\', \'WARD\', \'FORD\'. \n 51\n\n\nClauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53', '\n', '10. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n']","
```sql
DELETE FROM EMP
WHERE sal < (SELECT AVG(sal) FROM EMP GROUP BY deptno)
```
",Care interogare șterge angajații al căror salariu este mai mic decât salariul mediu al departamentului lor și returnează numărul de rânduri afectate?,"['1. ', ""Exemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45\n\nExemplu IN - Aflati angajatii \ncare au salariul egal cu salariul \ncel mai mare din fiecare \ndepartament \nCurs 6 - BAZE DE DATE 46\n\n\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47\n\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n\n\nOperatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare.\nAstfel, \n < ANY inseamna mai mic decat maximul \n ANY inseamna mai mare decat minimul\n = ANY este echivalent cu IN\nCurs 6 - BAZE DE DATE 49\n\nExemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50\n\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n\n\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52\n\nImbricarea subcererilor \n Subcererile pot fi folosite si in interiorul altor \nsubinterogari. \n Exemplu \n Gasiti numele, functia, data angajarii si salariul \nangajatilor al caror salariu este superior celui mai mare \nsalariu al vreunei persoane angajate dupa data de \n12/09/1982.\nCurs 6 - BAZE DE DATE 53\n\nSELECT ename, job, hiredate, sal\nFROM EMP\nWHERE sal >\n          ( SELECT MAX(sal)\n          FROM EMP\n          WHERE hiredate IN \n                           ( SELECT hiredate\n                           FROM EMP\n                           WHERE hiredate > '12/09/1982' ) );\nNumarul maxim de imbricari pentru o subinterogare este de \n255.\nCurs 6 - BAZE DE DATE 54\n\nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55"", '\n', '2. ', ""Exemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45\n\nExemplu IN - Aflati angajatii \ncare au salariul egal cu salariul \ncel mai mare din fiecare \ndepartament \nCurs 6 - BAZE DE DATE 46\n\n\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47\n\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n\n\nOperatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare.\nAstfel, \n < ANY inseamna mai mic decat maximul \n ANY inseamna mai mare decat minimul\n = ANY este echivalent cu IN\nCurs 6 - BAZE DE DATE 49\n\nExemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50\n\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n\n\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52\n\nImbricarea subcererilor \n Subcererile pot fi folosite si in interiorul altor \nsubinterogari. \n Exemplu \n Gasiti numele, functia, data angajarii si salariul \nangajatilor al caror salariu este superior celui mai mare \nsalariu al vreunei persoane angajate dupa data de \n12/09/1982.\nCurs 6 - BAZE DE DATE 53\n\nSELECT ename, job, hiredate, sal\nFROM EMP\nWHERE sal >\n          ( SELECT MAX(sal)\n          FROM EMP\n          WHERE hiredate IN \n                           ( SELECT hiredate\n                           FROM EMP\n                           WHERE hiredate > '12/09/1982' ) );\nNumarul maxim de imbricari pentru o subinterogare este de \n255.\nCurs 6 - BAZE DE DATE 54\n\nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55"", '\n', '3. ', ""Exemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45\n\nExemplu IN - Aflati angajatii \ncare au salariul egal cu salariul \ncel mai mare din fiecare \ndepartament \nCurs 6 - BAZE DE DATE 46\n\n\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47\n\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n\n\nOperatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare.\nAstfel, \n < ANY inseamna mai mic decat maximul \n ANY inseamna mai mare decat minimul\n = ANY este echivalent cu IN\nCurs 6 - BAZE DE DATE 49\n\nExemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50\n\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n\n\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52\n\nImbricarea subcererilor \n Subcererile pot fi folosite si in interiorul altor \nsubinterogari. \n Exemplu \n Gasiti numele, functia, data angajarii si salariul \nangajatilor al caror salariu este superior celui mai mare \nsalariu al vreunei persoane angajate dupa data de \n12/09/1982.\nCurs 6 - BAZE DE DATE 53\n\nSELECT ename, job, hiredate, sal\nFROM EMP\nWHERE sal >\n          ( SELECT MAX(sal)\n          FROM EMP\n          WHERE hiredate IN \n                           ( SELECT hiredate\n                           FROM EMP\n                           WHERE hiredate > '12/09/1982' ) );\nNumarul maxim de imbricari pentru o subinterogare este de \n255.\nCurs 6 - BAZE DE DATE 54\n\nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55"", '\n', '4. ', ""6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 25\n\n\n6.1. SINGLE ROW SUBQUERIES\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nSELECT ename, sal\nFROM EMP\nWHERE deptno =\n    ( SELECT deptno\n       FROM DEPT\n       WHERE dname = 'RESEARCH' );\nCurs 6 - BAZE DE DATE 26\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 27\n\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n \n 6.1. SINGLE ROW SUBQUERIES\n \n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 28\n\n6.2. MULTIPLE ROW SUBQUERIES\n Sunt acele subinterogări care dau ca rezultat \nmai multe valori.\nFolosesc operatorii multiple row: \n1. IN\n2. ANY\n3. ALL\n  Operatorul NOT poate fi folosit în \ncombinaţie cu oricare dintre aceştia.\nCurs 6 - BAZE DE DATE 29\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât cel puţin o valoare dintre cele \nextrase de subquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate < ANY \n      ( SELECT hiredate\n          FROM EMP\n          GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 32\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY - Acest operator este \nfolosit atunci când dorim ca \ninterogarea exterioară să selecteze \nvalori egale, mai mici sau mai mari \ndecât cel puţin o valoare dintre cele \nextrase de subquery.\nCurs 6 - BAZE DE DATE 33\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n3. Operatorul ALL\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât toate valorile extrase de \nsubquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate > ALL \n     ( SELECT hiredate\n       FROM EMP\n       GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 34"", '\n', '5. ', ""6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 25\n\n\n6.1. SINGLE ROW SUBQUERIES\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nSELECT ename, sal\nFROM EMP\nWHERE deptno =\n    ( SELECT deptno\n       FROM DEPT\n       WHERE dname = 'RESEARCH' );\nCurs 6 - BAZE DE DATE 26\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 27\n\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n \n 6.1. SINGLE ROW SUBQUERIES\n \n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 28\n\n6.2. MULTIPLE ROW SUBQUERIES\n Sunt acele subinterogări care dau ca rezultat \nmai multe valori.\nFolosesc operatorii multiple row: \n1. IN\n2. ANY\n3. ALL\n  Operatorul NOT poate fi folosit în \ncombinaţie cu oricare dintre aceştia.\nCurs 6 - BAZE DE DATE 29\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât cel puţin o valoare dintre cele \nextrase de subquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate < ANY \n      ( SELECT hiredate\n          FROM EMP\n          GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 32\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY - Acest operator este \nfolosit atunci când dorim ca \ninterogarea exterioară să selecteze \nvalori egale, mai mici sau mai mari \ndecât cel puţin o valoare dintre cele \nextrase de subquery.\nCurs 6 - BAZE DE DATE 33\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n3. Operatorul ALL\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât toate valorile extrase de \nsubquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate > ALL \n     ( SELECT hiredate\n       FROM EMP\n       GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 34"", '\n', '6. ', ""6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 25\n\n\n6.1. SINGLE ROW SUBQUERIES\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nSELECT ename, sal\nFROM EMP\nWHERE deptno =\n    ( SELECT deptno\n       FROM DEPT\n       WHERE dname = 'RESEARCH' );\nCurs 6 - BAZE DE DATE 26\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 27\n\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n \n 6.1. SINGLE ROW SUBQUERIES\n \n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 28\n\n6.2. MULTIPLE ROW SUBQUERIES\n Sunt acele subinterogări care dau ca rezultat \nmai multe valori.\nFolosesc operatorii multiple row: \n1. IN\n2. ANY\n3. ALL\n  Operatorul NOT poate fi folosit în \ncombinaţie cu oricare dintre aceştia.\nCurs 6 - BAZE DE DATE 29\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30\n\n6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât cel puţin o valoare dintre cele \nextrase de subquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate < ANY \n      ( SELECT hiredate\n          FROM EMP\n          GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 32\n\n6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY - Acest operator este \nfolosit atunci când dorim ca \ninterogarea exterioară să selecteze \nvalori egale, mai mici sau mai mari \ndecât cel puţin o valoare dintre cele \nextrase de subquery.\nCurs 6 - BAZE DE DATE 33\n\n\n6.2. MULTIPLE ROW SUBQUERIES\n3. Operatorul ALL\n  Acest operator este folosit atunci când dorim ca \ninterogarea exterioară să selecteze valori egale, mai \nmici sau mai mari decât toate valorile extrase de \nsubquery.\nSELECT ename, sal, hiredate\nFROM EMP\nWHERE hiredate > ALL \n     ( SELECT hiredate\n       FROM EMP\n       GROUP BY hiredate );\nCurs 6 - BAZE DE DATE 34"", '\n', '7. ', 'Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981. \n 39\n\n\nClauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10.\n 41\n\n\nClauza WHERE\n Atenţie! \n  Contează dacă caracterele sunt scrise cu litere \nmari sau cu litere mici.\n  Datele calendaristice sunt înregistrate în baza de \ndate într-un format numeric intern: \n secol, an, luna, ziua, ora, minute, secunde\n  Formatul de afişare este: DD-MON-RR. \nAcesta poate fi schimbat (vedeţi în alt curs). \n 42\n\nClauza WHERE\nC. Condiţii de comparare \n  În SQL sunt 4 operatori care pot fi folosiţi pentru \ntoate tipurile de date: \nOperator Semnificaţie\nBETWEEN...AND... între 2 valori (inclusiv)\nIN (lista) compară cu o listă de valori\nLIKE compară cu un model de tip caracter\nIS NULL este o valoare nulă\n 43\n\nClauza WHERE\n1. BETWEEN...AND... \nCondiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie).\nIntervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată\ntrebuie să fie limita inferioară. \n 44\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au salariul între 1000 şi 3000. \nSELECT *\nFROM EMP\nWHERE sal BETWEEN 1000 AND 3000;\n 45\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul între 1000 şi 3000. \n 46\n\n\nClauza WHERE\n2. IN \n  Condiţia IN testează valorile dintr-o listă \nspecificată.\n  Pot fi folosite orice tipuri de date, cu precizarea \ncă pentru şirurile de caractere şi date calendaristice \ntrebuie folosite ghilimelele simple (\' \'). \n 47\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au salariul în lista (1250, \n2450, 3000, 5000).\nSELECT ename, job, sal\nFROM EMP\nWHERE sal IN (1250, 2450, 3000, 5000);\n 48\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\n 49\n\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au numele în lista \'ALLEN\', \n\'WARD\', \'FORD\'. \nSELECT *\nFROM EMP\nWHERE ename IN (\'ALLEN\', \'WARD\', \'FORD\');\n 50\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista \'ALLEN\', \'WARD\', \'FORD\'. \n 51\n\n\nClauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53', '\n', '8. ', 'Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981. \n 39\n\n\nClauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10.\n 41\n\n\nClauza WHERE\n Atenţie! \n  Contează dacă caracterele sunt scrise cu litere \nmari sau cu litere mici.\n  Datele calendaristice sunt înregistrate în baza de \ndate într-un format numeric intern: \n secol, an, luna, ziua, ora, minute, secunde\n  Formatul de afişare este: DD-MON-RR. \nAcesta poate fi schimbat (vedeţi în alt curs). \n 42\n\nClauza WHERE\nC. Condiţii de comparare \n  În SQL sunt 4 operatori care pot fi folosiţi pentru \ntoate tipurile de date: \nOperator Semnificaţie\nBETWEEN...AND... între 2 valori (inclusiv)\nIN (lista) compară cu o listă de valori\nLIKE compară cu un model de tip caracter\nIS NULL este o valoare nulă\n 43\n\nClauza WHERE\n1. BETWEEN...AND... \nCondiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie).\nIntervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată\ntrebuie să fie limita inferioară. \n 44\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au salariul între 1000 şi 3000. \nSELECT *\nFROM EMP\nWHERE sal BETWEEN 1000 AND 3000;\n 45\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul între 1000 şi 3000. \n 46\n\n\nClauza WHERE\n2. IN \n  Condiţia IN testează valorile dintr-o listă \nspecificată.\n  Pot fi folosite orice tipuri de date, cu precizarea \ncă pentru şirurile de caractere şi date calendaristice \ntrebuie folosite ghilimelele simple (\' \'). \n 47\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au salariul în lista (1250, \n2450, 3000, 5000).\nSELECT ename, job, sal\nFROM EMP\nWHERE sal IN (1250, 2450, 3000, 5000);\n 48\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\n 49\n\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au numele în lista \'ALLEN\', \n\'WARD\', \'FORD\'. \nSELECT *\nFROM EMP\nWHERE ename IN (\'ALLEN\', \'WARD\', \'FORD\');\n 50\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista \'ALLEN\', \'WARD\', \'FORD\'. \n 51\n\n\nClauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53', '\n', '9. ', 'Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981. \n 39\n\n\nClauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10.\n 41\n\n\nClauza WHERE\n Atenţie! \n  Contează dacă caracterele sunt scrise cu litere \nmari sau cu litere mici.\n  Datele calendaristice sunt înregistrate în baza de \ndate într-un format numeric intern: \n secol, an, luna, ziua, ora, minute, secunde\n  Formatul de afişare este: DD-MON-RR. \nAcesta poate fi schimbat (vedeţi în alt curs). \n 42\n\nClauza WHERE\nC. Condiţii de comparare \n  În SQL sunt 4 operatori care pot fi folosiţi pentru \ntoate tipurile de date: \nOperator Semnificaţie\nBETWEEN...AND... între 2 valori (inclusiv)\nIN (lista) compară cu o listă de valori\nLIKE compară cu un model de tip caracter\nIS NULL este o valoare nulă\n 43\n\nClauza WHERE\n1. BETWEEN...AND... \nCondiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie).\nIntervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată\ntrebuie să fie limita inferioară. \n 44\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au salariul între 1000 şi 3000. \nSELECT *\nFROM EMP\nWHERE sal BETWEEN 1000 AND 3000;\n 45\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul între 1000 şi 3000. \n 46\n\n\nClauza WHERE\n2. IN \n  Condiţia IN testează valorile dintr-o listă \nspecificată.\n  Pot fi folosite orice tipuri de date, cu precizarea \ncă pentru şirurile de caractere şi date calendaristice \ntrebuie folosite ghilimelele simple (\' \'). \n 47\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au salariul în lista (1250, \n2450, 3000, 5000).\nSELECT ename, job, sal\nFROM EMP\nWHERE sal IN (1250, 2450, 3000, 5000);\n 48\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\n 49\n\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au numele în lista \'ALLEN\', \n\'WARD\', \'FORD\'. \nSELECT *\nFROM EMP\nWHERE ename IN (\'ALLEN\', \'WARD\', \'FORD\');\n 50\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista \'ALLEN\', \'WARD\', \'FORD\'. \n 51\n\n\nClauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53', '\n', '10. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n']","
```sql
DELETE FROM EMP
WHERE sal < (SELECT AVG(sal) FROM EMP GROUP BY deptno)
```
",DELETE FROM EMP WHERE SAL < (SELECT AVG(SAL) FROM EMP WHERE DEPTNO = EMP.DEPTNO);,0.0,0.0,0.8123186201474043,0.0,0.2885952308349238,0.7857142857142857,1.0
69,Manual - Test 3,Hard,,,"Scrie o interogare care actualizează salariul fiecărui angajat din departamentul 30, mărindu-l cu 5% din salariul mediu al departamentului său.","UPDATE EMP 
SET SAL = SAL + 0.05 * (SELECT AVG(SAL) FROM EMP WHERE DEPTNO = 30) 
WHERE DEPTNO = 30;
",Este corect,,"['1. ', ""Exemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45\n\nExemplu IN - Aflati angajatii \ncare au salariul egal cu salariul \ncel mai mare din fiecare \ndepartament \nCurs 6 - BAZE DE DATE 46\n\n\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47\n\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n\n\nOperatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare.\nAstfel, \n < ANY inseamna mai mic decat maximul \n ANY inseamna mai mare decat minimul\n = ANY este echivalent cu IN\nCurs 6 - BAZE DE DATE 49\n\nExemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50\n\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n\n\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52\n\nImbricarea subcererilor \n Subcererile pot fi folosite si in interiorul altor \nsubinterogari. \n Exemplu \n Gasiti numele, functia, data angajarii si salariul \nangajatilor al caror salariu este superior celui mai mare \nsalariu al vreunei persoane angajate dupa data de \n12/09/1982.\nCurs 6 - BAZE DE DATE 53\n\nSELECT ename, job, hiredate, sal\nFROM EMP\nWHERE sal >\n          ( SELECT MAX(sal)\n          FROM EMP\n          WHERE hiredate IN \n                           ( SELECT hiredate\n                           FROM EMP\n                           WHERE hiredate > '12/09/1982' ) );\nNumarul maxim de imbricari pentru o subinterogare este de \n255.\nCurs 6 - BAZE DE DATE 54\n\nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55"", '\n', '2. ', ""Exemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45\n\nExemplu IN - Aflati angajatii \ncare au salariul egal cu salariul \ncel mai mare din fiecare \ndepartament \nCurs 6 - BAZE DE DATE 46\n\n\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47\n\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n\n\nOperatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare.\nAstfel, \n < ANY inseamna mai mic decat maximul \n ANY inseamna mai mare decat minimul\n = ANY este echivalent cu IN\nCurs 6 - BAZE DE DATE 49\n\nExemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50\n\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n\n\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52\n\nImbricarea subcererilor \n Subcererile pot fi folosite si in interiorul altor \nsubinterogari. \n Exemplu \n Gasiti numele, functia, data angajarii si salariul \nangajatilor al caror salariu este superior celui mai mare \nsalariu al vreunei persoane angajate dupa data de \n12/09/1982.\nCurs 6 - BAZE DE DATE 53\n\nSELECT ename, job, hiredate, sal\nFROM EMP\nWHERE sal >\n          ( SELECT MAX(sal)\n          FROM EMP\n          WHERE hiredate IN \n                           ( SELECT hiredate\n                           FROM EMP\n                           WHERE hiredate > '12/09/1982' ) );\nNumarul maxim de imbricari pentru o subinterogare este de \n255.\nCurs 6 - BAZE DE DATE 54\n\nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55"", '\n', '3. ', ""Exemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45\n\nExemplu IN - Aflati angajatii \ncare au salariul egal cu salariul \ncel mai mare din fiecare \ndepartament \nCurs 6 - BAZE DE DATE 46\n\n\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47\n\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n\n\nOperatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare.\nAstfel, \n < ANY inseamna mai mic decat maximul \n ANY inseamna mai mare decat minimul\n = ANY este echivalent cu IN\nCurs 6 - BAZE DE DATE 49\n\nExemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50\n\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n\n\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52\n\nImbricarea subcererilor \n Subcererile pot fi folosite si in interiorul altor \nsubinterogari. \n Exemplu \n Gasiti numele, functia, data angajarii si salariul \nangajatilor al caror salariu este superior celui mai mare \nsalariu al vreunei persoane angajate dupa data de \n12/09/1982.\nCurs 6 - BAZE DE DATE 53\n\nSELECT ename, job, hiredate, sal\nFROM EMP\nWHERE sal >\n          ( SELECT MAX(sal)\n          FROM EMP\n          WHERE hiredate IN \n                           ( SELECT hiredate\n                           FROM EMP\n                           WHERE hiredate > '12/09/1982' ) );\nNumarul maxim de imbricari pentru o subinterogare este de \n255.\nCurs 6 - BAZE DE DATE 54\n\nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55"", '\n', '4. ', 'Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981. \n 39\n\n\nClauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10.\n 41\n\n\nClauza WHERE\n Atenţie! \n  Contează dacă caracterele sunt scrise cu litere \nmari sau cu litere mici.\n  Datele calendaristice sunt înregistrate în baza de \ndate într-un format numeric intern: \n secol, an, luna, ziua, ora, minute, secunde\n  Formatul de afişare este: DD-MON-RR. \nAcesta poate fi schimbat (vedeţi în alt curs). \n 42\n\nClauza WHERE\nC. Condiţii de comparare \n  În SQL sunt 4 operatori care pot fi folosiţi pentru \ntoate tipurile de date: \nOperator Semnificaţie\nBETWEEN...AND... între 2 valori (inclusiv)\nIN (lista) compară cu o listă de valori\nLIKE compară cu un model de tip caracter\nIS NULL este o valoare nulă\n 43\n\nClauza WHERE\n1. BETWEEN...AND... \nCondiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie).\nIntervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată\ntrebuie să fie limita inferioară. \n 44\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au salariul între 1000 şi 3000. \nSELECT *\nFROM EMP\nWHERE sal BETWEEN 1000 AND 3000;\n 45\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul între 1000 şi 3000. \n 46\n\n\nClauza WHERE\n2. IN \n  Condiţia IN testează valorile dintr-o listă \nspecificată.\n  Pot fi folosite orice tipuri de date, cu precizarea \ncă pentru şirurile de caractere şi date calendaristice \ntrebuie folosite ghilimelele simple (\' \'). \n 47\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au salariul în lista (1250, \n2450, 3000, 5000).\nSELECT ename, job, sal\nFROM EMP\nWHERE sal IN (1250, 2450, 3000, 5000);\n 48\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\n 49\n\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au numele în lista \'ALLEN\', \n\'WARD\', \'FORD\'. \nSELECT *\nFROM EMP\nWHERE ename IN (\'ALLEN\', \'WARD\', \'FORD\');\n 50\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista \'ALLEN\', \'WARD\', \'FORD\'. \n 51\n\n\nClauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53', '\n', '5. ', 'Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981. \n 39\n\n\nClauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10.\n 41\n\n\nClauza WHERE\n Atenţie! \n  Contează dacă caracterele sunt scrise cu litere \nmari sau cu litere mici.\n  Datele calendaristice sunt înregistrate în baza de \ndate într-un format numeric intern: \n secol, an, luna, ziua, ora, minute, secunde\n  Formatul de afişare este: DD-MON-RR. \nAcesta poate fi schimbat (vedeţi în alt curs). \n 42\n\nClauza WHERE\nC. Condiţii de comparare \n  În SQL sunt 4 operatori care pot fi folosiţi pentru \ntoate tipurile de date: \nOperator Semnificaţie\nBETWEEN...AND... între 2 valori (inclusiv)\nIN (lista) compară cu o listă de valori\nLIKE compară cu un model de tip caracter\nIS NULL este o valoare nulă\n 43\n\nClauza WHERE\n1. BETWEEN...AND... \nCondiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie).\nIntervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată\ntrebuie să fie limita inferioară. \n 44\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au salariul între 1000 şi 3000. \nSELECT *\nFROM EMP\nWHERE sal BETWEEN 1000 AND 3000;\n 45\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul între 1000 şi 3000. \n 46\n\n\nClauza WHERE\n2. IN \n  Condiţia IN testează valorile dintr-o listă \nspecificată.\n  Pot fi folosite orice tipuri de date, cu precizarea \ncă pentru şirurile de caractere şi date calendaristice \ntrebuie folosite ghilimelele simple (\' \'). \n 47\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au salariul în lista (1250, \n2450, 3000, 5000).\nSELECT ename, job, sal\nFROM EMP\nWHERE sal IN (1250, 2450, 3000, 5000);\n 48\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\n 49\n\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au numele în lista \'ALLEN\', \n\'WARD\', \'FORD\'. \nSELECT *\nFROM EMP\nWHERE ename IN (\'ALLEN\', \'WARD\', \'FORD\');\n 50\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista \'ALLEN\', \'WARD\', \'FORD\'. \n 51\n\n\nClauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53', '\n', '6. ', 'Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981. \n 39\n\n\nClauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10.\n 41\n\n\nClauza WHERE\n Atenţie! \n  Contează dacă caracterele sunt scrise cu litere \nmari sau cu litere mici.\n  Datele calendaristice sunt înregistrate în baza de \ndate într-un format numeric intern: \n secol, an, luna, ziua, ora, minute, secunde\n  Formatul de afişare este: DD-MON-RR. \nAcesta poate fi schimbat (vedeţi în alt curs). \n 42\n\nClauza WHERE\nC. Condiţii de comparare \n  În SQL sunt 4 operatori care pot fi folosiţi pentru \ntoate tipurile de date: \nOperator Semnificaţie\nBETWEEN...AND... între 2 valori (inclusiv)\nIN (lista) compară cu o listă de valori\nLIKE compară cu un model de tip caracter\nIS NULL este o valoare nulă\n 43\n\nClauza WHERE\n1. BETWEEN...AND... \nCondiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie).\nIntervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată\ntrebuie să fie limita inferioară. \n 44\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au salariul între 1000 şi 3000. \nSELECT *\nFROM EMP\nWHERE sal BETWEEN 1000 AND 3000;\n 45\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul între 1000 şi 3000. \n 46\n\n\nClauza WHERE\n2. IN \n  Condiţia IN testează valorile dintr-o listă \nspecificată.\n  Pot fi folosite orice tipuri de date, cu precizarea \ncă pentru şirurile de caractere şi date calendaristice \ntrebuie folosite ghilimelele simple (\' \'). \n 47\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au salariul în lista (1250, \n2450, 3000, 5000).\nSELECT ename, job, sal\nFROM EMP\nWHERE sal IN (1250, 2450, 3000, 5000);\n 48\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\n 49\n\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au numele în lista \'ALLEN\', \n\'WARD\', \'FORD\'. \nSELECT *\nFROM EMP\nWHERE ename IN (\'ALLEN\', \'WARD\', \'FORD\');\n 50\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista \'ALLEN\', \'WARD\', \'FORD\'. \n 51\n\n\nClauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53', '\n', '7. ', ""4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul mediu pe fiecare departament, iar \nrezultatele ordonate după salariul mediu pe departament. \nCurs 5 - BAZE DE DATE 36\n\n\n4.3.1. Clauza GROUP BY\nGruparea după mai multe coloane. \n  Câteodată este necesară obţinerea de rezultate \npentru grupuri în alte grupuri. \n  Atunci în dreptul clauzei GROUP BY vom întâlni \nmai multe coloane.\nCurs 5 - BAZE DE DATE 37\n\n4.3.1. Clauza GROUP BY\nExemplul 10 \n Salariul total pe fiecare departament si pe fiecare \nfunctie, iar rezultatele ordonate după salariul mediu \npe departament. \nSELECT deptno, job, SUM(sal)\nFROM EMP\nGROUP BY deptno, job\nORDER BY AVG(sal);\nCurs 5 - BAZE DE DATE 38\n\n4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul total pe fiecare departament si pe \nfiecare functie, iar rezultatele ordonate după salariul mediu pe \ndepartament. \nCurs 5 - BAZE DE DATE 39\n\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING) \n  Clauza HAVING funcţionează în mare ca şi clauza \nWHERE, diferenţa fiind că HAVING este folosit pentru a \nexclude anumite grupuri din rezultat, nu rânduri cum \nfăcea WHERE.\n Clauza HAVING poate fi folosită înainte de GROUP \nBY, însă este mai logic să fie folosită după. \n  Ordinea execuţiei va rămâne aceeaşi.\nCurs 5 - BAZE DE DATE 41\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nExemplul 11 \n Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$. \nSELECT deptno, AVG(sal)\nFROM EMP\nHAVING AVG(sal) > 2000\nGROUP BY deptno;\nCurs 5 - BAZE DE DATE 42\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nRezultatul obtinut - Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$. \nCurs 5 - BAZE DE DATE 43\n\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nExemplul 12 \n Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$. \nSELECT deptno, MAX(sal)\nFROM EMP\nHAVING MAX(sal) > 2000\nGROUP BY deptno;\nCurs 5 - BAZE DE DATE 44\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nRezultatul obtinut - Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$. \nCurs 5 - BAZE DE DATE 45\n\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nExemplul 13 \nSalariul total pe fiecare funcţie, fără a lua în calcul \nMANAGERII, excluzând funcţiile cu suma salariilor sub \n6000$ cu ordonare după total.\nSELECT job, SUM(sal)\nFROM EMP\nWHERE job != 'MANAGER'\nGROUP BY job\nHAVING SUM(sal) < 6000\nORDER BY SUM(sal);\nSalariul total pe fiecare funcţie \nfără a lua în calcul MANAGERII \nexcluzând funcţiile cu suma \nsalariilor sub 6000$ \ncu ordonare după total\nCurs 5 - BAZE DE DATE 46"", '\n', '8. ', ""4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul mediu pe fiecare departament, iar \nrezultatele ordonate după salariul mediu pe departament. \nCurs 5 - BAZE DE DATE 36\n\n\n4.3.1. Clauza GROUP BY\nGruparea după mai multe coloane. \n  Câteodată este necesară obţinerea de rezultate \npentru grupuri în alte grupuri. \n  Atunci în dreptul clauzei GROUP BY vom întâlni \nmai multe coloane.\nCurs 5 - BAZE DE DATE 37\n\n4.3.1. Clauza GROUP BY\nExemplul 10 \n Salariul total pe fiecare departament si pe fiecare \nfunctie, iar rezultatele ordonate după salariul mediu \npe departament. \nSELECT deptno, job, SUM(sal)\nFROM EMP\nGROUP BY deptno, job\nORDER BY AVG(sal);\nCurs 5 - BAZE DE DATE 38\n\n4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul total pe fiecare departament si pe \nfiecare functie, iar rezultatele ordonate după salariul mediu pe \ndepartament. \nCurs 5 - BAZE DE DATE 39\n\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING) \n  Clauza HAVING funcţionează în mare ca şi clauza \nWHERE, diferenţa fiind că HAVING este folosit pentru a \nexclude anumite grupuri din rezultat, nu rânduri cum \nfăcea WHERE.\n Clauza HAVING poate fi folosită înainte de GROUP \nBY, însă este mai logic să fie folosită după. \n  Ordinea execuţiei va rămâne aceeaşi.\nCurs 5 - BAZE DE DATE 41\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nExemplul 11 \n Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$. \nSELECT deptno, AVG(sal)\nFROM EMP\nHAVING AVG(sal) > 2000\nGROUP BY deptno;\nCurs 5 - BAZE DE DATE 42\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nRezultatul obtinut - Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$. \nCurs 5 - BAZE DE DATE 43\n\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nExemplul 12 \n Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$. \nSELECT deptno, MAX(sal)\nFROM EMP\nHAVING MAX(sal) > 2000\nGROUP BY deptno;\nCurs 5 - BAZE DE DATE 44\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nRezultatul obtinut - Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$. \nCurs 5 - BAZE DE DATE 45\n\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nExemplul 13 \nSalariul total pe fiecare funcţie, fără a lua în calcul \nMANAGERII, excluzând funcţiile cu suma salariilor sub \n6000$ cu ordonare după total.\nSELECT job, SUM(sal)\nFROM EMP\nWHERE job != 'MANAGER'\nGROUP BY job\nHAVING SUM(sal) < 6000\nORDER BY SUM(sal);\nSalariul total pe fiecare funcţie \nfără a lua în calcul MANAGERII \nexcluzând funcţiile cu suma \nsalariilor sub 6000$ \ncu ordonare după total\nCurs 5 - BAZE DE DATE 46"", '\n', '9. ', ""4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul mediu pe fiecare departament, iar \nrezultatele ordonate după salariul mediu pe departament. \nCurs 5 - BAZE DE DATE 36\n\n\n4.3.1. Clauza GROUP BY\nGruparea după mai multe coloane. \n  Câteodată este necesară obţinerea de rezultate \npentru grupuri în alte grupuri. \n  Atunci în dreptul clauzei GROUP BY vom întâlni \nmai multe coloane.\nCurs 5 - BAZE DE DATE 37\n\n4.3.1. Clauza GROUP BY\nExemplul 10 \n Salariul total pe fiecare departament si pe fiecare \nfunctie, iar rezultatele ordonate după salariul mediu \npe departament. \nSELECT deptno, job, SUM(sal)\nFROM EMP\nGROUP BY deptno, job\nORDER BY AVG(sal);\nCurs 5 - BAZE DE DATE 38\n\n4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul total pe fiecare departament si pe \nfiecare functie, iar rezultatele ordonate după salariul mediu pe \ndepartament. \nCurs 5 - BAZE DE DATE 39\n\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING) \n  Clauza HAVING funcţionează în mare ca şi clauza \nWHERE, diferenţa fiind că HAVING este folosit pentru a \nexclude anumite grupuri din rezultat, nu rânduri cum \nfăcea WHERE.\n Clauza HAVING poate fi folosită înainte de GROUP \nBY, însă este mai logic să fie folosită după. \n  Ordinea execuţiei va rămâne aceeaşi.\nCurs 5 - BAZE DE DATE 41\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nExemplul 11 \n Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$. \nSELECT deptno, AVG(sal)\nFROM EMP\nHAVING AVG(sal) > 2000\nGROUP BY deptno;\nCurs 5 - BAZE DE DATE 42\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nRezultatul obtinut - Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$. \nCurs 5 - BAZE DE DATE 43\n\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nExemplul 12 \n Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$. \nSELECT deptno, MAX(sal)\nFROM EMP\nHAVING MAX(sal) > 2000\nGROUP BY deptno;\nCurs 5 - BAZE DE DATE 44\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nRezultatul obtinut - Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$. \nCurs 5 - BAZE DE DATE 45\n\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nExemplul 13 \nSalariul total pe fiecare funcţie, fără a lua în calcul \nMANAGERII, excluzând funcţiile cu suma salariilor sub \n6000$ cu ordonare după total.\nSELECT job, SUM(sal)\nFROM EMP\nWHERE job != 'MANAGER'\nGROUP BY job\nHAVING SUM(sal) < 6000\nORDER BY SUM(sal);\nSalariul total pe fiecare funcţie \nfără a lua în calcul MANAGERII \nexcluzând funcţiile cu suma \nsalariilor sub 6000$ \ncu ordonare după total\nCurs 5 - BAZE DE DATE 46"", '\n', '10. ', 'Clauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82\n\n\nExercitii\n1. Listaţi toţi angajaţii care au salariul între 1500 \nşi 3000. \n2. Listaţi numele angajaţilor ordonându-i în \nordine alfabetică.\n3. Listaţi toţi angajaţii ai căror nume conţin LL sau \nTT în interior. \n4. Listaţi toţi angajaţii care nu au manager. \n 83\n\nExercitii\n5. Listaţi toţi angajaţii care au fost angajaţi în anul 1981. \n6. Afişaţi numele, salariul anual şi comisionul pentru toţi \nvânzătorii ai căror salariu lunar este mai mare decât \ncomisionul lor. \n- Ieşirea va fi ordonată după salariu, cele mai mari \nprimele. \n- Dacă doi sau mai mulţi angajaţi au acelaşi salariu \ntrebuie sortaţi după nume în ordinea celor mai mari \nsalarii.\n 84\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm\n3) https://www.w3resource.com/sql-exercises/\nCurs 4 - BAZE DE DATE 85\n\nÎntrebări?\n 86', '\n']","
```sql
UPDATE EMP
SET sal = sal + (SELECT AVG(sal) FROM EMP WHERE deptno = 30) * 0.05
WHERE deptno = 30;
```
","Scrie o interogare care actualizează salariul fiecărui angajat din departamentul 30, mărindu-l cu 5% din salariul mediu al departamentului său.","['1. ', ""Exemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45\n\nExemplu IN - Aflati angajatii \ncare au salariul egal cu salariul \ncel mai mare din fiecare \ndepartament \nCurs 6 - BAZE DE DATE 46\n\n\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47\n\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n\n\nOperatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare.\nAstfel, \n < ANY inseamna mai mic decat maximul \n ANY inseamna mai mare decat minimul\n = ANY este echivalent cu IN\nCurs 6 - BAZE DE DATE 49\n\nExemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50\n\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n\n\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52\n\nImbricarea subcererilor \n Subcererile pot fi folosite si in interiorul altor \nsubinterogari. \n Exemplu \n Gasiti numele, functia, data angajarii si salariul \nangajatilor al caror salariu este superior celui mai mare \nsalariu al vreunei persoane angajate dupa data de \n12/09/1982.\nCurs 6 - BAZE DE DATE 53\n\nSELECT ename, job, hiredate, sal\nFROM EMP\nWHERE sal >\n          ( SELECT MAX(sal)\n          FROM EMP\n          WHERE hiredate IN \n                           ( SELECT hiredate\n                           FROM EMP\n                           WHERE hiredate > '12/09/1982' ) );\nNumarul maxim de imbricari pentru o subinterogare este de \n255.\nCurs 6 - BAZE DE DATE 54\n\nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55"", '\n', '2. ', ""Exemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45\n\nExemplu IN - Aflati angajatii \ncare au salariul egal cu salariul \ncel mai mare din fiecare \ndepartament \nCurs 6 - BAZE DE DATE 46\n\n\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47\n\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n\n\nOperatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare.\nAstfel, \n < ANY inseamna mai mic decat maximul \n ANY inseamna mai mare decat minimul\n = ANY este echivalent cu IN\nCurs 6 - BAZE DE DATE 49\n\nExemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50\n\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n\n\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52\n\nImbricarea subcererilor \n Subcererile pot fi folosite si in interiorul altor \nsubinterogari. \n Exemplu \n Gasiti numele, functia, data angajarii si salariul \nangajatilor al caror salariu este superior celui mai mare \nsalariu al vreunei persoane angajate dupa data de \n12/09/1982.\nCurs 6 - BAZE DE DATE 53\n\nSELECT ename, job, hiredate, sal\nFROM EMP\nWHERE sal >\n          ( SELECT MAX(sal)\n          FROM EMP\n          WHERE hiredate IN \n                           ( SELECT hiredate\n                           FROM EMP\n                           WHERE hiredate > '12/09/1982' ) );\nNumarul maxim de imbricari pentru o subinterogare este de \n255.\nCurs 6 - BAZE DE DATE 54\n\nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55"", '\n', '3. ', ""Exemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45\n\nExemplu IN - Aflati angajatii \ncare au salariul egal cu salariul \ncel mai mare din fiecare \ndepartament \nCurs 6 - BAZE DE DATE 46\n\n\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47\n\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n\n\nOperatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare.\nAstfel, \n < ANY inseamna mai mic decat maximul \n ANY inseamna mai mare decat minimul\n = ANY este echivalent cu IN\nCurs 6 - BAZE DE DATE 49\n\nExemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50\n\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n\n\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52\n\nImbricarea subcererilor \n Subcererile pot fi folosite si in interiorul altor \nsubinterogari. \n Exemplu \n Gasiti numele, functia, data angajarii si salariul \nangajatilor al caror salariu este superior celui mai mare \nsalariu al vreunei persoane angajate dupa data de \n12/09/1982.\nCurs 6 - BAZE DE DATE 53\n\nSELECT ename, job, hiredate, sal\nFROM EMP\nWHERE sal >\n          ( SELECT MAX(sal)\n          FROM EMP\n          WHERE hiredate IN \n                           ( SELECT hiredate\n                           FROM EMP\n                           WHERE hiredate > '12/09/1982' ) );\nNumarul maxim de imbricari pentru o subinterogare este de \n255.\nCurs 6 - BAZE DE DATE 54\n\nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55"", '\n', '4. ', 'Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981. \n 39\n\n\nClauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10.\n 41\n\n\nClauza WHERE\n Atenţie! \n  Contează dacă caracterele sunt scrise cu litere \nmari sau cu litere mici.\n  Datele calendaristice sunt înregistrate în baza de \ndate într-un format numeric intern: \n secol, an, luna, ziua, ora, minute, secunde\n  Formatul de afişare este: DD-MON-RR. \nAcesta poate fi schimbat (vedeţi în alt curs). \n 42\n\nClauza WHERE\nC. Condiţii de comparare \n  În SQL sunt 4 operatori care pot fi folosiţi pentru \ntoate tipurile de date: \nOperator Semnificaţie\nBETWEEN...AND... între 2 valori (inclusiv)\nIN (lista) compară cu o listă de valori\nLIKE compară cu un model de tip caracter\nIS NULL este o valoare nulă\n 43\n\nClauza WHERE\n1. BETWEEN...AND... \nCondiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie).\nIntervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată\ntrebuie să fie limita inferioară. \n 44\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au salariul între 1000 şi 3000. \nSELECT *\nFROM EMP\nWHERE sal BETWEEN 1000 AND 3000;\n 45\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul între 1000 şi 3000. \n 46\n\n\nClauza WHERE\n2. IN \n  Condiţia IN testează valorile dintr-o listă \nspecificată.\n  Pot fi folosite orice tipuri de date, cu precizarea \ncă pentru şirurile de caractere şi date calendaristice \ntrebuie folosite ghilimelele simple (\' \'). \n 47\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au salariul în lista (1250, \n2450, 3000, 5000).\nSELECT ename, job, sal\nFROM EMP\nWHERE sal IN (1250, 2450, 3000, 5000);\n 48\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\n 49\n\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au numele în lista \'ALLEN\', \n\'WARD\', \'FORD\'. \nSELECT *\nFROM EMP\nWHERE ename IN (\'ALLEN\', \'WARD\', \'FORD\');\n 50\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista \'ALLEN\', \'WARD\', \'FORD\'. \n 51\n\n\nClauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53', '\n', '5. ', 'Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981. \n 39\n\n\nClauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10.\n 41\n\n\nClauza WHERE\n Atenţie! \n  Contează dacă caracterele sunt scrise cu litere \nmari sau cu litere mici.\n  Datele calendaristice sunt înregistrate în baza de \ndate într-un format numeric intern: \n secol, an, luna, ziua, ora, minute, secunde\n  Formatul de afişare este: DD-MON-RR. \nAcesta poate fi schimbat (vedeţi în alt curs). \n 42\n\nClauza WHERE\nC. Condiţii de comparare \n  În SQL sunt 4 operatori care pot fi folosiţi pentru \ntoate tipurile de date: \nOperator Semnificaţie\nBETWEEN...AND... între 2 valori (inclusiv)\nIN (lista) compară cu o listă de valori\nLIKE compară cu un model de tip caracter\nIS NULL este o valoare nulă\n 43\n\nClauza WHERE\n1. BETWEEN...AND... \nCondiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie).\nIntervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată\ntrebuie să fie limita inferioară. \n 44\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au salariul între 1000 şi 3000. \nSELECT *\nFROM EMP\nWHERE sal BETWEEN 1000 AND 3000;\n 45\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul între 1000 şi 3000. \n 46\n\n\nClauza WHERE\n2. IN \n  Condiţia IN testează valorile dintr-o listă \nspecificată.\n  Pot fi folosite orice tipuri de date, cu precizarea \ncă pentru şirurile de caractere şi date calendaristice \ntrebuie folosite ghilimelele simple (\' \'). \n 47\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au salariul în lista (1250, \n2450, 3000, 5000).\nSELECT ename, job, sal\nFROM EMP\nWHERE sal IN (1250, 2450, 3000, 5000);\n 48\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\n 49\n\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au numele în lista \'ALLEN\', \n\'WARD\', \'FORD\'. \nSELECT *\nFROM EMP\nWHERE ename IN (\'ALLEN\', \'WARD\', \'FORD\');\n 50\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista \'ALLEN\', \'WARD\', \'FORD\'. \n 51\n\n\nClauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53', '\n', '6. ', 'Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981. \n 39\n\n\nClauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10.\n 41\n\n\nClauza WHERE\n Atenţie! \n  Contează dacă caracterele sunt scrise cu litere \nmari sau cu litere mici.\n  Datele calendaristice sunt înregistrate în baza de \ndate într-un format numeric intern: \n secol, an, luna, ziua, ora, minute, secunde\n  Formatul de afişare este: DD-MON-RR. \nAcesta poate fi schimbat (vedeţi în alt curs). \n 42\n\nClauza WHERE\nC. Condiţii de comparare \n  În SQL sunt 4 operatori care pot fi folosiţi pentru \ntoate tipurile de date: \nOperator Semnificaţie\nBETWEEN...AND... între 2 valori (inclusiv)\nIN (lista) compară cu o listă de valori\nLIKE compară cu un model de tip caracter\nIS NULL este o valoare nulă\n 43\n\nClauza WHERE\n1. BETWEEN...AND... \nCondiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie).\nIntervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată\ntrebuie să fie limita inferioară. \n 44\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au salariul între 1000 şi 3000. \nSELECT *\nFROM EMP\nWHERE sal BETWEEN 1000 AND 3000;\n 45\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul între 1000 şi 3000. \n 46\n\n\nClauza WHERE\n2. IN \n  Condiţia IN testează valorile dintr-o listă \nspecificată.\n  Pot fi folosite orice tipuri de date, cu precizarea \ncă pentru şirurile de caractere şi date calendaristice \ntrebuie folosite ghilimelele simple (\' \'). \n 47\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au salariul în lista (1250, \n2450, 3000, 5000).\nSELECT ename, job, sal\nFROM EMP\nWHERE sal IN (1250, 2450, 3000, 5000);\n 48\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\n 49\n\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au numele în lista \'ALLEN\', \n\'WARD\', \'FORD\'. \nSELECT *\nFROM EMP\nWHERE ename IN (\'ALLEN\', \'WARD\', \'FORD\');\n 50\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista \'ALLEN\', \'WARD\', \'FORD\'. \n 51\n\n\nClauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53', '\n', '7. ', ""4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul mediu pe fiecare departament, iar \nrezultatele ordonate după salariul mediu pe departament. \nCurs 5 - BAZE DE DATE 36\n\n\n4.3.1. Clauza GROUP BY\nGruparea după mai multe coloane. \n  Câteodată este necesară obţinerea de rezultate \npentru grupuri în alte grupuri. \n  Atunci în dreptul clauzei GROUP BY vom întâlni \nmai multe coloane.\nCurs 5 - BAZE DE DATE 37\n\n4.3.1. Clauza GROUP BY\nExemplul 10 \n Salariul total pe fiecare departament si pe fiecare \nfunctie, iar rezultatele ordonate după salariul mediu \npe departament. \nSELECT deptno, job, SUM(sal)\nFROM EMP\nGROUP BY deptno, job\nORDER BY AVG(sal);\nCurs 5 - BAZE DE DATE 38\n\n4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul total pe fiecare departament si pe \nfiecare functie, iar rezultatele ordonate după salariul mediu pe \ndepartament. \nCurs 5 - BAZE DE DATE 39\n\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING) \n  Clauza HAVING funcţionează în mare ca şi clauza \nWHERE, diferenţa fiind că HAVING este folosit pentru a \nexclude anumite grupuri din rezultat, nu rânduri cum \nfăcea WHERE.\n Clauza HAVING poate fi folosită înainte de GROUP \nBY, însă este mai logic să fie folosită după. \n  Ordinea execuţiei va rămâne aceeaşi.\nCurs 5 - BAZE DE DATE 41\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nExemplul 11 \n Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$. \nSELECT deptno, AVG(sal)\nFROM EMP\nHAVING AVG(sal) > 2000\nGROUP BY deptno;\nCurs 5 - BAZE DE DATE 42\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nRezultatul obtinut - Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$. \nCurs 5 - BAZE DE DATE 43\n\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nExemplul 12 \n Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$. \nSELECT deptno, MAX(sal)\nFROM EMP\nHAVING MAX(sal) > 2000\nGROUP BY deptno;\nCurs 5 - BAZE DE DATE 44\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nRezultatul obtinut - Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$. \nCurs 5 - BAZE DE DATE 45\n\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nExemplul 13 \nSalariul total pe fiecare funcţie, fără a lua în calcul \nMANAGERII, excluzând funcţiile cu suma salariilor sub \n6000$ cu ordonare după total.\nSELECT job, SUM(sal)\nFROM EMP\nWHERE job != 'MANAGER'\nGROUP BY job\nHAVING SUM(sal) < 6000\nORDER BY SUM(sal);\nSalariul total pe fiecare funcţie \nfără a lua în calcul MANAGERII \nexcluzând funcţiile cu suma \nsalariilor sub 6000$ \ncu ordonare după total\nCurs 5 - BAZE DE DATE 46"", '\n', '8. ', ""4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul mediu pe fiecare departament, iar \nrezultatele ordonate după salariul mediu pe departament. \nCurs 5 - BAZE DE DATE 36\n\n\n4.3.1. Clauza GROUP BY\nGruparea după mai multe coloane. \n  Câteodată este necesară obţinerea de rezultate \npentru grupuri în alte grupuri. \n  Atunci în dreptul clauzei GROUP BY vom întâlni \nmai multe coloane.\nCurs 5 - BAZE DE DATE 37\n\n4.3.1. Clauza GROUP BY\nExemplul 10 \n Salariul total pe fiecare departament si pe fiecare \nfunctie, iar rezultatele ordonate după salariul mediu \npe departament. \nSELECT deptno, job, SUM(sal)\nFROM EMP\nGROUP BY deptno, job\nORDER BY AVG(sal);\nCurs 5 - BAZE DE DATE 38\n\n4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul total pe fiecare departament si pe \nfiecare functie, iar rezultatele ordonate după salariul mediu pe \ndepartament. \nCurs 5 - BAZE DE DATE 39\n\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING) \n  Clauza HAVING funcţionează în mare ca şi clauza \nWHERE, diferenţa fiind că HAVING este folosit pentru a \nexclude anumite grupuri din rezultat, nu rânduri cum \nfăcea WHERE.\n Clauza HAVING poate fi folosită înainte de GROUP \nBY, însă este mai logic să fie folosită după. \n  Ordinea execuţiei va rămâne aceeaşi.\nCurs 5 - BAZE DE DATE 41\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nExemplul 11 \n Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$. \nSELECT deptno, AVG(sal)\nFROM EMP\nHAVING AVG(sal) > 2000\nGROUP BY deptno;\nCurs 5 - BAZE DE DATE 42\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nRezultatul obtinut - Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$. \nCurs 5 - BAZE DE DATE 43\n\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nExemplul 12 \n Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$. \nSELECT deptno, MAX(sal)\nFROM EMP\nHAVING MAX(sal) > 2000\nGROUP BY deptno;\nCurs 5 - BAZE DE DATE 44\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nRezultatul obtinut - Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$. \nCurs 5 - BAZE DE DATE 45\n\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nExemplul 13 \nSalariul total pe fiecare funcţie, fără a lua în calcul \nMANAGERII, excluzând funcţiile cu suma salariilor sub \n6000$ cu ordonare după total.\nSELECT job, SUM(sal)\nFROM EMP\nWHERE job != 'MANAGER'\nGROUP BY job\nHAVING SUM(sal) < 6000\nORDER BY SUM(sal);\nSalariul total pe fiecare funcţie \nfără a lua în calcul MANAGERII \nexcluzând funcţiile cu suma \nsalariilor sub 6000$ \ncu ordonare după total\nCurs 5 - BAZE DE DATE 46"", '\n', '9. ', ""4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul mediu pe fiecare departament, iar \nrezultatele ordonate după salariul mediu pe departament. \nCurs 5 - BAZE DE DATE 36\n\n\n4.3.1. Clauza GROUP BY\nGruparea după mai multe coloane. \n  Câteodată este necesară obţinerea de rezultate \npentru grupuri în alte grupuri. \n  Atunci în dreptul clauzei GROUP BY vom întâlni \nmai multe coloane.\nCurs 5 - BAZE DE DATE 37\n\n4.3.1. Clauza GROUP BY\nExemplul 10 \n Salariul total pe fiecare departament si pe fiecare \nfunctie, iar rezultatele ordonate după salariul mediu \npe departament. \nSELECT deptno, job, SUM(sal)\nFROM EMP\nGROUP BY deptno, job\nORDER BY AVG(sal);\nCurs 5 - BAZE DE DATE 38\n\n4.3.1. Clauza GROUP BY\nRezultatul obtinut - Salariul total pe fiecare departament si pe \nfiecare functie, iar rezultatele ordonate după salariul mediu pe \ndepartament. \nCurs 5 - BAZE DE DATE 39\n\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING) \n  Clauza HAVING funcţionează în mare ca şi clauza \nWHERE, diferenţa fiind că HAVING este folosit pentru a \nexclude anumite grupuri din rezultat, nu rânduri cum \nfăcea WHERE.\n Clauza HAVING poate fi folosită înainte de GROUP \nBY, însă este mai logic să fie folosită după. \n  Ordinea execuţiei va rămâne aceeaşi.\nCurs 5 - BAZE DE DATE 41\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nExemplul 11 \n Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$. \nSELECT deptno, AVG(sal)\nFROM EMP\nHAVING AVG(sal) > 2000\nGROUP BY deptno;\nCurs 5 - BAZE DE DATE 42\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nRezultatul obtinut - Salariul mediu pe fiecare departament unde \nacesta depăşeşte 2000$. \nCurs 5 - BAZE DE DATE 43\n\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nExemplul 12 \n Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$. \nSELECT deptno, MAX(sal)\nFROM EMP\nHAVING MAX(sal) > 2000\nGROUP BY deptno;\nCurs 5 - BAZE DE DATE 44\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nRezultatul obtinut - Salariul maxim pe fiecare departament unde \nacesta depăşeşte 2000$. \nCurs 5 - BAZE DE DATE 45\n\n\n4.3.2. Excluderea grupurilor \n(clauza HAVING)\nExemplul 13 \nSalariul total pe fiecare funcţie, fără a lua în calcul \nMANAGERII, excluzând funcţiile cu suma salariilor sub \n6000$ cu ordonare după total.\nSELECT job, SUM(sal)\nFROM EMP\nWHERE job != 'MANAGER'\nGROUP BY job\nHAVING SUM(sal) < 6000\nORDER BY SUM(sal);\nSalariul total pe fiecare funcţie \nfără a lua în calcul MANAGERII \nexcluzând funcţiile cu suma \nsalariilor sub 6000$ \ncu ordonare după total\nCurs 5 - BAZE DE DATE 46"", '\n', '10. ', 'Clauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82\n\n\nExercitii\n1. Listaţi toţi angajaţii care au salariul între 1500 \nşi 3000. \n2. Listaţi numele angajaţilor ordonându-i în \nordine alfabetică.\n3. Listaţi toţi angajaţii ai căror nume conţin LL sau \nTT în interior. \n4. Listaţi toţi angajaţii care nu au manager. \n 83\n\nExercitii\n5. Listaţi toţi angajaţii care au fost angajaţi în anul 1981. \n6. Afişaţi numele, salariul anual şi comisionul pentru toţi \nvânzătorii ai căror salariu lunar este mai mare decât \ncomisionul lor. \n- Ieşirea va fi ordonată după salariu, cele mai mari \nprimele. \n- Dacă doi sau mai mulţi angajaţi au acelaşi salariu \ntrebuie sortaţi după nume în ordinea celor mai mari \nsalarii.\n 84\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm\n3) https://www.w3resource.com/sql-exercises/\nCurs 4 - BAZE DE DATE 85\n\nÎntrebări?\n 86', '\n']","
```sql
UPDATE EMP
SET sal = sal + (SELECT AVG(sal) FROM EMP WHERE deptno = 30) * 0.05
WHERE deptno = 30;
```
","UPDATE EMP 
SET SAL = SAL + 0.05 * (SELECT AVG(SAL) FROM EMP WHERE DEPTNO = 30) 
WHERE DEPTNO = 30;
",0.0,0.0,0.8499288082230212,0.0,0.24005284553444656,0.8648648648648649,1.0
70,Manual - Test 3,Hard,,,Scrie o interogare care modifică funcția (JOB) angajaților care au fost angajați înainte de anul 2000 și le schimbă funcția în 'SENIOR'.,"UPDATE EMP 
SET JOB = 'SENIOR' 
WHERE EXTRACT(YEAR FROM HIREDATE) < 2000;",Este corect,,"['1. ', 'Clauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82\n\n\nExercitii\n1. Listaţi toţi angajaţii care au salariul între 1500 \nşi 3000. \n2. Listaţi numele angajaţilor ordonându-i în \nordine alfabetică.\n3. Listaţi toţi angajaţii ai căror nume conţin LL sau \nTT în interior. \n4. Listaţi toţi angajaţii care nu au manager. \n 83\n\nExercitii\n5. Listaţi toţi angajaţii care au fost angajaţi în anul 1981. \n6. Afişaţi numele, salariul anual şi comisionul pentru toţi \nvânzătorii ai căror salariu lunar este mai mare decât \ncomisionul lor. \n- Ieşirea va fi ordonată după salariu, cele mai mari \nprimele. \n- Dacă doi sau mai mulţi angajaţi au acelaşi salariu \ntrebuie sortaţi după nume în ordinea celor mai mari \nsalarii.\n 84\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm\n3) https://www.w3resource.com/sql-exercises/\nCurs 4 - BAZE DE DATE 85\n\nÎntrebări?\n 86', '\n', '2. ', 'Clauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82\n\n\nExercitii\n1. Listaţi toţi angajaţii care au salariul între 1500 \nşi 3000. \n2. Listaţi numele angajaţilor ordonându-i în \nordine alfabetică.\n3. Listaţi toţi angajaţii ai căror nume conţin LL sau \nTT în interior. \n4. Listaţi toţi angajaţii care nu au manager. \n 83\n\nExercitii\n5. Listaţi toţi angajaţii care au fost angajaţi în anul 1981. \n6. Afişaţi numele, salariul anual şi comisionul pentru toţi \nvânzătorii ai căror salariu lunar este mai mare decât \ncomisionul lor. \n- Ieşirea va fi ordonată după salariu, cele mai mari \nprimele. \n- Dacă doi sau mai mulţi angajaţi au acelaşi salariu \ntrebuie sortaţi după nume în ordinea celor mai mari \nsalarii.\n 84\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm\n3) https://www.w3resource.com/sql-exercises/\nCurs 4 - BAZE DE DATE 85\n\nÎntrebări?\n 86', '\n', '3. ', 'Clauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82\n\n\nExercitii\n1. Listaţi toţi angajaţii care au salariul între 1500 \nşi 3000. \n2. Listaţi numele angajaţilor ordonându-i în \nordine alfabetică.\n3. Listaţi toţi angajaţii ai căror nume conţin LL sau \nTT în interior. \n4. Listaţi toţi angajaţii care nu au manager. \n 83\n\nExercitii\n5. Listaţi toţi angajaţii care au fost angajaţi în anul 1981. \n6. Afişaţi numele, salariul anual şi comisionul pentru toţi \nvânzătorii ai căror salariu lunar este mai mare decât \ncomisionul lor. \n- Ieşirea va fi ordonată după salariu, cele mai mari \nprimele. \n- Dacă doi sau mai mulţi angajaţi au acelaşi salariu \ntrebuie sortaţi după nume în ordinea celor mai mari \nsalarii.\n 84\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm\n3) https://www.w3resource.com/sql-exercises/\nCurs 4 - BAZE DE DATE 85\n\nÎntrebări?\n 86', '\n', '4. ', ""Exemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45\n\nExemplu IN - Aflati angajatii \ncare au salariul egal cu salariul \ncel mai mare din fiecare \ndepartament \nCurs 6 - BAZE DE DATE 46\n\n\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47\n\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n\n\nOperatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare.\nAstfel, \n < ANY inseamna mai mic decat maximul \n ANY inseamna mai mare decat minimul\n = ANY este echivalent cu IN\nCurs 6 - BAZE DE DATE 49\n\nExemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50\n\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n\n\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52\n\nImbricarea subcererilor \n Subcererile pot fi folosite si in interiorul altor \nsubinterogari. \n Exemplu \n Gasiti numele, functia, data angajarii si salariul \nangajatilor al caror salariu este superior celui mai mare \nsalariu al vreunei persoane angajate dupa data de \n12/09/1982.\nCurs 6 - BAZE DE DATE 53\n\nSELECT ename, job, hiredate, sal\nFROM EMP\nWHERE sal >\n          ( SELECT MAX(sal)\n          FROM EMP\n          WHERE hiredate IN \n                           ( SELECT hiredate\n                           FROM EMP\n                           WHERE hiredate > '12/09/1982' ) );\nNumarul maxim de imbricari pentru o subinterogare este de \n255.\nCurs 6 - BAZE DE DATE 54\n\nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55"", '\n', '5. ', ""Exemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45\n\nExemplu IN - Aflati angajatii \ncare au salariul egal cu salariul \ncel mai mare din fiecare \ndepartament \nCurs 6 - BAZE DE DATE 46\n\n\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47\n\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n\n\nOperatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare.\nAstfel, \n < ANY inseamna mai mic decat maximul \n ANY inseamna mai mare decat minimul\n = ANY este echivalent cu IN\nCurs 6 - BAZE DE DATE 49\n\nExemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50\n\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n\n\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52\n\nImbricarea subcererilor \n Subcererile pot fi folosite si in interiorul altor \nsubinterogari. \n Exemplu \n Gasiti numele, functia, data angajarii si salariul \nangajatilor al caror salariu este superior celui mai mare \nsalariu al vreunei persoane angajate dupa data de \n12/09/1982.\nCurs 6 - BAZE DE DATE 53\n\nSELECT ename, job, hiredate, sal\nFROM EMP\nWHERE sal >\n          ( SELECT MAX(sal)\n          FROM EMP\n          WHERE hiredate IN \n                           ( SELECT hiredate\n                           FROM EMP\n                           WHERE hiredate > '12/09/1982' ) );\nNumarul maxim de imbricari pentru o subinterogare este de \n255.\nCurs 6 - BAZE DE DATE 54\n\nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55"", '\n', '6. ', ""Exemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45\n\nExemplu IN - Aflati angajatii \ncare au salariul egal cu salariul \ncel mai mare din fiecare \ndepartament \nCurs 6 - BAZE DE DATE 46\n\n\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47\n\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n\n\nOperatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare.\nAstfel, \n < ANY inseamna mai mic decat maximul \n ANY inseamna mai mare decat minimul\n = ANY este echivalent cu IN\nCurs 6 - BAZE DE DATE 49\n\nExemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50\n\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n\n\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52\n\nImbricarea subcererilor \n Subcererile pot fi folosite si in interiorul altor \nsubinterogari. \n Exemplu \n Gasiti numele, functia, data angajarii si salariul \nangajatilor al caror salariu este superior celui mai mare \nsalariu al vreunei persoane angajate dupa data de \n12/09/1982.\nCurs 6 - BAZE DE DATE 53\n\nSELECT ename, job, hiredate, sal\nFROM EMP\nWHERE sal >\n          ( SELECT MAX(sal)\n          FROM EMP\n          WHERE hiredate IN \n                           ( SELECT hiredate\n                           FROM EMP\n                           WHERE hiredate > '12/09/1982' ) );\nNumarul maxim de imbricari pentru o subinterogare este de \n255.\nCurs 6 - BAZE DE DATE 54\n\nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55"", '\n', '7. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '8. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '9. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '10. ', 'Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981. \n 39\n\n\nClauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10.\n 41\n\n\nClauza WHERE\n Atenţie! \n  Contează dacă caracterele sunt scrise cu litere \nmari sau cu litere mici.\n  Datele calendaristice sunt înregistrate în baza de \ndate într-un format numeric intern: \n secol, an, luna, ziua, ora, minute, secunde\n  Formatul de afişare este: DD-MON-RR. \nAcesta poate fi schimbat (vedeţi în alt curs). \n 42\n\nClauza WHERE\nC. Condiţii de comparare \n  În SQL sunt 4 operatori care pot fi folosiţi pentru \ntoate tipurile de date: \nOperator Semnificaţie\nBETWEEN...AND... între 2 valori (inclusiv)\nIN (lista) compară cu o listă de valori\nLIKE compară cu un model de tip caracter\nIS NULL este o valoare nulă\n 43\n\nClauza WHERE\n1. BETWEEN...AND... \nCondiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie).\nIntervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată\ntrebuie să fie limita inferioară. \n 44\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au salariul între 1000 şi 3000. \nSELECT *\nFROM EMP\nWHERE sal BETWEEN 1000 AND 3000;\n 45\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul între 1000 şi 3000. \n 46\n\n\nClauza WHERE\n2. IN \n  Condiţia IN testează valorile dintr-o listă \nspecificată.\n  Pot fi folosite orice tipuri de date, cu precizarea \ncă pentru şirurile de caractere şi date calendaristice \ntrebuie folosite ghilimelele simple (\' \'). \n 47\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au salariul în lista (1250, \n2450, 3000, 5000).\nSELECT ename, job, sal\nFROM EMP\nWHERE sal IN (1250, 2450, 3000, 5000);\n 48\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\n 49\n\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au numele în lista \'ALLEN\', \n\'WARD\', \'FORD\'. \nSELECT *\nFROM EMP\nWHERE ename IN (\'ALLEN\', \'WARD\', \'FORD\');\n 50\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista \'ALLEN\', \'WARD\', \'FORD\'. \n 51\n\n\nClauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53', '\n']","
```sql
UPDATE EMP
SET JOB = 'SENIOR'
WHERE hiredate < '2000-01-01';
```
",Scrie o interogare care modifică funcția (JOB) angajaților care au fost angajați înainte de anul 2000 și le schimbă funcția în 'SENIOR'.,"['1. ', 'Clauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82\n\n\nExercitii\n1. Listaţi toţi angajaţii care au salariul între 1500 \nşi 3000. \n2. Listaţi numele angajaţilor ordonându-i în \nordine alfabetică.\n3. Listaţi toţi angajaţii ai căror nume conţin LL sau \nTT în interior. \n4. Listaţi toţi angajaţii care nu au manager. \n 83\n\nExercitii\n5. Listaţi toţi angajaţii care au fost angajaţi în anul 1981. \n6. Afişaţi numele, salariul anual şi comisionul pentru toţi \nvânzătorii ai căror salariu lunar este mai mare decât \ncomisionul lor. \n- Ieşirea va fi ordonată după salariu, cele mai mari \nprimele. \n- Dacă doi sau mai mulţi angajaţi au acelaşi salariu \ntrebuie sortaţi după nume în ordinea celor mai mari \nsalarii.\n 84\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm\n3) https://www.w3resource.com/sql-exercises/\nCurs 4 - BAZE DE DATE 85\n\nÎntrebări?\n 86', '\n', '2. ', 'Clauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82\n\n\nExercitii\n1. Listaţi toţi angajaţii care au salariul între 1500 \nşi 3000. \n2. Listaţi numele angajaţilor ordonându-i în \nordine alfabetică.\n3. Listaţi toţi angajaţii ai căror nume conţin LL sau \nTT în interior. \n4. Listaţi toţi angajaţii care nu au manager. \n 83\n\nExercitii\n5. Listaţi toţi angajaţii care au fost angajaţi în anul 1981. \n6. Afişaţi numele, salariul anual şi comisionul pentru toţi \nvânzătorii ai căror salariu lunar este mai mare decât \ncomisionul lor. \n- Ieşirea va fi ordonată după salariu, cele mai mari \nprimele. \n- Dacă doi sau mai mulţi angajaţi au acelaşi salariu \ntrebuie sortaţi după nume în ordinea celor mai mari \nsalarii.\n 84\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm\n3) https://www.w3resource.com/sql-exercises/\nCurs 4 - BAZE DE DATE 85\n\nÎntrebări?\n 86', '\n', '3. ', 'Clauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82\n\n\nExercitii\n1. Listaţi toţi angajaţii care au salariul între 1500 \nşi 3000. \n2. Listaţi numele angajaţilor ordonându-i în \nordine alfabetică.\n3. Listaţi toţi angajaţii ai căror nume conţin LL sau \nTT în interior. \n4. Listaţi toţi angajaţii care nu au manager. \n 83\n\nExercitii\n5. Listaţi toţi angajaţii care au fost angajaţi în anul 1981. \n6. Afişaţi numele, salariul anual şi comisionul pentru toţi \nvânzătorii ai căror salariu lunar este mai mare decât \ncomisionul lor. \n- Ieşirea va fi ordonată după salariu, cele mai mari \nprimele. \n- Dacă doi sau mai mulţi angajaţi au acelaşi salariu \ntrebuie sortaţi după nume în ordinea celor mai mari \nsalarii.\n 84\n\nReferinţe bibliografice\n1) https://docs.oracle.com/cloud/help/ro/analy\ntics-cloud/ACUBI/GUID-4CBCE8D4-CF17-\n43BD-AAEF-C5D614A8040A.htm#BILUG672\n2) https://www.tutorialspoint.com/sql_certifica\nte/using_single_row_functions.htm\n3) https://www.w3resource.com/sql-exercises/\nCurs 4 - BAZE DE DATE 85\n\nÎntrebări?\n 86', '\n', '4. ', ""Exemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45\n\nExemplu IN - Aflati angajatii \ncare au salariul egal cu salariul \ncel mai mare din fiecare \ndepartament \nCurs 6 - BAZE DE DATE 46\n\n\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47\n\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n\n\nOperatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare.\nAstfel, \n < ANY inseamna mai mic decat maximul \n ANY inseamna mai mare decat minimul\n = ANY este echivalent cu IN\nCurs 6 - BAZE DE DATE 49\n\nExemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50\n\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n\n\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52\n\nImbricarea subcererilor \n Subcererile pot fi folosite si in interiorul altor \nsubinterogari. \n Exemplu \n Gasiti numele, functia, data angajarii si salariul \nangajatilor al caror salariu este superior celui mai mare \nsalariu al vreunei persoane angajate dupa data de \n12/09/1982.\nCurs 6 - BAZE DE DATE 53\n\nSELECT ename, job, hiredate, sal\nFROM EMP\nWHERE sal >\n          ( SELECT MAX(sal)\n          FROM EMP\n          WHERE hiredate IN \n                           ( SELECT hiredate\n                           FROM EMP\n                           WHERE hiredate > '12/09/1982' ) );\nNumarul maxim de imbricari pentru o subinterogare este de \n255.\nCurs 6 - BAZE DE DATE 54\n\nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55"", '\n', '5. ', ""Exemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45\n\nExemplu IN - Aflati angajatii \ncare au salariul egal cu salariul \ncel mai mare din fiecare \ndepartament \nCurs 6 - BAZE DE DATE 46\n\n\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47\n\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n\n\nOperatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare.\nAstfel, \n < ANY inseamna mai mic decat maximul \n ANY inseamna mai mare decat minimul\n = ANY este echivalent cu IN\nCurs 6 - BAZE DE DATE 49\n\nExemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50\n\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n\n\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52\n\nImbricarea subcererilor \n Subcererile pot fi folosite si in interiorul altor \nsubinterogari. \n Exemplu \n Gasiti numele, functia, data angajarii si salariul \nangajatilor al caror salariu este superior celui mai mare \nsalariu al vreunei persoane angajate dupa data de \n12/09/1982.\nCurs 6 - BAZE DE DATE 53\n\nSELECT ename, job, hiredate, sal\nFROM EMP\nWHERE sal >\n          ( SELECT MAX(sal)\n          FROM EMP\n          WHERE hiredate IN \n                           ( SELECT hiredate\n                           FROM EMP\n                           WHERE hiredate > '12/09/1982' ) );\nNumarul maxim de imbricari pentru o subinterogare este de \n255.\nCurs 6 - BAZE DE DATE 54\n\nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55"", '\n', '6. ', ""Exemplu IN\nAflati angajatii care au salariul egal cu salariul cel \nmai mare din fiecare departament \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal IN\n             ( SELECT MAX(sal)\n                FROM EMP\n          GROUP BY deptno )\n  subinterogarea ofera salariile maxime din fiecare \ndepartament si prin interogarea principala se afla \nangajatii cu aceste salarii.\nCurs 6 - BAZE DE DATE 45\n\nExemplu IN - Aflati angajatii \ncare au salariul egal cu salariul \ncel mai mare din fiecare \ndepartament \nCurs 6 - BAZE DE DATE 46\n\n\nExemplu ANY \nAflati angajatii care au salariul mai mare decat vreun \nangajat al departamentului 20 si nu fac parte din \nacest departament.\nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal > ANY\n                ( SELECT sal\n                 FROM EMP\n                 WHERE deptno = 20 )\nAND deptno <> 20;\nCurs 6 - BAZE DE DATE 47\n\nExemplu ANY - Aflati angajatii \ncare au salariul mai mare decat \nvreun angajat al departamentului \n20 si nu fac parte din acest \ndepartament. \nCurs 6 - BAZE DE DATE 48\n\n\nOperatorul ANY (sinonim operatorului SOME) \ncompara o valoare cu fiecare valoare din cele \nreturnate de subinterogare.\nAstfel, \n < ANY inseamna mai mic decat maximul \n ANY inseamna mai mare decat minimul\n = ANY este echivalent cu IN\nCurs 6 - BAZE DE DATE 49\n\nExemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50\n\nExemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n\n\n•Operatorul ALL din interogarea principala compara o \nvaloare cu oricare valoare returnata de subinterogare. \nAstfel:\n> ALL inseamna mai mare decat maximul\n< ALL inseamna mai mic decat minimul\nCurs 6 - BAZE DE DATE 52\n\nImbricarea subcererilor \n Subcererile pot fi folosite si in interiorul altor \nsubinterogari. \n Exemplu \n Gasiti numele, functia, data angajarii si salariul \nangajatilor al caror salariu este superior celui mai mare \nsalariu al vreunei persoane angajate dupa data de \n12/09/1982.\nCurs 6 - BAZE DE DATE 53\n\nSELECT ename, job, hiredate, sal\nFROM EMP\nWHERE sal >\n          ( SELECT MAX(sal)\n          FROM EMP\n          WHERE hiredate IN \n                           ( SELECT hiredate\n                           FROM EMP\n                           WHERE hiredate > '12/09/1982' ) );\nNumarul maxim de imbricari pentru o subinterogare este de \n255.\nCurs 6 - BAZE DE DATE 54\n\nNumarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55"", '\n', '7. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '8. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '9. ', ""Executarea unei subinterogari single-row\nSELECT ename, job\nFROM  EMP\nWHERE job = \n            (SELECT job          \n              FROM EMP        \n              WHERE empno = 7369)\n            AND  sal > \n           ( SELECT  sal\n             FROM     EMP\n             WHERE  empno = 7876 ); \nENAME           JOB\n----------        ---------\nMILLER          CLERK\nExemplul urmator afiseaza angajatii a caror functie este\nacelasi cu cel al angajatului cu numarul 7369 si a caror\nsalariu este mai mare decat cel al angajatului 7875.\nCurs 6 - BAZE DE DATE 14\n\n6.1. SINGLE ROW SUBQUERIES\n• Exemplul este format din 3 blocuri de cereri: \n– o cerere exterioara\n– doua cereri interne\n• Blocurile de cereri interne sunt primele executate, \nproducand rezultatele cererii: FUNCTIONAR (CLERK), \nrespectiv 1300. \n• Blocul exterior de cereri este apoi procesat si foloseste \nvalorile returnate de catre cererile interne pentru a \nfinaliza propriile conditii de cautare.\n• Ambele cereri interne returneaza valori singulare \n(FUNCTIONAR si 1300), astfel ca aceasta instructiune \nSQL este denumita o subinterogare single-row.\nCurs 6 - BAZE DE DATE 15\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 16\n\n\n6.1. SINGLE ROW SUBQUERIES\nSELECT ename, job, sal, deptno\nFROM EMP\nWHERE job =\n    (SELECT job\n      FROM EMP\n      WHERE empno = 7934 )\nAND deptno =\n    (SELECT deptno\n      FROM DEPT\n      WHERE dname = 'ACCOUNTING');\nCurs 6 - BAZE DE DATE 17\n\n6.1. SINGLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 18\n\n\n6.1. SINGLE ROW SUBQUERIES\n Se pot folosi funcţiile de grup în subinterogări. \n  O funcţie de grup utilizată în subquery fără clauza \nGROUP BY, returnează o singură linie.\nSELECT nume, prenume, salariu\nFROM angajati\nWHERE salariu <\n    (SELECT MAX(salariu)\n       FROM angajati);\nCurs 6 - BAZE DE DATE 19\n\n6.1. SINGLE ROW SUBQUERIES\nSe pot folosi funcţiile de grup în subinterogări. \nO funcţie de grup utilizată în subquery fără clauza GROUP BY, returnează o singură \nlinie.\nCurs 6 - BAZE DE DATE 20\n\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de \ngrup, şi subinterogarea va avea aproape întotdeauna o \ncondiţie de grup.\nSELECT deptno, MIN(sal)\nFROM EMP\nGROUP BY deptno\nHAVING MIN(sal) > \n    ( SELECT MIN(sal)\n          FROM EMP\n      WHERE deptno = 20 );\nCurs 6 - BAZE DE DATE 21\n\n6.1. SINGLE ROW SUBQUERIES\n• Subinterogările pot fi plasate şi în clauza HAVING. \n• Deoarece clauza HAVING are întotdeauna o condiţie de grup, şi \nsubinterogarea va avea aproape întotdeauna o condiţie de grup.\nCurs 6 - BAZE DE DATE 22\n\n\n6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23"", '\n', '10. ', 'Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au data \nde angajare 9/28/1981. \n 39\n\n\nClauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n\n\nClauza WHERE\nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10.\n 41\n\n\nClauza WHERE\n Atenţie! \n  Contează dacă caracterele sunt scrise cu litere \nmari sau cu litere mici.\n  Datele calendaristice sunt înregistrate în baza de \ndate într-un format numeric intern: \n secol, an, luna, ziua, ora, minute, secunde\n  Formatul de afişare este: DD-MON-RR. \nAcesta poate fi schimbat (vedeţi în alt curs). \n 42\n\nClauza WHERE\nC. Condiţii de comparare \n  În SQL sunt 4 operatori care pot fi folosiţi pentru \ntoate tipurile de date: \nOperator Semnificaţie\nBETWEEN...AND... între 2 valori (inclusiv)\nIN (lista) compară cu o listă de valori\nLIKE compară cu un model de tip caracter\nIS NULL este o valoare nulă\n 43\n\nClauza WHERE\n1. BETWEEN...AND... \nCondiţia BETWEEN poate fi folosită pentru a \nselecta rânduri pe baza unui interval de \nvalori(conţinut în condiţie).\nIntervalul este inclusiv, are o limită inferioară şi o \nlimită superioară şi neapărat prima specificată\ntrebuie să fie limita inferioară. \n 44\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au salariul între 1000 şi 3000. \nSELECT *\nFROM EMP\nWHERE sal BETWEEN 1000 AND 3000;\n 45\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul între 1000 şi 3000. \n 46\n\n\nClauza WHERE\n2. IN \n  Condiţia IN testează valorile dintr-o listă \nspecificată.\n  Pot fi folosite orice tipuri de date, cu precizarea \ncă pentru şirurile de caractere şi date calendaristice \ntrebuie folosite ghilimelele simple (\' \'). \n 47\n\nClauza WHERE\nExemplu:\nListează toţi angajaţii care au salariul în lista (1250, \n2450, 3000, 5000).\nSELECT ename, job, sal\nFROM EMP\nWHERE sal IN (1250, 2450, 3000, 5000);\n 48\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au salariul \nîn lista (1250, 2450, 3000, 5000).\n 49\n\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii care au numele în lista \'ALLEN\', \n\'WARD\', \'FORD\'. \nSELECT *\nFROM EMP\nWHERE ename IN (\'ALLEN\', \'WARD\', \'FORD\');\n 50\n\n\nClauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista \'ALLEN\', \'WARD\', \'FORD\'. \n 51\n\n\nClauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52\n\nClauza WHERE\nExemplu: \nListează toţi angajaţii al căror nume începe cu litera S. \nSELECT *\nFROM EMP\nWHERE ename LIKE \'S%\';\n 53', '\n']","
```sql
UPDATE EMP
SET JOB = 'SENIOR'
WHERE hiredate < '2000-01-01';
```
","UPDATE EMP 
SET JOB = 'SENIOR' 
WHERE EXTRACT(YEAR FROM HIREDATE) < 2000;",0.03448275861724138,0.0,0.8433708484356327,0.0,0.2800590077865739,0.7272727272727273,1.0
71,Manual - Test 4,Negativ,,,Cum e vremea la galati ?,Nu am gasit informatii in curs despre intrebarea ta,,,[],"Nu am gasit informatii in curs despre intrebarea ta
",Cum e vremea la galati ?,[],"Nu am gasit informatii in curs despre intrebarea ta
",Nu am gasit informatii in curs despre intrebarea ta,0.0,1.0,0.0,1.0,1.0000000000000004,1.0,
72,Manual - Test 4,Negativ,,,Cati ani a trait Michael Jackson ?,Nu am gasit informatii in curs despre intrebarea ta,,,[],"Nu am gasit informatii in curs despre intrebarea ta
",Cati ani a trait Michael Jackson ?,[],"Nu am gasit informatii in curs despre intrebarea ta
",Nu am gasit informatii in curs despre intrebarea ta,0.0,0.0,0.0,0.0,1.0000000000000004,1.0,
73,Manual - Test 4,Negativ,,,Ce o carte ?,Nu am gasit informatii in curs despre intrebarea ta,,,[],"Nu am gasit informatii in curs despre intrebarea ta
",Ce o carte ?,[],"Nu am gasit informatii in curs despre intrebarea ta
",Nu am gasit informatii in curs despre intrebarea ta,0.0,0.0,0.0,0.0,1.0000000000000004,1.0,
74,Manual - Test 4,Negativ,,,Cat face 2 + 2 ?,Nu am gasit informatii in curs despre intrebarea ta,,,[],"Nu am gasit informatii in curs despre intrebarea ta
",Cat face 2 + 2 ?,[],"Nu am gasit informatii in curs despre intrebarea ta
",Nu am gasit informatii in curs despre intrebarea ta,0.0,0.0,0.0,0.0,1.0000000000000004,1.0,
75,Manual - Test 4,Negativ,,,Care dintre următoarele afirmații este corectă cu privire la diferențele dintre bazele de date distribuite și NoSQL?,Nu am gasit informatii in curs despre intrebarea ta,,,"['1. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '2. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '3. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '4. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '5. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '6. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '7. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '8. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '9. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '10. ', ""- SQL echivalent: SELECT * FROM Student JOIN Inscriere ON Student.ID = \nInscriere.StudentID; \n \n \n2.2 Studiu de caz: Utilizarea algebrei relaționale într-o companie de livrări \nO companie de livrări utilizează o bază de date relațională pentru a gestiona comenzile, clienții și \nlivratorii. Relațiile cheie sunt: \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    Status V ARCHAR(20), \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE Livrator ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \nInterogări pentru monitorizarea livrărilor: \nSELECT Client.Nume, Comanda.Status \nFROM Client \nJOIN Comanda ON Client.ID = Comanda.ClientID; \n \n \n \n2.3. SQL - Limbajul interogărilor \nLimbajul SQL (Structured Query Language) este standardul pentru interacțiunea cu bazele de \ndate relaționale. \n \n2.3.1 Crearea bazelor de date și a tabelelor \nCREATE DATABASE Universitate; \nUSE Universitate; \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Prenume V ARCHAR(50), \n    An INT \n); \n \nCREATE TABLE Curs ( \n\n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n2.3.2 Inserarea datelor \nINSERT INTO Student (ID, Nume, Prenume, An) V ALUES (1, 'Popescu', 'Ion', 2); \nINSERT INTO Curs (Cod, Denumire) V ALUES (101, 'Baze de date'); \nINSERT INTO Inscriere (StudentID, CursCod) V ALUES (1, 101); \n \n2.3.3 Interogarea bazelor de date \n-- Selectarea tuturor studenților \nSELECT * FROM Student; \n \n-- Selectarea studenților de anul 2 \nSELECT * FROM Student WHERE An = 2; \n \n-- Afișarea cursurilor la care este înscris un student \nSELECT Curs.Denumire  \nFROM Curs  \nJOIN Inscriere ON Curs.Cod = Inscriere.CursCod  \nWHERE Inscriere.StudentID = 1; \n \n \n3. Integritatea datelor \nIntegritatea datelor asigură corectitudinea și consistența acestora în cadrul bazei de date. Tipurile \nprincipale sunt: \n \n1. Integritatea entităților: Fiecare tabel trebuie să aibă un identificator unic. \n2. Integritatea referențială: Relațiile dintre tabele trebuie să fie menținute corect prin chei primare \nși străine. \n3. Integritatea domeniului: Valorile din coloane trebuie să respecte tipul de date definit."", '\n']","nu sunt menționate diferențe specifice între bazele de date distribuite și NoSQL. Totuși, pot să-ți spun că materialele de curs acoperă subiecte precum:

*   **Obiecte într-o bază de date:** tabele, vederi, secvențe, indecși, sinonime.
*   **Secvențe:** Generarea de numere întregi unice, utilizate în special pentru chei primare.
*   **Subinterogări SQL:** Interogări imbricate (SELECT în SELECT), folosite pentru a obține informații necesare altor interogări.
*   **Tipuri de subinterogări:** single-row (rezultat o singură linie) și multiple-row (rezultat mai multe linii).
* Algebra relationala
* Integritatea datelor
",Care dintre următoarele afirmații este corectă cu privire la diferențele dintre bazele de date distribuite și NoSQL?,"['1. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '2. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '3. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '4. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '5. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '6. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '7. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '8. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '9. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '10. ', ""- SQL echivalent: SELECT * FROM Student JOIN Inscriere ON Student.ID = \nInscriere.StudentID; \n \n \n2.2 Studiu de caz: Utilizarea algebrei relaționale într-o companie de livrări \nO companie de livrări utilizează o bază de date relațională pentru a gestiona comenzile, clienții și \nlivratorii. Relațiile cheie sunt: \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    Status V ARCHAR(20), \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE Livrator ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \nInterogări pentru monitorizarea livrărilor: \nSELECT Client.Nume, Comanda.Status \nFROM Client \nJOIN Comanda ON Client.ID = Comanda.ClientID; \n \n \n \n2.3. SQL - Limbajul interogărilor \nLimbajul SQL (Structured Query Language) este standardul pentru interacțiunea cu bazele de \ndate relaționale. \n \n2.3.1 Crearea bazelor de date și a tabelelor \nCREATE DATABASE Universitate; \nUSE Universitate; \n \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Prenume V ARCHAR(50), \n    An INT \n); \n \nCREATE TABLE Curs ( \n\n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); \n \n \n2.3.2 Inserarea datelor \nINSERT INTO Student (ID, Nume, Prenume, An) V ALUES (1, 'Popescu', 'Ion', 2); \nINSERT INTO Curs (Cod, Denumire) V ALUES (101, 'Baze de date'); \nINSERT INTO Inscriere (StudentID, CursCod) V ALUES (1, 101); \n \n2.3.3 Interogarea bazelor de date \n-- Selectarea tuturor studenților \nSELECT * FROM Student; \n \n-- Selectarea studenților de anul 2 \nSELECT * FROM Student WHERE An = 2; \n \n-- Afișarea cursurilor la care este înscris un student \nSELECT Curs.Denumire  \nFROM Curs  \nJOIN Inscriere ON Curs.Cod = Inscriere.CursCod  \nWHERE Inscriere.StudentID = 1; \n \n \n3. Integritatea datelor \nIntegritatea datelor asigură corectitudinea și consistența acestora în cadrul bazei de date. Tipurile \nprincipale sunt: \n \n1. Integritatea entităților: Fiecare tabel trebuie să aibă un identificator unic. \n2. Integritatea referențială: Relațiile dintre tabele trebuie să fie menținute corect prin chei primare \nși străine. \n3. Integritatea domeniului: Valorile din coloane trebuie să respecte tipul de date definit."", '\n']","nu sunt menționate diferențe specifice între bazele de date distribuite și NoSQL. Totuși, pot să-ți spun că materialele de curs acoperă subiecte precum:

*   **Obiecte într-o bază de date:** tabele, vederi, secvențe, indecși, sinonime.
*   **Secvențe:** Generarea de numere întregi unice, utilizate în special pentru chei primare.
*   **Subinterogări SQL:** Interogări imbricate (SELECT în SELECT), folosite pentru a obține informații necesare altor interogări.
*   **Tipuri de subinterogări:** single-row (rezultat o singură linie) și multiple-row (rezultat mai multe linii).
* Algebra relationala
* Integritatea datelor
",Nu am gasit informatii in curs despre intrebarea ta,0.0,1.0,0.0,0.7142857142857143,0.0,0.03883495145631068,0.12
76,Manual - Test 4,Negativ,,,Ce avantaj major oferă bazele de date NoSQL față de bazele de date distribuite tradiționale?,Nu am gasit informatii in curs despre intrebarea ta,,,"['1. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '2. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '3. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '4. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '5. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '6. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '7. ', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul.', '\n', '8. ', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul.', '\n', '9. ', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul.', '\n', '10. ', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 8\nLimbajul SQL \nCurs 8 - BAZE DE DATE 2\n\nLimbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3\n\nServerul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4\n\nTipuri de constrângeri\nCurs 8 - BAZE DE DATE 5\n\nGhidul Constrângerilor\n1. Toate constrângerile sunt cuprinse într-un dicţionar. \n2. Este uşor să se facă referinţă la constrângeri dacă li se \ndă nume sugestive. \n3. Numele unei constrângeri trebuie să urmeze un \nanumit standard. \n4. Dacă nu se denumeşte constrângerea, server-ul Oracle\ngenerează un nume de forma SYS_Cn, unde n este un \nnumăr întreg astfel încât numele constrângerii este \nunic.\n5. Constrângerile definite pentru o anumita tabela pot fi \nvizualizate în USER_CONSTRAINTS (dicţionarul tabelei).\nCurs 8 - BAZE DE DATE 6\n\nDefinirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7\n\nÎn sintaxa prezentată anterior avem:\nCurs 8 - BAZE DE DATE 8\n\nEXEMPLU - Adăugarea unei \nconstrângeri unei tabele odată cu \ncrearea lui.\nCREATE TABLE EMP1(\nempno number(6) NOT NULL,\nename varchar2(20),\nsal number(4),\nmgr number(4),\njob varchar2(20), \nPRIMARY KEY(empno));\nConstrângere \npentru tabela\nConstrângere \npentru coloană\nCurs 8 - BAZE DE DATE 9\n\n\n• De obicei constrângerile sunt create în acelaşi timp cu \ntabela.\n• Constrângerile pot fi adăugate tabelei după crearea ei.\n• Constrângerile pot fi definite pe 2 nivele: \nCurs 8 - BAZE DE DATE 10\n\nSintaxa:\n1. Constrângere la nivel de coloană\n2. Constrângere la nivel de tabela\nCurs 8 - BAZE DE DATE 11\n\n• In sintaxa avem:\nCurs 8 - BAZE DE DATE 12\n\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13\n\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14\n\nCREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15', '\n']","nu există informații despre avantajele bazelor de date NoSQL în comparație cu bazele de date distribuite tradiționale în contextul oferit. Contextul se concentrează pe bazele de date în general, SQL, constrângeri și componentele unui sistem de baze de date, nu specific pe NoSQL.
",Ce avantaj major oferă bazele de date NoSQL față de bazele de date distribuite tradiționale?,"['1. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '2. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '3. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '4. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '5. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '6. ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor.', '\n', '7. ', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul.', '\n', '8. ', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul.', '\n', '9. ', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul.', '\n', '10. ', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 8\nLimbajul SQL \nCurs 8 - BAZE DE DATE 2\n\nLimbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3\n\nServerul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4\n\nTipuri de constrângeri\nCurs 8 - BAZE DE DATE 5\n\nGhidul Constrângerilor\n1. Toate constrângerile sunt cuprinse într-un dicţionar. \n2. Este uşor să se facă referinţă la constrângeri dacă li se \ndă nume sugestive. \n3. Numele unei constrângeri trebuie să urmeze un \nanumit standard. \n4. Dacă nu se denumeşte constrângerea, server-ul Oracle\ngenerează un nume de forma SYS_Cn, unde n este un \nnumăr întreg astfel încât numele constrângerii este \nunic.\n5. Constrângerile definite pentru o anumita tabela pot fi \nvizualizate în USER_CONSTRAINTS (dicţionarul tabelei).\nCurs 8 - BAZE DE DATE 6\n\nDefinirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7\n\nÎn sintaxa prezentată anterior avem:\nCurs 8 - BAZE DE DATE 8\n\nEXEMPLU - Adăugarea unei \nconstrângeri unei tabele odată cu \ncrearea lui.\nCREATE TABLE EMP1(\nempno number(6) NOT NULL,\nename varchar2(20),\nsal number(4),\nmgr number(4),\njob varchar2(20), \nPRIMARY KEY(empno));\nConstrângere \npentru tabela\nConstrângere \npentru coloană\nCurs 8 - BAZE DE DATE 9\n\n\n• De obicei constrângerile sunt create în acelaşi timp cu \ntabela.\n• Constrângerile pot fi adăugate tabelei după crearea ei.\n• Constrângerile pot fi definite pe 2 nivele: \nCurs 8 - BAZE DE DATE 10\n\nSintaxa:\n1. Constrângere la nivel de coloană\n2. Constrângere la nivel de tabela\nCurs 8 - BAZE DE DATE 11\n\n• In sintaxa avem:\nCurs 8 - BAZE DE DATE 12\n\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13\n\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14\n\nCREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15', '\n']","nu există informații despre avantajele bazelor de date NoSQL în comparație cu bazele de date distribuite tradiționale în contextul oferit. Contextul se concentrează pe bazele de date în general, SQL, constrângeri și componentele unui sistem de baze de date, nu specific pe NoSQL.
",Nu am gasit informatii in curs despre intrebarea ta,0.0,1.0,0.0,1.0,0.01914603069010251,0.07142857142857142,0.8
77,Manual - Test 4,Negativ,,,Descrie scenariile în care o bază de date distribuită ar fi mai potrivită decât o bază de date NoSQL.,Nu am gasit informatii in curs despre intrebarea ta,,,"['1. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '2. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '3. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '4. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '5. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '6. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '7. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '8. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '9. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '10. ', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 8\nLimbajul SQL \nCurs 8 - BAZE DE DATE 2\n\nLimbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3\n\nServerul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4\n\nTipuri de constrângeri\nCurs 8 - BAZE DE DATE 5\n\nGhidul Constrângerilor\n1. Toate constrângerile sunt cuprinse într-un dicţionar. \n2. Este uşor să se facă referinţă la constrângeri dacă li se \ndă nume sugestive. \n3. Numele unei constrângeri trebuie să urmeze un \nanumit standard. \n4. Dacă nu se denumeşte constrângerea, server-ul Oracle\ngenerează un nume de forma SYS_Cn, unde n este un \nnumăr întreg astfel încât numele constrângerii este \nunic.\n5. Constrângerile definite pentru o anumita tabela pot fi \nvizualizate în USER_CONSTRAINTS (dicţionarul tabelei).\nCurs 8 - BAZE DE DATE 6\n\nDefinirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7\n\nÎn sintaxa prezentată anterior avem:\nCurs 8 - BAZE DE DATE 8\n\nEXEMPLU - Adăugarea unei \nconstrângeri unei tabele odată cu \ncrearea lui.\nCREATE TABLE EMP1(\nempno number(6) NOT NULL,\nename varchar2(20),\nsal number(4),\nmgr number(4),\njob varchar2(20), \nPRIMARY KEY(empno));\nConstrângere \npentru tabela\nConstrângere \npentru coloană\nCurs 8 - BAZE DE DATE 9\n\n\n• De obicei constrângerile sunt create în acelaşi timp cu \ntabela.\n• Constrângerile pot fi adăugate tabelei după crearea ei.\n• Constrângerile pot fi definite pe 2 nivele: \nCurs 8 - BAZE DE DATE 10\n\nSintaxa:\n1. Constrângere la nivel de coloană\n2. Constrângere la nivel de tabela\nCurs 8 - BAZE DE DATE 11\n\n• In sintaxa avem:\nCurs 8 - BAZE DE DATE 12\n\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13\n\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14\n\nCREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15', '\n']","o bază de date distribuită ar putea fi preferabilă într-un scenariu în care se dorește impunerea unor reguli stricte asupra datelor (constrângeri) la nivel de inserare, modificare sau ștergere, prevenind introducerea de date invalide. De asemenea, ar putea fi utilă când există dependențe între tabele și se dorește prevenirea ștergerii accidentale a datelor.
",Descrie scenariile în care o bază de date distribuită ar fi mai potrivită decât o bază de date NoSQL.,"['1. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '2. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '3. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '4. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '5. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '6. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n', '7. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '8. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '9. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '10. ', 'Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 8\nLimbajul SQL \nCurs 8 - BAZE DE DATE 2\n\nLimbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3\n\nServerul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4\n\nTipuri de constrângeri\nCurs 8 - BAZE DE DATE 5\n\nGhidul Constrângerilor\n1. Toate constrângerile sunt cuprinse într-un dicţionar. \n2. Este uşor să se facă referinţă la constrângeri dacă li se \ndă nume sugestive. \n3. Numele unei constrângeri trebuie să urmeze un \nanumit standard. \n4. Dacă nu se denumeşte constrângerea, server-ul Oracle\ngenerează un nume de forma SYS_Cn, unde n este un \nnumăr întreg astfel încât numele constrângerii este \nunic.\n5. Constrângerile definite pentru o anumita tabela pot fi \nvizualizate în USER_CONSTRAINTS (dicţionarul tabelei).\nCurs 8 - BAZE DE DATE 6\n\nDefinirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7\n\nÎn sintaxa prezentată anterior avem:\nCurs 8 - BAZE DE DATE 8\n\nEXEMPLU - Adăugarea unei \nconstrângeri unei tabele odată cu \ncrearea lui.\nCREATE TABLE EMP1(\nempno number(6) NOT NULL,\nename varchar2(20),\nsal number(4),\nmgr number(4),\njob varchar2(20), \nPRIMARY KEY(empno));\nConstrângere \npentru tabela\nConstrângere \npentru coloană\nCurs 8 - BAZE DE DATE 9\n\n\n• De obicei constrângerile sunt create în acelaşi timp cu \ntabela.\n• Constrângerile pot fi adăugate tabelei după crearea ei.\n• Constrângerile pot fi definite pe 2 nivele: \nCurs 8 - BAZE DE DATE 10\n\nSintaxa:\n1. Constrângere la nivel de coloană\n2. Constrângere la nivel de tabela\nCurs 8 - BAZE DE DATE 11\n\n• In sintaxa avem:\nCurs 8 - BAZE DE DATE 12\n\nConstrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13\n\nExemplu\nÎn exemplul următor constrângerea NOT NULL se \naplică coloanelor ENAME şi HIREDATE din tabela \nemp_new. \n⮚Pentru coloana ENAME constrângerea nu este \ndenumită astfel încât serverul Oracle o să creeze un \nnume pentru ea.\n⮚Pentru coloana HIREDATE constrângerea este \ndenumită: ""NOT NULL"".\nCurs 8 - BAZE DE DATE 14\n\nCREATE TABLE emp_new(\nEMPNO number(6),\nENAME varchar2(10) NOT NULL,\nSAL number(4),\nCOMM number(4),\nHIREDATE number(4) NOT \nNULL);\nCurs 8 - BAZE DE DATE 15', '\n']","o bază de date distribuită ar putea fi preferabilă într-un scenariu în care se dorește impunerea unor reguli stricte asupra datelor (constrângeri) la nivel de inserare, modificare sau ștergere, prevenind introducerea de date invalide. De asemenea, ar putea fi utilă când există dependențe între tabele și se dorește prevenirea ștergerii accidentale a datelor.
",Nu am gasit informatii in curs despre intrebarea ta,0.0,0.0,0.8979884104317634,0.0,0.0,0.0,0.0
78,Manual - Test 4,Negativ,,,Care sunt principalele provocări ale utilizării bazelor de date NoSQL într-un sistem distribuit?,Nu am gasit informatii in curs despre intrebarea ta,,,"['1. ', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul.', '\n', '2. ', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul.', '\n', '3. ', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul.', '\n', '4. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '5. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '6. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '7. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '8. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '9. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '10. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n']","nu am putut gasii informatii despre ""bazele de date NoSQL într-un sistem distribuit"". Dar pot sa va zic despre: 

**SGBD-ul Oracle**, care are următoarele caracteristici (versiunea 8i):

*   Este reproiectat arhitectural și se încadrează în tendința de trecere de la arhitectura client/server la arhitectura NC (network computing).
*   Permite dezvoltarea unei baze de date de orice dimensiune, în mod centralizat sau distribuit.
",Care sunt principalele provocări ale utilizării bazelor de date NoSQL într-un sistem distribuit?,"['1. ', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul.', '\n', '2. ', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul.', '\n', '3. ', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul.', '\n', '4. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '5. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '6. ', ""Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3\n\nS.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Oracle este un sistem de gestiune a bazelor de date \n(SGBD) complet relaţional, extins, cu facilităţi din \ntehnologia orientată obiect (OO). \n➢SGBD-ul Oracle este realizat de firma Oracle \nCorporation care a fost înfiinţată în anul 1977 în SUA -\nCalifornia şi acum este cel mai mare furnizor de \nsoftware de gestiunea datelor. \n➢Acesta este operaţional pe toată gama de calculatoare \n(micro, mini, mainframe) sub diverse sisteme de \noperare. \n5\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n➢Prima versiune de SGBD Oracle a fost realizată \nla sfârşitul anilor '70 respectând teoria \nrelaţională. \n➢În cadrul sistemului a fost implementat de la \nînceput limbajul relaţional SQL pe care l-a \ndezvoltat ulterior, faţă de versiunea standard \nrezultând SQL*Plus.\n6\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn iunie 1997 s-a lansat SGBD Oracle versiunea 8.0, \ninclusiv în România, care a marcat o nouă generaţie de \nbaze de date Oracle deoarece:\n- iniţiază trecerea de la arhitectura client/server la \narhitectura NC (Network Computing)\n- are o mare deschidere\n- are optimizări performante\n- pune accent mai mare pe analiză (modelare-\nfuncţionalitate) faţă de programare (codificare) \n8\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎn noiembrie 1998 s-a lansat SGBD Oracle 8i ca \nsistem de baze de date pe Internet. \nAceastă versiune are următoarele caracteristici: \n• Este reproiectat arhitectural în mod fundamental şi \nse încadrează în tendinţa de trecere de la \narhitectura client/server la arhitectura NC \n(network computing)\n• Permite dezvoltarea unei baze de date de orice \ndimensiune, în mod centralizat sau distribuit \n9"", '\n', '7. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '8. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '9. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '10. ', ""Curs 6 \nLimbajul SQL \nCurs 6 - BAZE DE DATE 2\n\nLimbajul SQL\n6. Subinterogări (Subqueries)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 3\n\n6. SUBQUERIES (Subinterogari)\n În SQL, subinterogările ne permit să aflăm o \ninformaţie care ne este necesară pentru a \nobţine informaţia pe care o vrem.\n➢O subinterogare (subquery) este o instrucţiune \nSELECT care este inclusă în clauza unei alte \ninstrucţiuni SELECT.\nCurs 6 - BAZE DE DATE 4\n\n6. SUBQUERIES (Subinterogari)\n➢Subinterogarea poate fi plasata în una din \nurmătoarele clauze: \n➢WHERE\n➢HAVING \n➢FROM\n➢Subinterogarea se execută prima dată, iar \nrezultatul este folosit pentru obţinerea \nrezultatului de către interogarea principală \n(outer query).\nCurs 6 - BAZE DE DATE 5\n\n6. SUBQUERIES (Subinterogari)\nSintaxa generală:\nSELECT select_list\nFROM table\nWHERE expression operator\n    (SELECT select_list\n     FROM table);\nCurs 6 - BAZE DE DATE 6\n\n6. SUBQUERIES (Subinterogari)\nReguli de folosire a subinterogarilor \n➢O subinterogare se pune între paranteze rotunde\n➢O subinterogare este plasată în partea dreaptă a \nunei condiţii de comparare\n➢Interogarea exterioară şi subinterogarea-ul pot \nprelua date din tabele diferite\nCurs 6 - BAZE DE DATE 7\n\n6. SUBQUERIES (Subinterogari)\n➢Într-o instrucţiune SELECT se poate folosi o singură clauză \nORDER BY şi, dacă se foloseşte, trebuie să fie ultima clauza a \ninterogării principale.\n➢Un subquery nu poate avea propria clauză ORDER BY.\n➢Singura limită a numărului de interogări este dimensiunea \nbuffer-ului folosit de interogare.\n➢Dacă subinterogarea returnează null sau nu returneaza nici o \nlinie, atunci interogarea exterioară nu va returna nimic.\nCurs 6 - BAZE DE DATE 8\n\n6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9\n\nLimbajul SQL\n6. SUBQUERIES (Subinterogări)\n 6.1. SINGLE ROW SUBQUERIES\n 6.2. MULTIPLE ROW SUBQUERIES\nCurs 6 - BAZE DE DATE 10\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nSELECT ename\nFROM EMP\nWHERE sal  >\n   ( SELECT sal\n     FROM EMP\n     WHERE ename = 'SMITH' );\nAflati numele angajatilor \ncare au salariul mai mare \ndecat angajatul care se \nnumeste SMITH.\nCurs 6 - BAZE DE DATE 11\n\n6.1. SINGLE ROW SUBQUERIES\nSingle row-subquery\nCurs 6 - BAZE DE DATE 12\n\n\n6.1. SINGLE ROW SUBQUERIES\nSubcereri din mai multe tabele\n  Subcererile (subinterogările) nu sunt limitate \nla o singură interogare (cerere). \n  Aşa cum se poate observa în exemplul \nurmător, pot fi mai mult de o singură \ninterogare. \n  De asemenea se pot face interogări din \ntabele diferite.\nCurs 6 - BAZE DE DATE 13"", '\n']","nu am putut gasii informatii despre ""bazele de date NoSQL într-un sistem distribuit"". Dar pot sa va zic despre: 

**SGBD-ul Oracle**, care are următoarele caracteristici (versiunea 8i):

*   Este reproiectat arhitectural și se încadrează în tendința de trecere de la arhitectura client/server la arhitectura NC (network computing).
*   Permite dezvoltarea unei baze de date de orice dimensiune, în mod centralizat sau distribuit.
",Nu am gasit informatii in curs despre intrebarea ta,0.0,0.0,0.0,1.0,0.034585921141027355,0.10810810810810811,0.33
