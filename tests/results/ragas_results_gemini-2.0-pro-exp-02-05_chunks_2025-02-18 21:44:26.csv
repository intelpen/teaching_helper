,initial_Generator,initial_Dificultate,initial_Capitole Principale,initial_Capitole Asociate,initial_user_input,initial_reference,initial_Evaluare Professor,initial_Unde se afla raspunsul,initial_retrieved_contexts,initial_response,user_input,retrieved_contexts,response,reference,context_precision,context_recall,answer_relevancy,faithfulness,bleu_score,rouge_score,factual_correctness
0,O3mini-high,LOW,C1,,"În contextul noțiunilor introductive, ce model de organizare a datelor este prezentat ca predominant în curs?",relațional,Este corect,,"['1. ', '1.2.Modelul de date relaţional\nCele mai importante constrângeri de integritate \nsunt: \nConstrângerea de integritate a entităţii care \nstabileşte că fiecare tuplu să fie unic identificat \nprintr-o cheie şi atributul cheie să nu poată fi null;\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\n40\n\n1.2.Modelul de date relaţional\nConstrâgerea referenţială de integritate\nstabileşte că un n-tuplu dintr-o relaţie care se \nreferă la o altă relaţie, trebuie să se refere la \nun n-tuplu care există în acea relaţie; această\ncondiţie se referă la cheile străine.\n 41\n\n1.2.Modelul de date relaţional\nO cheie candidat a unei relaţii R este o mulţime \nminimă de atribute de care toate celelalte atribute ale \nlui R sunt dependente funcţional. \nCheia primară a unei relaţii R este una din cheile \ncandidat care a fost desemnată în acest scop.\nO cheie străină a unei relaţii R este o mulţime de \natribute din schema relaţională care formează o cheie \nprimară pentru o altă relaţie. \nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00 42\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 43\n\n1.3.Modelul de  date orientate obiect\nBazele de date orientate obiect permit \ncrearea unor obiecte complexe din componente \nmai simple, fiecare având atribute proprii şi \ncomportament specific. \n  Aceste sisteme combină posibilitatea definirii \nşi manipulării structurilor complexe de date cu \nfuncţionalitatea unui limbaj de programare şi \ntehnologia de gestiune a bazelor de date.\n 44\n\n1.3.Modelul de  date orientate obiect\nModelele de date \norientate obiect (MDOO) au \nfost create pentru a modela \nlumea reală. \nDe exemplu, limbajul C++ \na fost dezvoltat pentru a crea \nmodelul unui sistem \ntelefonic. \nConceptul fundamental al \nunui MDOO este obiectul. \n 45\n\n1.3.Modelul de  date orientate obiect\nÎntr-un MDOO, orice entitate din lumea reală este \nun obiect şi reciproc, orice obiect reprezintă o entitate \na lumii reale. \nUn obiect reprezintă un grup de date stucturate, \nidentificate printr-o referinţă unică.\nUn obiect persistent este un obiect stocat în baza \nde date care are o durată de viaţă mai mare decât a \nprogramului care l-a creat. \nUn obiect tranzitoriu este un obiect depus în \nmemorie, a cărui durată de viaţă nu depăşeşte durata \nde viaţă a programului care l-a creat.\n 46', '\n', '2. ', '1.2.Modelul de date relaţional\nCele mai importante constrângeri de integritate \nsunt: \nConstrângerea de integritate a entităţii care \nstabileşte că fiecare tuplu să fie unic identificat \nprintr-o cheie şi atributul cheie să nu poată fi null;\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\n40\n\n1.2.Modelul de date relaţional\nConstrâgerea referenţială de integritate\nstabileşte că un n-tuplu dintr-o relaţie care se \nreferă la o altă relaţie, trebuie să se refere la \nun n-tuplu care există în acea relaţie; această\ncondiţie se referă la cheile străine.\n 41\n\n1.2.Modelul de date relaţional\nO cheie candidat a unei relaţii R este o mulţime \nminimă de atribute de care toate celelalte atribute ale \nlui R sunt dependente funcţional. \nCheia primară a unei relaţii R este una din cheile \ncandidat care a fost desemnată în acest scop.\nO cheie străină a unei relaţii R este o mulţime de \natribute din schema relaţională care formează o cheie \nprimară pentru o altă relaţie. \nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00 42\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 43\n\n1.3.Modelul de  date orientate obiect\nBazele de date orientate obiect permit \ncrearea unor obiecte complexe din componente \nmai simple, fiecare având atribute proprii şi \ncomportament specific. \n  Aceste sisteme combină posibilitatea definirii \nşi manipulării structurilor complexe de date cu \nfuncţionalitatea unui limbaj de programare şi \ntehnologia de gestiune a bazelor de date.\n 44\n\n1.3.Modelul de  date orientate obiect\nModelele de date \norientate obiect (MDOO) au \nfost create pentru a modela \nlumea reală. \nDe exemplu, limbajul C++ \na fost dezvoltat pentru a crea \nmodelul unui sistem \ntelefonic. \nConceptul fundamental al \nunui MDOO este obiectul. \n 45\n\n1.3.Modelul de  date orientate obiect\nÎntr-un MDOO, orice entitate din lumea reală este \nun obiect şi reciproc, orice obiect reprezintă o entitate \na lumii reale. \nUn obiect reprezintă un grup de date stucturate, \nidentificate printr-o referinţă unică.\nUn obiect persistent este un obiect stocat în baza \nde date care are o durată de viaţă mai mare decât a \nprogramului care l-a creat. \nUn obiect tranzitoriu este un obiect depus în \nmemorie, a cărui durată de viaţă nu depăşeşte durata \nde viaţă a programului care l-a creat.\n 46', '\n', '3. ', '1.3.Modelul de  date orientate obiect\nDintre caracteristicile opţionale ale unui SGBDOO\namintim:\n✓Distribuţia obiectelor. Această distribuţie permite \ngestionarea obiectelor în diferite staţii.\n✓Modelarea tranzacţiilor evoluate. Ideea este de a \naccepta tranzacţii imbricate care pot fi descompuse în \nsubtranzacţii.\n✓Versiuni ale obiectelor. Plecând de la un anumit obiect, \nprin modificări succesive sau paralele, pot fi obţinute \nmai multe versiuni ale obiectului. \n 55\n\n1.3.Modelul de  date orientate obiect\n✓Moştenirea multiplă. O clasă (subclasă) poate fi \nspecializarea directă a unor supraclase şi să \nmoştenească proprietăţile acestora.\n✓Mesajele de eroare. Este vorba de un \nmecanism de detectare şi tratare a erorilor care \nimplică faptul că dacă într-o metodă apare o \neroare, este trimis un mesaj unei clase speciale \ndefinită anterior, care o va înregistra şi o va trata \ncorespunzător.\n 56\n\nNoţiuni introductive \ndespre teoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 57\n\n1.4. Modelul de date obiect-relaţional\n Modelul de date obiect-relaţional\n(Object-Relational Model) reprezintă\nextinderea modelului relaţional cu\ncaracteristici ale modelului obiect, extindere\nnecesară pentru realizarea bazelor de date\ncare definesc şi prelucrează tipuri de date\ncomplexe.\n 58\n\n1.4. Modelul de date obiect-relaţional\n✓ În esenţă, modelul obiect-relaţional păstrează \nstructurarea datelor în relaţii (reprezentate ca tabele), \ndar adaugă posibilitatea definirii unor noi tipuri de \ndate, pentru domeniile de valori ale atributelor. \n✓Tipurile de date definite de utilizator pot fi extinse \nprin mecanismul de moştenire şi pentru fiecare tip sau \nsubtip se pot defini metode pe care le pot executa \nobiectele de acel tip.\n 59\n\nNoţiuni introductive \ndespre teoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 60\n\n1.5. Modelul de date ierarhic\n✓În modelul de date ierarhic (Hierarchical Model) o \nbază de date se reprezintă printr-o structură ierarhică \nde înregistrări de date (records) conectate prin \nlegături (links).\n✓Modelul ierarhic a fost primul model folosit pentru \ndezvoltatea bazelor de date.\n✓Schema conceptuală a unei baze de date în modelul \nierarhic se reprezintă printr-un număr oarecare de \nscheme ierarhice.\n 61', '\n', '4. ', '1.3.Modelul de  date orientate obiect\nDintre caracteristicile opţionale ale unui SGBDOO\namintim:\n✓Distribuţia obiectelor. Această distribuţie permite \ngestionarea obiectelor în diferite staţii.\n✓Modelarea tranzacţiilor evoluate. Ideea este de a \naccepta tranzacţii imbricate care pot fi descompuse în \nsubtranzacţii.\n✓Versiuni ale obiectelor. Plecând de la un anumit obiect, \nprin modificări succesive sau paralele, pot fi obţinute \nmai multe versiuni ale obiectului. \n 55\n\n1.3.Modelul de  date orientate obiect\n✓Moştenirea multiplă. O clasă (subclasă) poate fi \nspecializarea directă a unor supraclase şi să \nmoştenească proprietăţile acestora.\n✓Mesajele de eroare. Este vorba de un \nmecanism de detectare şi tratare a erorilor care \nimplică faptul că dacă într-o metodă apare o \neroare, este trimis un mesaj unei clase speciale \ndefinită anterior, care o va înregistra şi o va trata \ncorespunzător.\n 56\n\nNoţiuni introductive \ndespre teoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 57\n\n1.4. Modelul de date obiect-relaţional\n Modelul de date obiect-relaţional\n(Object-Relational Model) reprezintă\nextinderea modelului relaţional cu\ncaracteristici ale modelului obiect, extindere\nnecesară pentru realizarea bazelor de date\ncare definesc şi prelucrează tipuri de date\ncomplexe.\n 58\n\n1.4. Modelul de date obiect-relaţional\n✓ În esenţă, modelul obiect-relaţional păstrează \nstructurarea datelor în relaţii (reprezentate ca tabele), \ndar adaugă posibilitatea definirii unor noi tipuri de \ndate, pentru domeniile de valori ale atributelor. \n✓Tipurile de date definite de utilizator pot fi extinse \nprin mecanismul de moştenire şi pentru fiecare tip sau \nsubtip se pot defini metode pe care le pot executa \nobiectele de acel tip.\n 59\n\nNoţiuni introductive \ndespre teoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 60\n\n1.5. Modelul de date ierarhic\n✓În modelul de date ierarhic (Hierarchical Model) o \nbază de date se reprezintă printr-o structură ierarhică \nde înregistrări de date (records) conectate prin \nlegături (links).\n✓Modelul ierarhic a fost primul model folosit pentru \ndezvoltatea bazelor de date.\n✓Schema conceptuală a unei baze de date în modelul \nierarhic se reprezintă printr-un număr oarecare de \nscheme ierarhice.\n 61', '\n', '5. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '6. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '7. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '8. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '9. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '10. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n']","modelul de date relațional este prezentat ca modelul predominant.
","În contextul noțiunilor introductive, ce model de organizare a datelor este prezentat ca predominant în curs?","['1. ', '1.2.Modelul de date relaţional\nCele mai importante constrângeri de integritate \nsunt: \nConstrângerea de integritate a entităţii care \nstabileşte că fiecare tuplu să fie unic identificat \nprintr-o cheie şi atributul cheie să nu poată fi null;\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\n40\n\n1.2.Modelul de date relaţional\nConstrâgerea referenţială de integritate\nstabileşte că un n-tuplu dintr-o relaţie care se \nreferă la o altă relaţie, trebuie să se refere la \nun n-tuplu care există în acea relaţie; această\ncondiţie se referă la cheile străine.\n 41\n\n1.2.Modelul de date relaţional\nO cheie candidat a unei relaţii R este o mulţime \nminimă de atribute de care toate celelalte atribute ale \nlui R sunt dependente funcţional. \nCheia primară a unei relaţii R este una din cheile \ncandidat care a fost desemnată în acest scop.\nO cheie străină a unei relaţii R este o mulţime de \natribute din schema relaţională care formează o cheie \nprimară pentru o altă relaţie. \nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00 42\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 43\n\n1.3.Modelul de  date orientate obiect\nBazele de date orientate obiect permit \ncrearea unor obiecte complexe din componente \nmai simple, fiecare având atribute proprii şi \ncomportament specific. \n  Aceste sisteme combină posibilitatea definirii \nşi manipulării structurilor complexe de date cu \nfuncţionalitatea unui limbaj de programare şi \ntehnologia de gestiune a bazelor de date.\n 44\n\n1.3.Modelul de  date orientate obiect\nModelele de date \norientate obiect (MDOO) au \nfost create pentru a modela \nlumea reală. \nDe exemplu, limbajul C++ \na fost dezvoltat pentru a crea \nmodelul unui sistem \ntelefonic. \nConceptul fundamental al \nunui MDOO este obiectul. \n 45\n\n1.3.Modelul de  date orientate obiect\nÎntr-un MDOO, orice entitate din lumea reală este \nun obiect şi reciproc, orice obiect reprezintă o entitate \na lumii reale. \nUn obiect reprezintă un grup de date stucturate, \nidentificate printr-o referinţă unică.\nUn obiect persistent este un obiect stocat în baza \nde date care are o durată de viaţă mai mare decât a \nprogramului care l-a creat. \nUn obiect tranzitoriu este un obiect depus în \nmemorie, a cărui durată de viaţă nu depăşeşte durata \nde viaţă a programului care l-a creat.\n 46', '\n', '2. ', '1.2.Modelul de date relaţional\nCele mai importante constrângeri de integritate \nsunt: \nConstrângerea de integritate a entităţii care \nstabileşte că fiecare tuplu să fie unic identificat \nprintr-o cheie şi atributul cheie să nu poată fi null;\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\n40\n\n1.2.Modelul de date relaţional\nConstrâgerea referenţială de integritate\nstabileşte că un n-tuplu dintr-o relaţie care se \nreferă la o altă relaţie, trebuie să se refere la \nun n-tuplu care există în acea relaţie; această\ncondiţie se referă la cheile străine.\n 41\n\n1.2.Modelul de date relaţional\nO cheie candidat a unei relaţii R este o mulţime \nminimă de atribute de care toate celelalte atribute ale \nlui R sunt dependente funcţional. \nCheia primară a unei relaţii R este una din cheile \ncandidat care a fost desemnată în acest scop.\nO cheie străină a unei relaţii R este o mulţime de \natribute din schema relaţională care formează o cheie \nprimară pentru o altă relaţie. \nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00 42\n\nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 43\n\n1.3.Modelul de  date orientate obiect\nBazele de date orientate obiect permit \ncrearea unor obiecte complexe din componente \nmai simple, fiecare având atribute proprii şi \ncomportament specific. \n  Aceste sisteme combină posibilitatea definirii \nşi manipulării structurilor complexe de date cu \nfuncţionalitatea unui limbaj de programare şi \ntehnologia de gestiune a bazelor de date.\n 44\n\n1.3.Modelul de  date orientate obiect\nModelele de date \norientate obiect (MDOO) au \nfost create pentru a modela \nlumea reală. \nDe exemplu, limbajul C++ \na fost dezvoltat pentru a crea \nmodelul unui sistem \ntelefonic. \nConceptul fundamental al \nunui MDOO este obiectul. \n 45\n\n1.3.Modelul de  date orientate obiect\nÎntr-un MDOO, orice entitate din lumea reală este \nun obiect şi reciproc, orice obiect reprezintă o entitate \na lumii reale. \nUn obiect reprezintă un grup de date stucturate, \nidentificate printr-o referinţă unică.\nUn obiect persistent este un obiect stocat în baza \nde date care are o durată de viaţă mai mare decât a \nprogramului care l-a creat. \nUn obiect tranzitoriu este un obiect depus în \nmemorie, a cărui durată de viaţă nu depăşeşte durata \nde viaţă a programului care l-a creat.\n 46', '\n', '3. ', '1.3.Modelul de  date orientate obiect\nDintre caracteristicile opţionale ale unui SGBDOO\namintim:\n✓Distribuţia obiectelor. Această distribuţie permite \ngestionarea obiectelor în diferite staţii.\n✓Modelarea tranzacţiilor evoluate. Ideea este de a \naccepta tranzacţii imbricate care pot fi descompuse în \nsubtranzacţii.\n✓Versiuni ale obiectelor. Plecând de la un anumit obiect, \nprin modificări succesive sau paralele, pot fi obţinute \nmai multe versiuni ale obiectului. \n 55\n\n1.3.Modelul de  date orientate obiect\n✓Moştenirea multiplă. O clasă (subclasă) poate fi \nspecializarea directă a unor supraclase şi să \nmoştenească proprietăţile acestora.\n✓Mesajele de eroare. Este vorba de un \nmecanism de detectare şi tratare a erorilor care \nimplică faptul că dacă într-o metodă apare o \neroare, este trimis un mesaj unei clase speciale \ndefinită anterior, care o va înregistra şi o va trata \ncorespunzător.\n 56\n\nNoţiuni introductive \ndespre teoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 57\n\n1.4. Modelul de date obiect-relaţional\n Modelul de date obiect-relaţional\n(Object-Relational Model) reprezintă\nextinderea modelului relaţional cu\ncaracteristici ale modelului obiect, extindere\nnecesară pentru realizarea bazelor de date\ncare definesc şi prelucrează tipuri de date\ncomplexe.\n 58\n\n1.4. Modelul de date obiect-relaţional\n✓ În esenţă, modelul obiect-relaţional păstrează \nstructurarea datelor în relaţii (reprezentate ca tabele), \ndar adaugă posibilitatea definirii unor noi tipuri de \ndate, pentru domeniile de valori ale atributelor. \n✓Tipurile de date definite de utilizator pot fi extinse \nprin mecanismul de moştenire şi pentru fiecare tip sau \nsubtip se pot defini metode pe care le pot executa \nobiectele de acel tip.\n 59\n\nNoţiuni introductive \ndespre teoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 60\n\n1.5. Modelul de date ierarhic\n✓În modelul de date ierarhic (Hierarchical Model) o \nbază de date se reprezintă printr-o structură ierarhică \nde înregistrări de date (records) conectate prin \nlegături (links).\n✓Modelul ierarhic a fost primul model folosit pentru \ndezvoltatea bazelor de date.\n✓Schema conceptuală a unei baze de date în modelul \nierarhic se reprezintă printr-un număr oarecare de \nscheme ierarhice.\n 61', '\n', '4. ', '1.3.Modelul de  date orientate obiect\nDintre caracteristicile opţionale ale unui SGBDOO\namintim:\n✓Distribuţia obiectelor. Această distribuţie permite \ngestionarea obiectelor în diferite staţii.\n✓Modelarea tranzacţiilor evoluate. Ideea este de a \naccepta tranzacţii imbricate care pot fi descompuse în \nsubtranzacţii.\n✓Versiuni ale obiectelor. Plecând de la un anumit obiect, \nprin modificări succesive sau paralele, pot fi obţinute \nmai multe versiuni ale obiectului. \n 55\n\n1.3.Modelul de  date orientate obiect\n✓Moştenirea multiplă. O clasă (subclasă) poate fi \nspecializarea directă a unor supraclase şi să \nmoştenească proprietăţile acestora.\n✓Mesajele de eroare. Este vorba de un \nmecanism de detectare şi tratare a erorilor care \nimplică faptul că dacă într-o metodă apare o \neroare, este trimis un mesaj unei clase speciale \ndefinită anterior, care o va înregistra şi o va trata \ncorespunzător.\n 56\n\nNoţiuni introductive \ndespre teoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 57\n\n1.4. Modelul de date obiect-relaţional\n Modelul de date obiect-relaţional\n(Object-Relational Model) reprezintă\nextinderea modelului relaţional cu\ncaracteristici ale modelului obiect, extindere\nnecesară pentru realizarea bazelor de date\ncare definesc şi prelucrează tipuri de date\ncomplexe.\n 58\n\n1.4. Modelul de date obiect-relaţional\n✓ În esenţă, modelul obiect-relaţional păstrează \nstructurarea datelor în relaţii (reprezentate ca tabele), \ndar adaugă posibilitatea definirii unor noi tipuri de \ndate, pentru domeniile de valori ale atributelor. \n✓Tipurile de date definite de utilizator pot fi extinse \nprin mecanismul de moştenire şi pentru fiecare tip sau \nsubtip se pot defini metode pe care le pot executa \nobiectele de acel tip.\n 59\n\nNoţiuni introductive \ndespre teoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 60\n\n1.5. Modelul de date ierarhic\n✓În modelul de date ierarhic (Hierarchical Model) o \nbază de date se reprezintă printr-o structură ierarhică \nde înregistrări de date (records) conectate prin \nlegături (links).\n✓Modelul ierarhic a fost primul model folosit pentru \ndezvoltatea bazelor de date.\n✓Schema conceptuală a unei baze de date în modelul \nierarhic se reprezintă printr-un număr oarecare de \nscheme ierarhice.\n 61', '\n', '5. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '6. ', ""4 \n \n2. Tipuri de baze de date \nBazele de date pot fi clasificate în mai multe categorii în funcție de modelul de organizare \nși stocare a datelor. Fiecare tip are avantaje și dezavantaje specifice, iar alegerea unui model \ndepinde de cerințele aplicației și de volumul de date gestionat. \n \n2.1. Baze de date ierarhice \nDefiniție: \nBazele de date ierarhice organizează datele într-o structură de tip arbore, unde fiecare înregistrare \nare un singur părinte și poate avea mai mulți copii. Relațiile sunt de tipul părinte-copil. \nExemplu: \nUn exemplu clasic este IBM Information Management System (IMS), folosit în instituții financiare \nși guvernamentale. \nAvantaje: \n✓ Acces rapid la date pentru interogări predefinite \n✓ Structură clară și organizată \nDezavantaje: \n✓ Lipsa flexibilității (dificil de modificat structura) \n✓ Complexitate în gestionarea relațiilor între date \n \nExemplu 1 - Structura unei baze de date pentru o organizație: \nCREATE TABLE Departament ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Angajat ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    DepartamentID INT, \n    FOREIGN KEY (DepartamentID) REFERENCES Departament(ID) \n); \n \nInserare date de test: \nINSERT INTO Departament (ID, Nume) V ALUES (1, 'IT'), (2, 'HR'); \nINSERT INTO Angajat (ID, Nume, DepartamentID) V ALUES (1, 'Ion Popescu', 1), (2, 'Maria \nIonescu', 2); \n \nInterogare pentru angajații unui departament: \nSELECT Angajat.Nume FROM Angajat \nJOIN Departament ON Angajat.DepartamentID = Departament.ID \nWHERE Departament.Nume = 'IT'; \n \nExemplu 2 - Structura pentru o bază de date educațională: \nCREATE TABLE Scoala ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n\n5 \n \n); \n \nCREATE TABLE Clasa ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    ScoalaID INT, \n    FOREIGN KEY (ScoalaID) REFERENCES Scoala(ID) \n); \n \nInserare date de test: \nINSERT INTO Scoala (ID, Nume) V ALUES (1, 'Liceul National'), (2, 'Colegiul Tehnic'); \nINSERT INTO Clasa (ID, Nume, ScoalaID) V ALUES (1, '10A', 1), (2, '11B', 2); \n \nInterogare pentru clasele dintr-o anumită școală: \nSELECT Clasa.Nume FROM Clasa \nJOIN Scoala ON Clasa.ScoalaID = Scoala.ID \nWHERE Scoala.Nume = 'Liceul National'; \n \n2.2. Baze de date rețea \n \nDefiniție: Bazele de date de tip rețea permit relații multiple între înregistrări, spre deosebire de \nstructura ierarhică strictă. \n \nExemplu: Modelul CODASYL este un exemplu de bază de date de rețea, folosit pentru aplicații \ncomplexe de gestionare a datelor. \nAvantaje: \n✓ Mai multă flexibilitate în interconectarea datelor \n✓ Performanță crescută pentru structuri complexe \nDezavantaje: \n✓ Necesită administrare complexă \n✓ Mai dificil de învățat și utilizat \n \nExemplu 1 - Structura pentru un sistem de bibliotecă: \nCREATE TABLE Carte ( \n    ID INT PRIMARY KEY , \n    Titlu V ARCHAR(100) \n); \n \nCREATE TABLE Autor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(100) \n); \n \nCREATE TABLE Carte_Autor ( \n    CarteID INT, \n    AutorID INT,"", '\n', '7. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '8. ', '1.3.Modelul de  date orientate obiect\nBaza de date orientate obiect (BDOO) este o \norganizare coerentă de obiecte persistente, \npartajate de utilizatori concurenţi. \nPrin urmare, BDOO este rezultatul aplicării \ntehnologiei orientate obiect în domeniul stocării şi \ngăsirii informaţiilor. \nSchema unei BDOO trebuie să includă:\n- definiţiile structurale (atribute şi tipuri)\n- definiţiile comportamentale (metode) ale obiectelor\n 47\n\n1.3.Modelul de  date orientate obiect\n  Un sistem de gestiune al unei baze de date \norientate obiect (SGBDOO) trebuie să \nîndeplinească cerinţele unui SGBD şi să fie în \nplus, un sistem orientat pe obiecte. \nAceste două criterii generează o mulţime de \ncaracteristici  ale unui  SGBDOO. \n 48\n\n1.3.Modelul de  date orientate obiect\nPutem accepta ca definiţie minimală:\nSGBDOO = SGBD + obiect + moştenire + polimorfism\n 49\n\n1.3.Modelul de  date orientate obiect\nCaracteristicile obligatorii ale unui SGBDOO sunt:\n1. Manipularea obiectelor atomice şi complexe (colecţii \nimbricate). \nUn constructor este o funcţie asociată unei clase care \npermite crearea şi iniţializarea unui obiect (în memorie). \nUn destructor este o funcţie asociată unei clase care \npermite distrugerea unui obiect. \nNoţiunea de obiect complex s-a născut prin aplicarea \nde constructori asupra obiectelor simple. \nO condiţie privind constructorii, referitoare la MDOO, \no constituie ortogonalitatea care presupune ca fiecare \nconstructor să fie aplicabil fiecărui obiect.\n 50\n\n1.3.Modelul de  date orientate obiect\n2. Persistenţa obiectelor. Obiectele pot persista \nmai mult decât programul care a creat aceste \nobiecte.\n3. Concurenţa acceselor. BDOO poate să fie \npartajată simultan de către tranzacţiile care o \nconsultă şi o modifică.\n4. Fiabilitatea obiectelor. În cazul unei \ndefecţiuni, obiectele trebuie restaurate la \nstarea pe care au avut-o înainte de defecţiune.\n 51\n\n1.3.Modelul de  date orientate obiect\n5. Uşurinţa interogării.\nUn obiect poate fi găsit utilizând valorile \natributelor sale, legăturile cu alte obiecte sau \nmetodele aplicate acestuia.\n6. Identitatea obiectelor.\nOrice obiect trebuie să aibă un \nidentificator sistem.\n 52\n\n1.3.Modelul de  date orientate obiect\n7. Moştenirea (simplă).\nO clasă poate fi specializarea altei clase şi, prin \nurmare, poate să o moştenească. \nMoştenirea reduce efortul de programare. \nExistă mai multe modalităţi de a moşteni şi anume \nprin: \n1. substituţie\n2. incluziune\n3. restricţie\n4. specializare\n 53\n\n1.3.Modelul de  date orientate obiect\n8. Polimorfismul.\nCodul unei metode trebuie ales în funcţie de \nparametrii săi.\n9. Extensibilitatea.\nSGBDOO trebuie să includă pe lângă clasele sale şi \ntipurile predefinite şi instrumentele care să permită \nutilizatorului definirea unor noi clase şi tipuri.\n 54', '\n', '9. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n', '10. ', 'Curs 10\nLimbajul SQL \nCurs - BAZE DE DATE 2\n\nLimbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3\n\n➢O bază de date conţine şi alte obiecte decât cele cu \ncare v-aţi familiarizat în celelalte cursuri. \n➢Obiectele care pot exista într-o bază de date sunt: \n1. tabele \n2. vederi (views)\n3. secvenţe\n4. indecşi \n5. sinonime\nCurs - BAZE DE DATE 4\n\nCuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5\n\n1. Secventele\nDe ce folosim secventele?\n➢Aplicaţiile au în general nevoie în cadrul tabelelor de \na conţine unele numere de identificare unice per \ntabelă cum este şi cazul cheilor primare. \n➢Acestea pot fi calculate de către aplicaţie direct \nfolosind anumiţi algoritmi în funcţie de înregistrările \ndeja existente şi apoi pot fi introduse în baza de date \nodată cu celelalte date. \nCurs - BAZE DE DATE 6\n\n1. Secventele\n➢În acest caz însă apar mari probleme de sincronizare \nastfel încât dacă mai multe instanţe a aceleaşi \naplicaţii accesează în acelaşi timp aproximativ datele \ndeja existente în baza de date rezultatul cheilor va fi \nacelaşi. \n➢De asemenea sunt necesare de la una la mai multe \ncereri la baza de date pentru a determina care sunt \nvalorile deja existente astfel încât aplicaţia consuma \nmai mult timp procesor pentru fiecare inserare şi \ndevine mult mai lentă. \nCurs - BAZE DE DATE 7\n\n➢O soluţie la aceste probleme sunt secvenţele. \n➢Secvenţele sunt nişte obiecte care pot fi împărţite \nîntre mai mulţi utilizatori şi care pot să genereze \nnumere întregi unice.\n➢Cea mai răspândita utilizare a lor este pentru cheile \nunice ale tabelelor. \n➢Secvenţele sunt incrementate sau decrementate cu \najutorul unei rutine interne a sistemului de gestiune \na bazelor de date (Oracle).\nCurs - BAZE DE DATE 8\n\n➢Secvenţele nu sunt o proprietate a tabelelor astfel \nîncât ele pot fi folosite de către mai multe tabele în \nacelaşi timp. \n➢În practica uzuală pentru fiecare tabelă în parte se \natribuie o secvenţă separată dar ele mai pot fi \nutilizate astfel încât mai multe tabele folosesc aceeaşi \nsecvenţă sau o tabelă poate avea mai multe \nsecvenţe.\nCurs - BAZE DE DATE 9\n\nCrearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', '\n']","modelul de date relațional este prezentat ca modelul predominant.
",relațional,0.39090909089606063,1.0,0.8622635304058776,0.0,0.04196114906296548,0.33333333333333337,0.0
1,O3mini-high,LOW,C2,,Ce limbaj integrat în Oracle este utilizat pentru scrierea procedurilor stocate?,PL/SQL,Este corect,,"['1. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Are facilităţi de salvare/restaurare automate şi \ninteligente\n• Permite partiţionarea integrală pentru tabele şi indecşi\n• Are mesagerie integrală, prin comunicarea între \naplicaţii şi procesare offline (chiar dacă aplicaţiile nu \nsunt conectate)\n• Prelucrarea paralelă pentru: \n– replicare\n– cereri de regăsire\n– actualizare\n10SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oferă facilităţi din tehnologia OO, prin care se permite \ndefinirea şi utilizarea de obiecte mari şi complexe\n• Optimizează cererile de regăsire prin reutilizarea \ncomenzilor SQL identice lansate de utilizatori diferiţi şi \nprin realizarea unui plan de execuţie a instrucţiunilor \nSQL\n• Are un grad de securitate sporit prin: \n– server de criptare\n– control trafic reţea\n– niveluri de parolare, etc.\n11SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Permite lucrul cu depozite de date (Data Warehouse) \ncare conţin date multidimensionale (cu tehnologia \nOLAP)\n• Conţine foarte multe produse ceea ce-l face să fie o \nplatformă pentru baze de date:\n– servere (Oracle 8, Application, Security, Internet Commerce, \netc)\n– instrumente (Designer, Developer, Express, WebDB, etc)\n– aplicaţii (Financials, Projects, Market Manager, \nManufacturing, etc)\n12SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Este primul SGBD pentru Internet cu server Java inclus\n• Reduce drastic costurile pentru realizarea unei aplicaţii \n(de circa 10 ori faţă de versiunea anterioară)\n• Este o platformă multiplă permiţând lucrul pe orice \ncalculator, orice sistem de operare, orice aplicaţie, \norice utilizator\n13SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Are instrumente diverse pentru dezvoltarea aplicaţiilor: \n✓bazate pe modelare (Designer, Developer, Application Server)\n✓bazate pe componente (Java)\n✓bazate pe HTML (browsere, editoare Web) şi XML\n✓prin programare: \n✓proceduri stocate (PL/SQL, Java)\n✓obiecte standard\n✓obiecte ODBC\n✓obiecte JDBC\n✓fraze SQL\n✓tip internet WebDB\n14SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nUlterior a fost lansat sistemul Oracle 9i care a \nmarcat trecerea la o nouă generaţie de servicii \ninternet. \nEl este mai mult decât un suport pentru baze de \ndate deoarece oferă o infrastructură completă de \nsoftware pentru afaceri electronice (e-business) şi \nrulează pe o varietate de sisteme de calcul şi de \noperare: \n➢ SUN-SOLARIS \n➢ HP-Unix\n➢ IBM-AIX\n➢ PC_WINDOWS\n➢ LINUX\n15\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16', '\n', '2. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Are facilităţi de salvare/restaurare automate şi \ninteligente\n• Permite partiţionarea integrală pentru tabele şi indecşi\n• Are mesagerie integrală, prin comunicarea între \naplicaţii şi procesare offline (chiar dacă aplicaţiile nu \nsunt conectate)\n• Prelucrarea paralelă pentru: \n– replicare\n– cereri de regăsire\n– actualizare\n10SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oferă facilităţi din tehnologia OO, prin care se permite \ndefinirea şi utilizarea de obiecte mari şi complexe\n• Optimizează cererile de regăsire prin reutilizarea \ncomenzilor SQL identice lansate de utilizatori diferiţi şi \nprin realizarea unui plan de execuţie a instrucţiunilor \nSQL\n• Are un grad de securitate sporit prin: \n– server de criptare\n– control trafic reţea\n– niveluri de parolare, etc.\n11SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Permite lucrul cu depozite de date (Data Warehouse) \ncare conţin date multidimensionale (cu tehnologia \nOLAP)\n• Conţine foarte multe produse ceea ce-l face să fie o \nplatformă pentru baze de date:\n– servere (Oracle 8, Application, Security, Internet Commerce, \netc)\n– instrumente (Designer, Developer, Express, WebDB, etc)\n– aplicaţii (Financials, Projects, Market Manager, \nManufacturing, etc)\n12SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Este primul SGBD pentru Internet cu server Java inclus\n• Reduce drastic costurile pentru realizarea unei aplicaţii \n(de circa 10 ori faţă de versiunea anterioară)\n• Este o platformă multiplă permiţând lucrul pe orice \ncalculator, orice sistem de operare, orice aplicaţie, \norice utilizator\n13SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Are instrumente diverse pentru dezvoltarea aplicaţiilor: \n✓bazate pe modelare (Designer, Developer, Application Server)\n✓bazate pe componente (Java)\n✓bazate pe HTML (browsere, editoare Web) şi XML\n✓prin programare: \n✓proceduri stocate (PL/SQL, Java)\n✓obiecte standard\n✓obiecte ODBC\n✓obiecte JDBC\n✓fraze SQL\n✓tip internet WebDB\n14SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nUlterior a fost lansat sistemul Oracle 9i care a \nmarcat trecerea la o nouă generaţie de servicii \ninternet. \nEl este mai mult decât un suport pentru baze de \ndate deoarece oferă o infrastructură completă de \nsoftware pentru afaceri electronice (e-business) şi \nrulează pe o varietate de sisteme de calcul şi de \noperare: \n➢ SUN-SOLARIS \n➢ HP-Unix\n➢ IBM-AIX\n➢ PC_WINDOWS\n➢ LINUX\n15\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16', '\n', '3. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '4. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '5. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n', '6. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n', '7. ', 'Numarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55\n\n\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56\n\nExemplu \n Gasiti angajatii care au un salariu superior \nsalariului mediu al departamentului lor.\nSELECT ename, sal, deptno\nFROM EMP E\nWHERE sal >\n            ( SELECT AVG(sal)\n             FROM EMP\n             WHERE ( deptno = E.deptno ) )\nORDER BY deptno;\nCurs 6 - BAZE DE DATE 57\n\nExemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n\n\nValori de NULL intr-o subinterogare \n• In cazul in care subinterogarea returneaza \nvreuna din valori NULL si interogarea \nprincipala are operator NOT IN, atunci \ninterogarea principala nu va returna niciun \nrand. \n• Motivul este ca o comparatie cu NULL conduce \nla un rezultat NULL. \nCurs 6 - BAZE DE DATE 59\n\nExemplu \nGasiti angajatii care nu au subordonati. \nSELECT ename \nFROM EMP \nWHERE empno NOT IN\n                    ( SELECT mgr\n                         FROM EMP );\nCurs 6 - BAZE DE DATE 60\n\nExemplu \nGasiti angajatii care nu au \nsubordonati. \nCurs 6 - BAZE DE DATE 61\n\n\n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN. \n• De fapt operatorul NOT IN este echivalent cu <> ALL.\n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL). \nCurs 6 - BAZE DE DATE 62\n\nExemplu\nGasiti angajatii care au subordonati.\nSELECT ename\nFROM EMP \nWHERE empno IN\n               ( SELECT mgr\n                  FROM EMP );\nCurs 6 - BAZE DE DATE 63\n\nExemplu \nGasiti angajatii care au \nsubordonati.\nCurs 6 - BAZE DE DATE 64\n\n\n• In cazul utilizarii operatorului NOT IN in interogarea \nprincipala trebuie avut grija sa se excluda valorile NULL\ndin raspunsurile subcererii.\nExemplu \nGasiti angajatii care nu au subordonati. \nCurs 6 - BAZE DE DATE 65\n\nSELECT ename \n  FROM EMP \n  WHERE empno NOT IN\n                  ( SELECT mgr\n                    FROM EMP\n                    WHERE mgr IS NOT NULL );\nCurs 6 - BAZE DE DATE 66\n\n\nSfaturi în utilizarea subinterogarilor\n1. Includerea subinterogarilor în paranteze\n2. Plasarea subinterogarilor în partea dreapta a \noperatorului de comparare\n3. A nu se adauga clauza ORDER BY într-o \nsubinterogare\n4. Folosirea operatorilor single-row în subinterogari \nsingle-row\n5. Folosirea operatorilor multiple-row în \nsubinterogari multiple-row\nCurs 6 - BAZE DE DATE 67', '\n', '8. ', 'Numarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55\n\n\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56\n\nExemplu \n Gasiti angajatii care au un salariu superior \nsalariului mediu al departamentului lor.\nSELECT ename, sal, deptno\nFROM EMP E\nWHERE sal >\n            ( SELECT AVG(sal)\n             FROM EMP\n             WHERE ( deptno = E.deptno ) )\nORDER BY deptno;\nCurs 6 - BAZE DE DATE 57\n\nExemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n\n\nValori de NULL intr-o subinterogare \n• In cazul in care subinterogarea returneaza \nvreuna din valori NULL si interogarea \nprincipala are operator NOT IN, atunci \ninterogarea principala nu va returna niciun \nrand. \n• Motivul este ca o comparatie cu NULL conduce \nla un rezultat NULL. \nCurs 6 - BAZE DE DATE 59\n\nExemplu \nGasiti angajatii care nu au subordonati. \nSELECT ename \nFROM EMP \nWHERE empno NOT IN\n                    ( SELECT mgr\n                         FROM EMP );\nCurs 6 - BAZE DE DATE 60\n\nExemplu \nGasiti angajatii care nu au \nsubordonati. \nCurs 6 - BAZE DE DATE 61\n\n\n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN. \n• De fapt operatorul NOT IN este echivalent cu <> ALL.\n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL). \nCurs 6 - BAZE DE DATE 62\n\nExemplu\nGasiti angajatii care au subordonati.\nSELECT ename\nFROM EMP \nWHERE empno IN\n               ( SELECT mgr\n                  FROM EMP );\nCurs 6 - BAZE DE DATE 63\n\nExemplu \nGasiti angajatii care au \nsubordonati.\nCurs 6 - BAZE DE DATE 64\n\n\n• In cazul utilizarii operatorului NOT IN in interogarea \nprincipala trebuie avut grija sa se excluda valorile NULL\ndin raspunsurile subcererii.\nExemplu \nGasiti angajatii care nu au subordonati. \nCurs 6 - BAZE DE DATE 65\n\nSELECT ename \n  FROM EMP \n  WHERE empno NOT IN\n                  ( SELECT mgr\n                    FROM EMP\n                    WHERE mgr IS NOT NULL );\nCurs 6 - BAZE DE DATE 66\n\n\nSfaturi în utilizarea subinterogarilor\n1. Includerea subinterogarilor în paranteze\n2. Plasarea subinterogarilor în partea dreapta a \noperatorului de comparare\n3. A nu se adauga clauza ORDER BY într-o \nsubinterogare\n4. Folosirea operatorilor single-row în subinterogari \nsingle-row\n5. Folosirea operatorilor multiple-row în \nsubinterogari multiple-row\nCurs 6 - BAZE DE DATE 67', '\n', '9. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '10. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n']","limbajul procedural propriu pentru scrierea procedurilor stocate în Oracle este PL/SQL.
",Ce limbaj integrat în Oracle este utilizat pentru scrierea procedurilor stocate?,"['1. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Are facilităţi de salvare/restaurare automate şi \ninteligente\n• Permite partiţionarea integrală pentru tabele şi indecşi\n• Are mesagerie integrală, prin comunicarea între \naplicaţii şi procesare offline (chiar dacă aplicaţiile nu \nsunt conectate)\n• Prelucrarea paralelă pentru: \n– replicare\n– cereri de regăsire\n– actualizare\n10SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oferă facilităţi din tehnologia OO, prin care se permite \ndefinirea şi utilizarea de obiecte mari şi complexe\n• Optimizează cererile de regăsire prin reutilizarea \ncomenzilor SQL identice lansate de utilizatori diferiţi şi \nprin realizarea unui plan de execuţie a instrucţiunilor \nSQL\n• Are un grad de securitate sporit prin: \n– server de criptare\n– control trafic reţea\n– niveluri de parolare, etc.\n11SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Permite lucrul cu depozite de date (Data Warehouse) \ncare conţin date multidimensionale (cu tehnologia \nOLAP)\n• Conţine foarte multe produse ceea ce-l face să fie o \nplatformă pentru baze de date:\n– servere (Oracle 8, Application, Security, Internet Commerce, \netc)\n– instrumente (Designer, Developer, Express, WebDB, etc)\n– aplicaţii (Financials, Projects, Market Manager, \nManufacturing, etc)\n12SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Este primul SGBD pentru Internet cu server Java inclus\n• Reduce drastic costurile pentru realizarea unei aplicaţii \n(de circa 10 ori faţă de versiunea anterioară)\n• Este o platformă multiplă permiţând lucrul pe orice \ncalculator, orice sistem de operare, orice aplicaţie, \norice utilizator\n13SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Are instrumente diverse pentru dezvoltarea aplicaţiilor: \n✓bazate pe modelare (Designer, Developer, Application Server)\n✓bazate pe componente (Java)\n✓bazate pe HTML (browsere, editoare Web) şi XML\n✓prin programare: \n✓proceduri stocate (PL/SQL, Java)\n✓obiecte standard\n✓obiecte ODBC\n✓obiecte JDBC\n✓fraze SQL\n✓tip internet WebDB\n14SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nUlterior a fost lansat sistemul Oracle 9i care a \nmarcat trecerea la o nouă generaţie de servicii \ninternet. \nEl este mai mult decât un suport pentru baze de \ndate deoarece oferă o infrastructură completă de \nsoftware pentru afaceri electronice (e-business) şi \nrulează pe o varietate de sisteme de calcul şi de \noperare: \n➢ SUN-SOLARIS \n➢ HP-Unix\n➢ IBM-AIX\n➢ PC_WINDOWS\n➢ LINUX\n15\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16', '\n', '2. ', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Are facilităţi de salvare/restaurare automate şi \ninteligente\n• Permite partiţionarea integrală pentru tabele şi indecşi\n• Are mesagerie integrală, prin comunicarea între \naplicaţii şi procesare offline (chiar dacă aplicaţiile nu \nsunt conectate)\n• Prelucrarea paralelă pentru: \n– replicare\n– cereri de regăsire\n– actualizare\n10SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oferă facilităţi din tehnologia OO, prin care se permite \ndefinirea şi utilizarea de obiecte mari şi complexe\n• Optimizează cererile de regăsire prin reutilizarea \ncomenzilor SQL identice lansate de utilizatori diferiţi şi \nprin realizarea unui plan de execuţie a instrucţiunilor \nSQL\n• Are un grad de securitate sporit prin: \n– server de criptare\n– control trafic reţea\n– niveluri de parolare, etc.\n11SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Permite lucrul cu depozite de date (Data Warehouse) \ncare conţin date multidimensionale (cu tehnologia \nOLAP)\n• Conţine foarte multe produse ceea ce-l face să fie o \nplatformă pentru baze de date:\n– servere (Oracle 8, Application, Security, Internet Commerce, \netc)\n– instrumente (Designer, Developer, Express, WebDB, etc)\n– aplicaţii (Financials, Projects, Market Manager, \nManufacturing, etc)\n12SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Este primul SGBD pentru Internet cu server Java inclus\n• Reduce drastic costurile pentru realizarea unei aplicaţii \n(de circa 10 ori faţă de versiunea anterioară)\n• Este o platformă multiplă permiţând lucrul pe orice \ncalculator, orice sistem de operare, orice aplicaţie, \norice utilizator\n13SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Are instrumente diverse pentru dezvoltarea aplicaţiilor: \n✓bazate pe modelare (Designer, Developer, Application Server)\n✓bazate pe componente (Java)\n✓bazate pe HTML (browsere, editoare Web) şi XML\n✓prin programare: \n✓proceduri stocate (PL/SQL, Java)\n✓obiecte standard\n✓obiecte ODBC\n✓obiecte JDBC\n✓fraze SQL\n✓tip internet WebDB\n14SGBD Oracle 8i (continuare)\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nUlterior a fost lansat sistemul Oracle 9i care a \nmarcat trecerea la o nouă generaţie de servicii \ninternet. \nEl este mai mult decât un suport pentru baze de \ndate deoarece oferă o infrastructură completă de \nsoftware pentru afaceri electronice (e-business) şi \nrulează pe o varietate de sisteme de calcul şi de \noperare: \n➢ SUN-SOLARIS \n➢ HP-Unix\n➢ IBM-AIX\n➢ PC_WINDOWS\n➢ LINUX\n15\n\n2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nComponenta Oracle WebDB a evoluat în \nOracle Portal. \n• Oracle 9i DATABASEare faţă de versiunea \nanterioară o protecţie ridicată şi automatizată \niar costul administrării bazei de date scade în \nmod drastic. \n16', '\n', '3. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '4. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '5. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n', '6. ', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22\n\n2.2. Arhitectura SGBD-ului ORACLE\n Componentele care formează arhitectura de bază \nOracle (figura urmatoare) sunt dispuse într-o \nconfiguraţie client/server. \n  Aceste componente sunt plasate pe calculatoare \ndiferite într-o reţea asigurând funcţionalităţi specifice, \nastfel: \n- serverul asigură memorarea şi manipularea datelor, \nprecum şi administrarea bazei de date,\n- iar clientul asigură interfaţa cu utilizatorul şi lansează \naplicaţia care accesează datele din baza de date. \n23\n\n2.2. Arhitectura SGBD-ului ORACLE\nArhitectura ORACLE\n24\n\n2.2. Arhitectura SGBD-ului ORACLE\n Arhitectura Oracle se încadrează în \ntendinţele actuale şi anume este structurată \npe trei niveluri:\n \n1.Nucleul\n2.interfeţele \n3.instrumentele de întreţinere\n25\n\n2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26\n\n2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27\n\n2.2. Arhitectura SGBD-ului ORACLE\n2. Interfeţele sunt componentele care permit dezvoltarea \naplicaţiilor cu BD, astfel: \n• DEVELOPER SUITE este componenta destinată \ndezvoltatorilor (programatorilor) de aplicaţii. \nConţine generatoarele:\n- FORMS (meniuri şi videoformate)\n- REPORTS (rapoarte şi grafice)\n- JDEVELOPER\n28\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DESIGNER este o componentă destinată \nanaliştilor/proiectanţilor de aplicaţii. \nOferă elemente de CASE pentru proiectarea \naplicaţiilor cu BD\n• PRO*C este componenta destinată \nprogramatorilor în limbajele de programare \nuniversale (FORTRAN, COBOL, Pascal, C, ADA, \nPL1)\n29\n\n2.2. Arhitectura SGBD-ului ORACLE\n• DATAWAREHOUSE BUILDER este destinat \nanalizei datelor multidimensionale, folosind \ntehnologia de tip OLAP (On Line Analitical \nProcessing)\n• ORACLE APPLICATIONS permite dezvoltarea \nunor aplicaţii de întreprindere (Financials, \nManufacturing, Projects etc.)\n30\n\n2.2. Arhitectura SGBD-ului ORACLE\n3. Instrumentele sunt componente destinate \nîntreţinerii şi bunei funcţionări a unei BD Oracle. \nENTERPRISE MANAGER CONSOLE conţine mai multe \nutilitare destinate administratorului BD:\n- deschidere / închidere BD\n- autorizarea accesului\n- refacerea BD\n- conversii de date\n31\n\nS.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n32', '\n', '7. ', 'Numarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55\n\n\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56\n\nExemplu \n Gasiti angajatii care au un salariu superior \nsalariului mediu al departamentului lor.\nSELECT ename, sal, deptno\nFROM EMP E\nWHERE sal >\n            ( SELECT AVG(sal)\n             FROM EMP\n             WHERE ( deptno = E.deptno ) )\nORDER BY deptno;\nCurs 6 - BAZE DE DATE 57\n\nExemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n\n\nValori de NULL intr-o subinterogare \n• In cazul in care subinterogarea returneaza \nvreuna din valori NULL si interogarea \nprincipala are operator NOT IN, atunci \ninterogarea principala nu va returna niciun \nrand. \n• Motivul este ca o comparatie cu NULL conduce \nla un rezultat NULL. \nCurs 6 - BAZE DE DATE 59\n\nExemplu \nGasiti angajatii care nu au subordonati. \nSELECT ename \nFROM EMP \nWHERE empno NOT IN\n                    ( SELECT mgr\n                         FROM EMP );\nCurs 6 - BAZE DE DATE 60\n\nExemplu \nGasiti angajatii care nu au \nsubordonati. \nCurs 6 - BAZE DE DATE 61\n\n\n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN. \n• De fapt operatorul NOT IN este echivalent cu <> ALL.\n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL). \nCurs 6 - BAZE DE DATE 62\n\nExemplu\nGasiti angajatii care au subordonati.\nSELECT ename\nFROM EMP \nWHERE empno IN\n               ( SELECT mgr\n                  FROM EMP );\nCurs 6 - BAZE DE DATE 63\n\nExemplu \nGasiti angajatii care au \nsubordonati.\nCurs 6 - BAZE DE DATE 64\n\n\n• In cazul utilizarii operatorului NOT IN in interogarea \nprincipala trebuie avut grija sa se excluda valorile NULL\ndin raspunsurile subcererii.\nExemplu \nGasiti angajatii care nu au subordonati. \nCurs 6 - BAZE DE DATE 65\n\nSELECT ename \n  FROM EMP \n  WHERE empno NOT IN\n                  ( SELECT mgr\n                    FROM EMP\n                    WHERE mgr IS NOT NULL );\nCurs 6 - BAZE DE DATE 66\n\n\nSfaturi în utilizarea subinterogarilor\n1. Includerea subinterogarilor în paranteze\n2. Plasarea subinterogarilor în partea dreapta a \noperatorului de comparare\n3. A nu se adauga clauza ORDER BY într-o \nsubinterogare\n4. Folosirea operatorilor single-row în subinterogari \nsingle-row\n5. Folosirea operatorilor multiple-row în \nsubinterogari multiple-row\nCurs 6 - BAZE DE DATE 67', '\n', '8. ', 'Numarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55\n\n\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56\n\nExemplu \n Gasiti angajatii care au un salariu superior \nsalariului mediu al departamentului lor.\nSELECT ename, sal, deptno\nFROM EMP E\nWHERE sal >\n            ( SELECT AVG(sal)\n             FROM EMP\n             WHERE ( deptno = E.deptno ) )\nORDER BY deptno;\nCurs 6 - BAZE DE DATE 57\n\nExemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n\n\nValori de NULL intr-o subinterogare \n• In cazul in care subinterogarea returneaza \nvreuna din valori NULL si interogarea \nprincipala are operator NOT IN, atunci \ninterogarea principala nu va returna niciun \nrand. \n• Motivul este ca o comparatie cu NULL conduce \nla un rezultat NULL. \nCurs 6 - BAZE DE DATE 59\n\nExemplu \nGasiti angajatii care nu au subordonati. \nSELECT ename \nFROM EMP \nWHERE empno NOT IN\n                    ( SELECT mgr\n                         FROM EMP );\nCurs 6 - BAZE DE DATE 60\n\nExemplu \nGasiti angajatii care nu au \nsubordonati. \nCurs 6 - BAZE DE DATE 61\n\n\n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN. \n• De fapt operatorul NOT IN este echivalent cu <> ALL.\n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL). \nCurs 6 - BAZE DE DATE 62\n\nExemplu\nGasiti angajatii care au subordonati.\nSELECT ename\nFROM EMP \nWHERE empno IN\n               ( SELECT mgr\n                  FROM EMP );\nCurs 6 - BAZE DE DATE 63\n\nExemplu \nGasiti angajatii care au \nsubordonati.\nCurs 6 - BAZE DE DATE 64\n\n\n• In cazul utilizarii operatorului NOT IN in interogarea \nprincipala trebuie avut grija sa se excluda valorile NULL\ndin raspunsurile subcererii.\nExemplu \nGasiti angajatii care nu au subordonati. \nCurs 6 - BAZE DE DATE 65\n\nSELECT ename \n  FROM EMP \n  WHERE empno NOT IN\n                  ( SELECT mgr\n                    FROM EMP\n                    WHERE mgr IS NOT NULL );\nCurs 6 - BAZE DE DATE 66\n\n\nSfaturi în utilizarea subinterogarilor\n1. Includerea subinterogarilor în paranteze\n2. Plasarea subinterogarilor în partea dreapta a \noperatorului de comparare\n3. A nu se adauga clauza ORDER BY într-o \nsubinterogare\n4. Folosirea operatorilor single-row în subinterogari \nsingle-row\n5. Folosirea operatorilor multiple-row în \nsubinterogari multiple-row\nCurs 6 - BAZE DE DATE 67', '\n', '9. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '10. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n']","limbajul procedural propriu pentru scrierea procedurilor stocate în Oracle este PL/SQL.
",PL/SQL,0.33739495797475844,1.0,0.8679018532220854,1.0,0.10571070857151538,0.2857142857142857,0.0
2,O3mini-high,LOW,C3,,Cu ce clauză SQL se filtrează rândurile dintr-o interogare?,WHERE,Este corect,,"['1. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '2. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '3. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '4. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '5. ', 'Clauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \n 68\n\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 69\n\nClauza ORDER BY\n➢În mod normal (fără clauza ORDER BY) rândurile sunt \nreturnate într-o ordine convenită de Oracle însă ea \nfiind consistentă de la cerere la cerere. \n➢Cu ajutorul clauzei ORDER BY rândurile vor fi afişate în \nordinea solicitată (cu toate acestea nu se va modifica \nordinea internă a rândurilor din baza de date).\n➢Clauza ORDER BY trebuie să fie ultima clauză din cerere \n(interogare).\n 70\n\nClauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine crescătoare).\nSELECT * \nFROM EMP\nORDER BY hiredata; \n 72\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare (în ordine crescătoare).\n 73\n\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine descrescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate DESC;\n 74\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă data de angajare (în ordine descrescătoare). \n 75\n\n\nClauza ORDER BY\n➢Mai putem ordona randurile returnate cu ajutorul \nalias-urilor.\nExemplu: \nListati toti angajatii ordonandu-i dupa salariul anual: \nsal*12 salariuanual (in ordine crescatoare). \nSELECT ename, job, sal*12 SALARIU_ANUAL\nFROM EMP\nORDER BY SALARIU_ANUAL;\n 76\n\nClauza ORDER BY\nRezultatul obtinut - Listati toti angajatii ordonandu-i dupa salariul \nanual: sal*12 salariuanual (in ordine crescatoare). \n 77\n\n\nClauza ORDER BY\n➢ Rândurile mai pot fi ordonate şi după mai multe coloane. \n➢ Numărul de coloane după care se pot ordona rândurile \nîntoarse este numărul maxim de coloane existente în tabelă. \nExemplu \n Listaţi toţi angajaţii ordonându-i după data de angajare, \nsalariu şi comision (în ordine crescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate, sal, comm; \n 78\n\nClauza ORDER BY\n➢ Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare, salariu şi comision (în ordine crescătoare). \n 79\n\n\nClauza ORDER BY\n➢În clauza ORDER BY se pot folosi coloane care nu sunt \nconţinute în SELECT.\n \nExemplu: \n  Listaţi toţi angajaţii ordonându-i după salariu (în \nordine crescătoare).\nSELECT ename, job\nFROM EMP\nORDER BY sal;  \n 80\n\nClauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82', '\n', '6. ', 'Clauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \n 68\n\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 69\n\nClauza ORDER BY\n➢În mod normal (fără clauza ORDER BY) rândurile sunt \nreturnate într-o ordine convenită de Oracle însă ea \nfiind consistentă de la cerere la cerere. \n➢Cu ajutorul clauzei ORDER BY rândurile vor fi afişate în \nordinea solicitată (cu toate acestea nu se va modifica \nordinea internă a rândurilor din baza de date).\n➢Clauza ORDER BY trebuie să fie ultima clauză din cerere \n(interogare).\n 70\n\nClauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine crescătoare).\nSELECT * \nFROM EMP\nORDER BY hiredata; \n 72\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare (în ordine crescătoare).\n 73\n\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine descrescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate DESC;\n 74\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă data de angajare (în ordine descrescătoare). \n 75\n\n\nClauza ORDER BY\n➢Mai putem ordona randurile returnate cu ajutorul \nalias-urilor.\nExemplu: \nListati toti angajatii ordonandu-i dupa salariul anual: \nsal*12 salariuanual (in ordine crescatoare). \nSELECT ename, job, sal*12 SALARIU_ANUAL\nFROM EMP\nORDER BY SALARIU_ANUAL;\n 76\n\nClauza ORDER BY\nRezultatul obtinut - Listati toti angajatii ordonandu-i dupa salariul \nanual: sal*12 salariuanual (in ordine crescatoare). \n 77\n\n\nClauza ORDER BY\n➢ Rândurile mai pot fi ordonate şi după mai multe coloane. \n➢ Numărul de coloane după care se pot ordona rândurile \nîntoarse este numărul maxim de coloane existente în tabelă. \nExemplu \n Listaţi toţi angajaţii ordonându-i după data de angajare, \nsalariu şi comision (în ordine crescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate, sal, comm; \n 78\n\nClauza ORDER BY\n➢ Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare, salariu şi comision (în ordine crescătoare). \n 79\n\n\nClauza ORDER BY\n➢În clauza ORDER BY se pot folosi coloane care nu sunt \nconţinute în SELECT.\n \nExemplu: \n  Listaţi toţi angajaţii ordonându-i după salariu (în \nordine crescătoare).\nSELECT ename, job\nFROM EMP\nORDER BY sal;  \n 80\n\nClauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82', '\n', '7. ', 'Numarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55\n\n\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56\n\nExemplu \n Gasiti angajatii care au un salariu superior \nsalariului mediu al departamentului lor.\nSELECT ename, sal, deptno\nFROM EMP E\nWHERE sal >\n            ( SELECT AVG(sal)\n             FROM EMP\n             WHERE ( deptno = E.deptno ) )\nORDER BY deptno;\nCurs 6 - BAZE DE DATE 57\n\nExemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n\n\nValori de NULL intr-o subinterogare \n• In cazul in care subinterogarea returneaza \nvreuna din valori NULL si interogarea \nprincipala are operator NOT IN, atunci \ninterogarea principala nu va returna niciun \nrand. \n• Motivul este ca o comparatie cu NULL conduce \nla un rezultat NULL. \nCurs 6 - BAZE DE DATE 59\n\nExemplu \nGasiti angajatii care nu au subordonati. \nSELECT ename \nFROM EMP \nWHERE empno NOT IN\n                    ( SELECT mgr\n                         FROM EMP );\nCurs 6 - BAZE DE DATE 60\n\nExemplu \nGasiti angajatii care nu au \nsubordonati. \nCurs 6 - BAZE DE DATE 61\n\n\n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN. \n• De fapt operatorul NOT IN este echivalent cu <> ALL.\n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL). \nCurs 6 - BAZE DE DATE 62\n\nExemplu\nGasiti angajatii care au subordonati.\nSELECT ename\nFROM EMP \nWHERE empno IN\n               ( SELECT mgr\n                  FROM EMP );\nCurs 6 - BAZE DE DATE 63\n\nExemplu \nGasiti angajatii care au \nsubordonati.\nCurs 6 - BAZE DE DATE 64\n\n\n• In cazul utilizarii operatorului NOT IN in interogarea \nprincipala trebuie avut grija sa se excluda valorile NULL\ndin raspunsurile subcererii.\nExemplu \nGasiti angajatii care nu au subordonati. \nCurs 6 - BAZE DE DATE 65\n\nSELECT ename \n  FROM EMP \n  WHERE empno NOT IN\n                  ( SELECT mgr\n                    FROM EMP\n                    WHERE mgr IS NOT NULL );\nCurs 6 - BAZE DE DATE 66\n\n\nSfaturi în utilizarea subinterogarilor\n1. Includerea subinterogarilor în paranteze\n2. Plasarea subinterogarilor în partea dreapta a \noperatorului de comparare\n3. A nu se adauga clauza ORDER BY într-o \nsubinterogare\n4. Folosirea operatorilor single-row în subinterogari \nsingle-row\n5. Folosirea operatorilor multiple-row în \nsubinterogari multiple-row\nCurs 6 - BAZE DE DATE 67', '\n', '8. ', 'Numarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55\n\n\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56\n\nExemplu \n Gasiti angajatii care au un salariu superior \nsalariului mediu al departamentului lor.\nSELECT ename, sal, deptno\nFROM EMP E\nWHERE sal >\n            ( SELECT AVG(sal)\n             FROM EMP\n             WHERE ( deptno = E.deptno ) )\nORDER BY deptno;\nCurs 6 - BAZE DE DATE 57\n\nExemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n\n\nValori de NULL intr-o subinterogare \n• In cazul in care subinterogarea returneaza \nvreuna din valori NULL si interogarea \nprincipala are operator NOT IN, atunci \ninterogarea principala nu va returna niciun \nrand. \n• Motivul este ca o comparatie cu NULL conduce \nla un rezultat NULL. \nCurs 6 - BAZE DE DATE 59\n\nExemplu \nGasiti angajatii care nu au subordonati. \nSELECT ename \nFROM EMP \nWHERE empno NOT IN\n                    ( SELECT mgr\n                         FROM EMP );\nCurs 6 - BAZE DE DATE 60\n\nExemplu \nGasiti angajatii care nu au \nsubordonati. \nCurs 6 - BAZE DE DATE 61\n\n\n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN. \n• De fapt operatorul NOT IN este echivalent cu <> ALL.\n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL). \nCurs 6 - BAZE DE DATE 62\n\nExemplu\nGasiti angajatii care au subordonati.\nSELECT ename\nFROM EMP \nWHERE empno IN\n               ( SELECT mgr\n                  FROM EMP );\nCurs 6 - BAZE DE DATE 63\n\nExemplu \nGasiti angajatii care au \nsubordonati.\nCurs 6 - BAZE DE DATE 64\n\n\n• In cazul utilizarii operatorului NOT IN in interogarea \nprincipala trebuie avut grija sa se excluda valorile NULL\ndin raspunsurile subcererii.\nExemplu \nGasiti angajatii care nu au subordonati. \nCurs 6 - BAZE DE DATE 65\n\nSELECT ename \n  FROM EMP \n  WHERE empno NOT IN\n                  ( SELECT mgr\n                    FROM EMP\n                    WHERE mgr IS NOT NULL );\nCurs 6 - BAZE DE DATE 66\n\n\nSfaturi în utilizarea subinterogarilor\n1. Includerea subinterogarilor în paranteze\n2. Plasarea subinterogarilor în partea dreapta a \noperatorului de comparare\n3. A nu se adauga clauza ORDER BY într-o \nsubinterogare\n4. Folosirea operatorilor single-row în subinterogari \nsingle-row\n5. Folosirea operatorilor multiple-row în \nsubinterogari multiple-row\nCurs 6 - BAZE DE DATE 67', '\n', '9. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '10. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n']","clauza SQL care filtrează rândurile dintr-o interogare este `WHERE`. Aceasta este specificată în sintaxa unei interogări `SELECT` astfel:

```sql
SELECT [DISTINCT] lista_de_expresii
FROM nume_tabela
WHERE conditie_linie
ORDER BY criterii_sortare_rezultat;
```
`WHERE` este optionala.
",Cu ce clauză SQL se filtrează rândurile dintr-o interogare?,"['1. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '2. ', 'Curs 3 \nLimbajul SQL \n 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3\n\nSINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4\n\nEFECT\n Se parcurg rând pe rând liniile tabelei \nspecificate în clauza FROM.\n  Din fiecare linie continând date pentru care \nconditia aflata pe clauza WHERE este adevarata \nva rezulta o linie în rezultatul cererii. \n  În cazul în care WHERE lipseste, toate liniile \ntabelei FROM vor avea o linie corespondenta în \nrezultatul cererii.\n  Linia de rezultat este compusa pe baza listei \nde expresii aflata pe clauza SELECT.\n 5\n\nEFECT\n Daca exista cuvântul cheie DISTINCT, din \nrezultat se elimina liniile duplicat.\n  Înainte de a trimite rezultatul, serverul îl \nsorteaza în functie de criteriile specificate de \nclauza ORDER BY.\n  În cazul în care ORDER BY lipseste, liniile din \nrezultat sunt într-o ordine independenta de \ncontinutul lor sau de ordinea în care ele au fost \nadaugate în tabela.\n 6\n\nREZULTAT\n Numarul coloanelor din rezultat este egal cu \nnumarul expresiilor din lista aflata pe clauza \nSELECT. \n  Aceste expresii dau si numele coloanelor din \nrezultat.\n  În lipsa clauzei DISTINCT, numarul de linii din \nrezultat este egal cu numarul liniilor din tabela \ncare îndeplinesc conditia WHERE sau, când \nclauza respectiva lipseste, cu numarul total de \nlinii din tabela.\n 7\n\nREZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 9\n\nExemple\nConsiderăm următoarele tabele:\n1. STUDENT având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n10\n\nTabela STUDENT\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1003 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1001 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n11\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n12', '\n', '3. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '4. ', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68\n\nÎntrebări?\nCurs 6 - BAZE DE DATE 69', '\n', '5. ', 'Clauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \n 68\n\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 69\n\nClauza ORDER BY\n➢În mod normal (fără clauza ORDER BY) rândurile sunt \nreturnate într-o ordine convenită de Oracle însă ea \nfiind consistentă de la cerere la cerere. \n➢Cu ajutorul clauzei ORDER BY rândurile vor fi afişate în \nordinea solicitată (cu toate acestea nu se va modifica \nordinea internă a rândurilor din baza de date).\n➢Clauza ORDER BY trebuie să fie ultima clauză din cerere \n(interogare).\n 70\n\nClauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine crescătoare).\nSELECT * \nFROM EMP\nORDER BY hiredata; \n 72\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare (în ordine crescătoare).\n 73\n\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine descrescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate DESC;\n 74\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă data de angajare (în ordine descrescătoare). \n 75\n\n\nClauza ORDER BY\n➢Mai putem ordona randurile returnate cu ajutorul \nalias-urilor.\nExemplu: \nListati toti angajatii ordonandu-i dupa salariul anual: \nsal*12 salariuanual (in ordine crescatoare). \nSELECT ename, job, sal*12 SALARIU_ANUAL\nFROM EMP\nORDER BY SALARIU_ANUAL;\n 76\n\nClauza ORDER BY\nRezultatul obtinut - Listati toti angajatii ordonandu-i dupa salariul \nanual: sal*12 salariuanual (in ordine crescatoare). \n 77\n\n\nClauza ORDER BY\n➢ Rândurile mai pot fi ordonate şi după mai multe coloane. \n➢ Numărul de coloane după care se pot ordona rândurile \nîntoarse este numărul maxim de coloane existente în tabelă. \nExemplu \n Listaţi toţi angajaţii ordonându-i după data de angajare, \nsalariu şi comision (în ordine crescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate, sal, comm; \n 78\n\nClauza ORDER BY\n➢ Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare, salariu şi comision (în ordine crescătoare). \n 79\n\n\nClauza ORDER BY\n➢În clauza ORDER BY se pot folosi coloane care nu sunt \nconţinute în SELECT.\n \nExemplu: \n  Listaţi toţi angajaţii ordonându-i după salariu (în \nordine crescătoare).\nSELECT ename, job\nFROM EMP\nORDER BY sal;  \n 80\n\nClauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82', '\n', '6. ', 'Clauza WHERE\nRezultatul obtinut - Dar ordinea se poate modifica \ndacă se folosesc paranteze. \n 68\n\n\nLimbajul SQL\nCereri SELECT pe o tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 69\n\nClauza ORDER BY\n➢În mod normal (fără clauza ORDER BY) rândurile sunt \nreturnate într-o ordine convenită de Oracle însă ea \nfiind consistentă de la cerere la cerere. \n➢Cu ajutorul clauzei ORDER BY rândurile vor fi afişate în \nordinea solicitată (cu toate acestea nu se va modifica \nordinea internă a rândurilor din baza de date).\n➢Clauza ORDER BY trebuie să fie ultima clauză din cerere \n(interogare).\n 70\n\nClauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine crescătoare).\nSELECT * \nFROM EMP\nORDER BY hiredata; \n 72\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare (în ordine crescătoare).\n 73\n\n\nClauza ORDER BY\nExemplu:\nListaţi toţi angajaţii ordonându-i după data de \nangajare (în ordine descrescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate DESC;\n 74\n\n\nClauza ORDER BY\nRezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă data de angajare (în ordine descrescătoare). \n 75\n\n\nClauza ORDER BY\n➢Mai putem ordona randurile returnate cu ajutorul \nalias-urilor.\nExemplu: \nListati toti angajatii ordonandu-i dupa salariul anual: \nsal*12 salariuanual (in ordine crescatoare). \nSELECT ename, job, sal*12 SALARIU_ANUAL\nFROM EMP\nORDER BY SALARIU_ANUAL;\n 76\n\nClauza ORDER BY\nRezultatul obtinut - Listati toti angajatii ordonandu-i dupa salariul \nanual: sal*12 salariuanual (in ordine crescatoare). \n 77\n\n\nClauza ORDER BY\n➢ Rândurile mai pot fi ordonate şi după mai multe coloane. \n➢ Numărul de coloane după care se pot ordona rândurile \nîntoarse este numărul maxim de coloane existente în tabelă. \nExemplu \n Listaţi toţi angajaţii ordonându-i după data de angajare, \nsalariu şi comision (în ordine crescătoare). \nSELECT * \nFROM EMP\nORDER BY hiredate, sal, comm; \n 78\n\nClauza ORDER BY\n➢ Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i după \ndata de angajare, salariu şi comision (în ordine crescătoare). \n 79\n\n\nClauza ORDER BY\n➢În clauza ORDER BY se pot folosi coloane care nu sunt \nconţinute în SELECT.\n \nExemplu: \n  Listaţi toţi angajaţii ordonându-i după salariu (în \nordine crescătoare).\nSELECT ename, job\nFROM EMP\nORDER BY sal;  \n 80\n\nClauza ORDER BY\n➢Rezultatul obtinut - Listaţi toţi angajaţii ordonându-i \ndupă salariu (în ordine crescătoare).\n 81\n\n\nExercitii\nSe considera tabela EMP avand urmatoarea structura:\nsi avand urmatoarele valori introduse: \n 82', '\n', '7. ', 'Numarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55\n\n\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56\n\nExemplu \n Gasiti angajatii care au un salariu superior \nsalariului mediu al departamentului lor.\nSELECT ename, sal, deptno\nFROM EMP E\nWHERE sal >\n            ( SELECT AVG(sal)\n             FROM EMP\n             WHERE ( deptno = E.deptno ) )\nORDER BY deptno;\nCurs 6 - BAZE DE DATE 57\n\nExemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n\n\nValori de NULL intr-o subinterogare \n• In cazul in care subinterogarea returneaza \nvreuna din valori NULL si interogarea \nprincipala are operator NOT IN, atunci \ninterogarea principala nu va returna niciun \nrand. \n• Motivul este ca o comparatie cu NULL conduce \nla un rezultat NULL. \nCurs 6 - BAZE DE DATE 59\n\nExemplu \nGasiti angajatii care nu au subordonati. \nSELECT ename \nFROM EMP \nWHERE empno NOT IN\n                    ( SELECT mgr\n                         FROM EMP );\nCurs 6 - BAZE DE DATE 60\n\nExemplu \nGasiti angajatii care nu au \nsubordonati. \nCurs 6 - BAZE DE DATE 61\n\n\n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN. \n• De fapt operatorul NOT IN este echivalent cu <> ALL.\n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL). \nCurs 6 - BAZE DE DATE 62\n\nExemplu\nGasiti angajatii care au subordonati.\nSELECT ename\nFROM EMP \nWHERE empno IN\n               ( SELECT mgr\n                  FROM EMP );\nCurs 6 - BAZE DE DATE 63\n\nExemplu \nGasiti angajatii care au \nsubordonati.\nCurs 6 - BAZE DE DATE 64\n\n\n• In cazul utilizarii operatorului NOT IN in interogarea \nprincipala trebuie avut grija sa se excluda valorile NULL\ndin raspunsurile subcererii.\nExemplu \nGasiti angajatii care nu au subordonati. \nCurs 6 - BAZE DE DATE 65\n\nSELECT ename \n  FROM EMP \n  WHERE empno NOT IN\n                  ( SELECT mgr\n                    FROM EMP\n                    WHERE mgr IS NOT NULL );\nCurs 6 - BAZE DE DATE 66\n\n\nSfaturi în utilizarea subinterogarilor\n1. Includerea subinterogarilor în paranteze\n2. Plasarea subinterogarilor în partea dreapta a \noperatorului de comparare\n3. A nu se adauga clauza ORDER BY într-o \nsubinterogare\n4. Folosirea operatorilor single-row în subinterogari \nsingle-row\n5. Folosirea operatorilor multiple-row în \nsubinterogari multiple-row\nCurs 6 - BAZE DE DATE 67', '\n', '8. ', 'Numarul maxim de \nimbricari pentru o \nsubinterogare este \nde 255.\nCurs 6 - BAZE DE DATE 55\n\n\nSubcereri corelate \n• O subinterogare corelata este o subinterogare \ncare se executa o data pentru fiecare linie \nconsiderata de interogarea principala si care la \nexecutie foloseste o valoare dintr-o coloana \ndin interogarea exterioara.\n• Ea se poate identifica prin folosirea unei \ncoloane a interogarii exterioare in clauza \noperatorului interogarii interioare. \nCurs 6 - BAZE DE DATE 56\n\nExemplu \n Gasiti angajatii care au un salariu superior \nsalariului mediu al departamentului lor.\nSELECT ename, sal, deptno\nFROM EMP E\nWHERE sal >\n            ( SELECT AVG(sal)\n             FROM EMP\n             WHERE ( deptno = E.deptno ) )\nORDER BY deptno;\nCurs 6 - BAZE DE DATE 57\n\nExemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n\n\nValori de NULL intr-o subinterogare \n• In cazul in care subinterogarea returneaza \nvreuna din valori NULL si interogarea \nprincipala are operator NOT IN, atunci \ninterogarea principala nu va returna niciun \nrand. \n• Motivul este ca o comparatie cu NULL conduce \nla un rezultat NULL. \nCurs 6 - BAZE DE DATE 59\n\nExemplu \nGasiti angajatii care nu au subordonati. \nSELECT ename \nFROM EMP \nWHERE empno NOT IN\n                    ( SELECT mgr\n                         FROM EMP );\nCurs 6 - BAZE DE DATE 60\n\nExemplu \nGasiti angajatii care nu au \nsubordonati. \nCurs 6 - BAZE DE DATE 61\n\n\n• Astfel ori de cate ori valoarea NULL face parte din \nraspunsurile subcererii nu trebuie folosit operatorul \nNOT IN. \n• De fapt operatorul NOT IN este echivalent cu <> ALL.\n• Returnarea de valori NULL de catre subinterogare nu \nprezinta nici o problema in cazul operatorului IN in \ninterogarea principala (in echivalent cu = ALL). \nCurs 6 - BAZE DE DATE 62\n\nExemplu\nGasiti angajatii care au subordonati.\nSELECT ename\nFROM EMP \nWHERE empno IN\n               ( SELECT mgr\n                  FROM EMP );\nCurs 6 - BAZE DE DATE 63\n\nExemplu \nGasiti angajatii care au \nsubordonati.\nCurs 6 - BAZE DE DATE 64\n\n\n• In cazul utilizarii operatorului NOT IN in interogarea \nprincipala trebuie avut grija sa se excluda valorile NULL\ndin raspunsurile subcererii.\nExemplu \nGasiti angajatii care nu au subordonati. \nCurs 6 - BAZE DE DATE 65\n\nSELECT ename \n  FROM EMP \n  WHERE empno NOT IN\n                  ( SELECT mgr\n                    FROM EMP\n                    WHERE mgr IS NOT NULL );\nCurs 6 - BAZE DE DATE 66\n\n\nSfaturi în utilizarea subinterogarilor\n1. Includerea subinterogarilor în paranteze\n2. Plasarea subinterogarilor în partea dreapta a \noperatorului de comparare\n3. A nu se adauga clauza ORDER BY într-o \nsubinterogare\n4. Folosirea operatorilor single-row în subinterogari \nsingle-row\n5. Folosirea operatorilor multiple-row în \nsubinterogari multiple-row\nCurs 6 - BAZE DE DATE 67', '\n', '9. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '10. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n']","clauza SQL care filtrează rândurile dintr-o interogare este `WHERE`. Aceasta este specificată în sintaxa unei interogări `SELECT` astfel:

```sql
SELECT [DISTINCT] lista_de_expresii
FROM nume_tabela
WHERE conditie_linie
ORDER BY criterii_sortare_rezultat;
```
`WHERE` este optionala.
",WHERE,0.33739495797475844,1.0,0.9348793128518508,1.0,0.03747776736677921,0.047619047619047616,0.5
3,O3mini-high,LOW,C4,,Ce funcție SQL transformă șirurile de caractere în majuscule?,UPPER,Este corect,,"['1. ', ""Rezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = 'MARTIN';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 23\n4.2.1. Funcţii pentru şiruri de caractere\n\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 25\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER.\nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename)\nFROM EMP; \nCurs 4 - BAZE DE DATE 26\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 27\n4.2.1. Funcţii pentru şiruri de caractere\n\n➢Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime. \n➢Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior. \n➢Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea: \nCurs 4 - BAZE DE DATE 28\n4.2.1. Funcţii pentru şiruri de caractere\n\nSELECT ename, LENGTH (ename) - LENGTH (TRANSLATE(ename, 'DA', \n'D')) \nFROM EMP;\nCurs 4 - BAZE DE DATE 29\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 30\n4.2.1. Funcţii pentru şiruri de caractere\n\nExplicatii:\nÎn exemplul anterior, funcţia TRANSLATE (nume, 'DA', 'D') va \ncăuta în coloana “nume” primul caracter (caracterul 'D') din cel \nde-al doilea argument al funcţiei (şirul de caractere 'DA') şi îl va \nînlocui cu primul caracter (adică tot cu caracterul 'D') din cel de-al \ntreilea argument al funcţiei (şirul de caractere 'D'), apoi va căuta \ncel de-al doilea caracter, adică caracterul 'A', şi îl va şterge din \ncâmpul nume deoarece acesta nu are caracter corespondent în \ncel de-al treilea argument al funcţiei. \n  Am folosit acest artificiu deoarece şirul de caractere vid este \nechivalent cu valoarea Null, deci funcţia TRANSLATE (nume, 'A', ' \n') ar fi înlocuit toate valorile câmpului “nume” cu valoarea Null.\nCurs 4 - BAZE DE DATE 31\n4.2.1. Funcţii pentru şiruri de caractere\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 32\n\nAceste funcţii au ca argumente date de tip \nNUMBER şi returnează date de tip numeric.\nCurs 4 - BAZE DE DATE 33\n4.2.2. Funcţii de tip numeric"", '\n', '2. ', ""Rezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = 'MARTIN';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 23\n4.2.1. Funcţii pentru şiruri de caractere\n\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 25\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER.\nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename)\nFROM EMP; \nCurs 4 - BAZE DE DATE 26\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 27\n4.2.1. Funcţii pentru şiruri de caractere\n\n➢Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime. \n➢Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior. \n➢Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea: \nCurs 4 - BAZE DE DATE 28\n4.2.1. Funcţii pentru şiruri de caractere\n\nSELECT ename, LENGTH (ename) - LENGTH (TRANSLATE(ename, 'DA', \n'D')) \nFROM EMP;\nCurs 4 - BAZE DE DATE 29\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 30\n4.2.1. Funcţii pentru şiruri de caractere\n\nExplicatii:\nÎn exemplul anterior, funcţia TRANSLATE (nume, 'DA', 'D') va \ncăuta în coloana “nume” primul caracter (caracterul 'D') din cel \nde-al doilea argument al funcţiei (şirul de caractere 'DA') şi îl va \nînlocui cu primul caracter (adică tot cu caracterul 'D') din cel de-al \ntreilea argument al funcţiei (şirul de caractere 'D'), apoi va căuta \ncel de-al doilea caracter, adică caracterul 'A', şi îl va şterge din \ncâmpul nume deoarece acesta nu are caracter corespondent în \ncel de-al treilea argument al funcţiei. \n  Am folosit acest artificiu deoarece şirul de caractere vid este \nechivalent cu valoarea Null, deci funcţia TRANSLATE (nume, 'A', ' \n') ar fi înlocuit toate valorile câmpului “nume” cu valoarea Null.\nCurs 4 - BAZE DE DATE 31\n4.2.1. Funcţii pentru şiruri de caractere\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 32\n\nAceste funcţii au ca argumente date de tip \nNUMBER şi returnează date de tip numeric.\nCurs 4 - BAZE DE DATE 33\n4.2.2. Funcţii de tip numeric"", '\n', '3. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '4. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '5. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '6. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '7. ', 'Curs 5 \nLimbajul SQL \nCurs 5 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea III)\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 3\n\nTabele EMP si DEPT\nPentru exemplele din cursuri vom folosi tabela EMP:\nCurs 5 - BAZE DE DATE 4\nStructura tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 5\nPentru exemplele din cursuri vom folosi tabela EMP:\nContinutul initial al tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 6\nStructura tabelei DEPT.\nContinutul initial al tabelei DEPT.\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7\n\nFuncţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. funcţii caracter\n2. funcţii numerice\n3. funcţii pentru data calendaristică si oră\n4. funcţii de conversie\n5. funcţii diverse\nCurs 5 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• funcţii totalizatoare sau funcţii de grup\nCurs 5 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13\n\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', '\n', '8. ', 'Curs 5 \nLimbajul SQL \nCurs 5 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea III)\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 3\n\nTabele EMP si DEPT\nPentru exemplele din cursuri vom folosi tabela EMP:\nCurs 5 - BAZE DE DATE 4\nStructura tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 5\nPentru exemplele din cursuri vom folosi tabela EMP:\nContinutul initial al tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 6\nStructura tabelei DEPT.\nContinutul initial al tabelei DEPT.\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7\n\nFuncţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. funcţii caracter\n2. funcţii numerice\n3. funcţii pentru data calendaristică si oră\n4. funcţii de conversie\n5. funcţii diverse\nCurs 5 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• funcţii totalizatoare sau funcţii de grup\nCurs 5 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13\n\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', '\n', '9. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '10. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n']","funcția SQL care transformă șirurile de caractere în majuscule este `UPPER`.
",Ce funcție SQL transformă șirurile de caractere în majuscule?,"['1. ', ""Rezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = 'MARTIN';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 23\n4.2.1. Funcţii pentru şiruri de caractere\n\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 25\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER.\nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename)\nFROM EMP; \nCurs 4 - BAZE DE DATE 26\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 27\n4.2.1. Funcţii pentru şiruri de caractere\n\n➢Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime. \n➢Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior. \n➢Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea: \nCurs 4 - BAZE DE DATE 28\n4.2.1. Funcţii pentru şiruri de caractere\n\nSELECT ename, LENGTH (ename) - LENGTH (TRANSLATE(ename, 'DA', \n'D')) \nFROM EMP;\nCurs 4 - BAZE DE DATE 29\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 30\n4.2.1. Funcţii pentru şiruri de caractere\n\nExplicatii:\nÎn exemplul anterior, funcţia TRANSLATE (nume, 'DA', 'D') va \ncăuta în coloana “nume” primul caracter (caracterul 'D') din cel \nde-al doilea argument al funcţiei (şirul de caractere 'DA') şi îl va \nînlocui cu primul caracter (adică tot cu caracterul 'D') din cel de-al \ntreilea argument al funcţiei (şirul de caractere 'D'), apoi va căuta \ncel de-al doilea caracter, adică caracterul 'A', şi îl va şterge din \ncâmpul nume deoarece acesta nu are caracter corespondent în \ncel de-al treilea argument al funcţiei. \n  Am folosit acest artificiu deoarece şirul de caractere vid este \nechivalent cu valoarea Null, deci funcţia TRANSLATE (nume, 'A', ' \n') ar fi înlocuit toate valorile câmpului “nume” cu valoarea Null.\nCurs 4 - BAZE DE DATE 31\n4.2.1. Funcţii pentru şiruri de caractere\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 32\n\nAceste funcţii au ca argumente date de tip \nNUMBER şi returnează date de tip numeric.\nCurs 4 - BAZE DE DATE 33\n4.2.2. Funcţii de tip numeric"", '\n', '2. ', ""Rezultat obtinut: \nCurs 4 - BAZE DE DATE 21\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE ename = 'MARTIN';\n \nCurs 4 - BAZE DE DATE 22\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultat obtinut: \nCurs 4 - BAZE DE DATE 23\n4.2.1. Funcţii pentru şiruri de caractere\n\nClauza WHERE a acestei cereri SQL compară\nnumele din tabela Angajaţi cu 'Smith'. \n  Pentru comparaţie numele sunt convertite în \nlitere mici şi din această cauză se obţine un rezultat.\nExemplu:\nSELECT empno, UPPER(ename), job, deptno\nFROM EMP\nWHERE INITCAP(ename) = 'Smith';\nCurs 4 - BAZE DE DATE 24\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 25\n4.2.1. Funcţii pentru şiruri de caractere\n\nExemplu:\n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER.\nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename)\nFROM EMP; \nCurs 4 - BAZE DE DATE 26\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 27\n4.2.1. Funcţii pentru şiruri de caractere\n\n➢Spre deosebire de alte funcţii, funcţiile \ncaracter pot fi imbricate până la orice \nadâncime. \n➢Dacă funcţiile sunt imbricate, atunci ele sunt \nevaluate din interior spre exterior. \n➢Pentru a determina, de exemplu, de câte ori \napare caracterul 'A' în câmpul ename vom \nfolosi interogarea: \nCurs 4 - BAZE DE DATE 28\n4.2.1. Funcţii pentru şiruri de caractere\n\nSELECT ename, LENGTH (ename) - LENGTH (TRANSLATE(ename, 'DA', \n'D')) \nFROM EMP;\nCurs 4 - BAZE DE DATE 29\n4.2.1. Funcţii pentru şiruri de caractere\n\nRezultatul obtinut:\nCurs 4 - BAZE DE DATE 30\n4.2.1. Funcţii pentru şiruri de caractere\n\nExplicatii:\nÎn exemplul anterior, funcţia TRANSLATE (nume, 'DA', 'D') va \ncăuta în coloana “nume” primul caracter (caracterul 'D') din cel \nde-al doilea argument al funcţiei (şirul de caractere 'DA') şi îl va \nînlocui cu primul caracter (adică tot cu caracterul 'D') din cel de-al \ntreilea argument al funcţiei (şirul de caractere 'D'), apoi va căuta \ncel de-al doilea caracter, adică caracterul 'A', şi îl va şterge din \ncâmpul nume deoarece acesta nu are caracter corespondent în \ncel de-al treilea argument al funcţiei. \n  Am folosit acest artificiu deoarece şirul de caractere vid este \nechivalent cu valoarea Null, deci funcţia TRANSLATE (nume, 'A', ' \n') ar fi înlocuit toate valorile câmpului “nume” cu valoarea Null.\nCurs 4 - BAZE DE DATE 31\n4.2.1. Funcţii pentru şiruri de caractere\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.2. Funcţii referitoare la o singură înregistrare\n 4.2.1. Funcţii pentru şiruri de caractere\n 4.2.2. Funcţii de tip numeric\n4.2.3. Funcţii de tip dată calendaristică şi oră\n 4.2.4. Funcţii de conversie dintr-un tip în altul\n 4.2.5. Funcţii generale\n  4.2.6. Funcţii condiţionale\nCurs 4 - BAZE DE DATE 32\n\nAceste funcţii au ca argumente date de tip \nNUMBER şi returnează date de tip numeric.\nCurs 4 - BAZE DE DATE 33\n4.2.2. Funcţii de tip numeric"", '\n', '3. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '4. ', '2.6. Elemente ale limbajului SQL\nd) Variabile\n  Variabilele sunt date care pot avea în timp valori \ndiferite. \n  O variabilă are întotdeauna un nume pentru a \nputea fi referită.\n SQL acceptă două tipuri de variabile:\n1. variabilele asociate numelor coloanelor asociate\n2. variabile sistem\n70\n\n2.6. Elemente ale limbajului SQL\ne) Expresii\n  O expresie este formată din variabile, constante, \noperatori şi funcţii. \n  Operatorii care pot fi utilizaţi sunt împărţiţi astfel:\n1. Operatori aritmetici\n2. Operatori alfanumerici\n3. Operatori de comparatie\n4. Operatori logici\n71\n\n2.6. Elemente ale limbajului SQL\nCu ajutorul comenzii SELECT se pot realiza \nurmătoarele tipuri de operaţii:\n1. Selecţia – constă în filtrarea liniilor care vor fi afişate\n2. Proiecţia – constă în alegerea doar a anumitor coloane \npentru a fi afişate\n3. Join – constă în preluarea datelor din două sau mai \nmulte tabele “legate” conform unor reguli precizate\n72\n\n2.6. Elemente ale limbajului SQL\nOperaţiile realizate cu ajutorul comenzii SELECT\n73\n\nExemple\nConsiderăm următoarele tabele:\n1. STUD având structura MATR, NUME, AN, GRUPA, \nDATAN, LOC, INDRUMATOR, PUNCTAJ, CODS\n2. SPECIALIZARE având structura CODS, NUME, DOMENIU\n3. BURSA având structura TIP, PMIN, PMAX, SUMA\n74\n\nTabela STUD\nMATR NUME AN GRUPA DATAN LOC INDRUMATOR PUNCTAJ CODS\n1234 POPA MARCEL 1 114A 12-03-87 BUC 1001 2345 1\n1235 POPESCU ION 2 121B 02-04-89 TARGU-\nJIU 1001 1300 1\n1236 AVRAM NICOLAE 1 115A 21-03-68 TARGU-\nJIU 1002 3000 2\n1237 IONESCU MARIANA 2 116C 05-05-89 BUC 1003 1234 3\n1256 POPESCU GINA 3 114A 06-09-90 TARGU-\nJIU 1002 3456 2\n75\n\nTabelele SPECIALIZARE si BURSA\nCODS NUME DOMENIU\n1 AUTOMATICA CALCULATOARE\n2 ENERGETICA INGINERIE ELECTRICA\n3 MECANICA INGINERIE MECANICA\nTip Pmin Pmax Suma\nFara bursa 0 399\nBursa sociala 400 899 100\nBursa de studiu 900 1799 150\nBursa de merit 1800 2499 200\nBursa de exceptie 2500 3999 300\n76\n\nÎntrebări?\n77', '\n', '5. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '6. ', ""Baze de date\nAdrian Runceanu\nLimbajul SQL\nUCB: Universitatea Constantin Brâncuși din Târgu-Jiu\nAutomatică și Informatică Aplicată\n\nCurs 7\nLimbajul SQL \nCurs 7 - BAZE DE DATE 2\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD)\n1.1. Adăugare o nouă înregistrare\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 3\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4\n\n7.1. Limbajul de manipulare al datelor \n(LMD)\nÎn acest curs ne ocupăm de limbajul de \nmanipulare al datelor (DML) care ne permite:\n1. să adăugăm\n2. să modificăm \n3. sau să distrugem datele din baza de date \nOracle 12c conţine următoarele funcţii: \n1. INSERT\n2. UPDATE \n3. DELETE \n4. MERGE\nCurs 7 - BAZE DE DATE 5\n\nLimbajul SQL\nCapitolul 7\n1. Limbajul de manipulare al datelor (LMD) \n1.1. Adăugarea unei noi înregistrari\n1.2. Actualizarea datelor dintr-o tabelă \n1.3. Ştergerea tuplurilor dintr-o tabelă\n1.4. Instrucţiunea Merge\n2. Limbajul de control al datelor (LCD). Tranzacţii\nCurs 7 - BAZE DE DATE 6\n\n7.1.1. Adăugare o nouă \nînregistrare\ntabela – numele tabelei \ncoloana – numele coloanei din tabela \nvaloare – valoarea corespunzătoare coloanei \nNotă: Se poate adăuga o singură linie o dată. \nSintaxa este: \nINSERT INTO tabela [ ( coloana [ , coloana . . . ])] \nVALUES ( valoare [, valoare . . . ]); \nCurs 7 - BAZE DE DATE 7\n\n7.1.1. Adăugare o nouă \nînregistrare\nExemplu - Să se introducă un nou oras în tabela DEPT:\nINSERT INTO dept (deptno, dname, loc)\nVALUES (70,'FINANCIAR','Bucuresti');\nCurs 7 - BAZE DE DATE 8\n\n7.1.1. Adăugare o nouă \nînregistrare\nCurs 7 - BAZE DE DATE 9\n\n\n7.1.1. Adăugare o nouă \nînregistrare\n• Deoarece se poate insera o nouă linie ce conţine valori \npentru fiecare coloană, lista coloanelor nu mai este \nnecesară în clauza INSERT. \n• Totuşi dacă nu utilizăm lista de coloane, valorile trebuie \nsă fie listate în ordinea coloanelor din tabelă, iar o \nvaloare trebuie utilizată pentru fiecare coloană. \n• Pentru o utilizare mai uşoară putem folosi comanda \nDESCRIBE dept, care ne afişează câmpurile tabelei în \nordinea lor, precum şi tipul fiecărui câmp.\nCurs 7 - BAZE DE DATE 10\n\n7.1.1. Adăugare o nouă \nînregistrare\nInserarea linilor ce conţin valori NULL\nInserarea liniilor ce conţin valori NULL se poate \nface prin două metode: \n1. metoda implicită: Omiterea unui câmp din lista \ncâmpurilor existente în tabela respectivă. \nINSERT INTO dept (deptno, loc)\nVALUES (70, 'Bucuresti'); Campul DNAME a \nfost omis din lista\nCurs 7 - BAZE DE DATE 11"", '\n', '7. ', 'Curs 5 \nLimbajul SQL \nCurs 5 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea III)\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 3\n\nTabele EMP si DEPT\nPentru exemplele din cursuri vom folosi tabela EMP:\nCurs 5 - BAZE DE DATE 4\nStructura tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 5\nPentru exemplele din cursuri vom folosi tabela EMP:\nContinutul initial al tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 6\nStructura tabelei DEPT.\nContinutul initial al tabelei DEPT.\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7\n\nFuncţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. funcţii caracter\n2. funcţii numerice\n3. funcţii pentru data calendaristică si oră\n4. funcţii de conversie\n5. funcţii diverse\nCurs 5 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• funcţii totalizatoare sau funcţii de grup\nCurs 5 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13\n\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', '\n', '8. ', 'Curs 5 \nLimbajul SQL \nCurs 5 - BAZE DE DATE 2\n\nLimbajul SQL\nInterogări SELECT pe o singură tabelă (partea III)\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 3\n\nTabele EMP si DEPT\nPentru exemplele din cursuri vom folosi tabela EMP:\nCurs 5 - BAZE DE DATE 4\nStructura tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 5\nPentru exemplele din cursuri vom folosi tabela EMP:\nContinutul initial al tabelei EMP.\n\nTabele EMP si DEPT\nCurs 5 - BAZE DE DATE 6\nStructura tabelei DEPT.\nContinutul initial al tabelei DEPT.\n\nFuncţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7\n\nFuncţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8\n\nFuncţii\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions):\n1. funcţii caracter\n2. funcţii numerice\n3. funcţii pentru data calendaristică si oră\n4. funcţii de conversie\n5. funcţii diverse\nCurs 5 - BAZE DE DATE 9\n\nFuncţii\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions):\n• funcţii totalizatoare sau funcţii de grup\nCurs 5 - BAZE DE DATE 10\n\nFuncţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11\n\nFuncţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12\n\nLimbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13\n\n4.3. Funcții de grup\nFuncţiile de grup sunt funcţii care operează pe \nun set de rânduri pentru a da un rezultat pe întreg\nsetul.\nParametrii şi descrierea funcţiilor de grup. \nFuncţiile de grup sunt: \n1. AVG \n2. COUNT \n3. MAX \n4. MIN \n5. STDDEV \n6. SUM \n7. VARIANCE\nCurs 5 - BAZE DE DATE 14', '\n', '9. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n', '10. ', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63\n\nLimbajul SQL\n4. Limbajul de control al tranzacţiilor (LCT)\nComenzile utilizate sunt:\n1. COMMIT – pentru ca modificările efectuate asupra \nbazei de date să devină permanente\n2. ROLLBACK – permite renuţarea la ultimele \nmodificări asupra bazei de date\n3. SAVEPOINT – pentru definirea unui “punct de \nsalvare” la care se poate reveni, renunţând la \nmodificările făcute după acest punct asupra bazei \nde date\n64\n\nLimbajul SQL\n5. Limbajul de control al datelor (LCD) permite definirea \nşi modificarea drepturilor asupra bazelor de date. \nComenzile utilizate sunt:\n1. GRANT – pentru acordarea unor drepturi altor \nutilizatori asupra bazei de date\n2. REVOKE – pentru anularea unor anumite drepturi \nale utilizatorilor\n65\n\n2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66\n\n2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67\n\n2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68\n\n2.6. Elemente ale limbajului SQL\nExistă:\n1. Constante numerice, de exemplu 4, 12.34, .9, etc. \n– Se observă că dacă un număr real are partea \nîntreagă egală cu zero, atunci ea nu mai trebuie \nprecizată.\n2. Constante alfanumerice (sau şir de caractere)\n– Constantele şir de caractere sunt scrise între \napostrofuri şi sunt case-sensitive. \n– Exemple: ‘abc’, ‘baza de date’.\n69', '\n']","funcția SQL care transformă șirurile de caractere în majuscule este `UPPER`.
",UPPER,0.4499999999775,1.0,0.8725126228363279,1.0,0.028398387225677894,0.15384615384615385,0.67
