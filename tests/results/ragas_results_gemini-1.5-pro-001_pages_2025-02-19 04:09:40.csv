,initial_Generator,initial_Dificultate,initial_Capitole Principale,initial_Capitole Asociate,initial_user_input,initial_reference,initial_Evaluare Professor,initial_Unde se afla raspunsul,initial_retrieved_contexts,initial_response,user_input,retrieved_contexts,response,reference,context_precision,context_recall,answer_relevancy,faithfulness,bleu_score,rouge_score,factual_correctness
0,O3mini-high,LOW,C1,,"În contextul noțiunilor introductive, ce model de organizare a datelor este prezentat ca predominant în curs?",relațional,Este corect,,"['1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.5. Modelul de date ierarhic\n✓În modelul de date ierarhic (Hierarchical Model) o \nbază de date se reprezintă printr-o structură ierarhică \nde înregistrări de date (records) conectate prin \nlegături (links).\n✓Modelul ierarhic a fost primul model folosit pentru \ndezvoltatea bazelor de date.\n✓Schema conceptuală a unei baze de date în modelul \nierarhic se reprezintă printr-un număr oarecare de \nscheme ierarhice.\n 61', '1.5. Modelul de date ierarhic\n✓În modelul de date ierarhic (Hierarchical Model) o \nbază de date se reprezintă printr-o structură ierarhică \nde înregistrări de date (records) conectate prin \nlegături (links).\n✓Modelul ierarhic a fost primul model folosit pentru \ndezvoltatea bazelor de date.\n✓Schema conceptuală a unei baze de date în modelul \nierarhic se reprezintă printr-un număr oarecare de \nscheme ierarhice.\n 61', '1.5. Modelul de date ierarhic\n✓În modelul de date ierarhic (Hierarchical Model) o \nbază de date se reprezintă printr-o structură ierarhică \nde înregistrări de date (records) conectate prin \nlegături (links).\n✓Modelul ierarhic a fost primul model folosit pentru \ndezvoltatea bazelor de date.\n✓Schema conceptuală a unei baze de date în modelul \nierarhic se reprezintă printr-un număr oarecare de \nscheme ierarhice.\n 61', '1.5. Modelul de date ierarhic\n✓În modelul de date ierarhic (Hierarchical Model) o \nbază de date se reprezintă printr-o structură ierarhică \nde înregistrări de date (records) conectate prin \nlegături (links).\n✓Modelul ierarhic a fost primul model folosit pentru \ndezvoltatea bazelor de date.\n✓Schema conceptuală a unei baze de date în modelul \nierarhic se reprezintă printr-un număr oarecare de \nscheme ierarhice.\n 61', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere ""]","Conform informațiilor din context, modelul de organizare a datelor prezentat ca predominant în curs este **modelul relațional**. 

Acest lucru este evident din următoarele fragmente:

* **""1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.""**
* **""Curs 13. Modelul relational de reprezentare a bazelor de date""** 
* **""Modelul relațional este o abordare a organizării datelor bazată pe tabele (relații)""**

Deși contextul menționează și modelul ierarhic, accentul cade pe modelul relațional, acesta fiind descris detaliat și considerat fundamental în cadrul cursului. 
","În contextul noțiunilor introductive, ce model de organizare a datelor este prezentat ca predominant în curs?","['1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.5. Modelul de date ierarhic\n✓În modelul de date ierarhic (Hierarchical Model) o \nbază de date se reprezintă printr-o structură ierarhică \nde înregistrări de date (records) conectate prin \nlegături (links).\n✓Modelul ierarhic a fost primul model folosit pentru \ndezvoltatea bazelor de date.\n✓Schema conceptuală a unei baze de date în modelul \nierarhic se reprezintă printr-un număr oarecare de \nscheme ierarhice.\n 61', '1.5. Modelul de date ierarhic\n✓În modelul de date ierarhic (Hierarchical Model) o \nbază de date se reprezintă printr-o structură ierarhică \nde înregistrări de date (records) conectate prin \nlegături (links).\n✓Modelul ierarhic a fost primul model folosit pentru \ndezvoltatea bazelor de date.\n✓Schema conceptuală a unei baze de date în modelul \nierarhic se reprezintă printr-un număr oarecare de \nscheme ierarhice.\n 61', '1.5. Modelul de date ierarhic\n✓În modelul de date ierarhic (Hierarchical Model) o \nbază de date se reprezintă printr-o structură ierarhică \nde înregistrări de date (records) conectate prin \nlegături (links).\n✓Modelul ierarhic a fost primul model folosit pentru \ndezvoltatea bazelor de date.\n✓Schema conceptuală a unei baze de date în modelul \nierarhic se reprezintă printr-un număr oarecare de \nscheme ierarhice.\n 61', '1.5. Modelul de date ierarhic\n✓În modelul de date ierarhic (Hierarchical Model) o \nbază de date se reprezintă printr-o structură ierarhică \nde înregistrări de date (records) conectate prin \nlegături (links).\n✓Modelul ierarhic a fost primul model folosit pentru \ndezvoltatea bazelor de date.\n✓Schema conceptuală a unei baze de date în modelul \nierarhic se reprezintă printr-un număr oarecare de \nscheme ierarhice.\n 61', ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere ""]","Conform informațiilor din context, modelul de organizare a datelor prezentat ca predominant în curs este **modelul relațional**. 

Acest lucru este evident din următoarele fragmente:

* **""1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.""**
* **""Curs 13. Modelul relational de reprezentare a bazelor de date""** 
* **""Modelul relațional este o abordare a organizării datelor bazată pe tabele (relații)""**

Deși contextul menționează și modelul ierarhic, accentul cade pe modelul relațional, acesta fiind descris detaliat și considerat fundamental în cadrul cursului. 
",relațional,,,,,0.017272237992167868,0.0392156862745098,
1,O3mini-high,LOW,C2,,Ce limbaj integrat în Oracle este utilizat pentru scrierea procedurilor stocate?,PL/SQL,Este corect,,"['2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7', '2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38', '2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38', '2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38', '2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38', '2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26', '2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26']","Limbajul integrat în Oracle utilizat pentru scrierea procedurilor stocate este **PL/SQL** (limbaj procedural propriu). 
",Ce limbaj integrat în Oracle este utilizat pentru scrierea procedurilor stocate?,"['2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\nÎncepând cu versiunea 5.0 SGBD Oracle are \nurmătoarele facilităţi suplimentare: \n- funcţionează în arhitectura client/server\n- are limbaj procedural propriu PL/SQL\n- are precompilatoare ca interfaţă cu limbajele \nuniversale\n7', '2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38', '2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38', '2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38', '2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38', '2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26', '2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26']","Limbajul integrat în Oracle utilizat pentru scrierea procedurilor stocate este **PL/SQL** (limbaj procedural propriu). 
",PL/SQL,,,,,0.06429451441231725,0.23529411764705882,
2,O3mini-high,LOW,C3,,Cu ce clauză SQL se filtrează rândurile dintr-o interogare?,WHERE,Este corect,,"['Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68', 'Conţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\n 14\n', 'Conţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\n 14\n', 'Conţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\n 14\n', 'Conţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\n 14\n', '2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61', '2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61']","Conform textului, clauza SQL utilizată pentru a filtra rândurile dintr-o interogare este **WHERE**. 

Deși textul menționează că ""clauzele WHERE și HAVING folosesc rezultatele"" subinterogărilor, este important de reținut că **HAVING** filtrează rezultatele grupate (după o clauză GROUP BY), în timp ce **WHERE** filtrează rândurile înainte de grupare. 
",Cu ce clauză SQL se filtrează rândurile dintr-o interogare?,"['Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68', 'Conţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\n 14\n', 'Conţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\n 14\n', 'Conţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\n 14\n', 'Conţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\n 14\n', '2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61', '2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61']","Conform textului, clauza SQL utilizată pentru a filtra rândurile dintr-o interogare este **WHERE**. 

Deși textul menționează că ""clauzele WHERE și HAVING folosesc rezultatele"" subinterogărilor, este important de reținut că **HAVING** filtrează rezultatele grupate (după o clauză GROUP BY), în timp ce **WHERE** filtrează rândurile înainte de grupare. 
",WHERE,,,,,0.021476912089159056,0.03636363636363636,
3,O3mini-high,LOW,C4,,Ce funcție SQL transformă șirurile de caractere în majuscule?,UPPER,Este corect,,"['Funcţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7', 'Funcţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7', 'Funcţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7', 'Funcţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', 'Funcţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări(linii)\n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 4 - BAZE DE DATE 6', 'Funcţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări(linii)\n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 4 - BAZE DE DATE 6']","Deși textul furnizat menționează funcțiile SQL și scopul lor general, nu oferă informații specifice despre funcția care transformă șirurile de caractere în majuscule. 

Pentru a răspunde la întrebarea utilizatorului, funcția SQL care transformă șirurile de caractere în majuscule este **UPPER()**. 

Exemplu:

```sql
SELECT UPPER('exemplu de text');
```

Rezultat:

```
EXEMPLU DE TEXT
``` 
",Ce funcție SQL transformă șirurile de caractere în majuscule?,"['Funcţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7', 'Funcţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7', 'Funcţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7', 'Funcţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', 'Funcţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări(linii)\n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 4 - BAZE DE DATE 6', 'Funcţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări(linii)\n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 4 - BAZE DE DATE 6']","Deși textul furnizat menționează funcțiile SQL și scopul lor general, nu oferă informații specifice despre funcția care transformă șirurile de caractere în majuscule. 

Pentru a răspunde la întrebarea utilizatorului, funcția SQL care transformă șirurile de caractere în majuscule este **UPPER()**. 

Exemplu:

```sql
SELECT UPPER('exemplu de text');
```

Rezultat:

```
EXEMPLU DE TEXT
``` 
",UPPER,,,,,0.0,0.03389830508474576,
4,O3mini-high,LOW,C5,,Cu ce clauză se grupează înregistrările pentru a calcula valori agregate folosind funcțiile de grup?,GROUP BY,Este corect,,"['4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17', '4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17', '4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17', '4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17', '4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15', '4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15', '4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15', '4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15', 'Funcţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7', 'Funcţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7']","Înregistrările se grupează folosind clauza **GROUP BY**, urmată de numele coloanei pe baza căreia se face gruparea. 
",Cu ce clauză se grupează înregistrările pentru a calcula valori agregate folosind funcțiile de grup?,"['4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17', '4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17', '4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17', '4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17', '4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15', '4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15', '4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15', '4.3. Funcții de grup\nFunctia Descriere \nAVG([DISTINCT|ALL]n)  Valoarea medie pentru grup, \nignorand valorile nule  \nCOUNT({*|[DISTINCT|ALL]expr})  \nNumarul de randuri unde expr \nevalueaza altceva in afara de \nnull (folosind * sunt numarate \ntoate randurile, incluzand \nduplicatele si pe cele cu valoare \nnula)  \nMAX([DISTINCT|ALL]expr)  Valoarea maxima a expr, \nignorand valorile nule  \nMIN([DISTINCT|ALL]expr)  Valoarea minima a expr, \nignorand valorile nule  \nSTDDEV([DISTINCT|ALL]x)  Deviatia standard pentru grup, \nignorand valorile nule  \nSUM([DISTINCT|ALL]x)  Suma valorilor pentru grup, \nignorand valorile nule  \nVARIANCE([DISTINCT|ALL]x)  Variatia pentru grup, ignorand \nvalorile nule  \n \nFiecare dintre aceste funcţii acceptă anumiţi parametri: \nCurs 5 - BAZE DE DATE 15', 'Funcţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7', 'Funcţii\n Funcţiile sunt o caracteristică importantă a \nSQL si sunt utilizate pentru:\n✓a realiza calcule asupra datelor\n✓a modifica date\n✓a manipula grupuri de înregistrări \n✓a schimba formatul datelor \n✓sau pentru a converti diferite tipuri de date \nCurs 5 - BAZE DE DATE 7']","Înregistrările se grupează folosind clauza **GROUP BY**, urmată de numele coloanei pe baza căreia se face gruparea. 
",GROUP BY,,,,,0.03454447598433575,0.1904761904761905,
5,O3mini-high,LOW,C6,,Cum se numește subinterogarea care returnează o singură valoare pentru o condiție din clauza WHERE?,subinterogare single-row,Este corect,,"['6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30', 'Sintaxa conţine: \nO subcerere care întoarce elemente sortate şi \ncare conţine clauza ORDER BY. \nCa să avem cea mai mare valoare pe prima linie \nfolosim DESC. \nO cerere care selectează un anumit număr de \nlinii (N) ca rezultat final. Conţine: \n– ROWNUM care aloca o valoare începând de la 1 fiecărei \nlinii întoarse de subcerere.\n– WHERE care condiţionează numărul de linii întoarse\nCurs - BAZE DE DATE 51', 'Sintaxa conţine: \nO subcerere care întoarce elemente sortate şi \ncare conţine clauza ORDER BY. \nCa să avem cea mai mare valoare pe prima linie \nfolosim DESC. \nO cerere care selectează un anumit număr de \nlinii (N) ca rezultat final. Conţine: \n– ROWNUM care aloca o valoare începând de la 1 fiecărei \nlinii întoarse de subcerere.\n– WHERE care condiţionează numărul de linii întoarse\nCurs - BAZE DE DATE 51']","Informațiile din context nu oferă un răspuns la întrebarea ta. Contextul explică conceptul de subinterogări cu operatorul IN, care returnează o listă de valori, nu o singură valoare. 

Pentru a afla cum se numește o subinterogare ce returnează o singură valoare pentru o condiție WHERE, ar trebui să cauți informații despre **subinterogări scalare**. Acestea sunt subinterogări care returnează un singur rând și o singură coloană, putând fi utilizate în clauza WHERE asemeni unei valori. 
",Cum se numește subinterogarea care returnează o singură valoare pentru o condiție din clauza WHERE?,"['6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30', 'Sintaxa conţine: \nO subcerere care întoarce elemente sortate şi \ncare conţine clauza ORDER BY. \nCa să avem cea mai mare valoare pe prima linie \nfolosim DESC. \nO cerere care selectează un anumit număr de \nlinii (N) ca rezultat final. Conţine: \n– ROWNUM care aloca o valoare începând de la 1 fiecărei \nlinii întoarse de subcerere.\n– WHERE care condiţionează numărul de linii întoarse\nCurs - BAZE DE DATE 51', 'Sintaxa conţine: \nO subcerere care întoarce elemente sortate şi \ncare conţine clauza ORDER BY. \nCa să avem cea mai mare valoare pe prima linie \nfolosim DESC. \nO cerere care selectează un anumit număr de \nlinii (N) ca rezultat final. Conţine: \n– ROWNUM care aloca o valoare începând de la 1 fiecărei \nlinii întoarse de subcerere.\n– WHERE care condiţionează numărul de linii întoarse\nCurs - BAZE DE DATE 51']","Informațiile din context nu oferă un răspuns la întrebarea ta. Contextul explică conceptul de subinterogări cu operatorul IN, care returnează o listă de valori, nu o singură valoare. 

Pentru a afla cum se numește o subinterogare ce returnează o singură valoare pentru o condiție WHERE, ar trebui să cauți informații despre **subinterogări scalare**. Acestea sunt subinterogări care returnează un singur rând și o singură coloană, putând fi utilizate în clauza WHERE asemeni unei valori. 
",subinterogare single-row,,,,,0.0,0.022727272727272728,
6,O3mini-high,LOW,C7,,Ce instrucțiune SQL permite inserarea sau actualizarea condiționată a datelor?,MERGE,Este corect,,"['7.1.4. Instrucţiunea Merge\nInstrucţiunea MERGE permite inserarea \nsau actualizarea condiţionată a datelor \nîntr-un/dintr-un tabel al bazei de date. \nCurs 7 - BAZE DE DATE 34', '7.1.4. Instrucţiunea Merge\nInstrucţiunea MERGE permite inserarea \nsau actualizarea condiţionată a datelor \nîntr-un/dintr-un tabel al bazei de date. \nCurs 7 - BAZE DE DATE 34', '7.1.4. Instrucţiunea Merge\nInstrucţiunea MERGE permite inserarea \nsau actualizarea condiţionată a datelor \nîntr-un/dintr-un tabel al bazei de date. \nCurs 7 - BAZE DE DATE 34', '7.1.4. Instrucţiunea Merge\nInstrucţiunea MERGE permite inserarea \nsau actualizarea condiţionată a datelor \nîntr-un/dintr-un tabel al bazei de date. \nCurs 7 - BAZE DE DATE 34', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', '7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4', '7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4']","Instrucțiunea SQL care permite inserarea sau actualizarea condiționată a datelor este **MERGE**. 
",Ce instrucțiune SQL permite inserarea sau actualizarea condiționată a datelor?,"['7.1.4. Instrucţiunea Merge\nInstrucţiunea MERGE permite inserarea \nsau actualizarea condiţionată a datelor \nîntr-un/dintr-un tabel al bazei de date. \nCurs 7 - BAZE DE DATE 34', '7.1.4. Instrucţiunea Merge\nInstrucţiunea MERGE permite inserarea \nsau actualizarea condiţionată a datelor \nîntr-un/dintr-un tabel al bazei de date. \nCurs 7 - BAZE DE DATE 34', '7.1.4. Instrucţiunea Merge\nInstrucţiunea MERGE permite inserarea \nsau actualizarea condiţionată a datelor \nîntr-un/dintr-un tabel al bazei de date. \nCurs 7 - BAZE DE DATE 34', '7.1.4. Instrucţiunea Merge\nInstrucţiunea MERGE permite inserarea \nsau actualizarea condiţionată a datelor \nîntr-un/dintr-un tabel al bazei de date. \nCurs 7 - BAZE DE DATE 34', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', '7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4', '7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4']","Instrucțiunea SQL care permite inserarea sau actualizarea condiționată a datelor este **MERGE**. 
",MERGE,,,,,0.024455939372403628,0.13333333333333333,
7,O3mini-high,LOW,C8,,Ce constrângere SQL impune ca o coloană să nu accepte valori NULL?,NOT NULL,Este corect,,"['Constrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17', 'Constrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17', 'Constrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17', 'Constrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17', 'Funcţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 4 - BAZE DE DATE 12', 'Funcţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 4 - BAZE DE DATE 12', 'Funcţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 4 - BAZE DE DATE 12', 'Funcţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 4 - BAZE DE DATE 12', 'Funcţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12', 'Funcţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12']","În SQL, constrângerea care impune ca o coloană să nu accepte valori NULL este **NOT NULL**. 
",Ce constrângere SQL impune ca o coloană să nu accepte valori NULL?,"['Constrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17', 'Constrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17', 'Constrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17', 'Constrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17', 'Funcţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 4 - BAZE DE DATE 12', 'Funcţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 4 - BAZE DE DATE 12', 'Funcţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 4 - BAZE DE DATE 12', 'Funcţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 4 - BAZE DE DATE 12', 'Funcţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12', 'Funcţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12']","În SQL, constrângerea care impune ca o coloană să nu accepte valori NULL este **NOT NULL**. 
",NOT NULL,,,,,0.036321698830878615,0.21052631578947367,
8,O3mini-high,LOW,C9,,"Cu ce instrucțiune SQL se creează o vedere, adică o tabelă virtuală care extrage date din tabelele reale?",CREATE VIEW,Este corect,,"['Extragere de date dintr-o vedere\n➢Extragerea de date se face exact ca în cazul \nunei tabele. \n➢Se pot selecta anumite rânduri sau toată \nvederea. \nSELECT * FROM emp10;\nCurs - BAZE DE DATE 26\n', 'Extragere de date dintr-o vedere\n➢Extragerea de date se face exact ca în cazul \nunei tabele. \n➢Se pot selecta anumite rânduri sau toată \nvederea. \nSELECT * FROM emp10;\nCurs - BAZE DE DATE 26\n', 'Extragere de date dintr-o vedere\n➢Extragerea de date se face exact ca în cazul \nunei tabele. \n➢Se pot selecta anumite rânduri sau toată \nvederea. \nSELECT * FROM emp10;\nCurs - BAZE DE DATE 26\n', 'Extragere de date dintr-o vedere\n➢Extragerea de date se face exact ca în cazul \nunei tabele. \n➢Se pot selecta anumite rânduri sau toată \nvederea. \nSELECT * FROM emp10;\nCurs - BAZE DE DATE 26\n', 'Avantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6', 'Avantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6', 'Avantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6', 'Avantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6', 'Limbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3', 'Limbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3']","Din păcate, contextul oferit descrie cum se extrag date dintr-o vedere și care sunt avantajele utilizării lor, dar nu menționează sintaxa instrucțiunii SQL pentru crearea unei vederi. 

Pentru a crea o vedere în SQL, se folosește instrucțiunea **CREATE VIEW**. 

Sintaxa generală este:

```sql
CREATE VIEW nume_vedere AS
SELECT coloana1, coloana2, ...
FROM nume_tabel
WHERE conditie;
```

Unde:

* **nume_vedere** este numele pe care vrei să-l dai vederii.
* **SELECT coloana1, coloana2, ...** specifică coloanele pe care vrei să le incluzi în vedere.
* **FROM nume_tabel** specifică tabelul sau tabelele din care vrei să extragi datele.
* **WHERE conditie** este o clauză opțională care filtrează datele incluse în vedere.

De exemplu, pentru a crea o vedere numită ""AngajatiActivi"" care să conțină doar angajații activi dintr-un tabel numit ""Angajati"":

```sql
CREATE VIEW AngajatiActivi AS
SELECT nume, prenume, departament
FROM Angajati
WHERE activ = 1;
```

Această vedere va afișa numele, prenumele și departamentul pentru toți angajații care au coloana ""activ"" setată la 1. 
","Cu ce instrucțiune SQL se creează o vedere, adică o tabelă virtuală care extrage date din tabelele reale?","['Extragere de date dintr-o vedere\n➢Extragerea de date se face exact ca în cazul \nunei tabele. \n➢Se pot selecta anumite rânduri sau toată \nvederea. \nSELECT * FROM emp10;\nCurs - BAZE DE DATE 26\n', 'Extragere de date dintr-o vedere\n➢Extragerea de date se face exact ca în cazul \nunei tabele. \n➢Se pot selecta anumite rânduri sau toată \nvederea. \nSELECT * FROM emp10;\nCurs - BAZE DE DATE 26\n', 'Extragere de date dintr-o vedere\n➢Extragerea de date se face exact ca în cazul \nunei tabele. \n➢Se pot selecta anumite rânduri sau toată \nvederea. \nSELECT * FROM emp10;\nCurs - BAZE DE DATE 26\n', 'Extragere de date dintr-o vedere\n➢Extragerea de date se face exact ca în cazul \nunei tabele. \n➢Se pot selecta anumite rânduri sau toată \nvederea. \nSELECT * FROM emp10;\nCurs - BAZE DE DATE 26\n', 'Avantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6', 'Avantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6', 'Avantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6', 'Avantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6', 'Limbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3', 'Limbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3']","Din păcate, contextul oferit descrie cum se extrag date dintr-o vedere și care sunt avantajele utilizării lor, dar nu menționează sintaxa instrucțiunii SQL pentru crearea unei vederi. 

Pentru a crea o vedere în SQL, se folosește instrucțiunea **CREATE VIEW**. 

Sintaxa generală este:

```sql
CREATE VIEW nume_vedere AS
SELECT coloana1, coloana2, ...
FROM nume_tabel
WHERE conditie;
```

Unde:

* **nume_vedere** este numele pe care vrei să-l dai vederii.
* **SELECT coloana1, coloana2, ...** specifică coloanele pe care vrei să le incluzi în vedere.
* **FROM nume_tabel** specifică tabelul sau tabelele din care vrei să extragi datele.
* **WHERE conditie** este o clauză opțională care filtrează datele incluse în vedere.

De exemplu, pentru a crea o vedere numită ""AngajatiActivi"" care să conțină doar angajații activi dintr-un tabel numit ""Angajati"":

```sql
CREATE VIEW AngajatiActivi AS
SELECT nume, prenume, departament
FROM Angajati
WHERE activ = 1;
```

Această vedere va afișa numele, prenumele și departamentul pentru toți angajații care au coloana ""activ"" setată la 1. 
",CREATE VIEW,,,,,0.0,0.023121387283236997,
9,O3mini-high,LOW,C10,,"Ce obiect SQL este folosit pentru a genera automat valori unice, utile de obicei pentru identificatori?",SEQUENCE,Este corect,,"['2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', 'Funcţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12', 'Funcţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12', 'Funcţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12', 'Funcţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12', 'Funcţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 4 - BAZE DE DATE 12', 'Funcţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 4 - BAZE DE DATE 12']","Contextul furnizat nu conține informații despre obiectul SQL utilizat pentru a genera automat valori unice pentru identificatori. 

Totuși, obiectul SQL pe care îl cauți se numește **secvență** (sequence).  O secvență este un obiect al bazei de date care generează o secvență de numere întregi unice. Secvențele sunt adesea folosite ca valori pentru coloanele cheie primară, deoarece garantează unicitatea valorilor. 
","Ce obiect SQL este folosit pentru a genera automat valori unice, utile de obicei pentru identificatori?","['2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', 'Funcţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12', 'Funcţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12', 'Funcţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12', 'Funcţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 5 - BAZE DE DATE 12', 'Funcţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 4 - BAZE DE DATE 12', 'Funcţii\n O observaţie importanta este faptul că dacă se \napelează o funcţie SQL ce are un argument (parametru) \negal cu valoarea Null, atunci în mod automat rezultatul \nva avea valoarea Null. \n  Singurele funcţii care nu respectă această regulă \nsunt: \n– CONCAT\n– DECODE\n– DUMP\n– NVL\n– REPLACE\nCurs 4 - BAZE DE DATE 12']","Contextul furnizat nu conține informații despre obiectul SQL utilizat pentru a genera automat valori unice pentru identificatori. 

Totuși, obiectul SQL pe care îl cauți se numește **secvență** (sequence).  O secvență este un obiect al bazei de date care generează o secvență de numere întregi unice. Secvențele sunt adesea folosite ca valori pentru coloanele cheie primară, deoarece garantează unicitatea valorilor. 
",SEQUENCE,,,,,0.0,0.030303030303030307,
10,O3mini-high,LOW,C11,,"Cu ce instrucțiune SQL se creează un utilizator nou în Oracle, conform politicilor de control al accesului?",CREATE USER,Este corect,,"['Controlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4', 'Controlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4', 'Controlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4', 'Controlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4', '2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26', '2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26', '2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26', '2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26', 'Serverul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4', 'Serverul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4']","Informațiile furnizate nu conțin sintaxa exactă pentru crearea unui nou utilizator în Oracle. Totuși, se specifică faptul că Oracle permite controlul accesului la baza de date și la obiectele specifice din baza de date. 

Pentru a crea un utilizator nou în Oracle și a-i acorda privilegii, se folosește în general instrucțiunea `CREATE USER`  împreună cu `GRANT`. 

Iată un exemplu generic:

```sql
CREATE USER nume_utilizator IDENTIFIED BY parola;
GRANT connect, resource TO nume_utilizator;
```

**Explicație:**

* `CREATE USER nume_utilizator IDENTIFIED BY parola;` - Această parte a instrucțiunii creează un nou utilizator cu numele specificat și setează o parolă pentru autentificare.
* `GRANT connect, resource TO nume_utilizator;` - Această parte acordă utilizatorului nou creat anumite privilegii. În acest caz,  `connect` permite utilizatorului să se conecteze la baza de date, iar `resource` îi oferă permisiuni de a crea propriile obiecte (tabele, etc.).

**Important:** 

* Este crucial să consultați documentația oficială Oracle pentru sintaxa exactă și opțiunile disponibile pentru `CREATE USER` și `GRANT` deoarece acestea pot varia în funcție de versiunea Oracle.
*  Asigurați-vă că înțelegeți implicațiile de securitate ale privilegiilor pe care le acordați înainte de a le aplica. 
 
Pentru a crea un utilizator conform politicilor specifice de control al accesului din organizația dvs., trebuie să consultați documentația internă sau să contactați administratorul bazei de date. 
","Cu ce instrucțiune SQL se creează un utilizator nou în Oracle, conform politicilor de control al accesului?","['Controlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4', 'Controlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4', 'Controlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4', 'Controlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4', '2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26', '2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26', '2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26', '2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26', 'Serverul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4', 'Serverul Oracle utilizează constrângeri pentru a preveni \npătrunderea de date invalide în tabele.\nPutem utiliza constrângeri pentru a realiza următoarele \nacțiuni:\n1. Impune reguli datelor unei tabele ori de câte ori un \nrând este inserat, modificat sau şters din tabela. \n2. Prevenirea ştergerii unei tabela în cazul în care există \ndependenţă de alte tabele \n3. Furnizarea regulilor pentru instrumentele Oracle, \ncum ar fi ORACLE DEVELOPER. \nCurs 8 - BAZE DE DATE 4']","Informațiile furnizate nu conțin sintaxa exactă pentru crearea unui nou utilizator în Oracle. Totuși, se specifică faptul că Oracle permite controlul accesului la baza de date și la obiectele specifice din baza de date. 

Pentru a crea un utilizator nou în Oracle și a-i acorda privilegii, se folosește în general instrucțiunea `CREATE USER`  împreună cu `GRANT`. 

Iată un exemplu generic:

```sql
CREATE USER nume_utilizator IDENTIFIED BY parola;
GRANT connect, resource TO nume_utilizator;
```

**Explicație:**

* `CREATE USER nume_utilizator IDENTIFIED BY parola;` - Această parte a instrucțiunii creează un nou utilizator cu numele specificat și setează o parolă pentru autentificare.
* `GRANT connect, resource TO nume_utilizator;` - Această parte acordă utilizatorului nou creat anumite privilegii. În acest caz,  `connect` permite utilizatorului să se conecteze la baza de date, iar `resource` îi oferă permisiuni de a crea propriile obiecte (tabele, etc.).

**Important:** 

* Este crucial să consultați documentația oficială Oracle pentru sintaxa exactă și opțiunile disponibile pentru `CREATE USER` și `GRANT` deoarece acestea pot varia în funcție de versiunea Oracle.
*  Asigurați-vă că înțelegeți implicațiile de securitate ale privilegiilor pe care le acordați înainte de a le aplica. 
 
Pentru a crea un utilizator conform politicilor specifice de control al accesului din organizația dvs., trebuie să consultați documentația internă sau să contactați administratorul bazei de date. 
",CREATE USER,,,,,0.0,0.017094017094017096,
11,O3mini-high,LOW,C12,,"Ce model de baze de date, care organizează datele în tabele interconectate, este descris în acest capitol?",relațional,Este corect,,"[""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.6. Modelul de date reţea\nModelul de date reţea (Network Model) \nfoloseşte o structură de graf pentru definirea \nschemei conceptuale a bazei de date:\n➢nodurile grafului sunt tipuri de entităţi \n(înregistrări, records), \n➢iar muchiile grafului reprezintă în mod explicit \nasocierile (legăturile, links) dintre tipurile de \nentităţi.\n 64', '1.6. Modelul de date reţea\nModelul de date reţea (Network Model) \nfoloseşte o structură de graf pentru definirea \nschemei conceptuale a bazei de date:\n➢nodurile grafului sunt tipuri de entităţi \n(înregistrări, records), \n➢iar muchiile grafului reprezintă în mod explicit \nasocierile (legăturile, links) dintre tipurile de \nentităţi.\n 64']","Modelul de baze de date descris în capitol este **modelul relațional**. Acesta se bazează pe organizarea datelor în **tabele interconectate**, numite și relații.  
","Ce model de baze de date, care organizează datele în tabele interconectate, este descris în acest capitol?","[""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.6. Modelul de date reţea\nModelul de date reţea (Network Model) \nfoloseşte o structură de graf pentru definirea \nschemei conceptuale a bazei de date:\n➢nodurile grafului sunt tipuri de entităţi \n(înregistrări, records), \n➢iar muchiile grafului reprezintă în mod explicit \nasocierile (legăturile, links) dintre tipurile de \nentităţi.\n 64', '1.6. Modelul de date reţea\nModelul de date reţea (Network Model) \nfoloseşte o structură de graf pentru definirea \nschemei conceptuale a bazei de date:\n➢nodurile grafului sunt tipuri de entităţi \n(înregistrări, records), \n➢iar muchiile grafului reprezintă în mod explicit \nasocierile (legăturile, links) dintre tipurile de \nentităţi.\n 64']","Modelul de baze de date descris în capitol este **modelul relațional**. Acesta se bazează pe organizarea datelor în **tabele interconectate**, numite și relații.  
",relațional,,,,,0.02627961710408444,0.14814814814814814,
12,O3mini-high,LOW,C13,,Cu ce cuvânt cheie SQL se definește o cheie primară pentru a asigura identificarea unică a înregistrărilor în modelul relațional?,PRIMARY KEY,Este corect,,"[""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", '1.2.Modelul de date relaţional\nCele mai importante constrângeri de integritate \nsunt: \nConstrângerea de integritate a entităţii care \nstabileşte că fiecare tuplu să fie unic identificat \nprintr-o cheie şi atributul cheie să nu poată fi null;\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\n40', '1.2.Modelul de date relaţional\nCele mai importante constrângeri de integritate \nsunt: \nConstrângerea de integritate a entităţii care \nstabileşte că fiecare tuplu să fie unic identificat \nprintr-o cheie şi atributul cheie să nu poată fi null;\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\n40', '1.2.Modelul de date relaţional\nCele mai importante constrângeri de integritate \nsunt: \nConstrângerea de integritate a entităţii care \nstabileşte că fiecare tuplu să fie unic identificat \nprintr-o cheie şi atributul cheie să nu poată fi null;\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\n40', '1.2.Modelul de date relaţional\nCele mai importante constrângeri de integritate \nsunt: \nConstrângerea de integritate a entităţii care \nstabileşte că fiecare tuplu să fie unic identificat \nprintr-o cheie şi atributul cheie să nu poată fi null;\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\n40', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36']","Cuvântul cheie SQL folosit pentru a defini o cheie primară este **PRIMARY KEY**. 
",Cu ce cuvânt cheie SQL se definește o cheie primară pentru a asigura identificarea unică a înregistrărilor în modelul relațional?,"[""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", '1.2.Modelul de date relaţional\nCele mai importante constrângeri de integritate \nsunt: \nConstrângerea de integritate a entităţii care \nstabileşte că fiecare tuplu să fie unic identificat \nprintr-o cheie şi atributul cheie să nu poată fi null;\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\n40', '1.2.Modelul de date relaţional\nCele mai importante constrângeri de integritate \nsunt: \nConstrângerea de integritate a entităţii care \nstabileşte că fiecare tuplu să fie unic identificat \nprintr-o cheie şi atributul cheie să nu poată fi null;\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\n40', '1.2.Modelul de date relaţional\nCele mai importante constrângeri de integritate \nsunt: \nConstrângerea de integritate a entităţii care \nstabileşte că fiecare tuplu să fie unic identificat \nprintr-o cheie şi atributul cheie să nu poată fi null;\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\n40', '1.2.Modelul de date relaţional\nCele mai importante constrângeri de integritate \nsunt: \nConstrângerea de integritate a entităţii care \nstabileşte că fiecare tuplu să fie unic identificat \nprintr-o cheie şi atributul cheie să nu poată fi null;\nCODSTUD NUMEPREN AN FACULTATE GRUPA MEDADM\n101 Popa Ionel 4 Inginerie 145 10.00\n102 Popescu Vasile 1 Drept 113 9.24\n103 Badea George 1 Inginerie 112 8.79\n104 Achim Mimi 2 Economic 126 9.31\n105 Ionescu Mioara 3 Litere 132 10.00\n40', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36']","Cuvântul cheie SQL folosit pentru a defini o cheie primară este **PRIMARY KEY**. 
",PRIMARY KEY,,,,,0.04573913556123801,0.25,
13,O3mini-high,LOW,C14,,"În proiectarea bazelor de date relaționale, ce etapă transformă modelul conceptual într-un model relațional, pregătind implementarea efectivă a structurii bazei?",modelarea logică,Este corect,,"[' \nCurs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); ', ' \nCurs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); ', ' \nCurs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); ', ' \nCurs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); ', '1.5. Modelul de date ierarhic\n✓În modelul de date ierarhic (Hierarchical Model) o \nbază de date se reprezintă printr-o structură ierarhică \nde înregistrări de date (records) conectate prin \nlegături (links).\n✓Modelul ierarhic a fost primul model folosit pentru \ndezvoltatea bazelor de date.\n✓Schema conceptuală a unei baze de date în modelul \nierarhic se reprezintă printr-un număr oarecare de \nscheme ierarhice.\n 61', '1.5. Modelul de date ierarhic\n✓În modelul de date ierarhic (Hierarchical Model) o \nbază de date se reprezintă printr-o structură ierarhică \nde înregistrări de date (records) conectate prin \nlegături (links).\n✓Modelul ierarhic a fost primul model folosit pentru \ndezvoltatea bazelor de date.\n✓Schema conceptuală a unei baze de date în modelul \nierarhic se reprezintă printr-un număr oarecare de \nscheme ierarhice.\n 61', '1.5. Modelul de date ierarhic\n✓În modelul de date ierarhic (Hierarchical Model) o \nbază de date se reprezintă printr-o structură ierarhică \nde înregistrări de date (records) conectate prin \nlegături (links).\n✓Modelul ierarhic a fost primul model folosit pentru \ndezvoltatea bazelor de date.\n✓Schema conceptuală a unei baze de date în modelul \nierarhic se reprezintă printr-un număr oarecare de \nscheme ierarhice.\n 61', '1.5. Modelul de date ierarhic\n✓În modelul de date ierarhic (Hierarchical Model) o \nbază de date se reprezintă printr-o structură ierarhică \nde înregistrări de date (records) conectate prin \nlegături (links).\n✓Modelul ierarhic a fost primul model folosit pentru \ndezvoltatea bazelor de date.\n✓Schema conceptuală a unei baze de date în modelul \nierarhic se reprezintă printr-un număr oarecare de \nscheme ierarhice.\n 61', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36']","Etapa care transformă modelul conceptual într-un model relațional, pregătind implementarea efectivă a structurii bazei de date se numește **Modelarea logică**. 

Informația este preluată din secțiunea ""1.1 Etapele proiectării bazelor de date"", punctul 3: ""Modelarea logică - Transformarea modelului conceptual într-un model relațional.""
","În proiectarea bazelor de date relaționale, ce etapă transformă modelul conceptual într-un model relațional, pregătind implementarea efectivă a structurii bazei?","[' \nCurs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); ', ' \nCurs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); ', ' \nCurs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); ', ' \nCurs 14. Proiectarea bazelor de date relaționale \n \n1. Procesul de proiectare \n \nProiectarea unei baze de date relaționale implică mai multe etape esențiale care asigură \nstructura optimă a datelor și eficiența utilizării acestora. \n \n1.1 Etapele proiectării bazelor de date \n1. Identificarea cerințelor - Colectarea cerințelor utilizatorilor și analiza acestora. \n2. Modelarea conceptuală - Crearea unui model abstract al bazei de date folosind diagrame \nER (Entity-Relationship). \n3. Modelarea logică - Transformarea modelului conceptual într-un model relațional. \n4. Modelarea fizică - Optimizarea modelului logic pentru implementare în SGBD. \n5. Normalizarea - Aplicarea regulilor pentru a elimina redundanța și asigura integritatea \ndatelor. \nExemplu de diagramă ER pentru o bază de date universitară: \nEntități: Student, Profesor, Curs \nRelații: Student se înscrie la Curs, Profesor predă Curs \n \n1.2 Exemplu de modelare conceptuală \nCREATE TABLE Student ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) \n); \n \nCREATE TABLE Profesor ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50) \n); \n \nCREATE TABLE Curs ( \n    Cod INT PRIMARY KEY , \n    Denumire V ARCHAR(100), \n    ProfesorID INT, \n    FOREIGN KEY (ProfesorID) REFERENCES Profesor(ID) \n); \n \nCREATE TABLE Inscriere ( \n    StudentID INT, \n    CursCod INT, \n    PRIMARY KEY (StudentID, CursCod), \n    FOREIGN KEY (StudentID) REFERENCES Student(ID), \n    FOREIGN KEY (CursCod) REFERENCES Curs(Cod) \n); ', '1.5. Modelul de date ierarhic\n✓În modelul de date ierarhic (Hierarchical Model) o \nbază de date se reprezintă printr-o structură ierarhică \nde înregistrări de date (records) conectate prin \nlegături (links).\n✓Modelul ierarhic a fost primul model folosit pentru \ndezvoltatea bazelor de date.\n✓Schema conceptuală a unei baze de date în modelul \nierarhic se reprezintă printr-un număr oarecare de \nscheme ierarhice.\n 61', '1.5. Modelul de date ierarhic\n✓În modelul de date ierarhic (Hierarchical Model) o \nbază de date se reprezintă printr-o structură ierarhică \nde înregistrări de date (records) conectate prin \nlegături (links).\n✓Modelul ierarhic a fost primul model folosit pentru \ndezvoltatea bazelor de date.\n✓Schema conceptuală a unei baze de date în modelul \nierarhic se reprezintă printr-un număr oarecare de \nscheme ierarhice.\n 61', '1.5. Modelul de date ierarhic\n✓În modelul de date ierarhic (Hierarchical Model) o \nbază de date se reprezintă printr-o structură ierarhică \nde înregistrări de date (records) conectate prin \nlegături (links).\n✓Modelul ierarhic a fost primul model folosit pentru \ndezvoltatea bazelor de date.\n✓Schema conceptuală a unei baze de date în modelul \nierarhic se reprezintă printr-un număr oarecare de \nscheme ierarhice.\n 61', '1.5. Modelul de date ierarhic\n✓În modelul de date ierarhic (Hierarchical Model) o \nbază de date se reprezintă printr-o structură ierarhică \nde înregistrări de date (records) conectate prin \nlegături (links).\n✓Modelul ierarhic a fost primul model folosit pentru \ndezvoltatea bazelor de date.\n✓Schema conceptuală a unei baze de date în modelul \nierarhic se reprezintă printr-un număr oarecare de \nscheme ierarhice.\n 61', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36']","Etapa care transformă modelul conceptual într-un model relațional, pregătind implementarea efectivă a structurii bazei de date se numește **Modelarea logică**. 

Informația este preluată din secțiunea ""1.1 Etapele proiectării bazelor de date"", punctul 3: ""Modelarea logică - Transformarea modelului conceptual într-un model relațional.""
",modelarea logică,,,,,0.01506189323093867,0.07547169811320754,
14,O3mini-high,Medium,Curs 1,,"Ce este o bază de date, conform cursului?","O bază de date este o colecție organizată de date stocate electronic, care permite accesul, gestionarea și actualizarea eficientă a acestora.",Este corect,,"['1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20', '1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20', '1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20', '1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', 'Conţinutul cursului\nÎn cadrul acestui curs se vor studia bazele de \ndate prelucrate cu ajutorul sistemului de \ngestiune a bazelor de date\nORACLE Database 12c Express Edition\n 13', 'Conţinutul cursului\nÎn cadrul acestui curs se vor studia bazele de \ndate prelucrate cu ajutorul sistemului de \ngestiune a bazelor de date\nORACLE Database 12c Express Edition\n 13']","Conform cursului, o bază de date este reprezentată cu ajutorul modelului relațional ca o colecție de tabele. 
","Ce este o bază de date, conform cursului?","['1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20', '1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20', '1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20', '1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', 'Conţinutul cursului\nÎn cadrul acestui curs se vor studia bazele de \ndate prelucrate cu ajutorul sistemului de \ngestiune a bazelor de date\nORACLE Database 12c Express Edition\n 13', 'Conţinutul cursului\nÎn cadrul acestui curs se vor studia bazele de \ndate prelucrate cu ajutorul sistemului de \ngestiune a bazelor de date\nORACLE Database 12c Express Edition\n 13']","Conform cursului, o bază de date este reprezentată cu ajutorul modelului relațional ca o colecție de tabele. 
","O bază de date este o colecție organizată de date stocate electronic, care permite accesul, gestionarea și actualizarea eficientă a acestora.",,,,,0.12311103973058554,0.43902439024390244,
15,O3mini-high,Medium,Curs 2,,Ce reprezintă Oracle în cursul prezentat?,"Oracle este un SGBD complet relațional, extins, cu facilități din tehnologia orientată obiect, operațional pe toată gama de calculatoare.",Este corect,sllde 5,"['2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40', '2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40', '2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40', '2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40', '2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26', '2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26', '2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26', '2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26', '2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38', '2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38']","În contextul prezentat, Oracle se referă la **server-ul de baze de date Oracle**, mai precis la versiunea simplificată **Oracle Database 11g Express Edition**, utilizată pentru executarea aplicațiilor de laborator. 

Contextul menționează că această versiune este gratuită și poate fi descărcată de pe site-ul Oracle. 

De asemenea, se specifică faptul că Oracle utilizează limbajul relațional de regăsire **SQL** și limbajul procedural propriu **PL/SQL**. 
",Ce reprezintă Oracle în cursul prezentat?,"['2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40', '2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40', '2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40', '2.4. ORACLE Database 11g Expres Edition\n Aplicatiile de laborator pot fi executate cu \najutorul unei versiuni simplificate a server-ului \nOracle si anume: \nOracle Database 11g Expres Edition\nAceasta se poate descarca gratuit de pe site-ul:\nhttp://www.oracle.com/technetwork/products/exp\nress-edition/downloads/index.html \n40', '2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26', '2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26', '2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26', '2.2. Arhitectura SGBD-ului ORACLE\n1. Nucleul Oracle conţine componentele care \ndau tipul relaţional pentru SGBD Oracle:\n➢limbajul relaţional de regăsire SQL \n➢limbajul procedural propriu PL/SQL\n26', '2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38', '2.3. ORACLE Server\nB. Instanţa Oracle (Oracle instance) este \ncombinaţia logică dintre:\n✓structurile de memorie internă:\n✓SGA - system global area\n✓PGA - program global area\n✓şi procesele Oracle de bază activate la \nmomentul pornirii unei baze de date \n38']","În contextul prezentat, Oracle se referă la **server-ul de baze de date Oracle**, mai precis la versiunea simplificată **Oracle Database 11g Express Edition**, utilizată pentru executarea aplicațiilor de laborator. 

Contextul menționează că această versiune este gratuită și poate fi descărcată de pe site-ul Oracle. 

De asemenea, se specifică faptul că Oracle utilizează limbajul relațional de regăsire **SQL** și limbajul procedural propriu **PL/SQL**. 
","Oracle este un SGBD complet relațional, extins, cu facilități din tehnologia orientată obiect, operațional pe toată gama de calculatoare.",,,,,0.013737889784665155,0.10869565217391304,
16,O3mini-high,Medium,Curs 3,,Ce face clauza ORDER BY într-o interogare SELECT?,"ORDER BY sortează liniile rezultatului conform criteriilor specificate; fără aceasta, ordinea rezultatelor este independentă de ordinea inserării.",Este corect,sllde 6,"['Exista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17', 'Exista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17', 'Exista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17', 'Exista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17', 'Clauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71', 'Clauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71', 'Clauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71', 'Clauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71', 'SINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4', 'SINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4']","Clauza **ORDER BY** într-o interogare SELECT specifică ordinea în care sunt sortate rândurile rezultate. Fără ea, rezultatele interogării sunt returnate într-o ordine aleatorie.

Iată mai multe detalii:

* **Sintaxă:**
  ```sql
  SELECT coloana
  FROM tabela
  [WHERE conditie] 
  [ORDER BY {coloana, expresie} [ASC/DESC]];
  ```
* **Funcționare:** Specifică una sau mai multe coloane (sau expresii) după care se face sortarea.
* **Ordinea sortării:**
    * **ASC:** Ordonează rândurile crescător (implicit).
    * **DESC:** Ordonează rândurile descrescător. 

**Exemplu:**

```sql
SELECT nume, prenume
FROM angajati
ORDER BY nume ASC, prenume DESC;
```

Această interogare va returna toți angajații din tabela `angajati` sortați alfabetic după `nume` (crescător) și apoi după `prenume` (descrescător).
",Ce face clauza ORDER BY într-o interogare SELECT?,"['Exista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17', 'Exista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17', 'Exista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17', 'Exista niste constrangeri la folosirea pseudocoloanelor \nCURRVAL si NEXTVAL:\n➢Cand cererea SELECT se refera la obiecte de tip vedere\n➢Cand in cererea SELECT se utilizeaza cuvantul cheie \nDISTINCT\n➢Cand cererea SELECT contine GROUP BY , HAVING sau \nORDER BY\n➢Cand instructiunea SELECT este folosita intr-o sub-\ninterogare.\n➢Cand este utilizata expresia DEFAULT impreuna cu \nCREATE TABLE sau cu ALTER TABLE\nCurs - BAZE DE DATE 17', 'Clauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71', 'Clauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71', 'Clauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71', 'Clauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71', 'SINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4', 'SINTAXA\nSELECT [DISTINCT] lista_de_expresii\nFROM nume_tabela\nWHERE conditie_linie -- clauza optionala\nORDER BY criterii_sortare_rezultat; -- clauza \noptionala\n 4']","Clauza **ORDER BY** într-o interogare SELECT specifică ordinea în care sunt sortate rândurile rezultate. Fără ea, rezultatele interogării sunt returnate într-o ordine aleatorie.

Iată mai multe detalii:

* **Sintaxă:**
  ```sql
  SELECT coloana
  FROM tabela
  [WHERE conditie] 
  [ORDER BY {coloana, expresie} [ASC/DESC]];
  ```
* **Funcționare:** Specifică una sau mai multe coloane (sau expresii) după care se face sortarea.
* **Ordinea sortării:**
    * **ASC:** Ordonează rândurile crescător (implicit).
    * **DESC:** Ordonează rândurile descrescător. 

**Exemplu:**

```sql
SELECT nume, prenume
FROM angajati
ORDER BY nume ASC, prenume DESC;
```

Această interogare va returna toți angajații din tabela `angajati` sortați alfabetic după `nume` (crescător) și apoi după `prenume` (descrescător).
","ORDER BY sortează liniile rezultatului conform criteriilor specificate; fără aceasta, ordinea rezultatelor este independentă de ordinea inserării.",,,,,0.04253727916575855,0.10526315789473684,
17,O3mini-high,Medium,Curs 4,,"În ce două categorii se împart funcțiile în SQL, conform cursului?",Funcțiile se clasifică în: 1. Funcții referitoare la o singură înregistrare; 2. Funcții referitoare la mai multe înregistrări (funcții de grup).,Este corect,slide 8,"['Funcţii\nFuncţiile se pot clasifica în două categorii:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 4 - BAZE DE DATE 8', 'Funcţii\nFuncţiile se pot clasifica în două categorii:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 4 - BAZE DE DATE 8', 'Funcţii\nFuncţiile se pot clasifica în două categorii:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 4 - BAZE DE DATE 8', 'Funcţii\nFuncţiile se pot clasifica în două categorii:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 4 - BAZE DE DATE 8', 'Funcţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8', 'Funcţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8', 'Funcţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8', 'Funcţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3']","Conform cursului, funcțiile în SQL se împart în două categorii:

1. **Funcții referitoare la o singură înregistrare (single-row functions)**
2. **Funcții referitoare la mai multe înregistrări (multiple-row functions)** 
","În ce două categorii se împart funcțiile în SQL, conform cursului?","['Funcţii\nFuncţiile se pot clasifica în două categorii:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 4 - BAZE DE DATE 8', 'Funcţii\nFuncţiile se pot clasifica în două categorii:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 4 - BAZE DE DATE 8', 'Funcţii\nFuncţiile se pot clasifica în două categorii:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 4 - BAZE DE DATE 8', 'Funcţii\nFuncţiile se pot clasifica în două categorii:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 4 - BAZE DE DATE 8', 'Funcţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8', 'Funcţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8', 'Funcţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8', 'Funcţii\nFuncţiile se clasifică în două tipuri:\n1. Funcţii referitoare la o singură înregistrare \n(single-row functions)\n2. Funcţii referitoare la mai multe înregistrări \n(multiple-row functions)\nCurs 5 - BAZE DE DATE 8', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3']","Conform cursului, funcțiile în SQL se împart în două categorii:

1. **Funcții referitoare la o singură înregistrare (single-row functions)**
2. **Funcții referitoare la mai multe înregistrări (multiple-row functions)** 
",Funcțiile se clasifică în: 1. Funcții referitoare la o singură înregistrare; 2. Funcții referitoare la mai multe înregistrări (funcții de grup).,,,,,0.07347053125977879,0.7,
18,O3mini-high,Medium,Curs 5,,"Ce sunt funcțiile de grup în SQL, conform cursului?","Funcțiile de grup operează pe un set de rânduri, returnând un singur rezultat pentru fiecare grup (ex. AVG, COUNT, SUM).",Este corect,slide 14,"['Limbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13', 'Limbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13', 'Limbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13', 'Limbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13', 'Limbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'Limbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'Limbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'Limbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'Limbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'Limbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48']","Conform informațiilor din context, funcțiile de grup în SQL sunt discutate în secțiunea ""4.3. Funcţii referitoare la mai multe înregistrări"" din cursul ""BAZE DE DATE"". 

Mai exact, informațiile despre acestea se găsesc în următoarele subpuncte:

* 4.3.1. Clauza GROUP BY
* 4.3.2. Excluderea grupurilor (clauza HAVING)
* 4.3.3. Imbricarea funcţiilor de grup

Din păcate, contextul nu oferă detalii despre funcțiile specifice. 
","Ce sunt funcțiile de grup în SQL, conform cursului?","['Limbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13', 'Limbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13', 'Limbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13', 'Limbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 13', 'Limbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'Limbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'Limbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'Limbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 40', 'Limbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48', 'Limbajul SQL\nCereri SELECT pe o tabela\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\n4.3. Funcţii referitoare la mai multe înregistrări\n4.3.1. Clauza GROUP BY\n4.3.2. Excluderea grupurilor (clauza HAVING)\n4.3.3. Imbricarea funcţiilor de grup\nCurs 5 - BAZE DE DATE 48']","Conform informațiilor din context, funcțiile de grup în SQL sunt discutate în secțiunea ""4.3. Funcţii referitoare la mai multe înregistrări"" din cursul ""BAZE DE DATE"". 

Mai exact, informațiile despre acestea se găsesc în următoarele subpuncte:

* 4.3.1. Clauza GROUP BY
* 4.3.2. Excluderea grupurilor (clauza HAVING)
* 4.3.3. Imbricarea funcţiilor de grup

Din păcate, contextul nu oferă detalii despre funcțiile specifice. 
","Funcțiile de grup operează pe un set de rânduri, returnând un singur rezultat pentru fiecare grup (ex. AVG, COUNT, SUM).",,,,,0.04487525652041662,0.12121212121212123,
19,O3mini-high,Medium,Curs 6,,Ce este o subinterogare (subquery) în SQL?,"O subinterogare este o instrucțiune SELECT inclusă într-o altă instrucțiune, executată prima, iar rezultatul ei este folosit de interogarea principală.",Este corect,"slide 4,5","['Curs 3 \nLimbajul SQL \n 2', 'Curs 3 \nLimbajul SQL \n 2', 'Curs 3 \nLimbajul SQL \n 2', 'Curs 3 \nLimbajul SQL \n 2', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66']","O subinterogare în SQL este o instrucțiune SELECT inclusă într-o clauză a altei instrucțiuni SQL. 

Practic, este o interogare imbricată care se execută în cadrul unei interogări principale. 

**Utilitate:**
Subinterogările sunt folositoare atunci când interogarea principală se bazează pe criterii necunoscute, care trebuie determinate dinamic printr-o altă interogare.

**Caracteristici:**

* Pot transmite un rând de date sau mai multe rânduri de date către instrucțiunea principală, în funcție de operatorul folosit (single-row sau multiple-row).
* Serverul de baze de date procesează mai întâi subinterogarea, iar rezultatul acesteia este folosit în clauzele WHERE și HAVING ale interogării principale.
* Pot conține funcții de grup. 

**Exemplu:** 
```sql
SELECT nume_angajat
FROM angajati
WHERE salariu > (SELECT AVG(salariu) FROM angajati); 
```

Această interogare va selecta numele angajaților al căror salariu este mai mare decât salariul mediu al tuturor angajaților (calculat prin subinterogarea `SELECT AVG(salariu) FROM angajati`). 
",Ce este o subinterogare (subquery) în SQL?,"['Curs 3 \nLimbajul SQL \n 2', 'Curs 3 \nLimbajul SQL \n 2', 'Curs 3 \nLimbajul SQL \n 2', 'Curs 3 \nLimbajul SQL \n 2', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66']","O subinterogare în SQL este o instrucțiune SELECT inclusă într-o clauză a altei instrucțiuni SQL. 

Practic, este o interogare imbricată care se execută în cadrul unei interogări principale. 

**Utilitate:**
Subinterogările sunt folositoare atunci când interogarea principală se bazează pe criterii necunoscute, care trebuie determinate dinamic printr-o altă interogare.

**Caracteristici:**

* Pot transmite un rând de date sau mai multe rânduri de date către instrucțiunea principală, în funcție de operatorul folosit (single-row sau multiple-row).
* Serverul de baze de date procesează mai întâi subinterogarea, iar rezultatul acesteia este folosit în clauzele WHERE și HAVING ale interogării principale.
* Pot conține funcții de grup. 

**Exemplu:** 
```sql
SELECT nume_angajat
FROM angajati
WHERE salariu > (SELECT AVG(salariu) FROM angajati); 
```

Această interogare va selecta numele angajaților al căror salariu este mai mare decât salariul mediu al tuturor angajaților (calculat prin subinterogarea `SELECT AVG(salariu) FROM angajati`). 
","O subinterogare este o instrucțiune SELECT inclusă într-o altă instrucțiune, executată prima, iar rezultatul ei este folosit de interogarea principală.",,,,,0.213621974000934,0.1847826086956522,
20,O3mini-high,Medium,Curs 7,,Ce permite limbajul de manipulare al datelor (DML) în SQL?,"DML permite adăugarea, modificarea și ștergerea datelor din baza de date, fiind nucleul limbajului SQL.",Este corect,slide 4,"['2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59', 'S.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4', 'S.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4']","Limbajul de manipulare al datelor (DML) în SQL permite **modificarea datelor** din baza de date. 
",Ce permite limbajul de manipulare al datelor (DML) în SQL?,"['2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59', 'S.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4', 'S.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4']","Limbajul de manipulare al datelor (DML) în SQL permite **modificarea datelor** din baza de date. 
","DML permite adăugarea, modificarea și ștergerea datelor din baza de date, fiind nucleul limbajului SQL.",,,,,0.13924499401499876,0.5161290322580646,
21,O3mini-high,Medium,Curs 8,,"Ce definește constrângerea FOREIGN KEY în SQL, conform cursului?","FOREIGN KEY stabilește o relație între coloana din tabela copil și cheia primară a tabelei părinte, asigurând integritatea referențială.",Este corect,slide 21,"['Limbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3', 'Limbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3', 'Limbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3', 'Limbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3', 'Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', 'Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', 'Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', 'Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', 'Definirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7', 'Definirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7']","Nu pot răspunde la această întrebare pe baza contextului furnizat. Deși contextul menționează ""Constrângeri"" și ""Limbajul SQL"", nu oferă o definiție specifică pentru constrângerea FOREIGN KEY. 
","Ce definește constrângerea FOREIGN KEY în SQL, conform cursului?","['Limbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3', 'Limbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3', 'Limbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3', 'Limbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3', 'Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', 'Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', 'Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', 'Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', 'Definirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7', 'Definirea Constrângerilor\nSintaxa \nCREATE TABLE [schema.] table \n(column datatype [DEFAULT expr] \n[column_constraint], \n[table_constraint][...]);\nCurs 8 - BAZE DE DATE 7']","Nu pot răspunde la această întrebare pe baza contextului furnizat. Deși contextul menționează ""Constrângeri"" și ""Limbajul SQL"", nu oferă o definiție specifică pentru constrângerea FOREIGN KEY. 
","FOREIGN KEY stabilește o relație între coloana din tabela copil și cheia primară a tabelei părinte, asigurând integritatea referențială.",,,,,0.0,0.07142857142857144,
22,O3mini-high,Medium,Curs 9,,"Ce este o vedere (view) în SQL, conform cursului?","O vedere este o tabelă logică generată printr-o instrucțiune SELECT, fără a stoca date proprii, ci extrăgându-le din tabele.",Este corect,slide 4,"['Limbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3', 'Limbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3', 'Limbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3', 'Limbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3', 'Pentru a vizualiza conţinutul vederii folosim cererea SQL \nSELECT. \nSELECT * \nFROM emp20;\nCurs - BAZE DE DATE 16\n', 'Pentru a vizualiza conţinutul vederii folosim cererea SQL \nSELECT. \nSELECT * \nFROM emp20;\nCurs - BAZE DE DATE 16\n', 'Pentru a vizualiza conţinutul vederii folosim cererea SQL \nSELECT. \nSELECT * \nFROM emp20;\nCurs - BAZE DE DATE 16\n', 'Pentru a vizualiza conţinutul vederii folosim cererea SQL \nSELECT. \nSELECT * \nFROM emp20;\nCurs - BAZE DE DATE 16\n', 'Pentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22', 'Pentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22']","Conform informațiilor din context, o vedere (view) în SQL este prezentată în cursul ""BAZE DE DATE 3"", în cadrul lecției despre Limbajul SQL. 
","Ce este o vedere (view) în SQL, conform cursului?","['Limbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3', 'Limbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3', 'Limbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3', 'Limbajul SQL\nVederi (Views)\nCurs - BAZE DE DATE 3', 'Pentru a vizualiza conţinutul vederii folosim cererea SQL \nSELECT. \nSELECT * \nFROM emp20;\nCurs - BAZE DE DATE 16\n', 'Pentru a vizualiza conţinutul vederii folosim cererea SQL \nSELECT. \nSELECT * \nFROM emp20;\nCurs - BAZE DE DATE 16\n', 'Pentru a vizualiza conţinutul vederii folosim cererea SQL \nSELECT. \nSELECT * \nFROM emp20;\nCurs - BAZE DE DATE 16\n', 'Pentru a vizualiza conţinutul vederii folosim cererea SQL \nSELECT. \nSELECT * \nFROM emp20;\nCurs - BAZE DE DATE 16\n', 'Pentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22', 'Pentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22']","Conform informațiilor din context, o vedere (view) în SQL este prezentată în cursul ""BAZE DE DATE 3"", în cadrul lecției despre Limbajul SQL. 
","O vedere este o tabelă logică generată printr-o instrucțiune SELECT, fără a stoca date proprii, ci extrăgându-le din tabele.",,,,,0.0201381482546679,0.16,
23,O3mini-high,Medium,Curs 10,,"De ce se folosesc secvențele în SQL, potrivit cursului?","Secvențele generează automat numere întregi unice, esențiale pentru chei primare, evitând problemele de sincronizare.",Este corect,slide 8,"['De ce folosim indecsii?\n➢Indecsii ofera o metode de acces direct catre \ninregistrarile care se doresc extrase.\n➢Scopul lor este de a diminua operatile de intrare/iesire \ncatre disc prin folosirea unei metode de indexare a \ncailor catre acele date. \n➢Indecsii sunt utilizati si mentinuti de catre serverul \nOracle in mod transparent pentru utilizator care nu \nimplica nici o alta actiune ulterioara.\nCurs - BAZE DE DATE 26', 'De ce folosim indecsii?\n➢Indecsii ofera o metode de acces direct catre \ninregistrarile care se doresc extrase.\n➢Scopul lor este de a diminua operatile de intrare/iesire \ncatre disc prin folosirea unei metode de indexare a \ncailor catre acele date. \n➢Indecsii sunt utilizati si mentinuti de catre serverul \nOracle in mod transparent pentru utilizator care nu \nimplica nici o alta actiune ulterioara.\nCurs - BAZE DE DATE 26', 'De ce folosim indecsii?\n➢Indecsii ofera o metode de acces direct catre \ninregistrarile care se doresc extrase.\n➢Scopul lor este de a diminua operatile de intrare/iesire \ncatre disc prin folosirea unei metode de indexare a \ncailor catre acele date. \n➢Indecsii sunt utilizati si mentinuti de catre serverul \nOracle in mod transparent pentru utilizator care nu \nimplica nici o alta actiune ulterioara.\nCurs - BAZE DE DATE 26', 'De ce folosim indecsii?\n➢Indecsii ofera o metode de acces direct catre \ninregistrarile care se doresc extrase.\n➢Scopul lor este de a diminua operatile de intrare/iesire \ncatre disc prin folosirea unei metode de indexare a \ncailor catre acele date. \n➢Indecsii sunt utilizati si mentinuti de catre serverul \nOracle in mod transparent pentru utilizator care nu \nimplica nici o alta actiune ulterioara.\nCurs - BAZE DE DATE 26', 'Curs 3 \nLimbajul SQL \n 2', 'Curs 3 \nLimbajul SQL \n 2', 'Curs 3 \nLimbajul SQL \n 2', 'Curs 3 \nLimbajul SQL \n 2', 'Limbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60', 'Limbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60']","Contextul furnizat vorbește despre indecși în SQL, nu despre secvențe. Pentru a putea răspunde la întrebarea ""De ce se folosesc secvențele în SQL"", ar fi nevoie de mai multe informații despre acest subiect. 

Secvențele în SQL sunt utilizate de obicei pentru a genera valori unice, incrementale, care pot fi folosite drept chei primare pentru tabele. 

Te rog să furnizezi mai mult context despre secvențe în SQL pentru a putea oferi un răspuns mai complet. 
","De ce se folosesc secvențele în SQL, potrivit cursului?","['De ce folosim indecsii?\n➢Indecsii ofera o metode de acces direct catre \ninregistrarile care se doresc extrase.\n➢Scopul lor este de a diminua operatile de intrare/iesire \ncatre disc prin folosirea unei metode de indexare a \ncailor catre acele date. \n➢Indecsii sunt utilizati si mentinuti de catre serverul \nOracle in mod transparent pentru utilizator care nu \nimplica nici o alta actiune ulterioara.\nCurs - BAZE DE DATE 26', 'De ce folosim indecsii?\n➢Indecsii ofera o metode de acces direct catre \ninregistrarile care se doresc extrase.\n➢Scopul lor este de a diminua operatile de intrare/iesire \ncatre disc prin folosirea unei metode de indexare a \ncailor catre acele date. \n➢Indecsii sunt utilizati si mentinuti de catre serverul \nOracle in mod transparent pentru utilizator care nu \nimplica nici o alta actiune ulterioara.\nCurs - BAZE DE DATE 26', 'De ce folosim indecsii?\n➢Indecsii ofera o metode de acces direct catre \ninregistrarile care se doresc extrase.\n➢Scopul lor este de a diminua operatile de intrare/iesire \ncatre disc prin folosirea unei metode de indexare a \ncailor catre acele date. \n➢Indecsii sunt utilizati si mentinuti de catre serverul \nOracle in mod transparent pentru utilizator care nu \nimplica nici o alta actiune ulterioara.\nCurs - BAZE DE DATE 26', 'De ce folosim indecsii?\n➢Indecsii ofera o metode de acces direct catre \ninregistrarile care se doresc extrase.\n➢Scopul lor este de a diminua operatile de intrare/iesire \ncatre disc prin folosirea unei metode de indexare a \ncailor catre acele date. \n➢Indecsii sunt utilizati si mentinuti de catre serverul \nOracle in mod transparent pentru utilizator care nu \nimplica nici o alta actiune ulterioara.\nCurs - BAZE DE DATE 26', 'Curs 3 \nLimbajul SQL \n 2', 'Curs 3 \nLimbajul SQL \n 2', 'Curs 3 \nLimbajul SQL \n 2', 'Curs 3 \nLimbajul SQL \n 2', 'Limbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60', 'Limbajul SQL\n \n  Limbajul SQL (Structured Query Language) se \nbazează pe studiile lui E.F. Codd, prima implementare a \nacestui limbaj datând din anul 1970.\n  Este un limbaj complet standardizat şi se poate \nutiliza pentru a accesa baze de date:\n1. Oracle\n2. SQL Server\n3. DB2 \n4. MySQL (open-source)\n5. MsSQL\n60']","Contextul furnizat vorbește despre indecși în SQL, nu despre secvențe. Pentru a putea răspunde la întrebarea ""De ce se folosesc secvențele în SQL"", ar fi nevoie de mai multe informații despre acest subiect. 

Secvențele în SQL sunt utilizate de obicei pentru a genera valori unice, incrementale, care pot fi folosite drept chei primare pentru tabele. 

Te rog să furnizezi mai mult context despre secvențe în SQL pentru a putea oferi un răspuns mai complet. 
","Secvențele generează automat numere întregi unice, esențiale pentru chei primare, evitând problemele de sincronizare.",,,,,0.0217212999031354,0.09999999999999998,
24,O3mini-high,Medium,Curs 11,,"Ce acoperă securitatea bazei de date, conform cursului?","Securitatea bazei de date acoperă controlul accesului, acordarea privilegiilor de sistem și obiect, protejând datele într-un mediu multi-user.",Este corect,slide 4,"['tt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5', 'tt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5', 'tt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5', 'tt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5', 'Cuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3', 'Cuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3', 'Cuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3', 'Cuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3', '1.1.Sisteme de baze de date\nMetadatele sunt\nmemorate în \ndicţionarul de \ndate, care \ninclude:\n➢structura bazei\nde date sau\nschema\n➢constrângerile\nde integritate\n➢constrângerile\nde securitate\n 33', '1.1.Sisteme de baze de date\nMetadatele sunt\nmemorate în \ndicţionarul de \ndate, care \ninclude:\n➢structura bazei\nde date sau\nschema\n➢constrângerile\nde integritate\n➢constrângerile\nde securitate\n 33']","Conform cursului, securitatea bazei de date acoperă:

* **Securitatea sistemului**
* **Securitatea datelor** 
","Ce acoperă securitatea bazei de date, conform cursului?","['tt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5', 'tt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5', 'tt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5', 'tt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5', 'Cuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3', 'Cuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3', 'Cuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3', 'Cuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3', '1.1.Sisteme de baze de date\nMetadatele sunt\nmemorate în \ndicţionarul de \ndate, care \ninclude:\n➢structura bazei\nde date sau\nschema\n➢constrângerile\nde integritate\n➢constrângerile\nde securitate\n 33', '1.1.Sisteme de baze de date\nMetadatele sunt\nmemorate în \ndicţionarul de \ndate, care \ninclude:\n➢structura bazei\nde date sau\nschema\n➢constrângerile\nde integritate\n➢constrângerile\nde securitate\n 33']","Conform cursului, securitatea bazei de date acoperă:

* **Securitatea sistemului**
* **Securitatea datelor** 
","Securitatea bazei de date acoperă controlul accesului, acordarea privilegiilor de sistem și obiect, protejând datele într-un mediu multi-user.",,,,,0.11408424519986962,0.31249999999999994,
25,O3mini-high,Medium,Curs 12,,"Care sunt avantajele bazelor de date față de fișierele tradiționale, conform cursului?","Avantajele: elimină redundanța, îmbunătățesc integritatea, oferă acces flexibil și securitate sporită.",Este corect,pagina 1,"['1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', 'Curs 1 \nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n 2', 'Curs 1 \nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n 2', 'Curs 1 \nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n 2', 'Curs 1 \nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n 2', 'De ce folosim indecsii?\n➢Indecsii ofera o metode de acces direct catre \ninregistrarile care se doresc extrase.\n➢Scopul lor este de a diminua operatile de intrare/iesire \ncatre disc prin folosirea unei metode de indexare a \ncailor catre acele date. \n➢Indecsii sunt utilizati si mentinuti de catre serverul \nOracle in mod transparent pentru utilizator care nu \nimplica nici o alta actiune ulterioara.\nCurs - BAZE DE DATE 26', 'De ce folosim indecsii?\n➢Indecsii ofera o metode de acces direct catre \ninregistrarile care se doresc extrase.\n➢Scopul lor este de a diminua operatile de intrare/iesire \ncatre disc prin folosirea unei metode de indexare a \ncailor catre acele date. \n➢Indecsii sunt utilizati si mentinuti de catre serverul \nOracle in mod transparent pentru utilizator care nu \nimplica nici o alta actiune ulterioara.\nCurs - BAZE DE DATE 26']","Conform informațiilor din text, bazele de date oferă multiple avantaje comparativ cu sistemele tradiționale bazate pe fișiere, printre care:

* **Reducerea redundanței:** Datele sunt stocate o singură dată, eliminând duplicarea informațiilor.
* **Îmbunătățirea integrității:** Datele respectă reguli de consistență, asigurând validitatea și acuratețea lor.
* **Acces facil la date:** Utilizatorii pot accesa rapid informațiile relevante, indiferent de volumul total de date. 

Textul menționează și ""limitări semnificative"" ale sistemelor bazate pe fișiere, sugerând că bazele de date au fost create pentru a le depăși, oferind astfel o soluție superioară. 
","Care sunt avantajele bazelor de date față de fișierele tradiționale, conform cursului?","['1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', 'Curs 1 \nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n 2', 'Curs 1 \nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n 2', 'Curs 1 \nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n 2', 'Curs 1 \nNoţiuni introductive \ndespre \nteoria generală a bazelor de date\n 2', 'De ce folosim indecsii?\n➢Indecsii ofera o metode de acces direct catre \ninregistrarile care se doresc extrase.\n➢Scopul lor este de a diminua operatile de intrare/iesire \ncatre disc prin folosirea unei metode de indexare a \ncailor catre acele date. \n➢Indecsii sunt utilizati si mentinuti de catre serverul \nOracle in mod transparent pentru utilizator care nu \nimplica nici o alta actiune ulterioara.\nCurs - BAZE DE DATE 26', 'De ce folosim indecsii?\n➢Indecsii ofera o metode de acces direct catre \ninregistrarile care se doresc extrase.\n➢Scopul lor este de a diminua operatile de intrare/iesire \ncatre disc prin folosirea unei metode de indexare a \ncailor catre acele date. \n➢Indecsii sunt utilizati si mentinuti de catre serverul \nOracle in mod transparent pentru utilizator care nu \nimplica nici o alta actiune ulterioara.\nCurs - BAZE DE DATE 26']","Conform informațiilor din text, bazele de date oferă multiple avantaje comparativ cu sistemele tradiționale bazate pe fișiere, printre care:

* **Reducerea redundanței:** Datele sunt stocate o singură dată, eliminând duplicarea informațiilor.
* **Îmbunătățirea integrității:** Datele respectă reguli de consistență, asigurând validitatea și acuratețea lor.
* **Acces facil la date:** Utilizatorii pot accesa rapid informațiile relevante, indiferent de volumul total de date. 

Textul menționează și ""limitări semnificative"" ale sistemelor bazate pe fișiere, sugerând că bazele de date au fost create pentru a le depăși, oferind astfel o soluție superioară. 
","Avantajele: elimină redundanța, îmbunătățesc integritatea, oferă acces flexibil și securitate sporită.",,,,,0.0067077791718752776,0.08547008547008547,
26,O3mini-high,Medium,Curs 13,,"Ce caracteristici are modelul relațional de baze de date, conform cursului?","Modelul relațional organizează datele în tabele, utilizează chei primare și străine pentru integritate și oferă independența datelor față de aplicații.",Este corect,pagina 1,"[""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', 'Noţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 43', 'Noţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 43']","Conform cursului, modelul relațional de baze de date are următoarele caracteristici principale: 

* **Datele sunt organizate în tabele bidimensionale.**
* **Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare.**
* **Cheile străine definesc relațiile între tabele.**
* **Independența datelor față de aplicațiile care le folosesc.**
* **Limbajul de interogare SQL este standardizat.** 
","Ce caracteristici are modelul relațional de baze de date, conform cursului?","[""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', 'Noţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 43', 'Noţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 43']","Conform cursului, modelul relațional de baze de date are următoarele caracteristici principale: 

* **Datele sunt organizate în tabele bidimensionale.**
* **Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare.**
* **Cheile străine definesc relațiile între tabele.**
* **Independența datelor față de aplicațiile care le folosesc.**
* **Limbajul de interogare SQL este standardizat.** 
","Modelul relațional organizează datele în tabele, utilizează chei primare și străine pentru integritate și oferă independența datelor față de aplicații.",,,,,0.026008450745511214,0.38961038961038963,
27,O3mini-high,Medium,Curs 14,,"Care sunt etapele proiectării bazelor de date relaționale, potrivit cursului?","Etapele sunt: 1. Identificarea cerințelor, 2. Modelarea conceptuală, 3. Modelarea logică, 4. Modelarea fizică, 5. Normalizarea.",Este corect,pagina 1,"['Concepte de bază din teoria relațională a \nbazelor de date\n46', 'Concepte de bază din teoria relațională a \nbazelor de date\n46', 'Concepte de bază din teoria relațională a \nbazelor de date\n46', 'Concepte de bază din teoria relațională a \nbazelor de date\n46', 'Concepte de bază din teoria relațională a bazelor de \ndate\n➢Înainte de a începe să realizăm o aplicaţie cu \nbaze de date relaţionale trebuie să cunoaştem \nprincipalele concepte din teoria relaţională.\n➢Acestea sunt absolut necesare, atât pentru \nanaliza şi proiectarea bazei de date \nrelaţionale, cât şi pentru elaborarea \nprogramelor de aplicaţie într-un SGBD \nrelaţional ales.\n 47', 'Concepte de bază din teoria relațională a bazelor de \ndate\n➢Înainte de a începe să realizăm o aplicaţie cu \nbaze de date relaţionale trebuie să cunoaştem \nprincipalele concepte din teoria relaţională.\n➢Acestea sunt absolut necesare, atât pentru \nanaliza şi proiectarea bazei de date \nrelaţionale, cât şi pentru elaborarea \nprogramelor de aplicaţie într-un SGBD \nrelaţional ales.\n 47', 'Concepte de bază din teoria relațională a bazelor de \ndate\n➢Înainte de a începe să realizăm o aplicaţie cu \nbaze de date relaţionale trebuie să cunoaştem \nprincipalele concepte din teoria relaţională.\n➢Acestea sunt absolut necesare, atât pentru \nanaliza şi proiectarea bazei de date \nrelaţionale, cât şi pentru elaborarea \nprogramelor de aplicaţie într-un SGBD \nrelaţional ales.\n 47', 'Concepte de bază din teoria relațională a bazelor de \ndate\n➢Înainte de a începe să realizăm o aplicaţie cu \nbaze de date relaţionale trebuie să cunoaştem \nprincipalele concepte din teoria relaţională.\n➢Acestea sunt absolut necesare, atât pentru \nanaliza şi proiectarea bazei de date \nrelaţionale, cât şi pentru elaborarea \nprogramelor de aplicaţie într-un SGBD \nrelaţional ales.\n 47', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54']","Fragmentul de text furnizat nu enumeră etapele de proiectare ale unei baze de date relaționale. Totuși, menționează că înainte de a crea o aplicație cu baze de date relaționale, este esențial să înțelegem conceptele de bază ale teoriei relaționale. Aceste concepte sunt necesare atât pentru analiza și proiectarea bazei de date, cât și pentru dezvoltarea aplicațiilor. 
","Care sunt etapele proiectării bazelor de date relaționale, potrivit cursului?","['Concepte de bază din teoria relațională a \nbazelor de date\n46', 'Concepte de bază din teoria relațională a \nbazelor de date\n46', 'Concepte de bază din teoria relațională a \nbazelor de date\n46', 'Concepte de bază din teoria relațională a \nbazelor de date\n46', 'Concepte de bază din teoria relațională a bazelor de \ndate\n➢Înainte de a începe să realizăm o aplicaţie cu \nbaze de date relaţionale trebuie să cunoaştem \nprincipalele concepte din teoria relaţională.\n➢Acestea sunt absolut necesare, atât pentru \nanaliza şi proiectarea bazei de date \nrelaţionale, cât şi pentru elaborarea \nprogramelor de aplicaţie într-un SGBD \nrelaţional ales.\n 47', 'Concepte de bază din teoria relațională a bazelor de \ndate\n➢Înainte de a începe să realizăm o aplicaţie cu \nbaze de date relaţionale trebuie să cunoaştem \nprincipalele concepte din teoria relaţională.\n➢Acestea sunt absolut necesare, atât pentru \nanaliza şi proiectarea bazei de date \nrelaţionale, cât şi pentru elaborarea \nprogramelor de aplicaţie într-un SGBD \nrelaţional ales.\n 47', 'Concepte de bază din teoria relațională a bazelor de \ndate\n➢Înainte de a începe să realizăm o aplicaţie cu \nbaze de date relaţionale trebuie să cunoaştem \nprincipalele concepte din teoria relaţională.\n➢Acestea sunt absolut necesare, atât pentru \nanaliza şi proiectarea bazei de date \nrelaţionale, cât şi pentru elaborarea \nprogramelor de aplicaţie într-un SGBD \nrelaţional ales.\n 47', 'Concepte de bază din teoria relațională a bazelor de \ndate\n➢Înainte de a începe să realizăm o aplicaţie cu \nbaze de date relaţionale trebuie să cunoaştem \nprincipalele concepte din teoria relaţională.\n➢Acestea sunt absolut necesare, atât pentru \nanaliza şi proiectarea bazei de date \nrelaţionale, cât şi pentru elaborarea \nprogramelor de aplicaţie într-un SGBD \nrelaţional ales.\n 47', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54', 'Concepte de bază din teoria relațională a bazelor de \ndate\nPentru exemplificare considerăm următoarea baza de \ndate FACULTATEcare contine cinci tabele:\n1.Tabela GRUPE cu cheile: profil si codgr=codul grupei\n2.Tabela STUDENTI cu cheile: codgr si codst=codul \nstudentului\n3.Tabela DISCIPLINE cu cheile codob=codul disciplinei si \ndenumire\n4.Tabela PROFESORI cu cheile codprof=codul \nprofesorului, numele si specializarea\n5.Tabela INCADRARE care are chei de la celelalte tabele: \ncodgr, codob si codprof.\n 54']","Fragmentul de text furnizat nu enumeră etapele de proiectare ale unei baze de date relaționale. Totuși, menționează că înainte de a crea o aplicație cu baze de date relaționale, este esențial să înțelegem conceptele de bază ale teoriei relaționale. Aceste concepte sunt necesare atât pentru analiza și proiectarea bazei de date, cât și pentru dezvoltarea aplicațiilor. 
","Etapele sunt: 1. Identificarea cerințelor, 2. Modelarea conceptuală, 3. Modelarea logică, 4. Modelarea fizică, 5. Normalizarea.",,,,,0.0,0.047619047619047616,
28,O3mini-high,High,"C1, C13",C12,"Comparați modelul relațional cu celelalte modele de baze de date, evidențiind avantajele fundamentale.","Modelul relațional organizează datele în tabele, folosind chei primare și străine pentru integritate și independența datelor” – spre deosebire de modelele ierarhice sau de rețea, care sunt mai rigide.",Partial corect,C12,"['Modele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\n 34', 'Modele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\n 34', 'Modele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\n 34', 'Modele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\n 34', 'Noţiuni introductive \ndespre teoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 57', 'Noţiuni introductive \ndespre teoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 57', 'Noţiuni introductive \ndespre teoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 57', 'Noţiuni introductive \ndespre teoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 57', 'Noţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 35', 'Noţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 35']","Informațiile furnizate în context menționează modelul relațional, modelul orientat pe obiecte, modelul obiect-relațional, modelul ierarhic și modelul rețea ca modele de baze de date. Din păcate, nu oferă detalii suplimentare despre avantajele și dezavantajele fiecăruia pentru a putea face o comparație detaliată. 

Pentru a răspunde la întrebarea ta, ar fi util să ai mai multe informații despre fiecare model în parte. 

Totuși, pot oferi o comparație generală a modelului relațional cu celelalte modele, evidențiind avantajele sale fundamentale:

**Modelul relațional:**

* **Simplitate și ușurință în utilizare:** Modelul relațional este intuitiv și ușor de înțeles, chiar și pentru utilizatorii neexperimentați. Datele sunt organizate în tabele cu rânduri și coloane, ceea ce îl face ușor de vizualizat și de interogat.
* **Flexibilitate:** Modelul relațional permite o mare flexibilitate în modelarea datelor și a relațiilor dintre acestea. Tabelele pot fi ușor adăugate, modificate sau șterse, iar relațiile dintre ele pot fi definite și actualizate după cum este necesar.
* **Integritate a datelor:** Modelul relațional oferă mecanisme puternice pentru asigurarea integrității datelor, cum ar fi cheile primare și restricțiile de integritate referențială. Aceste mecanisme ajută la prevenirea introducerii de date inconsistente sau incorecte în baza de date.
* **Suport larg din partea industriei:** Modelul relațional este cel mai popular model de baze de date și este suportat de o gamă largă de sisteme de gestionare a bazelor de date (SGBD). Aceasta înseamnă că există o mulțime de instrumente, resurse și expertiză disponibile pentru a sprijini dezvoltarea și gestionarea bazelor de date relaționale.

**Comparație cu alte modele:**

* **Modele ierarhice și de rețea:** Aceste modele sunt mai vechi și mai complexe decât modelul relațional. Ele se bazează pe o structură rigidă de tip arbore (ierarhic) sau graf (rețea), ceea ce le face mai puțin flexibile și mai dificil de utilizat.
* **Modelul orientat pe obiecte:** Acest model este mai potrivit pentru stocarea și gestionarea datelor complexe, cum ar fi obiectele multimedia. Cu toate acestea, poate fi mai complex de implementat și de gestionat decât modelul relațional.
* **Modelul obiect-relațional:** Acest model combină caracteristicile modelului relațional cu cele ale modelului orientat pe obiecte. Oferă un echilibru între flexibilitate și putere, dar poate fi, de asemenea, mai complex de implementat și de gestionat.

În concluzie, modelul relațional rămâne o alegere populară și eficientă pentru o gamă largă de aplicații de baze de date, datorită simplității, flexibilității și suportului său larg din partea industriei. 
","Comparați modelul relațional cu celelalte modele de baze de date, evidențiind avantajele fundamentale.","['Modele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\n 34', 'Modele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\n 34', 'Modele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\n 34', 'Modele de baze de date\nVom prezenta acum două din modele de\nbaze de date care sunt cele mai utilizate:\n1. Modelul de date relaţional\n2. Modelul de date orientate obiect\n 34', 'Noţiuni introductive \ndespre teoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 57', 'Noţiuni introductive \ndespre teoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 57', 'Noţiuni introductive \ndespre teoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 57', 'Noţiuni introductive \ndespre teoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 57', 'Noţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 35', 'Noţiuni introductive \ndespre \nteoria generală a bazelor de date\n1.1. Sisteme de baze de date\n1.2. Modelul de date relaţional\n1.3. Modelul de date orientate obiect\n1.4. Modelul de date obiect-relaţional\n1.5. Modelul de date ierarhic\n1.6. Modelul de date reţea\n 35']","Informațiile furnizate în context menționează modelul relațional, modelul orientat pe obiecte, modelul obiect-relațional, modelul ierarhic și modelul rețea ca modele de baze de date. Din păcate, nu oferă detalii suplimentare despre avantajele și dezavantajele fiecăruia pentru a putea face o comparație detaliată. 

Pentru a răspunde la întrebarea ta, ar fi util să ai mai multe informații despre fiecare model în parte. 

Totuși, pot oferi o comparație generală a modelului relațional cu celelalte modele, evidențiind avantajele sale fundamentale:

**Modelul relațional:**

* **Simplitate și ușurință în utilizare:** Modelul relațional este intuitiv și ușor de înțeles, chiar și pentru utilizatorii neexperimentați. Datele sunt organizate în tabele cu rânduri și coloane, ceea ce îl face ușor de vizualizat și de interogat.
* **Flexibilitate:** Modelul relațional permite o mare flexibilitate în modelarea datelor și a relațiilor dintre acestea. Tabelele pot fi ușor adăugate, modificate sau șterse, iar relațiile dintre ele pot fi definite și actualizate după cum este necesar.
* **Integritate a datelor:** Modelul relațional oferă mecanisme puternice pentru asigurarea integrității datelor, cum ar fi cheile primare și restricțiile de integritate referențială. Aceste mecanisme ajută la prevenirea introducerii de date inconsistente sau incorecte în baza de date.
* **Suport larg din partea industriei:** Modelul relațional este cel mai popular model de baze de date și este suportat de o gamă largă de sisteme de gestionare a bazelor de date (SGBD). Aceasta înseamnă că există o mulțime de instrumente, resurse și expertiză disponibile pentru a sprijini dezvoltarea și gestionarea bazelor de date relaționale.

**Comparație cu alte modele:**

* **Modele ierarhice și de rețea:** Aceste modele sunt mai vechi și mai complexe decât modelul relațional. Ele se bazează pe o structură rigidă de tip arbore (ierarhic) sau graf (rețea), ceea ce le face mai puțin flexibile și mai dificil de utilizat.
* **Modelul orientat pe obiecte:** Acest model este mai potrivit pentru stocarea și gestionarea datelor complexe, cum ar fi obiectele multimedia. Cu toate acestea, poate fi mai complex de implementat și de gestionat decât modelul relațional.
* **Modelul obiect-relațional:** Acest model combină caracteristicile modelului relațional cu cele ale modelului orientat pe obiecte. Oferă un echilibru între flexibilitate și putere, dar poate fi, de asemenea, mai complex de implementat și de gestionat.

În concluzie, modelul relațional rămâne o alegere populară și eficientă pentru o gamă largă de aplicații de baze de date, datorită simplității, flexibilității și suportului său larg din partea industriei. 
","Modelul relațional organizează datele în tabele, folosind chei primare și străine pentru integritate și independența datelor” – spre deosebire de modelele ierarhice sau de rețea, care sunt mai rigide.",,,,,0.019394585779096685,0.08033826638477802,
29,O3mini-high,High,"C2, C12",C1,Explicați evoluția SGBD-ului Oracle și diferențele față de alte tipuri de baze de date moderne.,"Oracle este un SGBD complet relațional, extins, cu facilități din tehnologia orientată obiect” și a evoluat de la arhitectura client/server la NC, integrând tehnici cloud și inovații pentru performanță și flexibilitate.",Este corect,C2,"['S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n39', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n39']","Contextul furnizat indică faptul că informațiile despre ""Evoluția și facilitățile sistemului ORACLE"" se găsesc în secțiunea 2.1 a unei surse despre SGBD-ul Oracle. 

Din păcate, contextul nu oferă detalii despre evoluția Oracle sau diferențele față de alte baze de date.  

Pentru a putea răspunde la întrebarea utilizatorului, ar fi nevoie să se consulte secțiunea 2.1 din sursa menționată sau alte surse relevante care detaliază:

* **Evoluția SGBD-ului Oracle:**  Cum a evoluat Oracle de-a lungul timpului, de la versiunile timpurii la cele actuale? Ce caracteristici noi au fost adăugate și cum s-a schimbat arhitectura sa?
* **Diferențe față de alte tipuri de baze de date moderne:** Ce caracteristici diferențiază Oracle de alte SGBD-uri populare, cum ar fi MySQL, PostgreSQL, MongoDB sau Microsoft SQL Server? Aceste diferențe pot include:
    * **Modelul de date:** relațional, document, graf, etc.
    * **Scalabilitate și performanță:** Cum se comportă Oracle în cazul unor volume mari de date sau a unui număr mare de utilizatori concurenți?
    * **Funcționalități:** Ce caracteristici specifice oferă Oracle, cum ar fi suport pentru tranzacții distribuite, replicare a datelor sau securitate avansată?
    * **Costuri și licențiere:** Care sunt costurile asociate cu utilizarea Oracle, inclusiv licențe, suport tehnic și mentenanță?

Prin urmare, pentru a oferi un răspuns complet, ar fi necesară o analiză mai detaliată a evoluției și caracteristicilor SGBD-ului Oracle, precum și o comparație cu alte sisteme de gestionare a bazelor de date moderne. 
",Explicați evoluția SGBD-ului Oracle și diferențele față de alte tipuri de baze de date moderne.,"['S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n3', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n22', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n39', 'S.G.B.D. ORACLE\n2.1. Evoluţia şi facilităţile sistemului ORACLE\n2.2. Arhitectura SGBD-ului ORACLE\n2.3. ORACLE Server\n2.4. Oracle Database 11g Express Edition\n39']","Contextul furnizat indică faptul că informațiile despre ""Evoluția și facilitățile sistemului ORACLE"" se găsesc în secțiunea 2.1 a unei surse despre SGBD-ul Oracle. 

Din păcate, contextul nu oferă detalii despre evoluția Oracle sau diferențele față de alte baze de date.  

Pentru a putea răspunde la întrebarea utilizatorului, ar fi nevoie să se consulte secțiunea 2.1 din sursa menționată sau alte surse relevante care detaliază:

* **Evoluția SGBD-ului Oracle:**  Cum a evoluat Oracle de-a lungul timpului, de la versiunile timpurii la cele actuale? Ce caracteristici noi au fost adăugate și cum s-a schimbat arhitectura sa?
* **Diferențe față de alte tipuri de baze de date moderne:** Ce caracteristici diferențiază Oracle de alte SGBD-uri populare, cum ar fi MySQL, PostgreSQL, MongoDB sau Microsoft SQL Server? Aceste diferențe pot include:
    * **Modelul de date:** relațional, document, graf, etc.
    * **Scalabilitate și performanță:** Cum se comportă Oracle în cazul unor volume mari de date sau a unui număr mare de utilizatori concurenți?
    * **Funcționalități:** Ce caracteristici specifice oferă Oracle, cum ar fi suport pentru tranzacții distribuite, replicare a datelor sau securitate avansată?
    * **Costuri și licențiere:** Care sunt costurile asociate cu utilizarea Oracle, inclusiv licențe, suport tehnic și mentenanță?

Prin urmare, pentru a oferi un răspuns complet, ar fi necesară o analiză mai detaliată a evoluției și caracteristicilor SGBD-ului Oracle, precum și o comparație cu alte sisteme de gestionare a bazelor de date moderne. 
","Oracle este un SGBD complet relațional, extins, cu facilități din tehnologia orientată obiect” și a evoluat de la arhitectura client/server la NC, integrând tehnici cloud și inovații pentru performanță și flexibilitate.",,,,,0.012265874789060258,0.08813559322033897,
30,O3mini-high,High,"C3, C4",C5,"Cum se combină clauzele WHERE, ORDER BY și funcțiile agregate pentru a obține rezultate sumare?","WHERE filtrează rândurile, ORDER BY sortează rezultatul, iar funcțiile de grup (ex. AVG, COUNT) calculează valori sumare pentru fiecare grup definit prin GROUP BY. Exemplu: „SELECT deptno, AVG(sal) FROM EMP GROUP BY deptno ORDER BY AVG(sal)” – rezultatul fiind o sumă statistică pe departamente.",Este corect,C5,"['4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17', '4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17', '4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17', '4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17', 'Ordinea de executie a functiilor de \ngrup\n Serverul Oracle execută funcţiile de grup într-o \nanumită ordine:\n1. Selecţia rândurilor ce respectă clauza WHERE \n2. Gruparea rândurilor obţinute, respectând clauza \nGROUP BY \n3. Calcularea rezultatelor funcţiilor de grup pentru \nfiecare grup în parte \n4. Eliminarea grupurilor ce nu respectă clauza HAVING \n5. Ordonarea rezultatelor respectând clauza GROUP BY.\nCurs 5 - BAZE DE DATE 49', 'Ordinea de executie a functiilor de \ngrup\n Serverul Oracle execută funcţiile de grup într-o \nanumită ordine:\n1. Selecţia rândurilor ce respectă clauza WHERE \n2. Gruparea rândurilor obţinute, respectând clauza \nGROUP BY \n3. Calcularea rezultatelor funcţiilor de grup pentru \nfiecare grup în parte \n4. Eliminarea grupurilor ce nu respectă clauza HAVING \n5. Ordonarea rezultatelor respectând clauza GROUP BY.\nCurs 5 - BAZE DE DATE 49', 'Ordinea de executie a functiilor de \ngrup\n Serverul Oracle execută funcţiile de grup într-o \nanumită ordine:\n1. Selecţia rândurilor ce respectă clauza WHERE \n2. Gruparea rândurilor obţinute, respectând clauza \nGROUP BY \n3. Calcularea rezultatelor funcţiilor de grup pentru \nfiecare grup în parte \n4. Eliminarea grupurilor ce nu respectă clauza HAVING \n5. Ordonarea rezultatelor respectând clauza GROUP BY.\nCurs 5 - BAZE DE DATE 49', 'Ordinea de executie a functiilor de \ngrup\n Serverul Oracle execută funcţiile de grup într-o \nanumită ordine:\n1. Selecţia rândurilor ce respectă clauza WHERE \n2. Gruparea rândurilor obţinute, respectând clauza \nGROUP BY \n3. Calcularea rezultatelor funcţiilor de grup pentru \nfiecare grup în parte \n4. Eliminarea grupurilor ce nu respectă clauza HAVING \n5. Ordonarea rezultatelor respectând clauza GROUP BY.\nCurs 5 - BAZE DE DATE 49', 'Clauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71', 'Clauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71']","Pentru a obține rezultate sumare utilizând clauzele WHERE, ORDER BY și funcțiile agregate, se urmeaza sintaxa prezentată mai jos:

```sql
SELECT [coloana,] functie_de_grup(coloana), ...
FROM tabel
[WHERE conditie]
[GROUP BY coloana]
[HAVING conditie_de_grupare]
[ORDER BY coloana]; 
```

Iată cum se combină:

1. **WHERE**: Se filtrează datele din tabel conform unei condiții specifice **înainte** de grupare.
2. **GROUP BY**: Se grupează rândurile cu valori identice într-o coloană specificată.
3. **Funcții agregate**: Se aplică funcții precum SUM, AVG, COUNT, MAX, MIN pe fiecare grup pentru a calcula un rezultat sumar.
4. **HAVING**: Se filtrează grupurile rezultate în urma grupării, similar cu clauza WHERE, dar aplicată pe rezultatele grupării.
5. **ORDER BY**: Se ordonează rezultatele finale, crescător (implicit) sau descrescător (cu DESC),  în funcție de o coloană sau o expresie.

**Exemplu:**

Să presupunem că avem un tabel cu comenzi și dorim să vedem suma totală a comenzilor pentru fiecare client, ordonată descrescător în funcție de valoarea totală:

```sql
SELECT nume_client, SUM(valoare_comanda) AS total_comenzi
FROM comenzi
GROUP BY nume_client
ORDER BY total_comenzi DESC;
```

Această interogare va:

1. Grupa toate comenzile după `nume_client`.
2. Calcula suma valorilor comenzilor (`valoare_comanda`) pentru fiecare client folosind funcția agregată `SUM`.
3. Ordona rezultatele descrescător (`DESC`) în funcție de `total_comenzi`, afișând clientul cu cele mai mari comenzi primul. 
","Cum se combină clauzele WHERE, ORDER BY și funcțiile agregate pentru a obține rezultate sumare?","['4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17', '4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17', '4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17', '4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17', 'Ordinea de executie a functiilor de \ngrup\n Serverul Oracle execută funcţiile de grup într-o \nanumită ordine:\n1. Selecţia rândurilor ce respectă clauza WHERE \n2. Gruparea rândurilor obţinute, respectând clauza \nGROUP BY \n3. Calcularea rezultatelor funcţiilor de grup pentru \nfiecare grup în parte \n4. Eliminarea grupurilor ce nu respectă clauza HAVING \n5. Ordonarea rezultatelor respectând clauza GROUP BY.\nCurs 5 - BAZE DE DATE 49', 'Ordinea de executie a functiilor de \ngrup\n Serverul Oracle execută funcţiile de grup într-o \nanumită ordine:\n1. Selecţia rândurilor ce respectă clauza WHERE \n2. Gruparea rândurilor obţinute, respectând clauza \nGROUP BY \n3. Calcularea rezultatelor funcţiilor de grup pentru \nfiecare grup în parte \n4. Eliminarea grupurilor ce nu respectă clauza HAVING \n5. Ordonarea rezultatelor respectând clauza GROUP BY.\nCurs 5 - BAZE DE DATE 49', 'Ordinea de executie a functiilor de \ngrup\n Serverul Oracle execută funcţiile de grup într-o \nanumită ordine:\n1. Selecţia rândurilor ce respectă clauza WHERE \n2. Gruparea rândurilor obţinute, respectând clauza \nGROUP BY \n3. Calcularea rezultatelor funcţiilor de grup pentru \nfiecare grup în parte \n4. Eliminarea grupurilor ce nu respectă clauza HAVING \n5. Ordonarea rezultatelor respectând clauza GROUP BY.\nCurs 5 - BAZE DE DATE 49', 'Ordinea de executie a functiilor de \ngrup\n Serverul Oracle execută funcţiile de grup într-o \nanumită ordine:\n1. Selecţia rândurilor ce respectă clauza WHERE \n2. Gruparea rândurilor obţinute, respectând clauza \nGROUP BY \n3. Calcularea rezultatelor funcţiilor de grup pentru \nfiecare grup în parte \n4. Eliminarea grupurilor ce nu respectă clauza HAVING \n5. Ordonarea rezultatelor respectând clauza GROUP BY.\nCurs 5 - BAZE DE DATE 49', 'Clauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71', 'Clauza ORDER BY\nunde:\nORDER BY - Specifică ordinea în care sunt ordonate \nrândurile\nASC - Ordonează rândurile crescător\nDESC - Ordonează rândurile descrescător \nSintaxa: \nSELECT coloana\nFROM tabela\n[WHERE conditie] \n[ORDER BY {coloana, expresie} \n[ASC/DESC]];\n 71']","Pentru a obține rezultate sumare utilizând clauzele WHERE, ORDER BY și funcțiile agregate, se urmeaza sintaxa prezentată mai jos:

```sql
SELECT [coloana,] functie_de_grup(coloana), ...
FROM tabel
[WHERE conditie]
[GROUP BY coloana]
[HAVING conditie_de_grupare]
[ORDER BY coloana]; 
```

Iată cum se combină:

1. **WHERE**: Se filtrează datele din tabel conform unei condiții specifice **înainte** de grupare.
2. **GROUP BY**: Se grupează rândurile cu valori identice într-o coloană specificată.
3. **Funcții agregate**: Se aplică funcții precum SUM, AVG, COUNT, MAX, MIN pe fiecare grup pentru a calcula un rezultat sumar.
4. **HAVING**: Se filtrează grupurile rezultate în urma grupării, similar cu clauza WHERE, dar aplicată pe rezultatele grupării.
5. **ORDER BY**: Se ordonează rezultatele finale, crescător (implicit) sau descrescător (cu DESC),  în funcție de o coloană sau o expresie.

**Exemplu:**

Să presupunem că avem un tabel cu comenzi și dorim să vedem suma totală a comenzilor pentru fiecare client, ordonată descrescător în funcție de valoarea totală:

```sql
SELECT nume_client, SUM(valoare_comanda) AS total_comenzi
FROM comenzi
GROUP BY nume_client
ORDER BY total_comenzi DESC;
```

Această interogare va:

1. Grupa toate comenzile după `nume_client`.
2. Calcula suma valorilor comenzilor (`valoare_comanda`) pentru fiecare client folosind funcția agregată `SUM`.
3. Ordona rezultatele descrescător (`DESC`) în funcție de `total_comenzi`, afișând clientul cu cele mai mari comenzi primul. 
","WHERE filtrează rândurile, ORDER BY sortează rezultatul, iar funcțiile de grup (ex. AVG, COUNT) calculează valori sumare pentru fiecare grup definit prin GROUP BY. Exemplu: „SELECT deptno, AVG(sal) FROM EMP GROUP BY deptno ORDER BY AVG(sal)” – rezultatul fiind o sumă statistică pe departamente.",,,,,0.031505630076935465,0.13986013986013987,
31,O3mini-high,High,"C4, C3",(C5),"Cum se utilizează funcțiile UPPER, LOWER și INITCAP în manipularea șirurilor și în condițiile din clauza WHERE?","Funcțiile UPPER, LOWER și INITCAP transformă șirurile pentru o comparare uniformă. De exemplu, „SELECT empno, UPPER(ename) FROM EMP WHERE INITCAP(ename) = 'Smith'” asigură că literele sunt comparate indiferent de caz, facilitând filtrarea corectă a datelor.",Este corect,"C5, slide 24","['Exemplu:\n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER.\nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename)\nFROM EMP; \nCurs 4 - BAZE DE DATE 26\n4.2.1. Funcţii pentru şiruri de caractere', 'Exemplu:\n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER.\nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename)\nFROM EMP; \nCurs 4 - BAZE DE DATE 26\n4.2.1. Funcţii pentru şiruri de caractere', 'Exemplu:\n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER.\nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename)\nFROM EMP; \nCurs 4 - BAZE DE DATE 26\n4.2.1. Funcţii pentru şiruri de caractere', 'Exemplu:\n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER.\nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename)\nFROM EMP; \nCurs 4 - BAZE DE DATE 26\n4.2.1. Funcţii pentru şiruri de caractere', ""Clauza WHERE\nDar ordinea se poate modifica dacă se folosesc \nparanteze. \nSELECT *\nFROM EMP\nWHERE (job = 'MANAGER' OR job = 'ANALYST')\nAND sal < 3000;\n 67\n"", ""Clauza WHERE\nDar ordinea se poate modifica dacă se folosesc \nparanteze. \nSELECT *\nFROM EMP\nWHERE (job = 'MANAGER' OR job = 'ANALYST')\nAND sal < 3000;\n 67\n"", ""Clauza WHERE\nDar ordinea se poate modifica dacă se folosesc \nparanteze. \nSELECT *\nFROM EMP\nWHERE (job = 'MANAGER' OR job = 'ANALYST')\nAND sal < 3000;\n 67\n"", ""Clauza WHERE\nDar ordinea se poate modifica dacă se folosesc \nparanteze. \nSELECT *\nFROM EMP\nWHERE (job = 'MANAGER' OR job = 'ANALYST')\nAND sal < 3000;\n 67\n"", '4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17', '4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17']","Contextul furnizat oferă un exemplu de utilizare a funcției `UPPER` în instrucțiunea `SELECT` pentru a afișa un nume de coloană cu majuscule, dar nu oferă informații despre utilizarea funcțiilor `LOWER`, `INITCAP` sau despre cum se pot utiliza aceste funcții în clauza `WHERE`. 

Pentru a răspunde întrebării tale, iată cum se pot utiliza funcțiile `UPPER`, `LOWER` și `INITCAP` în manipularea șirurilor și în condițiile din clauza `WHERE`:

**Funcția UPPER:**

- Returnează șirul cu toate literele majuscule.

**Exemplu în SELECT:**

```sql
SELECT UPPER(nume_coloana) AS NumeCuMajuscule
FROM nume_tabel;
```

**Exemplu în WHERE:**

```sql
SELECT *
FROM nume_tabel
WHERE UPPER(nume_coloana) = 'VALOARE';
```


**Funcția LOWER:**

- Returnează șirul cu toate literele minuscule.

**Exemplu în SELECT:**

```sql
SELECT LOWER(nume_coloana) AS NumeCuMinuscule
FROM nume_tabel;
```

**Exemplu în WHERE:**

```sql
SELECT *
FROM nume_tabel
WHERE LOWER(nume_coloana) = 'valoare';
```


**Funcția INITCAP:**

- Returnează șirul cu prima literă a fiecărui cuvânt majusculă, iar celelalte litere minuscule.

**Exemplu în SELECT:**

```sql
SELECT INITCAP(nume_coloana) AS NumeCuInițialeMajuscule
FROM nume_tabel;
```

**Exemplu în WHERE:**

```sql
SELECT *
FROM nume_tabel
WHERE INITCAP(nume_coloana) = 'Valoare';
```

**Utilizarea în clauza WHERE:**

Funcțiile `UPPER`, `LOWER` și `INITCAP` pot fi utile în clauza `WHERE` pentru a efectua comparații independente de majuscule sau minuscule. De exemplu, dacă doriți să selectați toate înregistrările în care `nume_coloana` este egală cu ""valoare"", indiferent de cum este scrisă valoarea (cu majuscule sau minuscule), puteți utiliza funcția `LOWER` sau `UPPER`:

```sql
SELECT *
FROM nume_tabel
WHERE LOWER(nume_coloana) = 'valoare';
```
","Cum se utilizează funcțiile UPPER, LOWER și INITCAP în manipularea șirurilor și în condițiile din clauza WHERE?","['Exemplu:\n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER.\nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename)\nFROM EMP; \nCurs 4 - BAZE DE DATE 26\n4.2.1. Funcţii pentru şiruri de caractere', 'Exemplu:\n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER.\nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename)\nFROM EMP; \nCurs 4 - BAZE DE DATE 26\n4.2.1. Funcţii pentru şiruri de caractere', 'Exemplu:\n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER.\nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename)\nFROM EMP; \nCurs 4 - BAZE DE DATE 26\n4.2.1. Funcţii pentru şiruri de caractere', 'Exemplu:\n  Pentru afişarea numelui cu majuscule de foloseşte \nfuncţia UPPER.\nSELECT empno, CONCAT(ename, job), ename, \nUPPER(ename)\nFROM EMP; \nCurs 4 - BAZE DE DATE 26\n4.2.1. Funcţii pentru şiruri de caractere', ""Clauza WHERE\nDar ordinea se poate modifica dacă se folosesc \nparanteze. \nSELECT *\nFROM EMP\nWHERE (job = 'MANAGER' OR job = 'ANALYST')\nAND sal < 3000;\n 67\n"", ""Clauza WHERE\nDar ordinea se poate modifica dacă se folosesc \nparanteze. \nSELECT *\nFROM EMP\nWHERE (job = 'MANAGER' OR job = 'ANALYST')\nAND sal < 3000;\n 67\n"", ""Clauza WHERE\nDar ordinea se poate modifica dacă se folosesc \nparanteze. \nSELECT *\nFROM EMP\nWHERE (job = 'MANAGER' OR job = 'ANALYST')\nAND sal < 3000;\n 67\n"", ""Clauza WHERE\nDar ordinea se poate modifica dacă se folosesc \nparanteze. \nSELECT *\nFROM EMP\nWHERE (job = 'MANAGER' OR job = 'ANALYST')\nAND sal < 3000;\n 67\n"", '4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17', '4.3. Funcții de grup\nSintaxa funcţiilor de grup:\nRezultatele sunt sortate implicit crescător. Pentru o \nordonare descrescătoare se va folosi clauza DESC după \nORDER BY. \nSELECT [coloana,] functie_de_grup(coloana), \n...\nFROM tabel\n[WHERE conditie]\n[GROUP BY coloana]\n[HAVING conditie_de_grupare]\n[ORDER BY coloana];  \nCurs 5 - BAZE DE DATE 17']","Contextul furnizat oferă un exemplu de utilizare a funcției `UPPER` în instrucțiunea `SELECT` pentru a afișa un nume de coloană cu majuscule, dar nu oferă informații despre utilizarea funcțiilor `LOWER`, `INITCAP` sau despre cum se pot utiliza aceste funcții în clauza `WHERE`. 

Pentru a răspunde întrebării tale, iată cum se pot utiliza funcțiile `UPPER`, `LOWER` și `INITCAP` în manipularea șirurilor și în condițiile din clauza `WHERE`:

**Funcția UPPER:**

- Returnează șirul cu toate literele majuscule.

**Exemplu în SELECT:**

```sql
SELECT UPPER(nume_coloana) AS NumeCuMajuscule
FROM nume_tabel;
```

**Exemplu în WHERE:**

```sql
SELECT *
FROM nume_tabel
WHERE UPPER(nume_coloana) = 'VALOARE';
```


**Funcția LOWER:**

- Returnează șirul cu toate literele minuscule.

**Exemplu în SELECT:**

```sql
SELECT LOWER(nume_coloana) AS NumeCuMinuscule
FROM nume_tabel;
```

**Exemplu în WHERE:**

```sql
SELECT *
FROM nume_tabel
WHERE LOWER(nume_coloana) = 'valoare';
```


**Funcția INITCAP:**

- Returnează șirul cu prima literă a fiecărui cuvânt majusculă, iar celelalte litere minuscule.

**Exemplu în SELECT:**

```sql
SELECT INITCAP(nume_coloana) AS NumeCuInițialeMajuscule
FROM nume_tabel;
```

**Exemplu în WHERE:**

```sql
SELECT *
FROM nume_tabel
WHERE INITCAP(nume_coloana) = 'Valoare';
```

**Utilizarea în clauza WHERE:**

Funcțiile `UPPER`, `LOWER` și `INITCAP` pot fi utile în clauza `WHERE` pentru a efectua comparații independente de majuscule sau minuscule. De exemplu, dacă doriți să selectați toate înregistrările în care `nume_coloana` este egală cu ""valoare"", indiferent de cum este scrisă valoarea (cu majuscule sau minuscule), puteți utiliza funcția `LOWER` sau `UPPER`:

```sql
SELECT *
FROM nume_tabel
WHERE LOWER(nume_coloana) = 'valoare';
```
","Funcțiile UPPER, LOWER și INITCAP transformă șirurile pentru o comparare uniformă. De exemplu, „SELECT empno, UPPER(ename) FROM EMP WHERE INITCAP(ename) = 'Smith'” asigură că literele sunt comparate indiferent de caz, facilitând filtrarea corectă a datelor.",,,,,0.011978273337400553,0.09271523178807947,
32,O3mini-high,High,"C6, C3",C5,Explicați mecanismul de execuție al unei subinterogări single-row și integrarea acesteia în clauza WHERE.,"O subinterogare single-row se execută înaintea interogării principale, returnând o valoare unică folosită în condiția WHERE. Exemplu: „WHERE sal > (SELECT sal FROM EMP WHERE ename = 'SMITH')” – fiecare salariu este comparat cu valoarea unică obținută din subquery.",Este corect,"C6, slide 11","['Crearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', 'Crearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', 'Crearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', 'Crearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', '6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9', '6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9', '6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9', '6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9', 'Constrângeri Cascadate\n⮚Constrângerile de tip CASCADE sunt utilizate cu \nclauza DROP COLUMN. \n⮚Constrângerea CASCADE şterge toate constrângerile \nde integritate ce se referă la cheile primare şi unice \ndefinite în coloanele şterse. \n⮚Şterge de asemenea toate constrângerile \nmulticoloane definite în coloanele şterse. \nCurs 8 - BAZE DE DATE 43', 'Constrângeri Cascadate\n⮚Constrângerile de tip CASCADE sunt utilizate cu \nclauza DROP COLUMN. \n⮚Constrângerea CASCADE şterge toate constrângerile \nde integritate ce se referă la cheile primare şi unice \ndefinite în coloanele şterse. \n⮚Şterge de asemenea toate constrângerile \nmulticoloane definite în coloanele şterse. \nCurs 8 - BAZE DE DATE 43']","O subinterogare single-row este o interogare imbricată într-o clauză SQL (cum ar fi SELECT, INSERT, UPDATE sau DELETE), care returnează un singur rând cu o singură coloană.  

**Mecanismul de execuție:**

1. **Executarea subinterogării:**  Baza de date execută mai întâi subinterogarea.
2. **Returnarea valorii:** Subinterogarea returnează o singură valoare (un singur rând cu o singură coloană) către interogarea principală.
3. **Utilizarea valorii în clauza WHERE:** Interogarea principală utilizează valoarea returnată de subinterogare pentru a evalua condiția din clauza WHERE.
4. **Filtrarea rezultatelor:** În funcție de rezultatul evaluării, interogarea principală selectează rândurile care îndeplinesc condiția.

**Integrarea în clauza WHERE:**

Subinterogarea single-row este integrată în clauza WHERE folosind operatori de comparație single-row: `=`, `>`, `<`, `>=`, `<=`.  

**Exemplu:**

Să presupunem că avem o tabelă `Angajati` cu coloanele `Nume`, `Salariu` și `Departament`. Dorim să găsim toți angajații care câștigă mai mult decât salariul mediu din departamentul 'Vanzari'.

```sql
SELECT Nume, Salariu
FROM Angajati
WHERE Salariu > (SELECT AVG(Salariu) 
                FROM Angajati
                WHERE Departament = 'Vânzări'); 
```

În acest exemplu:

1. Subinterogarea `(SELECT AVG(Salariu) FROM Angajati WHERE Departament = 'Vânzări')` calculează salariul mediu din departamentul 'Vânzări'.
2. Această valoare este apoi comparată cu salariul fiecărui angajat din tabela `Angajati` folosind operatorul `>`.
3. Interogarea principală returnează numele și salariul angajaților care câștigă mai mult decât salariul mediu calculat. 
",Explicați mecanismul de execuție al unei subinterogări single-row și integrarea acesteia în clauza WHERE.,"['Crearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', 'Crearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', 'Crearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', 'Crearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', '6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9', '6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9', '6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9', '6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9', 'Constrângeri Cascadate\n⮚Constrângerile de tip CASCADE sunt utilizate cu \nclauza DROP COLUMN. \n⮚Constrângerea CASCADE şterge toate constrângerile \nde integritate ce se referă la cheile primare şi unice \ndefinite în coloanele şterse. \n⮚Şterge de asemenea toate constrângerile \nmulticoloane definite în coloanele şterse. \nCurs 8 - BAZE DE DATE 43', 'Constrângeri Cascadate\n⮚Constrângerile de tip CASCADE sunt utilizate cu \nclauza DROP COLUMN. \n⮚Constrângerea CASCADE şterge toate constrângerile \nde integritate ce se referă la cheile primare şi unice \ndefinite în coloanele şterse. \n⮚Şterge de asemenea toate constrângerile \nmulticoloane definite în coloanele şterse. \nCurs 8 - BAZE DE DATE 43']","O subinterogare single-row este o interogare imbricată într-o clauză SQL (cum ar fi SELECT, INSERT, UPDATE sau DELETE), care returnează un singur rând cu o singură coloană.  

**Mecanismul de execuție:**

1. **Executarea subinterogării:**  Baza de date execută mai întâi subinterogarea.
2. **Returnarea valorii:** Subinterogarea returnează o singură valoare (un singur rând cu o singură coloană) către interogarea principală.
3. **Utilizarea valorii în clauza WHERE:** Interogarea principală utilizează valoarea returnată de subinterogare pentru a evalua condiția din clauza WHERE.
4. **Filtrarea rezultatelor:** În funcție de rezultatul evaluării, interogarea principală selectează rândurile care îndeplinesc condiția.

**Integrarea în clauza WHERE:**

Subinterogarea single-row este integrată în clauza WHERE folosind operatori de comparație single-row: `=`, `>`, `<`, `>=`, `<=`.  

**Exemplu:**

Să presupunem că avem o tabelă `Angajati` cu coloanele `Nume`, `Salariu` și `Departament`. Dorim să găsim toți angajații care câștigă mai mult decât salariul mediu din departamentul 'Vanzari'.

```sql
SELECT Nume, Salariu
FROM Angajati
WHERE Salariu > (SELECT AVG(Salariu) 
                FROM Angajati
                WHERE Departament = 'Vânzări'); 
```

În acest exemplu:

1. Subinterogarea `(SELECT AVG(Salariu) FROM Angajati WHERE Departament = 'Vânzări')` calculează salariul mediu din departamentul 'Vânzări'.
2. Această valoare este apoi comparată cu salariul fiecărui angajat din tabela `Angajati` folosind operatorul `>`.
3. Interogarea principală returnează numele și salariul angajaților care câștigă mai mult decât salariul mediu calculat. 
","O subinterogare single-row se execută înaintea interogării principale, returnând o valoare unică folosită în condiția WHERE. Exemplu: „WHERE sal > (SELECT sal FROM EMP WHERE ename = 'SMITH')” – fiecare salariu este comparat cu valoarea unică obținută din subquery.",,,,,0.058343471803385186,0.15217391304347827,
33,O3mini-high,High,C7,"C3, C6",Cum se utilizează instrucțiunea UPDATE combinată cu subinterogări pentru a actualiza date selective?,UPDATE poate folosi o subinterogare pentru a seta valori. Exemplu: „UPDATE EMP SET sal = (SELECT AVG(sal) FROM EMP) WHERE deptno = 10” actualizează salariile din departamentul 10 cu media salarială calculată prin subquery.,Este corect,C7,"['7.1.4. Instrucţiunea Merge\nInstrucţiunea MERGE permite inserarea \nsau actualizarea condiţionată a datelor \nîntr-un/dintr-un tabel al bazei de date. \nCurs 7 - BAZE DE DATE 34', '7.1.4. Instrucţiunea Merge\nInstrucţiunea MERGE permite inserarea \nsau actualizarea condiţionată a datelor \nîntr-un/dintr-un tabel al bazei de date. \nCurs 7 - BAZE DE DATE 34', '7.1.4. Instrucţiunea Merge\nInstrucţiunea MERGE permite inserarea \nsau actualizarea condiţionată a datelor \nîntr-un/dintr-un tabel al bazei de date. \nCurs 7 - BAZE DE DATE 34', '7.1.4. Instrucţiunea Merge\nInstrucţiunea MERGE permite inserarea \nsau actualizarea condiţionată a datelor \nîntr-un/dintr-un tabel al bazei de date. \nCurs 7 - BAZE DE DATE 34', '7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21', '7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21', '7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21', '7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21', 'Modificaţi vederea dept_sal utilizând comanda UPDATE. \nUPDATE dept_sal \nSET SAL_MEDIU = SAL_MEDIU + 1000\nWHERE cod = 10;\n \nCurs - BAZE DE DATE 39\n', 'Modificaţi vederea dept_sal utilizând comanda UPDATE. \nUPDATE dept_sal \nSET SAL_MEDIU = SAL_MEDIU + 1000\nWHERE cod = 10;\n \nCurs - BAZE DE DATE 39\n']","Contextul furnizat descrie instrucțiunea MERGE și sintaxa generală a instrucțiunii UPDATE în SQL, dar nu oferă informații specifice despre cum se combină UPDATE cu subinterogări pentru actualizarea selectivă a datelor. 

Pentru a actualiza date selective folosind UPDATE și subinterogări, puteți utiliza o clauză WHERE care include o subinterogare. Subinterogarea va returna un set de valori, iar clauza WHERE va selecta doar rândurile din tabelul principal care se potrivesc cu valorile returnate de subinterogare.

Iată un exemplu generic de sintaxă:

```sql
UPDATE tabel_principal
SET coloana1 = valoare1, coloana2 = valoare2, ...
WHERE coloana_cheie IN (SELECT coloana_cheie FROM tabel_secundar WHERE conditie);
```

**Explicație:**

* **UPDATE tabel_principal**: Specifică tabelul în care doriți să actualizați datele.
* **SET coloana1 = valoare1, coloana2 = valoare2, ...**: Specifică coloanele pe care doriți să le actualizați și noile valori pentru acestea.
* **WHERE coloana_cheie IN (subinterogare)**: Această clauză este esențială. 
    * **coloana_cheie** este coloana din tabelul principal pe care o utilizați pentru a face legătura cu subinterogarea.
    * **subinterogarea** este o interogare SELECT imbricată care selectează valori dintr-un alt tabel (tabel_secundar) pe baza unei anumite condiții.

**Exemplu concret:**

Să presupunem că aveți un tabel ""Angajati"" și un tabel ""Departamente"". Doriți să măriți salariul cu 10% pentru toți angajații din departamentul ""IT"". 

```sql
UPDATE Angajati
SET Salariu = Salariu * 1.10
WHERE ID_Departament IN (SELECT ID_Departament FROM Departamente WHERE Nume_Departament = 'IT');
```

În acest exemplu, subinterogarea selectează ID-ul departamentului ""IT"" din tabelul ""Departamente"". Apoi, clauza WHERE din instrucțiunea UPDATE selectează doar angajații al căror ID_Departament se potrivește cu ID-ul returnat de subinterogare.

Puteți adapta această structură generală pentru a efectua o gamă largă de actualizări selective utilizând UPDATE și subinterogări în funcție de nevoile dvs. specifice.
",Cum se utilizează instrucțiunea UPDATE combinată cu subinterogări pentru a actualiza date selective?,"['7.1.4. Instrucţiunea Merge\nInstrucţiunea MERGE permite inserarea \nsau actualizarea condiţionată a datelor \nîntr-un/dintr-un tabel al bazei de date. \nCurs 7 - BAZE DE DATE 34', '7.1.4. Instrucţiunea Merge\nInstrucţiunea MERGE permite inserarea \nsau actualizarea condiţionată a datelor \nîntr-un/dintr-un tabel al bazei de date. \nCurs 7 - BAZE DE DATE 34', '7.1.4. Instrucţiunea Merge\nInstrucţiunea MERGE permite inserarea \nsau actualizarea condiţionată a datelor \nîntr-un/dintr-un tabel al bazei de date. \nCurs 7 - BAZE DE DATE 34', '7.1.4. Instrucţiunea Merge\nInstrucţiunea MERGE permite inserarea \nsau actualizarea condiţionată a datelor \nîntr-un/dintr-un tabel al bazei de date. \nCurs 7 - BAZE DE DATE 34', '7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21', '7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21', '7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21', '7.1.2. Actualizarea datelor dintr-o tabelă\nSchimbarea liniilor existente folosind clauza \nUPDATE.\nSintaxa \nUPDATE tabela \nSET coloana = valoare \n[, coloana = valoare, . . . ] \n[WHERE conditie ]; \nCurs 7 - BAZE DE DATE 21', 'Modificaţi vederea dept_sal utilizând comanda UPDATE. \nUPDATE dept_sal \nSET SAL_MEDIU = SAL_MEDIU + 1000\nWHERE cod = 10;\n \nCurs - BAZE DE DATE 39\n', 'Modificaţi vederea dept_sal utilizând comanda UPDATE. \nUPDATE dept_sal \nSET SAL_MEDIU = SAL_MEDIU + 1000\nWHERE cod = 10;\n \nCurs - BAZE DE DATE 39\n']","Contextul furnizat descrie instrucțiunea MERGE și sintaxa generală a instrucțiunii UPDATE în SQL, dar nu oferă informații specifice despre cum se combină UPDATE cu subinterogări pentru actualizarea selectivă a datelor. 

Pentru a actualiza date selective folosind UPDATE și subinterogări, puteți utiliza o clauză WHERE care include o subinterogare. Subinterogarea va returna un set de valori, iar clauza WHERE va selecta doar rândurile din tabelul principal care se potrivesc cu valorile returnate de subinterogare.

Iată un exemplu generic de sintaxă:

```sql
UPDATE tabel_principal
SET coloana1 = valoare1, coloana2 = valoare2, ...
WHERE coloana_cheie IN (SELECT coloana_cheie FROM tabel_secundar WHERE conditie);
```

**Explicație:**

* **UPDATE tabel_principal**: Specifică tabelul în care doriți să actualizați datele.
* **SET coloana1 = valoare1, coloana2 = valoare2, ...**: Specifică coloanele pe care doriți să le actualizați și noile valori pentru acestea.
* **WHERE coloana_cheie IN (subinterogare)**: Această clauză este esențială. 
    * **coloana_cheie** este coloana din tabelul principal pe care o utilizați pentru a face legătura cu subinterogarea.
    * **subinterogarea** este o interogare SELECT imbricată care selectează valori dintr-un alt tabel (tabel_secundar) pe baza unei anumite condiții.

**Exemplu concret:**

Să presupunem că aveți un tabel ""Angajati"" și un tabel ""Departamente"". Doriți să măriți salariul cu 10% pentru toți angajații din departamentul ""IT"". 

```sql
UPDATE Angajati
SET Salariu = Salariu * 1.10
WHERE ID_Departament IN (SELECT ID_Departament FROM Departamente WHERE Nume_Departament = 'IT');
```

În acest exemplu, subinterogarea selectează ID-ul departamentului ""IT"" din tabelul ""Departamente"". Apoi, clauza WHERE din instrucțiunea UPDATE selectează doar angajații al căror ID_Departament se potrivește cu ID-ul returnat de subinterogare.

Puteți adapta această structură generală pentru a efectua o gamă largă de actualizări selective utilizând UPDATE și subinterogări în funcție de nevoile dvs. specifice.
",UPDATE poate folosi o subinterogare pentru a seta valori. Exemplu: „UPDATE EMP SET sal = (SELECT AVG(sal) FROM EMP) WHERE deptno = 10” actualizează salariile din departamentul 10 cu media salarială calculată prin subquery.,,,,,0.016422934488346717,0.08746355685131195,
34,O3mini-high,High,"C8, C11",C2,"Cum se aplică constrângerile de integritate (PRIMARY KEY, FOREIGN KEY, CHECK) pentru a asigura securitatea și consistența datelor?","Constrângerile asigură integritatea: PRIMARY KEY identifică unic fiecare rând, FOREIGN KEY “REFERENCES” stabilește relații corecte între tabele, iar CHECK impune condiții (ex.: CHECK(sal > 0)). Aceste reguli „previn pătrunderea de date invalide” și susțin securitatea în medii multi-user.",Este corect,"C11, slide 4","[""2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n); \n \n "", ""2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n); \n \n "", ""2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n); \n \n "", ""2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n); \n \n "", 'Cuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3', 'Cuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3', 'Cuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3', 'Cuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3', 'tt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5', 'tt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5']","Constrângerile de integritate sunt esențiale pentru a asigura securitatea și consistența datelor într-o bază de date. Iată cum se aplică ele:

**1. PRIMARY KEY:**

* **Securitate:**  Cheia primară nu are un rol direct în securitate, ci în identificarea unică a înregistrărilor. Această unicitate este fundamentală pentru alte mecanisme de securitate, permițând controlul accesului granular la date.
* **Consistență:** Asigură că fiecare înregistrare dintr-un tabel poate fi identificată unic. Previne duplicarea înregistrărilor și erorile de integritate referențială.

**2. FOREIGN KEY:**

* **Securitate:** Indirect, ajută la securitate prin menținerea integrității referențiale, prevenind ștergerea sau modificarea datelor care ar putea compromite alte tabele.
* **Consistență:**  Asigură relații valide între tabele. Doar valorile cheilor primare din tabelul părinte pot fi utilizate ca chei străine în tabelul copil.

**3. CHECK:**

* **Securitate:** Pot fi utilizate pentru a limita tipul de date introduse, prevenind introducerea de informații eronate sau malițioase.
* **Consistență:**  Permit definirea unor reguli specifice pentru valorile dintr-o coloană, asigurând că datele stocate respectă regulile de business. De exemplu, se poate impune ca vârsta unui client să fie mai mare de 18 ani.

**Exemplu din context:**

```sql
ALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); 
```

Această constrângere CHECK asigură că adresa de email introdusă în coloana ""Email"" din tabelul ""Student"" are un format valid (conține ""@"" și ""."").

**Concluzie:**

Constrângerile de integritate sunt esențiale pentru a construi baze de date robuste și fiabile,  contribuind la:

* **Integritatea datelor:** Datele sunt corecte și consistente.
* **Securitatea datelor:** Accesul și modificarea datelor sunt controlate.
* **Eficiența operațiunilor:** Interogările și operațiunile pe baza de date sunt mai rapide și mai eficiente.
","Cum se aplică constrângerile de integritate (PRIMARY KEY, FOREIGN KEY, CHECK) pentru a asigura securitatea și consistența datelor?","[""2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n); \n \n "", ""2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n); \n \n "", ""2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n); \n \n "", ""2. Integritatea datelor în proiectare \n \nPentru a asigura consistența bazei de date, sunt utilizate mai multe tipuri de constrângeri de \nintegritate: \n1. Cheia primară (PRIMARY KEY) - Asigură unicitatea fiecărei înregistrări. \n2. Cheia străină (FOREIGN KEY) - Asigură referențialitatea corectă între tabele. \n3. Constrângeri CHECK - Restricționează valorile acceptate într-o coloană. \n4. NOT NULL - Impune ca un atribut să nu fie gol. \n5. UNIQUE - Asigură valori unice pentru un atribut. \nExemplu de aplicare a integrității datelor: \nALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); \n \n \n3. Studii de caz despre proiectarea bazelor de date \n \n3.1. Sistem de gestionare a comenzilor în e-commerce \nO companie de comerț electronic trebuie să gestioneze produse, clienți și comenzi. \nCREATE TABLE Client ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Email V ARCHAR(50) UNIQUE \n); \n \nCREATE TABLE Produs ( \n    ID INT PRIMARY KEY , \n    Nume V ARCHAR(50), \n    Pret DECIMAL(10,2) \n); \n \nCREATE TABLE Comanda ( \n    ID INT PRIMARY KEY , \n    ClientID INT, \n    DataComanda DATE, \n    FOREIGN KEY (ClientID) REFERENCES Client(ID) \n); \n \nCREATE TABLE ComandaProdus ( \n    ComandaID INT, \n    ProdusID INT, \n    Cantitate INT, \n    PRIMARY KEY (ComandaID, ProdusID), \n    FOREIGN KEY (ComandaID) REFERENCES Comanda(ID), \n    FOREIGN KEY (ProdusID) REFERENCES Produs(ID) \n); \n \n "", 'Cuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3', 'Cuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3', 'Cuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3', 'Cuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3', 'tt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5', 'tt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5']","Constrângerile de integritate sunt esențiale pentru a asigura securitatea și consistența datelor într-o bază de date. Iată cum se aplică ele:

**1. PRIMARY KEY:**

* **Securitate:**  Cheia primară nu are un rol direct în securitate, ci în identificarea unică a înregistrărilor. Această unicitate este fundamentală pentru alte mecanisme de securitate, permițând controlul accesului granular la date.
* **Consistență:** Asigură că fiecare înregistrare dintr-un tabel poate fi identificată unic. Previne duplicarea înregistrărilor și erorile de integritate referențială.

**2. FOREIGN KEY:**

* **Securitate:** Indirect, ajută la securitate prin menținerea integrității referențiale, prevenind ștergerea sau modificarea datelor care ar putea compromite alte tabele.
* **Consistență:**  Asigură relații valide între tabele. Doar valorile cheilor primare din tabelul părinte pot fi utilizate ca chei străine în tabelul copil.

**3. CHECK:**

* **Securitate:** Pot fi utilizate pentru a limita tipul de date introduse, prevenind introducerea de informații eronate sau malițioase.
* **Consistență:**  Permit definirea unor reguli specifice pentru valorile dintr-o coloană, asigurând că datele stocate respectă regulile de business. De exemplu, se poate impune ca vârsta unui client să fie mai mare de 18 ani.

**Exemplu din context:**

```sql
ALTER TABLE Student ADD CONSTRAINT chk_email CHECK (Email LIKE '%@%.%'); 
```

Această constrângere CHECK asigură că adresa de email introdusă în coloana ""Email"" din tabelul ""Student"" are un format valid (conține ""@"" și ""."").

**Concluzie:**

Constrângerile de integritate sunt esențiale pentru a construi baze de date robuste și fiabile,  contribuind la:

* **Integritatea datelor:** Datele sunt corecte și consistente.
* **Securitatea datelor:** Accesul și modificarea datelor sunt controlate.
* **Eficiența operațiunilor:** Interogările și operațiunile pe baza de date sunt mai rapide și mai eficiente.
","Constrângerile asigură integritatea: PRIMARY KEY identifică unic fiecare rând, FOREIGN KEY “REFERENCES” stabilește relații corecte între tabele, iar CHECK impune condiții (ex.: CHECK(sal > 0)). Aceste reguli „previn pătrunderea de date invalide” și susțin securitatea în medii multi-user.",,,,,0.06150343144231885,0.11550151975683892,
35,O3mini-high,High,"C9, C3",C4,Ce avantaje oferă utilizarea vederilor (views) și cum simplifică ele interogările complexe?,"Vederile sunt „tabele logice” definite printr-o instrucțiune SELECT, care nu stochează date proprii, ci le extrag din tabele. Ele oferă acces restricționat, simplifică join-urile complexe și permit reutilizarea codului SQL, facilitând astfel interogările complexe.",Este corect,"C9, slide 6","['Crearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', 'Crearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', 'Crearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', 'Crearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', 'Clasificare\n Vederile se clasifică în: \n1.vederi simple\n2.vederi complexe\n  Pentru început prezentăm vederile \nsimple. \nCurs - BAZE DE DATE 7', 'Clasificare\n Vederile se clasifică în: \n1.vederi simple\n2.vederi complexe\n  Pentru început prezentăm vederile \nsimple. \nCurs - BAZE DE DATE 7', 'Clasificare\n Vederile se clasifică în: \n1.vederi simple\n2.vederi complexe\n  Pentru început prezentăm vederile \nsimple. \nCurs - BAZE DE DATE 7', 'Clasificare\n Vederile se clasifică în: \n1.vederi simple\n2.vederi complexe\n  Pentru început prezentăm vederile \nsimple. \nCurs - BAZE DE DATE 7', 'Avantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6', 'Avantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6']","Utilizarea vederilor (views) în bazele de date oferă multiple avantaje, simplificând în special interogările complexe. Iată câteva dintre ele:

* **Simplificarea interogărilor:** Vederile permit executarea unor cereri SQL simple, chiar dacă în spate rulează interogări complexe ce ar putea implica mai multe tabele și funcții. Acest lucru este benefic mai ales pentru utilizatorii care nu stăpânesc concepte avansate precum JOIN-urile.
* **Accesul la date din mai multe tabele:** O singură vedere poate combina date din multiple tabele, oferind o perspectivă unificată asupra informațiilor.
* **Securitate și controlul accesului:** Vederile pot fi utilizate pentru a oferi grupurilor de utilizatori acces doar la anumite date din tabele, protejând astfel informațiile sensibile.

Prin urmare, vederile acționează ca o interfață simplificată pentru datele din baza de date, facilitând accesul, interogarea și  securitatea informațiilor.
",Ce avantaje oferă utilizarea vederilor (views) și cum simplifică ele interogările complexe?,"['Crearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', 'Crearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', 'Crearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', 'Crearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', 'Clasificare\n Vederile se clasifică în: \n1.vederi simple\n2.vederi complexe\n  Pentru început prezentăm vederile \nsimple. \nCurs - BAZE DE DATE 7', 'Clasificare\n Vederile se clasifică în: \n1.vederi simple\n2.vederi complexe\n  Pentru început prezentăm vederile \nsimple. \nCurs - BAZE DE DATE 7', 'Clasificare\n Vederile se clasifică în: \n1.vederi simple\n2.vederi complexe\n  Pentru început prezentăm vederile \nsimple. \nCurs - BAZE DE DATE 7', 'Clasificare\n Vederile se clasifică în: \n1.vederi simple\n2.vederi complexe\n  Pentru început prezentăm vederile \nsimple. \nCurs - BAZE DE DATE 7', 'Avantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6', 'Avantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6']","Utilizarea vederilor (views) în bazele de date oferă multiple avantaje, simplificând în special interogările complexe. Iată câteva dintre ele:

* **Simplificarea interogărilor:** Vederile permit executarea unor cereri SQL simple, chiar dacă în spate rulează interogări complexe ce ar putea implica mai multe tabele și funcții. Acest lucru este benefic mai ales pentru utilizatorii care nu stăpânesc concepte avansate precum JOIN-urile.
* **Accesul la date din mai multe tabele:** O singură vedere poate combina date din multiple tabele, oferind o perspectivă unificată asupra informațiilor.
* **Securitate și controlul accesului:** Vederile pot fi utilizate pentru a oferi grupurilor de utilizatori acces doar la anumite date din tabele, protejând astfel informațiile sensibile.

Prin urmare, vederile acționează ca o interfață simplificată pentru datele din baza de date, facilitând accesul, interogarea și  securitatea informațiilor.
","Vederile sunt „tabele logice” definite printr-o instrucțiune SELECT, care nu stochează date proprii, ci le extrag din tabele. Ele oferă acces restricționat, simplifică join-urile complexe și permit reutilizarea codului SQL, facilitând astfel interogările complexe.",,,,,0.05109276028583519,0.11049723756906078,
36,O3mini-high,High,"C10, C3",C8,Cum contribuie secvențele și indicii la performanța bazelor de date?,"Secvențele generează „rapid numere întregi unice” pentru chei primare, evitând blocajele, iar indicii optimizează căutările prin reducerea operațiilor I/O. Astfel, ele îmbunătățesc semnificativ performanța bazei de date.",Este corect,C10,"['1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', 'Pentru realizarea unei aplicaţii care foloseşte baze de \ndate se poate proceda în două moduri:\na)Se creează baza de date cu ajutorul unei aplicaţii de tip server \nde baze de date şi se scriu apoi aplicaţiile care accesează baza \nde date într-un limbaj care posedă funcţiile necesare accesării \nserver-ului (frecvent se folosesc limbajele C++, Java, C# sau \nVisual Basic)\nb)Se foloseste o aplicaţie de tip sistem de gestiune de baze de \ndate (S.G.B.D. sau D.B.M.S. - DataBase Management System). \n      Un astfel de sistem oferă un ansamblu de instrumente \nsoftware cu ajutorul cărora se crează atât baza de date cât şi \naplicaţiile prin care aceasta este exploatată. \n      Pentru utilizatorii sistemului de operare Windows cele mai \ncunoscute sisteme de acest fel sunt Access şi Visual FoxPro. \n 18', 'Pentru realizarea unei aplicaţii care foloseşte baze de \ndate se poate proceda în două moduri:\na)Se creează baza de date cu ajutorul unei aplicaţii de tip server \nde baze de date şi se scriu apoi aplicaţiile care accesează baza \nde date într-un limbaj care posedă funcţiile necesare accesării \nserver-ului (frecvent se folosesc limbajele C++, Java, C# sau \nVisual Basic)\nb)Se foloseste o aplicaţie de tip sistem de gestiune de baze de \ndate (S.G.B.D. sau D.B.M.S. - DataBase Management System). \n      Un astfel de sistem oferă un ansamblu de instrumente \nsoftware cu ajutorul cărora se crează atât baza de date cât şi \naplicaţiile prin care aceasta este exploatată. \n      Pentru utilizatorii sistemului de operare Windows cele mai \ncunoscute sisteme de acest fel sunt Access şi Visual FoxPro. \n 18', 'Pentru realizarea unei aplicaţii care foloseşte baze de \ndate se poate proceda în două moduri:\na)Se creează baza de date cu ajutorul unei aplicaţii de tip server \nde baze de date şi se scriu apoi aplicaţiile care accesează baza \nde date într-un limbaj care posedă funcţiile necesare accesării \nserver-ului (frecvent se folosesc limbajele C++, Java, C# sau \nVisual Basic)\nb)Se foloseste o aplicaţie de tip sistem de gestiune de baze de \ndate (S.G.B.D. sau D.B.M.S. - DataBase Management System). \n      Un astfel de sistem oferă un ansamblu de instrumente \nsoftware cu ajutorul cărora se crează atât baza de date cât şi \naplicaţiile prin care aceasta este exploatată. \n      Pentru utilizatorii sistemului de operare Windows cele mai \ncunoscute sisteme de acest fel sunt Access şi Visual FoxPro. \n 18', 'Pentru realizarea unei aplicaţii care foloseşte baze de \ndate se poate proceda în două moduri:\na)Se creează baza de date cu ajutorul unei aplicaţii de tip server \nde baze de date şi se scriu apoi aplicaţiile care accesează baza \nde date într-un limbaj care posedă funcţiile necesare accesării \nserver-ului (frecvent se folosesc limbajele C++, Java, C# sau \nVisual Basic)\nb)Se foloseste o aplicaţie de tip sistem de gestiune de baze de \ndate (S.G.B.D. sau D.B.M.S. - DataBase Management System). \n      Un astfel de sistem oferă un ansamblu de instrumente \nsoftware cu ajutorul cărora se crează atât baza de date cât şi \naplicaţiile prin care aceasta este exploatată. \n      Pentru utilizatorii sistemului de operare Windows cele mai \ncunoscute sisteme de acest fel sunt Access şi Visual FoxPro. \n 18', 'Introducere\nObiectivele specifice:\nCurs: \n✓ Cunoaşterea noţiunilor privind bazele de date relaţionale\n✓ Modele de reprezentare a bazelor de date relaţionale\n✓ Arhitectura bazelor de date relaţionale\n✓ Analiza, implementarea şi prelucrarea bazelor de date cu \najutorul sistemului de gestiune a bazelor de date ORACLE \nDATABASE\nLaborator: \n✓ Se vor cunoaşte toate elementele de utilizare a unui sistem de \ngestiune a bazelor de date SQL (Structured Query Language)\n✓ Realizarea unor aplicatii de gestiune a bazelor de date in APEX\n(Application Express)\n 11', 'Introducere\nObiectivele specifice:\nCurs: \n✓ Cunoaşterea noţiunilor privind bazele de date relaţionale\n✓ Modele de reprezentare a bazelor de date relaţionale\n✓ Arhitectura bazelor de date relaţionale\n✓ Analiza, implementarea şi prelucrarea bazelor de date cu \najutorul sistemului de gestiune a bazelor de date ORACLE \nDATABASE\nLaborator: \n✓ Se vor cunoaşte toate elementele de utilizare a unui sistem de \ngestiune a bazelor de date SQL (Structured Query Language)\n✓ Realizarea unor aplicatii de gestiune a bazelor de date in APEX\n(Application Express)\n 11']","Îmi pare rău, dar contextul furnizat nu conține informații despre modul în care secvențele și indiciile contribuie la performanța bazelor de date. 

Te pot ajuta însă cu informații despre acest subiect, dacă dorești. 

Pe scurt, secvențele și indiciile sunt elemente esențiale pentru performanța bazelor de date:

* **Secvențele** sunt utilizate pentru a genera valori unice, secvențiale, utilizate de obicei ca chei primare. Utilizarea secvențelor previne conflictele la inserarea de noi înregistrări și îmbunătățește viteza de inserare. 
* **Indiciile** sunt structuri de date care permit SGBD-ului să localizeze rapid înregistrările care corespund unei anumite condiții, fără a fi necesară scanarea întregii tabele. Aceasta accelerează semnificativ interogările și operațiunile de filtrare.

Pentru a înțelege mai bine cum funcționează și ce beneficii aduc, ar fi util să-mi spui ce anume te interesează legat de secvențe și indicii în bazele de date. 
",Cum contribuie secvențele și indicii la performanța bazelor de date?,"['1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', 'Pentru realizarea unei aplicaţii care foloseşte baze de \ndate se poate proceda în două moduri:\na)Se creează baza de date cu ajutorul unei aplicaţii de tip server \nde baze de date şi se scriu apoi aplicaţiile care accesează baza \nde date într-un limbaj care posedă funcţiile necesare accesării \nserver-ului (frecvent se folosesc limbajele C++, Java, C# sau \nVisual Basic)\nb)Se foloseste o aplicaţie de tip sistem de gestiune de baze de \ndate (S.G.B.D. sau D.B.M.S. - DataBase Management System). \n      Un astfel de sistem oferă un ansamblu de instrumente \nsoftware cu ajutorul cărora se crează atât baza de date cât şi \naplicaţiile prin care aceasta este exploatată. \n      Pentru utilizatorii sistemului de operare Windows cele mai \ncunoscute sisteme de acest fel sunt Access şi Visual FoxPro. \n 18', 'Pentru realizarea unei aplicaţii care foloseşte baze de \ndate se poate proceda în două moduri:\na)Se creează baza de date cu ajutorul unei aplicaţii de tip server \nde baze de date şi se scriu apoi aplicaţiile care accesează baza \nde date într-un limbaj care posedă funcţiile necesare accesării \nserver-ului (frecvent se folosesc limbajele C++, Java, C# sau \nVisual Basic)\nb)Se foloseste o aplicaţie de tip sistem de gestiune de baze de \ndate (S.G.B.D. sau D.B.M.S. - DataBase Management System). \n      Un astfel de sistem oferă un ansamblu de instrumente \nsoftware cu ajutorul cărora se crează atât baza de date cât şi \naplicaţiile prin care aceasta este exploatată. \n      Pentru utilizatorii sistemului de operare Windows cele mai \ncunoscute sisteme de acest fel sunt Access şi Visual FoxPro. \n 18', 'Pentru realizarea unei aplicaţii care foloseşte baze de \ndate se poate proceda în două moduri:\na)Se creează baza de date cu ajutorul unei aplicaţii de tip server \nde baze de date şi se scriu apoi aplicaţiile care accesează baza \nde date într-un limbaj care posedă funcţiile necesare accesării \nserver-ului (frecvent se folosesc limbajele C++, Java, C# sau \nVisual Basic)\nb)Se foloseste o aplicaţie de tip sistem de gestiune de baze de \ndate (S.G.B.D. sau D.B.M.S. - DataBase Management System). \n      Un astfel de sistem oferă un ansamblu de instrumente \nsoftware cu ajutorul cărora se crează atât baza de date cât şi \naplicaţiile prin care aceasta este exploatată. \n      Pentru utilizatorii sistemului de operare Windows cele mai \ncunoscute sisteme de acest fel sunt Access şi Visual FoxPro. \n 18', 'Pentru realizarea unei aplicaţii care foloseşte baze de \ndate se poate proceda în două moduri:\na)Se creează baza de date cu ajutorul unei aplicaţii de tip server \nde baze de date şi se scriu apoi aplicaţiile care accesează baza \nde date într-un limbaj care posedă funcţiile necesare accesării \nserver-ului (frecvent se folosesc limbajele C++, Java, C# sau \nVisual Basic)\nb)Se foloseste o aplicaţie de tip sistem de gestiune de baze de \ndate (S.G.B.D. sau D.B.M.S. - DataBase Management System). \n      Un astfel de sistem oferă un ansamblu de instrumente \nsoftware cu ajutorul cărora se crează atât baza de date cât şi \naplicaţiile prin care aceasta este exploatată. \n      Pentru utilizatorii sistemului de operare Windows cele mai \ncunoscute sisteme de acest fel sunt Access şi Visual FoxPro. \n 18', 'Introducere\nObiectivele specifice:\nCurs: \n✓ Cunoaşterea noţiunilor privind bazele de date relaţionale\n✓ Modele de reprezentare a bazelor de date relaţionale\n✓ Arhitectura bazelor de date relaţionale\n✓ Analiza, implementarea şi prelucrarea bazelor de date cu \najutorul sistemului de gestiune a bazelor de date ORACLE \nDATABASE\nLaborator: \n✓ Se vor cunoaşte toate elementele de utilizare a unui sistem de \ngestiune a bazelor de date SQL (Structured Query Language)\n✓ Realizarea unor aplicatii de gestiune a bazelor de date in APEX\n(Application Express)\n 11', 'Introducere\nObiectivele specifice:\nCurs: \n✓ Cunoaşterea noţiunilor privind bazele de date relaţionale\n✓ Modele de reprezentare a bazelor de date relaţionale\n✓ Arhitectura bazelor de date relaţionale\n✓ Analiza, implementarea şi prelucrarea bazelor de date cu \najutorul sistemului de gestiune a bazelor de date ORACLE \nDATABASE\nLaborator: \n✓ Se vor cunoaşte toate elementele de utilizare a unui sistem de \ngestiune a bazelor de date SQL (Structured Query Language)\n✓ Realizarea unor aplicatii de gestiune a bazelor de date in APEX\n(Application Express)\n 11']","Îmi pare rău, dar contextul furnizat nu conține informații despre modul în care secvențele și indiciile contribuie la performanța bazelor de date. 

Te pot ajuta însă cu informații despre acest subiect, dacă dorești. 

Pe scurt, secvențele și indiciile sunt elemente esențiale pentru performanța bazelor de date:

* **Secvențele** sunt utilizate pentru a genera valori unice, secvențiale, utilizate de obicei ca chei primare. Utilizarea secvențelor previne conflictele la inserarea de noi înregistrări și îmbunătățește viteza de inserare. 
* **Indiciile** sunt structuri de date care permit SGBD-ului să localizeze rapid înregistrările care corespund unei anumite condiții, fără a fi necesară scanarea întregii tabele. Aceasta accelerează semnificativ interogările și operațiunile de filtrare.

Pentru a înțelege mai bine cum funcționează și ce beneficii aduc, ar fi util să-mi spui ce anume te interesează legat de secvențe și indicii în bazele de date. 
","Secvențele generează „rapid numere întregi unice” pentru chei primare, evitând blocajele, iar indicii optimizează căutările prin reducerea operațiilor I/O. Astfel, ele îmbunătățesc semnificativ performanța bazei de date.",,,,,0.03916449665002247,0.1206030150753769,
37,O3mini-high,High,"C11, C2",C8,Cum se implementează controlul accesului și gestionarea privilegiilor în Oracle?,"Controlul accesului se realizează prin acordarea de privilegii de sistem și obiect de către DBA, folosind comenzi precum CREATE USER și GRANT. Aceste măsuri „asigură securitatea utilizării și accesării bazei de date” într-un mediu multi-user.",Este corect,"C11, slide 18","['Controlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4', 'Controlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4', 'Controlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4', 'Controlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4', 'Confirmarea privilegiilor acordate\n➢Daca se încearca sa se efectueze o operatie \nneautorizata – de exemplu stergerea unui rând \ndintr-o tabela asupra careia nu avem \nprivilegiul DELETE – serverul Oracle nu va \npermite ca operatia sa fie efectuata.\nCurs - BAZE DE DATE 42', 'Confirmarea privilegiilor acordate\n➢Daca se încearca sa se efectueze o operatie \nneautorizata – de exemplu stergerea unui rând \ndintr-o tabela asupra careia nu avem \nprivilegiul DELETE – serverul Oracle nu va \npermite ca operatia sa fie efectuata.\nCurs - BAZE DE DATE 42', 'Confirmarea privilegiilor acordate\n➢Daca se încearca sa se efectueze o operatie \nneautorizata – de exemplu stergerea unui rând \ndintr-o tabela asupra careia nu avem \nprivilegiul DELETE – serverul Oracle nu va \npermite ca operatia sa fie efectuata.\nCurs - BAZE DE DATE 42', 'Confirmarea privilegiilor acordate\n➢Daca se încearca sa se efectueze o operatie \nneautorizata – de exemplu stergerea unui rând \ndintr-o tabela asupra careia nu avem \nprivilegiul DELETE – serverul Oracle nu va \npermite ca operatia sa fie efectuata.\nCurs - BAZE DE DATE 42', '2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27', '2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27']","În Oracle, controlul accesului și gestionarea privilegiilor se implementează prin următoarele mecanisme:

**1. Controlul accesului la baza de date:**

* Se acordă acces utilizatorilor specifici sau rolurilor.
* Se pot defini restricții de timp pentru acces.

**2. Acordarea accesului la obiecte specifice din baza de date:**

* Utilizatorii primesc privilegii specifice (SELECT, INSERT, UPDATE, DELETE) pe tabele, vizualizări, proceduri stocate etc.
*  Aceste privilegii se pot acorda direct sau prin intermediul rolurilor.

**3. Confirmarea privilegiilor date si primite cu ajutorul dicționarului de date Oracle:**

* Dicționarul de date Oracle stochează informații despre utilizatori, roluri și privilegii.
* Utilizatorii pot interoga dicționarul de date pentru a vedea ce privilegii au fost acordate.
* Încercarea de a efectua o operațiune neautorizată va fi blocată de serverul Oracle (exemplu: ștergerea unui rând dintr-o tabelă fără privilegiu DELETE).

**4. Crearea de sinonime pentru obiectele bazei de date:**

* Sinonimele oferă un nume alternativ pentru un obiect din baza de date.
*  Se pot utiliza pentru a simplifica accesul la obiecte sau pentru a ascunde complexitatea structurii bazei de date.

**Pe scurt, Oracle oferă un sistem robust de control al accesului și gestionare a privilegiilor, care permite administratorilor de baze de date să controleze cu precizie cine are acces la ce date și ce operațiuni pot efectua.**
",Cum se implementează controlul accesului și gestionarea privilegiilor în Oracle?,"['Controlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4', 'Controlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4', 'Controlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4', 'Controlul accesului utilizatorilor\nÎntr-un mediu multi-user, vrem sa mentinem \nsecuritatea utilizarii si accesarii  bazei de date. \nSecuritatea bazei de date de pe serverul Oracle \nne permite urmatoarele:\n➢Controlul accesului la baza de date \n➢Acordarea accesului la obiecte specifice din baza de \ndate\n➢Confirmarea privilegiilor date si primite cu ajutorul \ndictionarului de date Oracle\n➢Crearea de sinonime pentru obiectele bazei de date\nCurs - BAZE DE DATE 4', 'Confirmarea privilegiilor acordate\n➢Daca se încearca sa se efectueze o operatie \nneautorizata – de exemplu stergerea unui rând \ndintr-o tabela asupra careia nu avem \nprivilegiul DELETE – serverul Oracle nu va \npermite ca operatia sa fie efectuata.\nCurs - BAZE DE DATE 42', 'Confirmarea privilegiilor acordate\n➢Daca se încearca sa se efectueze o operatie \nneautorizata – de exemplu stergerea unui rând \ndintr-o tabela asupra careia nu avem \nprivilegiul DELETE – serverul Oracle nu va \npermite ca operatia sa fie efectuata.\nCurs - BAZE DE DATE 42', 'Confirmarea privilegiilor acordate\n➢Daca se încearca sa se efectueze o operatie \nneautorizata – de exemplu stergerea unui rând \ndintr-o tabela asupra careia nu avem \nprivilegiul DELETE – serverul Oracle nu va \npermite ca operatia sa fie efectuata.\nCurs - BAZE DE DATE 42', 'Confirmarea privilegiilor acordate\n➢Daca se încearca sa se efectueze o operatie \nneautorizata – de exemplu stergerea unui rând \ndintr-o tabela asupra careia nu avem \nprivilegiul DELETE – serverul Oracle nu va \npermite ca operatia sa fie efectuata.\nCurs - BAZE DE DATE 42', '2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27', '2.2. Arhitectura SGBD-ului ORACLE\nSistemul Oracle creează şi întreţine automat \ndicţionarul de date. \n➢Acesta face parte din baza de date Oracle şi conţine un set \nde tabele şi vizualizari (vederi) accesibile utilizatorilor doar în \nconsultare. \n➢Dicţionarul conţine informaţii de tipul: \n- numele utilizatorilor autorizaţi\n- drepturile de acces\n- numele obiectelor din baza de date\n- structurile de date\n- spaţiul ocupat de date\n- chei de acces\n27']","În Oracle, controlul accesului și gestionarea privilegiilor se implementează prin următoarele mecanisme:

**1. Controlul accesului la baza de date:**

* Se acordă acces utilizatorilor specifici sau rolurilor.
* Se pot defini restricții de timp pentru acces.

**2. Acordarea accesului la obiecte specifice din baza de date:**

* Utilizatorii primesc privilegii specifice (SELECT, INSERT, UPDATE, DELETE) pe tabele, vizualizări, proceduri stocate etc.
*  Aceste privilegii se pot acorda direct sau prin intermediul rolurilor.

**3. Confirmarea privilegiilor date si primite cu ajutorul dicționarului de date Oracle:**

* Dicționarul de date Oracle stochează informații despre utilizatori, roluri și privilegii.
* Utilizatorii pot interoga dicționarul de date pentru a vedea ce privilegii au fost acordate.
* Încercarea de a efectua o operațiune neautorizată va fi blocată de serverul Oracle (exemplu: ștergerea unui rând dintr-o tabelă fără privilegiu DELETE).

**4. Crearea de sinonime pentru obiectele bazei de date:**

* Sinonimele oferă un nume alternativ pentru un obiect din baza de date.
*  Se pot utiliza pentru a simplifica accesul la obiecte sau pentru a ascunde complexitatea structurii bazei de date.

**Pe scurt, Oracle oferă un sistem robust de control al accesului și gestionare a privilegiilor, care permite administratorilor de baze de date să controleze cu precizie cine are acces la ce date și ce operațiuni pot efectua.**
","Controlul accesului se realizează prin acordarea de privilegii de sistem și obiect de către DBA, folosind comenzi precum CREATE USER și GRANT. Aceste măsuri „asigură securitatea utilizării și accesării bazei de date” într-un mediu multi-user.",,,,,0.03419798030780472,0.11718749999999999,
38,O3mini-high,High,"C12, C1",C13,Care sunt principalele diferențe între sistemele tradiționale de fișiere și bazele de date moderne?,"Bazele de date moderne elimină redundanța, îmbunătățesc integritatea, oferă acces rapid și securitate sporită, spre deosebire de sistemele tradiționale de fișiere, unde datele sunt gestionate prin programe personalizate. „Accesul rapid și sigur la date” este un avantaj major al bazelor de date moderne.",Este corect,"C12, pagina 2","['1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20', '1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20', '1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20', '1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', '1.1.Sisteme de baze de date\nModelele bazelor de date permit \ndiferenţierea dintre descrierea bazei de date, \ncare este specificată în schemă, şi colecţia de \nconţinuturi sau de valori ale datelor din baza de \ndate la un moment dat, care se numeşte \ninstanţă. \n 29', '1.1.Sisteme de baze de date\nModelele bazelor de date permit \ndiferenţierea dintre descrierea bazei de date, \ncare este specificată în schemă, şi colecţia de \nconţinuturi sau de valori ale datelor din baza de \ndate la un moment dat, care se numeşte \ninstanţă. \n 29']","Înainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe fișiere tradiționale. Aceste sisteme aveau limitări semnificative, pe care bazele de date le-au rezolvat. 

Iată câteva diferențe principale:

**Sisteme tradiționale de fișiere:**

* Datele sunt stocate în fișiere text sau binare.
* Fiecare aplicație software trebuie să își implementeze propriile metode de acces și manipulare a datelor.
* Există risc crescut de redundanță a datelor (aceeași informație stocată în mai multe locuri).
* Integritatea datelor este dificil de menținut (asigurarea că datele sunt corecte și consistente).
* Accesul concurent la date este dificil de gestionat, ducând la potențiale conflicte și erori.

**Baze de date moderne:**

* Datele sunt organizate structurat în tabele, cu relații definite între ele.
* Un sistem de gestionare a bazelor de date (SGBD) oferă un mod unitar de a accesa și manipula datele, indiferent de aplicație.
* SGBD-urile oferă mecanisme pentru a reduce redundanța datelor și a menține integritatea datelor.
* Accesul concurent la date este gestionat eficient de către SGBD, prevenind conflictele și erorile.
* Oferă securitate sporită a datelor, controlând accesul prin permisiuni și autentificare. 

Pe scurt, bazele de date moderne oferă o modalitate mult mai eficientă, sigură și scalabilă de a gestiona datele comparativ cu sistemele tradiționale de fișiere.
",Care sunt principalele diferențe între sistemele tradiționale de fișiere și bazele de date moderne?,"['1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20', '1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20', '1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20', '1.1.Sisteme de baze de date\nUn sistem de baze de date este un sistem \ncomputerizat de evidenţă a informaţiilor. \nInformaţia într-un sistem de baze de date \nconsta atât din date cât şi din informaţii \ndespre date (metadate) cum ar fi relaţiile \ndintre date.\n 20', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', '1 \n \nCurs 12. Tipuri de baze de date \n \nConcepte ale bazelor de date \n \n \n \n1. Definiții și caracteristici ale bazelor de date \n \nBazele de date sunt fundamentale pentru gestionarea eficientă a informațiilor în era \ndigitală. Comparativ cu sistemele tradiționale bazate pe fișiere, bazele de date oferă multiple \navantaje, inclusiv reducerea redundanței, îmbunătățirea integrității și acces facil la date. \nComponentele unui sistem de baze de date – hardware, software, date, utilizatori și proceduri – \ncolaborează pentru a asigura o administrare eficientă și sigură a datelor. Pe măsură ce tehnologiile \nevoluează, bazele de date devin din ce în ce mai complexe, dar și mai eficiente în gestionarea \nvolumelor mari de informații. \n \n1.1. Ce este o bază de date? \nO bază de date este o colecție organizată de date care sunt stocate electronic și structurate \nîntr-un mod care permite accesul, gestionarea și actualizarea eficientă a acestora. Bazele de date \nsunt utilizate în aproape toate domeniile, inclusiv afaceri, sănătate, educație și cercetare, datorită \ncapacității lor de a gestiona volume mari de informații și de a permite acces rapid la date relevante. \nBazele de date sunt construite pe un model specific, cel mai utilizat fiind modelul relațional, care \norganizează datele în tabele interconectate. Alte modele includ modelul ierarhic, modelul rețea și \nmodelul orientat pe obiecte. Prin utilizarea unui Sistem de Gestionare a Bazelor de Date (SGBD), \nutilizatorii pot crea, interoga și manipula date fără a avea nevoie de cunoștințe avansate de \nprogramare. \nO bază de date trebuie să îndeplinească mai multe caracteristici esențiale: \n✓ Persistența datelor – Datele sunt stocate permanent și nu se pierd după oprirea sistemului. \n✓ Consecvența - Datele trebuie să respecte anumite  reguli de integritate pentru a asigura \nvaliditatea acestora. \n✓ Concurența - Mai mulți utilizatori pot accesa și modifica datele simultan fără a genera \nerori sau conflicte. \n✓ Securitatea - Accesul la date este controlat prin permisiuni și mecanisme de autentificare. \n✓ Independența datelor  - Modificările structurale nu afectează aplicațiile care utilizează \nbaza de date. \n \n1.2. Diferența dintre baze de date și fișiere tradiționale \nÎnainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe \nfișiere tradiționale. Aceste sisteme aveau limitări semnificative, iar bazele de date au fost \ndezvoltate pentru a rezolva aceste probleme. \n \n1.2.1. Sisteme de fișiere tradiționale \nÎn sistemele tradiționale bazate pe fișiere, datele sunt stocate în fișiere text sau binare, \ngestionate de aplicații software specifice. Fiecare aplicație trebuie să implementeze propriile \nmetode de acces și manipulare a datelor. \n ', '1.1.Sisteme de baze de date\nModelele bazelor de date permit \ndiferenţierea dintre descrierea bazei de date, \ncare este specificată în schemă, şi colecţia de \nconţinuturi sau de valori ale datelor din baza de \ndate la un moment dat, care se numeşte \ninstanţă. \n 29', '1.1.Sisteme de baze de date\nModelele bazelor de date permit \ndiferenţierea dintre descrierea bazei de date, \ncare este specificată în schemă, şi colecţia de \nconţinuturi sau de valori ale datelor din baza de \ndate la un moment dat, care se numeşte \ninstanţă. \n 29']","Înainte de apariția bazelor de date moderne, datele erau gestionate în sisteme bazate pe fișiere tradiționale. Aceste sisteme aveau limitări semnificative, pe care bazele de date le-au rezolvat. 

Iată câteva diferențe principale:

**Sisteme tradiționale de fișiere:**

* Datele sunt stocate în fișiere text sau binare.
* Fiecare aplicație software trebuie să își implementeze propriile metode de acces și manipulare a datelor.
* Există risc crescut de redundanță a datelor (aceeași informație stocată în mai multe locuri).
* Integritatea datelor este dificil de menținut (asigurarea că datele sunt corecte și consistente).
* Accesul concurent la date este dificil de gestionat, ducând la potențiale conflicte și erori.

**Baze de date moderne:**

* Datele sunt organizate structurat în tabele, cu relații definite între ele.
* Un sistem de gestionare a bazelor de date (SGBD) oferă un mod unitar de a accesa și manipula datele, indiferent de aplicație.
* SGBD-urile oferă mecanisme pentru a reduce redundanța datelor și a menține integritatea datelor.
* Accesul concurent la date este gestionat eficient de către SGBD, prevenind conflictele și erorile.
* Oferă securitate sporită a datelor, controlând accesul prin permisiuni și autentificare. 

Pe scurt, bazele de date moderne oferă o modalitate mult mai eficientă, sigură și scalabilă de a gestiona datele comparativ cu sistemele tradiționale de fișiere.
","Bazele de date moderne elimină redundanța, îmbunătățesc integritatea, oferă acces rapid și securitate sporită, spre deosebire de sistemele tradiționale de fișiere, unde datele sunt gestionate prin programe personalizate. „Accesul rapid și sigur la date” este un avantaj major al bazelor de date moderne.",,,,,0.18002829271425153,0.14652014652014655,
39,O3mini-high,High,"C13, C4",C5,Cum asigură modelul relațional integritatea datelor și ce rol joacă SQL în implementarea constrângerilor?,"Modelul relațional folosește chei primare și străine pentru a asigura integritatea, iar SQL permite definirea constrângerilor (ex.: PRIMARY KEY, FOREIGN KEY, CHECK). Aceste reguli „mențin coerența și validitatea datelor” la nivel de tabelă.",Este corect,"C13, pagina 1","[""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', 'Conţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\n 14\n', 'Conţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\n 14\n']","Modelul relațional asigură integritatea datelor prin utilizarea cheilor primare și a cheilor străine. 

**Cheile primare** sunt folosite pentru a identifica unic fiecare înregistrare dintr-un tabel. Asta înseamnă că nu pot exista două înregistrări cu aceeași valoare a cheii primare.

**Cheile străine** definesc relațiile dintre tabele. O cheie străină dintr-un tabel face referire la cheia primară a altui tabel, asigurând astfel că relațiile dintre înregistrări sunt valide și consistente. 

**SQL (Structured Query Language)** joacă un rol esențial în implementarea constrângerilor ce asigură integritatea datelor. Prin intermediul comenzilor SQL, se pot defini:

* **Chei primare:**  Cu ajutorul clauzei `PRIMARY KEY` se specifică ce coloană sau grup de coloane vor reprezenta cheia primară a unui tabel.
* **Chei străine:**  Clauza `FOREIGN KEY` definește o coloană sau un grup de coloane ca fiind cheie străină, făcând legătura cu cheia primară a altui tabel.
* **Restricții de integritate:** SQL permite definirea unor reguli suplimentare pentru a asigura  integritatea datelor. De exemplu, se poate specifica că o coloană nu poate avea valori nule (`NOT NULL`) sau că valorile dintr-o coloană trebuie să respecte un anumit format sau să se încadreze într-un anumit interval.

Prin urmare, modelul relațional asigură integritatea datelor prin chei primare și chei străine, iar SQL oferă instrumentele necesare pentru a implementa și impune aceste constrângeri în bazele de date relaționale. 
",Cum asigură modelul relațional integritatea datelor și ce rol joacă SQL în implementarea constrângerilor?,"[""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", ""Curs 13. Modelul relational de reprezentare a bazelor de date \n \n1. Definiția modelului relațional \nModelul relațional este o abordare a organizării datelor bazată pe tabele (relații), unde \nfiecare tabel conține un set de atribute și tuple (înregistrări). Relațiile dintre tabele sunt definite \nprin chei primare și chei străine, asigurând integritatea datelor. \n \n Caracteristici principale ale modelului relațional: \n- Datele sunt organizate în tabele bidimensionale. \n- Utilizarea cheilor primare pentru a identifica unic fiecare înregistrare. \n- Cheile străine definesc relațiile între tabele. \n- Independența datelor față de aplicațiile care le folosesc. \n- Limbajul de interogare SQL este standardizat. \n \n2. Algebra relațională \nAlgebra relațională este un set de operații matematice utilizate pentru a manipula datele din \nbazele de date relaționale. \n \n2.1. Operațiile fundamentale: \n1. Selecția (σ): Filtrează rândurile care îndeplinesc o anumită condiție. \n   - Ex.: σ (Nume='Popescu') (Student) \n   - SQL echivalent: SELECT * FROM Student WHERE Nume = 'Popescu'; \n \n2. Proiecția (π): Selectează anumite coloane dintr-un tabel. \n   - Ex.: π (Nume, Prenume) (Student) \n   - SQL echivalent: SELECT Nume, Prenume FROM Student; \n \n3. Reuniunea (∪): Combină două relații cu aceleași atribute. \n   - Ex.: Curs1 ∪ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 UNION SELECT * FROM Curs2; \n \n4. Intersecția (∩): Returnează elementele comune între două relații. \n   - Ex.: Curs1 ∩ Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 INTERSECT SELECT * FROM Curs2; \n \n5. Diferența (−): Returnează elementele dintr-o relație care nu se află în cealaltă. \n   - Ex.: Curs1 - Curs2 \n   - SQL echivalent: SELECT * FROM Curs1 EXCEPT SELECT * FROM Curs2; \n \n6. Produsul cartezian (×): Combină fiecare rând din prima relație cu fiecare rând din a doua. \n   - Ex.: Student × Curs \n   - SQL echivalent: SELECT * FROM Student, Curs; \n \n7. Îmbinarea (JOIN): Conectează două relații printr-o condiție comună. \n   - Ex.: Student ⨝ StudentID = Inscriere.StudentID Inscriere "", '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', '1.2.Modelul de date relaţional\nO bază de date este reprezentată cu ajutorul \nmodelului relaţional ca o colecţie de tabele.\nMult mai important, este faptul că acest model este \ndirect legat de conceptul matematic de relaţie şi este \ncompus din:\n1. o parte structurală. Schema bazei de date este o \ncolecţie de scheme de relaţii şi o bază de date este o \ncolecţie de relaţii.\n2. o parte de integritate. Chei primare şi chei străine.\n3. o parte de manipulare. Algebra relaţională şi calcul \nrelaţional.\n 36', 'Conţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\n 14\n', 'Conţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\n 14\n']","Modelul relațional asigură integritatea datelor prin utilizarea cheilor primare și a cheilor străine. 

**Cheile primare** sunt folosite pentru a identifica unic fiecare înregistrare dintr-un tabel. Asta înseamnă că nu pot exista două înregistrări cu aceeași valoare a cheii primare.

**Cheile străine** definesc relațiile dintre tabele. O cheie străină dintr-un tabel face referire la cheia primară a altui tabel, asigurând astfel că relațiile dintre înregistrări sunt valide și consistente. 

**SQL (Structured Query Language)** joacă un rol esențial în implementarea constrângerilor ce asigură integritatea datelor. Prin intermediul comenzilor SQL, se pot defini:

* **Chei primare:**  Cu ajutorul clauzei `PRIMARY KEY` se specifică ce coloană sau grup de coloane vor reprezenta cheia primară a unui tabel.
* **Chei străine:**  Clauza `FOREIGN KEY` definește o coloană sau un grup de coloane ca fiind cheie străină, făcând legătura cu cheia primară a altui tabel.
* **Restricții de integritate:** SQL permite definirea unor reguli suplimentare pentru a asigura  integritatea datelor. De exemplu, se poate specifica că o coloană nu poate avea valori nule (`NOT NULL`) sau că valorile dintr-o coloană trebuie să respecte un anumit format sau să se încadreze într-un anumit interval.

Prin urmare, modelul relațional asigură integritatea datelor prin chei primare și chei străine, iar SQL oferă instrumentele necesare pentru a implementa și impune aceste constrângeri în bazele de date relaționale. 
","Modelul relațional folosește chei primare și străine pentru a asigura integritatea, iar SQL permite definirea constrângerilor (ex.: PRIMARY KEY, FOREIGN KEY, CHECK). Aceste reguli „mențin coerența și validitatea datelor” la nivel de tabelă.",,,,,0.1004916995660316,0.14285714285714285,
40,O3mini-high,High,"C7, C6",C3,Cum se realizează o operație complexă de manipulare a datelor folosind subinterogări?,"Operația combină DML și subinterogări pentru actualizări selective. De exemplu: „UPDATE EMP SET sal = sal * 1.1 WHERE sal < (SELECT AVG(sal) FROM EMP)” actualizează salariile angajaților cu valori sub medie, folosind rezultatul unei subinterogări în clauza WHERE.",Este corect,Curs ???,"['Crearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', 'Crearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', 'Crearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', 'Crearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', 'De ce folosim indecsii?\n➢Indecsii ofera o metode de acces direct catre \ninregistrarile care se doresc extrase.\n➢Scopul lor este de a diminua operatile de intrare/iesire \ncatre disc prin folosirea unei metode de indexare a \ncailor catre acele date. \n➢Indecsii sunt utilizati si mentinuti de catre serverul \nOracle in mod transparent pentru utilizator care nu \nimplica nici o alta actiune ulterioara.\nCurs - BAZE DE DATE 26', 'De ce folosim indecsii?\n➢Indecsii ofera o metode de acces direct catre \ninregistrarile care se doresc extrase.\n➢Scopul lor este de a diminua operatile de intrare/iesire \ncatre disc prin folosirea unei metode de indexare a \ncailor catre acele date. \n➢Indecsii sunt utilizati si mentinuti de catre serverul \nOracle in mod transparent pentru utilizator care nu \nimplica nici o alta actiune ulterioara.\nCurs - BAZE DE DATE 26', 'De ce folosim indecsii?\n➢Indecsii ofera o metode de acces direct catre \ninregistrarile care se doresc extrase.\n➢Scopul lor este de a diminua operatile de intrare/iesire \ncatre disc prin folosirea unei metode de indexare a \ncailor catre acele date. \n➢Indecsii sunt utilizati si mentinuti de catre serverul \nOracle in mod transparent pentru utilizator care nu \nimplica nici o alta actiune ulterioara.\nCurs - BAZE DE DATE 26', 'De ce folosim indecsii?\n➢Indecsii ofera o metode de acces direct catre \ninregistrarile care se doresc extrase.\n➢Scopul lor este de a diminua operatile de intrare/iesire \ncatre disc prin folosirea unei metode de indexare a \ncailor catre acele date. \n➢Indecsii sunt utilizati si mentinuti de catre serverul \nOracle in mod transparent pentru utilizator care nu \nimplica nici o alta actiune ulterioara.\nCurs - BAZE DE DATE 26', '1.1.Sisteme de baze de date\nSGBD-ul utilizează o mulţime \ncomplexă de componente software \npentru a-şi îndeplini funcţiile sale. \nAceste componente includ:\n- managerul de date care furnizează o \ninterfaţă către datele stocate fizic în \nbaza de date;\n- procesorul de interogări care traduce \nlimbajul de interogare în instrucţiuni \npentru managerul de date;\n 31', '1.1.Sisteme de baze de date\nSGBD-ul utilizează o mulţime \ncomplexă de componente software \npentru a-şi îndeplini funcţiile sale. \nAceste componente includ:\n- managerul de date care furnizează o \ninterfaţă către datele stocate fizic în \nbaza de date;\n- procesorul de interogări care traduce \nlimbajul de interogare în instrucţiuni \npentru managerul de date;\n 31']","Informațiile furnizate nu conțin detalii despre realizarea unei operații complexe de manipulare a datelor folosind subinterogări. Textul se referă la crearea de vederi complexe și utilizarea funcțiilor de grup,  indexarea în bazele de date și componentele unui sistem de gestiune a bazelor de date (SGBD). 

Pentru a afla cum se realizează o operație complexă de manipulare a datelor folosind subinterogări, ar trebui să cauți informații despre:

* **Subinterogări (subqueries)**: Ce sunt subinterogările și cum funcționează ele în contextul interogărilor SQL.
* **Tipuri de subinterogări**: Diferitele tipuri de subinterogări, cum ar fi subinterogări scalare, subinterogări corelate și subinterogări imbricate.
* **Operatori utilizați cu subinterogări**:  Operatori precum IN, EXISTS, ANY, ALL, etc.
* **Exemple de utilizare**: Exemple concrete de interogări complexe care folosesc subinterogări pentru a extrage informații specifice din baza de date.

Recomand să cauți informații suplimentare despre subinterogări în documentația specifică a sistemului de gestiune a bazelor de date pe care îl utilizezi (ex: MySQL, PostgreSQL, Oracle, SQL Server, etc.). 
",Cum se realizează o operație complexă de manipulare a datelor folosind subinterogări?,"['Crearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', 'Crearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', 'Crearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', 'Crearea unei vederi complexe\nVom utiliza funcţii de grup pentru a afişa o vedere complexă \nasupra a 2 tabele.\nCurs - BAZE DE DATE 32\n', 'De ce folosim indecsii?\n➢Indecsii ofera o metode de acces direct catre \ninregistrarile care se doresc extrase.\n➢Scopul lor este de a diminua operatile de intrare/iesire \ncatre disc prin folosirea unei metode de indexare a \ncailor catre acele date. \n➢Indecsii sunt utilizati si mentinuti de catre serverul \nOracle in mod transparent pentru utilizator care nu \nimplica nici o alta actiune ulterioara.\nCurs - BAZE DE DATE 26', 'De ce folosim indecsii?\n➢Indecsii ofera o metode de acces direct catre \ninregistrarile care se doresc extrase.\n➢Scopul lor este de a diminua operatile de intrare/iesire \ncatre disc prin folosirea unei metode de indexare a \ncailor catre acele date. \n➢Indecsii sunt utilizati si mentinuti de catre serverul \nOracle in mod transparent pentru utilizator care nu \nimplica nici o alta actiune ulterioara.\nCurs - BAZE DE DATE 26', 'De ce folosim indecsii?\n➢Indecsii ofera o metode de acces direct catre \ninregistrarile care se doresc extrase.\n➢Scopul lor este de a diminua operatile de intrare/iesire \ncatre disc prin folosirea unei metode de indexare a \ncailor catre acele date. \n➢Indecsii sunt utilizati si mentinuti de catre serverul \nOracle in mod transparent pentru utilizator care nu \nimplica nici o alta actiune ulterioara.\nCurs - BAZE DE DATE 26', 'De ce folosim indecsii?\n➢Indecsii ofera o metode de acces direct catre \ninregistrarile care se doresc extrase.\n➢Scopul lor este de a diminua operatile de intrare/iesire \ncatre disc prin folosirea unei metode de indexare a \ncailor catre acele date. \n➢Indecsii sunt utilizati si mentinuti de catre serverul \nOracle in mod transparent pentru utilizator care nu \nimplica nici o alta actiune ulterioara.\nCurs - BAZE DE DATE 26', '1.1.Sisteme de baze de date\nSGBD-ul utilizează o mulţime \ncomplexă de componente software \npentru a-şi îndeplini funcţiile sale. \nAceste componente includ:\n- managerul de date care furnizează o \ninterfaţă către datele stocate fizic în \nbaza de date;\n- procesorul de interogări care traduce \nlimbajul de interogare în instrucţiuni \npentru managerul de date;\n 31', '1.1.Sisteme de baze de date\nSGBD-ul utilizează o mulţime \ncomplexă de componente software \npentru a-şi îndeplini funcţiile sale. \nAceste componente includ:\n- managerul de date care furnizează o \ninterfaţă către datele stocate fizic în \nbaza de date;\n- procesorul de interogări care traduce \nlimbajul de interogare în instrucţiuni \npentru managerul de date;\n 31']","Informațiile furnizate nu conțin detalii despre realizarea unei operații complexe de manipulare a datelor folosind subinterogări. Textul se referă la crearea de vederi complexe și utilizarea funcțiilor de grup,  indexarea în bazele de date și componentele unui sistem de gestiune a bazelor de date (SGBD). 

Pentru a afla cum se realizează o operație complexă de manipulare a datelor folosind subinterogări, ar trebui să cauți informații despre:

* **Subinterogări (subqueries)**: Ce sunt subinterogările și cum funcționează ele în contextul interogărilor SQL.
* **Tipuri de subinterogări**: Diferitele tipuri de subinterogări, cum ar fi subinterogări scalare, subinterogări corelate și subinterogări imbricate.
* **Operatori utilizați cu subinterogări**:  Operatori precum IN, EXISTS, ANY, ALL, etc.
* **Exemple de utilizare**: Exemple concrete de interogări complexe care folosesc subinterogări pentru a extrage informații specifice din baza de date.

Recomand să cauți informații suplimentare despre subinterogări în documentația specifică a sistemului de gestiune a bazelor de date pe care îl utilizezi (ex: MySQL, PostgreSQL, Oracle, SQL Server, etc.). 
","Operația combină DML și subinterogări pentru actualizări selective. De exemplu: „UPDATE EMP SET sal = sal * 1.1 WHERE sal < (SELECT AVG(sal) FROM EMP)” actualizează salariile angajaților cu valori sub medie, folosind rezultatul unei subinterogări în clauza WHERE.",,,,,0.0321858262703621,0.08849557522123894,
41,O3mini-high,High,"C8, C9",C11,Cum pot fi utilizate constrângerile și vederile pentru implementarea politicilor de securitate în baze de date?,"Constrângerile (NOT NULL, FOREIGN KEY, CHECK) asigură „integritatea datelor”, iar vederile controlează accesul la informații sensibile. Împreună, ele permit „controlul accesului la obiecte specifice” și implementează politici stricte de securitate în mediul de baze de date.",Este corect,Curs ???,"['tt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/', 'tt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/', 'tt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/', 'tt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/', 'Cuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3', 'Cuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3', 'Cuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3', 'Cuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3', 'tt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5', 'tt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5']","Informațiile furnizate din context nu oferă detalii despre constrângeri și vederi în contextul bazelor de date. Prin urmare, nu pot răspunde la întrebarea ta pe baza contextului dat. 
",Cum pot fi utilizate constrângerile și vederile pentru implementarea politicilor de securitate în baze de date?,"['tt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/', 'tt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/', 'tt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/', 'tt\n2) Securitatea bazei de date acopera accesarea \nsi utilizarea obiectelor bazei de date si actiunile \npe care acesti utilizatori le  pot efectua asupra  \nobiectelor.\nCurs - BAZE DE DATE 7\nhttps://www.opensourceforu.com/2020/09/a-comprehensive-look-at-opensource-database-security-concerns/', 'Cuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3', 'Cuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3', 'Cuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3', 'Cuprins\n1. Securitatea bazei de date\n    1.1. Securitatea sistemului\n    1.2. Securitatea datelor \n2. Privilegii de sistem\n3. Privilegii de obiect\n4. Scheme\nCurs - BAZE DE DATE 3', 'tt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5', 'tt\nSecuritatea bazei de date poate fi clasificata în \ndoua categorii: \n1) securitatea sistemului\n2) securitatea datelor\nCurs - BAZE DE DATE 5']","Informațiile furnizate din context nu oferă detalii despre constrângeri și vederi în contextul bazelor de date. Prin urmare, nu pot răspunde la întrebarea ta pe baza contextului dat. 
","Constrângerile (NOT NULL, FOREIGN KEY, CHECK) asigură „integritatea datelor”, iar vederile controlează accesul la informații sensibile. Împreună, ele permit „controlul accesului la obiecte specifice” și implementează politici stricte de securitate în mediul de baze de date.",,,,,0.042555413819961536,0.14492753623188406,
42,Manual - Test 1,,,1,Ce înseamnă SQL?,Structured Query Language,Este corect,,"['Curs 3 \nLimbajul SQL \n 2', 'Curs 3 \nLimbajul SQL \n 2', 'Curs 3 \nLimbajul SQL \n 2', 'Curs 3 \nLimbajul SQL \n 2', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Limbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3', 'Limbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3']","SQL este un limbaj utilizat pentru interogarea bazelor de date. 
",Ce înseamnă SQL?,"['Curs 3 \nLimbajul SQL \n 2', 'Curs 3 \nLimbajul SQL \n 2', 'Curs 3 \nLimbajul SQL \n 2', 'Curs 3 \nLimbajul SQL \n 2', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Limbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3', 'Limbajul SQL\nConstrângeri\nCurs 8 - BAZE DE DATE 3']","SQL este un limbaj utilizat pentru interogarea bazelor de date. 
",Structured Query Language,,,,,0.0,0.0,
43,Manual - Test 1,,,2,Ce instrucțiune SQL se folosește pentru extragerea datelor dintr-o bază de date?,SELECT,Este corect,,"['Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59']","Instrucțiunea SQL folosită pentru extragerea datelor dintr-o bază de date este instrucțiunea **SELECT**. 

Contextul menționează ""sublimbajul de interogare (DQL - data query language)"", iar instrucțiunea SELECT este elementul principal al DQL. 
",Ce instrucțiune SQL se folosește pentru extragerea datelor dintr-o bază de date?,"['Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59']","Instrucțiunea SQL folosită pentru extragerea datelor dintr-o bază de date este instrucțiunea **SELECT**. 

Contextul menționează ""sublimbajul de interogare (DQL - data query language)"", iar instrucțiunea SELECT este elementul principal al DQL. 
",SELECT,,,,,0.022869567780619007,0.05555555555555556,
44,Manual - Test 1,,,3,Ce instrucțiune SQL se folosește pentru actualizarea datelor dintr-o bază de date?,UPDATE,Este corect,,"['Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', '7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4', '7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4', '7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4', '7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3']","Instrucțiunea SQL folosită pentru actualizarea datelor dintr-o bază de date este o comandă DML (Data Manipulation Language). Din contextul furnizat, nu reiese o comandă anume, dar știm că actualizarea datelor se realizează prin comenzi DML. 
",Ce instrucțiune SQL se folosește pentru actualizarea datelor dintr-o bază de date?,"['Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', '7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4', '7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4', '7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4', '7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3']","Instrucțiunea SQL folosită pentru actualizarea datelor dintr-o bază de date este o comandă DML (Data Manipulation Language). Din contextul furnizat, nu reiese o comandă anume, dar știm că actualizarea datelor se realizează prin comenzi DML. 
",UPDATE,,,,,0.0,0.0,
45,Manual - Test 1,,,4,Ce instrucțiune SQL se folosește pentru ștergerea datelor dintr-o bază de date?,DELETE,Este corect,,"['Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', '7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4', '7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4', '7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4', '7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59']","Informațiile din context menționează că pentru ștergerea datelor dintr-o bază de date se folosesc comenzi DML (Data Manipulation Language) din limbajul SQL. 

Deși nu este specificată o comandă anume, în SQL, comanda folosită pentru a șterge date este **DELETE**. 

Exemplu:
```sql
DELETE FROM numele_tabelului
WHERE conditie;
```

""conditie"" se referă la criteriile pe baza cărora se selectează rândurile care vor fi șterse. 
",Ce instrucțiune SQL se folosește pentru ștergerea datelor dintr-o bază de date?,"['Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', '7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4', '7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4', '7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4', '7.1. Limbajul de manipulare al datelor \n(LMD)\nLimbajul de manipulare al datelor este \nnucleul limbajului SQL. \nCând doriţi să adăugaţi, să actualizaţi, sau să \nştergeţi date din baza de date, executaţi \ncomenzi DML(Data Manipulation Language).\nO colecţie de comenzi DML care formează o \nunitate logică reprezintă o tranzacţie. \nCurs 7 - BAZE DE DATE 4', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59']","Informațiile din context menționează că pentru ștergerea datelor dintr-o bază de date se folosesc comenzi DML (Data Manipulation Language) din limbajul SQL. 

Deși nu este specificată o comandă anume, în SQL, comanda folosită pentru a șterge date este **DELETE**. 

Exemplu:
```sql
DELETE FROM numele_tabelului
WHERE conditie;
```

""conditie"" se referă la criteriile pe baza cărora se selectează rândurile care vor fi șterse. 
",DELETE,,,,,0.0,0.028985507246376812,
46,Manual - Test 1,,,5,Ce instrucțiune SQL se folosește pentru inserarea de date noi într-o bază de date?,INSERT INTO,Este corect,,"['Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66']","Contextul furnizat nu conține informații despre instrucțiunea SQL specifică utilizată pentru inserarea de date noi într-o bază de date. Cu toate acestea, menționează ""**DML - data manipulation language**"" (limbajul de manipulare a datelor).  

Instrucțiunea SQL folosită pentru inserarea datelor face parte din DML și se numește **INSERT INTO**. 

Iată un exemplu de cum arată sintaxa:

```sql
INSERT INTO nume_tabel (coloana1, coloana2, ...) VALUES (valoare1, valoare2, ...);
```

Unde:

* **nume_tabel** este numele tabelului în care doriți să inserați date.
* **(coloana1, coloana2, ... )**  este o listă opțională a coloanelor în care doriți să inserați date. Dacă este omisă, se presupune că inserați valori în toate coloanele, în ordinea în care au fost definite în tabel.
* **(valoare1, valoare2, ... )** este o listă de valori care vor fi inserate în coloanele specificate. 

**Important:**  Contextul furnizat nu oferă suficiente informații pentru a oferi un răspuns mai detaliat sau specific. 
",Ce instrucțiune SQL se folosește pentru inserarea de date noi într-o bază de date?,"['Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n59', '2.5. Limbajul SQL\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - data \nquery language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor (DCL \n- data control language)\n       2.5.5. Comenzi ale sublimbajului de control al tranzactiilor \n(TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n66']","Contextul furnizat nu conține informații despre instrucțiunea SQL specifică utilizată pentru inserarea de date noi într-o bază de date. Cu toate acestea, menționează ""**DML - data manipulation language**"" (limbajul de manipulare a datelor).  

Instrucțiunea SQL folosită pentru inserarea datelor face parte din DML și se numește **INSERT INTO**. 

Iată un exemplu de cum arată sintaxa:

```sql
INSERT INTO nume_tabel (coloana1, coloana2, ...) VALUES (valoare1, valoare2, ...);
```

Unde:

* **nume_tabel** este numele tabelului în care doriți să inserați date.
* **(coloana1, coloana2, ... )**  este o listă opțională a coloanelor în care doriți să inserați date. Dacă este omisă, se presupune că inserați valori în toate coloanele, în ordinea în care au fost definite în tabel.
* **(valoare1, valoare2, ... )** este o listă de valori care vor fi inserate în coloanele specificate. 

**Important:**  Contextul furnizat nu oferă suficiente informații pentru a oferi un răspuns mai detaliat sau specific. 
",INSERT INTO,,,,,0.0,0.025477707006369425,
47,Manual - Test 1,,,6,"Folosind SQL, cum se selectează coloana ""FirstName"" din tabelul ""Persons"" ?",SELECT FirstName FROM Persons,Este corect,,"['2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'Pentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22', 'Pentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22']","```sql
SELECT FirstName
FROM Persons;
```
","Folosind SQL, cum se selectează coloana ""FirstName"" din tabelul ""Persons"" ?","['2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'Pentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22', 'Pentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22']","```sql
SELECT FirstName
FROM Persons;
```
",SELECT FirstName FROM Persons,,,,,0.21200626759025185,0.888888888888889,
48,Manual - Test 1,,,7,"Folosind SQL, cum se selectează toate coloanele din tabelul ""Persons""?",SELECT * FROM Persons,Este corect,,"['Pentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22', 'Pentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22', 'Pentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22', 'Pentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3']","Contextul furnizat nu oferă informații despre sintaxa exactă SQL pentru selectarea tuturor coloanelor dintr-un tabel. 

Totuși, pentru a selecta toate coloanele din tabelul ""Persons"" în SQL, se folosește caracterul wildcard ""*"":

```sql
SELECT *
FROM Persons;
```

Această instrucțiune va returna toate coloanele și toate rândurile din tabelul ""Persons"". 
","Folosind SQL, cum se selectează toate coloanele din tabelul ""Persons""?","['Pentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22', 'Pentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22', 'Pentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22', 'Pentru a vizualiza conţinutul vederii folosim \ncererea SQL SELECT. \nAtenţie: trebuiesc selectate alias-urile de coloană. \nExerciţiu:\n.........\nCurs - BAZE DE DATE 22', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3']","Contextul furnizat nu oferă informații despre sintaxa exactă SQL pentru selectarea tuturor coloanelor dintr-un tabel. 

Totuși, pentru a selecta toate coloanele din tabelul ""Persons"" în SQL, se folosește caracterul wildcard ""*"":

```sql
SELECT *
FROM Persons;
```

Această instrucțiune va returna toate coloanele și toate rândurile din tabelul ""Persons"". 
",SELECT * FROM Persons,,,,,0.0,0.1090909090909091,
49,Manual - Test 1,,,8,"Folosind SQL, cum se selectează toate înregistrările din tabelul ""Persons"" unde valoarea coloanei ""FirstName"" este ""Peter""?",SELECT * FROM Persons WHERE FirstName='Peter',Este corect,,"['2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23']","Contextul furnizat nu conține informații despre cum se selectează înregistrări din tabele SQL unde o coloană are o anumită valoare. 

Pentru a răspunde la întrebarea utilizatorului, iată declarația SQL corectă:

```sql
SELECT *
FROM Persons
WHERE FirstName = 'Peter';
```

Această declarație va selecta toate coloanele (`*`) din tabelul `Persons` unde valoarea coloanei `FirstName` este egală cu `'Peter'`. 
","Folosind SQL, cum se selectează toate înregistrările din tabelul ""Persons"" unde valoarea coloanei ""FirstName"" este ""Peter""?","['2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23']","Contextul furnizat nu conține informații despre cum se selectează înregistrări din tabele SQL unde o coloană are o anumită valoare. 

Pentru a răspunde la întrebarea utilizatorului, iată declarația SQL corectă:

```sql
SELECT *
FROM Persons
WHERE FirstName = 'Peter';
```

Această declarație va selecta toate coloanele (`*`) din tabelul `Persons` unde valoarea coloanei `FirstName` este egală cu `'Peter'`. 
",SELECT * FROM Persons WHERE FirstName='Peter',,,,,0.0,0.18181818181818182,
50,Manual - Test 1,,,9,"Folosind SQL, cum selectezi toate înregistrările dintr-un tabel numit ""Persons"" unde valoarea coloanei ""FirstName"" începe cu litera ""a""?",SELECT * FROM Persons WHERE FirstName LIKE 'a%',Este corect,,"['2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23']","Contextul oferit descrie sintaxa generală a numelor în SQL și prezintă exemple de query-uri, dar nu oferă informații specifice despre selectarea înregistrărilor unde o coloană începe cu o anumită literă. 

Pentru a selecta toate înregistrările dintr-un tabel numit ""Persons"" unde valoarea coloanei ""FirstName"" începe cu litera ""a"" folosind SQL, se poate utiliza clauza `WHERE` împreună cu operatorul `LIKE`. Iată query-ul:

```sql
SELECT *
FROM Persons
WHERE FirstName LIKE 'a%';
```

Explicație:

* `SELECT *`: Această clauză selectează toate coloanele (`*`) din tabelul `Persons`.
* `FROM Persons`: Această clauză specifică tabelul din care se vor selecta datele, în acest caz `Persons`.
* `WHERE FirstName LIKE 'a%'`: Această clauză filtrează rezultatele pentru a include doar rândurile în care valoarea coloanei `FirstName` începe cu ""a"". 
    * `LIKE` este un operator utilizat pentru a compara șiruri de caractere.
    * `'a%'` este un șablon care se potrivește cu orice șir de caractere care începe cu ""a"", urmat de orice alte caractere (reprezentate de `%`).

Acest query va returna toate înregistrările din tabelul `Persons` unde numele persoanei începe cu litera ""a"".
","Folosind SQL, cum selectezi toate înregistrările dintr-un tabel numit ""Persons"" unde valoarea coloanei ""FirstName"" începe cu litera ""a""?","['2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23']","Contextul oferit descrie sintaxa generală a numelor în SQL și prezintă exemple de query-uri, dar nu oferă informații specifice despre selectarea înregistrărilor unde o coloană începe cu o anumită literă. 

Pentru a selecta toate înregistrările dintr-un tabel numit ""Persons"" unde valoarea coloanei ""FirstName"" începe cu litera ""a"" folosind SQL, se poate utiliza clauza `WHERE` împreună cu operatorul `LIKE`. Iată query-ul:

```sql
SELECT *
FROM Persons
WHERE FirstName LIKE 'a%';
```

Explicație:

* `SELECT *`: Această clauză selectează toate coloanele (`*`) din tabelul `Persons`.
* `FROM Persons`: Această clauză specifică tabelul din care se vor selecta datele, în acest caz `Persons`.
* `WHERE FirstName LIKE 'a%'`: Această clauză filtrează rezultatele pentru a include doar rândurile în care valoarea coloanei `FirstName` începe cu ""a"". 
    * `LIKE` este un operator utilizat pentru a compara șiruri de caractere.
    * `'a%'` este un șablon care se potrivește cu orice șir de caractere care începe cu ""a"", urmat de orice alte caractere (reprezentate de `%`).

Acest query va returna toate înregistrările din tabelul `Persons` unde numele persoanei începe cu litera ""a"".
",SELECT * FROM Persons WHERE FirstName LIKE 'a%',,,,,0.0,0.07692307692307693,
51,Manual - Test 1,,,10,Operatorul OR afișează o înregistrare dacă oricare condiție este adevărată; operatorul AND afișează o înregistrare doar dacă toate condițiile sunt adevărate.,Adevărat,Este corect,,"['Funcţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14', 'Funcţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14', 'Funcţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14', 'Funcţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14', 'REZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8', 'REZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8', 'REZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8', 'REZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8', 'Funcţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 4 - BAZE DE DATE 11', 'Funcţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 4 - BAZE DE DATE 11']","Informația furnizată în prompt-ul utilizatorului se referă la operatorii logici **OR** și **AND**, utilizați în clauzele **WHERE** ale interogărilor SQL pentru a filtra înregistrările dintr-o bază de date. 

Contextul oferit descrie funcțiile SQL și clauzele **SELECT**, **WHERE** și **ORDER BY**, dar nu menționează explicit operatorii **OR** sau **AND**. 

Așadar, contextul nu conține informațiile necesare pentru a răspunde la întrebarea utilizatorului. 
",Operatorul OR afișează o înregistrare dacă oricare condiție este adevărată; operatorul AND afișează o înregistrare doar dacă toate condițiile sunt adevărate.,"['Funcţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14', 'Funcţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14', 'Funcţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14', 'Funcţii referitoare la o singură înregistrare\nFuncţiile referitoare la o singură înregistrare pot fi \nfolosite în:\na) clauza SELECT - pentru a modifica modul de \nafişare a datelor, pentru a realiza diferite calcule,\netc. \nb) clauza WHERE - pentru a scrie conditia pe baza \ncareia se afişează înregistrările(liniile) \nc) clauza ORDER BY- pentru a afisa datele pe baza \nunor criterii de sortare\nCurs 4 - BAZE DE DATE 14', 'REZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8', 'REZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8', 'REZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8', 'REZULTAT\n Evaluarea valorii de adevar a conditiei din \nWHERE se face doar pe baza datelor aflate pe \nlinia respectiva.\n  Deoarece parcurgerea liniilor specificata de \no cerere SELECT se face dupa un plan de \nexecutie generat de server, folosirea clauzei \nORDER BY este obligatorie în cazul în care se \ndoreste un rezultat sortat dupa anumite criterii.\n 8', 'Funcţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 4 - BAZE DE DATE 11', 'Funcţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 4 - BAZE DE DATE 11']","Informația furnizată în prompt-ul utilizatorului se referă la operatorii logici **OR** și **AND**, utilizați în clauzele **WHERE** ale interogărilor SQL pentru a filtra înregistrările dintr-o bază de date. 

Contextul oferit descrie funcțiile SQL și clauzele **SELECT**, **WHERE** și **ORDER BY**, dar nu menționează explicit operatorii **OR** sau **AND**. 

Așadar, contextul nu conține informațiile necesare pentru a răspunde la întrebarea utilizatorului. 
",Adevărat,,,,,0.0,0.0,
52,Manual - Test 1,,,11,"Folosind SQL, cum selectezi toate înregistrările dintr-un tabel numit ""Persons"" unde valoarea coloanei ""FirstName"" este ""Peter"" și valoarea coloanei ""LastName"" este ""Jackson""?",SELECT * FROM Persons WHERE FirstName='Peter' AND LastName='Jackson',Este corect,,"['2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16', '2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16', '2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16', '2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23']","Contextul furnizat nu conține informații despre cum să selectezi înregistrări dintr-un tabel folosind SQL unde FirstName este ""Peter"" și LastName este ""Jackson"". 

Totuși, pot să îți ofer sintaxa SQL pentru a rezolva această cerere:

```sql
SELECT *
FROM Persons
WHERE FirstName = 'Peter' AND LastName = 'Jackson';
```

Această interogare va selecta toate coloanele (`*`) din tabelul `Persons` unde coloana `FirstName` este egală cu ""Peter"" și coloana `LastName` este egală cu ""Jackson"".
","Folosind SQL, cum selectezi toate înregistrările dintr-un tabel numit ""Persons"" unde valoarea coloanei ""FirstName"" este ""Peter"" și valoarea coloanei ""LastName"" este ""Jackson""?","['2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16', '2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16', '2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16', '2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23']","Contextul furnizat nu conține informații despre cum să selectezi înregistrări dintr-un tabel folosind SQL unde FirstName este ""Peter"" și LastName este ""Jackson"". 

Totuși, pot să îți ofer sintaxa SQL pentru a rezolva această cerere:

```sql
SELECT *
FROM Persons
WHERE FirstName = 'Peter' AND LastName = 'Jackson';
```

Această interogare va selecta toate coloanele (`*`) din tabelul `Persons` unde coloana `FirstName` este egală cu ""Peter"" și coloana `LastName` este egală cu ""Jackson"".
",SELECT * FROM Persons WHERE FirstName='Peter' AND LastName='Jackson',,,,,0.01717906001229923,0.2222222222222222,
53,Manual - Test 1,,,12,"Folosing SQL, cum se selectează toate înregistrările din tabelul ""Persons"" unde valoarea coloanei ""LastName"" este între ""Hansen"" și ""Pettersen"" (inclusiv)?",SELECT * FROM Persons WHERE LastName BETWEEN 'Hansen' AND 'Pettersen',Este corect,,"['2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', '2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16', '2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16']","Contextul furnizat descrie crearea indexurilor și utilizarea secvențelor în SQL, dar nu oferă informații despre cum se selectează înregistrările dintr-un tabel pe baza unei valori cuprinse între două limite.

Pentru a selecta toate înregistrările din tabelul ""Persons"" unde valoarea coloanei ""LastName"" este între ""Hansen"" și ""Pettersen"" (inclusiv), se folosește clauza `BETWEEN` în clauza `WHERE` a instrucțiunii SQL.

Iată cum arată interogarea:

```sql
SELECT *
FROM Persons
WHERE LastName BETWEEN 'Hansen' AND 'Pettersen';
```

Această interogare va returna toate înregistrările din tabelul ""Persons"" unde valoarea coloanei ""LastName"" este mai mare sau egală cu ""Hansen"" și mai mică sau egală cu ""Pettersen"".
","Folosing SQL, cum se selectează toate înregistrările din tabelul ""Persons"" unde valoarea coloanei ""LastName"" este între ""Hansen"" și ""Pettersen"" (inclusiv)?","['2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', '2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16', '2. CURRVAL este folosita pentru a putea extrage din \ncadrul secventei ultima valoare care a fost generata. \n➢Precum am precizat anterior trebuie utilizata \npseudocoloana NEXTVAL pentru generarea valorii care \nva fi continuta in CURRVAL. \n➢CURRVAL este extras in acelasi mod in care se extrage \nsi valoarea NEXTVAL printr-o cerere SQL SELECT \nimpreuna cu numele secventei pentru care se doreste \naflarea valorii. \n➢Cand cererea se face cu ajutorul sintaxei \nnume_secventa.CURRVAL valoarea returnata va fi \nvaloarea care a fost folosita ultima data in cadrul \naceluiasi proces.\nCurs - BAZE DE DATE 16']","Contextul furnizat descrie crearea indexurilor și utilizarea secvențelor în SQL, dar nu oferă informații despre cum se selectează înregistrările dintr-un tabel pe baza unei valori cuprinse între două limite.

Pentru a selecta toate înregistrările din tabelul ""Persons"" unde valoarea coloanei ""LastName"" este între ""Hansen"" și ""Pettersen"" (inclusiv), se folosește clauza `BETWEEN` în clauza `WHERE` a instrucțiunii SQL.

Iată cum arată interogarea:

```sql
SELECT *
FROM Persons
WHERE LastName BETWEEN 'Hansen' AND 'Pettersen';
```

Această interogare va returna toate înregistrările din tabelul ""Persons"" unde valoarea coloanei ""LastName"" este mai mare sau egală cu ""Hansen"" și mai mică sau egală cu ""Pettersen"".
",SELECT * FROM Persons WHERE LastName BETWEEN 'Hansen' AND 'Pettersen',,,,,0.06359269312399485,0.15652173913043477,
54,Manual - Test 2,,,1,Care instrucțiune SQL este utilizată pentru a returna doar valori diferite?,SELECT DISTINCT,Este corect,,"['7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nControlul tranzacţiilor cu instrucţiuni SQL\nUrmătoarele instrucţiuni SQL sunt utilizate când \napar execuţii (commit) sau refaceri (rollback):\n• COMMIT[WORK]\n• SAVEPOINT nume_savepoint\n• ROLLBACK[WORK] to [SAVEPOINT] nume_savepoint\nDe notat că, COMMIT şi ROLLBACK sunt instrucţiuni \n(blocuri) SQL. \nCurs 7 - BAZE DE DATE 50', '7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nControlul tranzacţiilor cu instrucţiuni SQL\nUrmătoarele instrucţiuni SQL sunt utilizate când \napar execuţii (commit) sau refaceri (rollback):\n• COMMIT[WORK]\n• SAVEPOINT nume_savepoint\n• ROLLBACK[WORK] to [SAVEPOINT] nume_savepoint\nDe notat că, COMMIT şi ROLLBACK sunt instrucţiuni \n(blocuri) SQL. \nCurs 7 - BAZE DE DATE 50', '7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nControlul tranzacţiilor cu instrucţiuni SQL\nUrmătoarele instrucţiuni SQL sunt utilizate când \napar execuţii (commit) sau refaceri (rollback):\n• COMMIT[WORK]\n• SAVEPOINT nume_savepoint\n• ROLLBACK[WORK] to [SAVEPOINT] nume_savepoint\nDe notat că, COMMIT şi ROLLBACK sunt instrucţiuni \n(blocuri) SQL. \nCurs 7 - BAZE DE DATE 50', '7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nControlul tranzacţiilor cu instrucţiuni SQL\nUrmătoarele instrucţiuni SQL sunt utilizate când \napar execuţii (commit) sau refaceri (rollback):\n• COMMIT[WORK]\n• SAVEPOINT nume_savepoint\n• ROLLBACK[WORK] to [SAVEPOINT] nume_savepoint\nDe notat că, COMMIT şi ROLLBACK sunt instrucţiuni \n(blocuri) SQL. \nCurs 7 - BAZE DE DATE 50', '2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68', '2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68', '2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68', '2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oferă facilităţi din tehnologia OO, prin care se permite \ndefinirea şi utilizarea de obiecte mari şi complexe\n• Optimizează cererile de regăsire prin reutilizarea \ncomenzilor SQL identice lansate de utilizatori diferiţi şi \nprin realizarea unui plan de execuţie a instrucţiunilor \nSQL\n• Are un grad de securitate sporit prin: \n– server de criptare\n– control trafic reţea\n– niveluri de parolare, etc.\n11SGBD Oracle 8i (continuare)', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oferă facilităţi din tehnologia OO, prin care se permite \ndefinirea şi utilizarea de obiecte mari şi complexe\n• Optimizează cererile de regăsire prin reutilizarea \ncomenzilor SQL identice lansate de utilizatori diferiţi şi \nprin realizarea unui plan de execuţie a instrucţiunilor \nSQL\n• Are un grad de securitate sporit prin: \n– server de criptare\n– control trafic reţea\n– niveluri de parolare, etc.\n11SGBD Oracle 8i (continuare)']","Contextul oferit nu conține informații despre instrucțiunea SQL utilizată pentru a returna doar valori diferite. 

Totuși, instrucțiunea SQL utilizată pentru a returna doar valori distincte este **DISTINCT**. Aceasta se utilizează în cadrul clauzei SELECT a unei interogări. 

De exemplu:

```sql
SELECT DISTINCT nume_coloana FROM nume_tabel; 
```

Această interogare va returna toate valorile distincte (unice) din coloana ""nume_coloana"" a tabelului ""nume_tabel"".
",Care instrucțiune SQL este utilizată pentru a returna doar valori diferite?,"['7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nControlul tranzacţiilor cu instrucţiuni SQL\nUrmătoarele instrucţiuni SQL sunt utilizate când \napar execuţii (commit) sau refaceri (rollback):\n• COMMIT[WORK]\n• SAVEPOINT nume_savepoint\n• ROLLBACK[WORK] to [SAVEPOINT] nume_savepoint\nDe notat că, COMMIT şi ROLLBACK sunt instrucţiuni \n(blocuri) SQL. \nCurs 7 - BAZE DE DATE 50', '7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nControlul tranzacţiilor cu instrucţiuni SQL\nUrmătoarele instrucţiuni SQL sunt utilizate când \napar execuţii (commit) sau refaceri (rollback):\n• COMMIT[WORK]\n• SAVEPOINT nume_savepoint\n• ROLLBACK[WORK] to [SAVEPOINT] nume_savepoint\nDe notat că, COMMIT şi ROLLBACK sunt instrucţiuni \n(blocuri) SQL. \nCurs 7 - BAZE DE DATE 50', '7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nControlul tranzacţiilor cu instrucţiuni SQL\nUrmătoarele instrucţiuni SQL sunt utilizate când \napar execuţii (commit) sau refaceri (rollback):\n• COMMIT[WORK]\n• SAVEPOINT nume_savepoint\n• ROLLBACK[WORK] to [SAVEPOINT] nume_savepoint\nDe notat că, COMMIT şi ROLLBACK sunt instrucţiuni \n(blocuri) SQL. \nCurs 7 - BAZE DE DATE 50', '7.2. Limbajul de control al datelor (LCD). \nTranzacţii\nControlul tranzacţiilor cu instrucţiuni SQL\nUrmătoarele instrucţiuni SQL sunt utilizate când \napar execuţii (commit) sau refaceri (rollback):\n• COMMIT[WORK]\n• SAVEPOINT nume_savepoint\n• ROLLBACK[WORK] to [SAVEPOINT] nume_savepoint\nDe notat că, COMMIT şi ROLLBACK sunt instrucţiuni \n(blocuri) SQL. \nCurs 7 - BAZE DE DATE 50', '2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68', '2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68', '2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68', '2.6. Elemente ale limbajului SQL\nb) Cuvinte rezervate\nLa fel ca în orice limbaj, şi în SQL există o listă de \ncuvinte rezervate. Aceste cuvinte nu pot fi utilizate în \nalt scop decât cel definit iniţial.\nc) Constante\nO constantă sau literal este o valoare fixă care nu \npoate fi modificată.\n68', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oferă facilităţi din tehnologia OO, prin care se permite \ndefinirea şi utilizarea de obiecte mari şi complexe\n• Optimizează cererile de regăsire prin reutilizarea \ncomenzilor SQL identice lansate de utilizatori diferiţi şi \nprin realizarea unui plan de execuţie a instrucţiunilor \nSQL\n• Are un grad de securitate sporit prin: \n– server de criptare\n– control trafic reţea\n– niveluri de parolare, etc.\n11SGBD Oracle 8i (continuare)', '2.1. EVOLUŢIA ŞI FACILITĂŢILE SISTEMULUI ORACLE\n• Oferă facilităţi din tehnologia OO, prin care se permite \ndefinirea şi utilizarea de obiecte mari şi complexe\n• Optimizează cererile de regăsire prin reutilizarea \ncomenzilor SQL identice lansate de utilizatori diferiţi şi \nprin realizarea unui plan de execuţie a instrucţiunilor \nSQL\n• Are un grad de securitate sporit prin: \n– server de criptare\n– control trafic reţea\n– niveluri de parolare, etc.\n11SGBD Oracle 8i (continuare)']","Contextul oferit nu conține informații despre instrucțiunea SQL utilizată pentru a returna doar valori diferite. 

Totuși, instrucțiunea SQL utilizată pentru a returna doar valori distincte este **DISTINCT**. Aceasta se utilizează în cadrul clauzei SELECT a unei interogări. 

De exemplu:

```sql
SELECT DISTINCT nume_coloana FROM nume_tabel; 
```

Această interogare va returna toate valorile distincte (unice) din coloana ""nume_coloana"" a tabelului ""nume_tabel"".
",SELECT DISTINCT,,,,,0.0,0.05633802816901409,
55,Manual - Test 2,,,2,Ce cuvânt cheie SQL este folosit pentru a sorta multimea de rezultate?,ORDER BY,Este corect,,"['2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', 'Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', 'Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', 'Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', 'Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3']","Contextul furnizat nu conține informații despre cuvântul cheie SQL utilizat pentru sortarea setului de rezultate, ci prezintă elemente de bază ale limbajului SQL precum definirea numelor și crearea secvențelor. 

Cu toate acestea, cuvântul cheie SQL utilizat pentru a sorta setul de rezultate este **ORDER BY**.
",Ce cuvânt cheie SQL este folosit pentru a sorta multimea de rezultate?,"['2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', 'Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', 'Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', 'Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', 'Crearea secvenţelor\nO secvenţă poate fi creată utilizând următoarea sintaxa SQL: \n \nCREATE SEQUENCE nume_secventa\n   [INCREMENT BY n]\n   [START WITH n]\n   [{MAXVALUE n| NOMAXVALUE}]\n   [{MINVALUE n| NOMINVALUE}]\n   [{CYCLE | NOCYCLE}]\n   [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 10', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă\n3.1. SELECT. Sintaxa. Efect. Rezultat\n3.2. Lista SELECT\n3.3. Clauza WHERE\n3.4. Clauza ORDER BY\n 3']","Contextul furnizat nu conține informații despre cuvântul cheie SQL utilizat pentru sortarea setului de rezultate, ci prezintă elemente de bază ale limbajului SQL precum definirea numelor și crearea secvențelor. 

Cu toate acestea, cuvântul cheie SQL utilizat pentru a sorta setul de rezultate este **ORDER BY**.
",ORDER BY,,,,,0.0,0.07692307692307693,
56,Manual - Test 2,,,3,"Folosind SQL, cum se pot returna toate înregistrările dintr-un tabel numit ""Persons"" sortate descrescător după ""FirstName""?",SELECT * FROM Persons ORDER BY FirstName DESC,Este corect,,"['2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23']","```sql
SELECT *
FROM Persons
ORDER BY FirstName DESC;
```

Această interogare va selecta toate coloanele (`*`) din tabelul `Persons` și va sorta rezultatele în ordine descrescătoare (`DESC`) pe baza valorilor din coloana `FirstName`. 
","Folosind SQL, cum se pot returna toate înregistrările dintr-un tabel numit ""Persons"" sortate descrescător după ""FirstName""?","['2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', '2.6. Elemente ale limbajului SQL\n Principalele elemente care compun o comanda \nSQL:\na) Nume\n  Toate obiectele dintr-o bază de date: tabele, \ncoloane, vizualizări, indecşi, etc, au un nume.\n  Numele poate fi orice şir de maximum 30 de litere, \ncifre şi caractere speciale (“_”,”#”,”$”), primul caracter \nfiind obligatoriu o literă.\n67', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23']","```sql
SELECT *
FROM Persons
ORDER BY FirstName DESC;
```

Această interogare va selecta toate coloanele (`*`) din tabelul `Persons` și va sorta rezultatele în ordine descrescătoare (`DESC`) pe baza valorilor din coloana `FirstName`. 
",SELECT * FROM Persons ORDER BY FirstName DESC,,,,,0.126806763865757,0.358974358974359,
57,Manual - Test 2,,,4,"Folosind SQL, cum se inserează o înregistrare nouă în tabelul ""Persons""?","INSERT INTO Persons VALUES ('Jimmy', 'Jackson')",Este corect,,"['7.1.1. Adăugare o nouă \nînregistrare\nExemplu \nInserează în tabela Angajati datele personale, \nprecum şi data când acestea au fost introduse, prin \nutilizarea comenzii SYSDATE, care reprezintă data \nsistemului. \nCurs 7 - BAZE DE DATE 14', '7.1.1. Adăugare o nouă \nînregistrare\nExemplu \nInserează în tabela Angajati datele personale, \nprecum şi data când acestea au fost introduse, prin \nutilizarea comenzii SYSDATE, care reprezintă data \nsistemului. \nCurs 7 - BAZE DE DATE 14', '7.1.1. Adăugare o nouă \nînregistrare\nExemplu \nInserează în tabela Angajati datele personale, \nprecum şi data când acestea au fost introduse, prin \nutilizarea comenzii SYSDATE, care reprezintă data \nsistemului. \nCurs 7 - BAZE DE DATE 14', '7.1.1. Adăugare o nouă \nînregistrare\nExemplu \nInserează în tabela Angajati datele personale, \nprecum şi data când acestea au fost introduse, prin \nutilizarea comenzii SYSDATE, care reprezintă data \nsistemului. \nCurs 7 - BAZE DE DATE 14', ""3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46"", ""3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46"", ""3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46"", ""3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46"", 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3']","Contextul furnizat nu oferă informații specifice despre cum să introduceți o nouă înregistrare într-un tabel numit ""Persoane"" utilizând SQL. 

Totuși, contextul menționează adăugarea de înregistrări în tabela ""Angajati"". Putem deduce sintaxa generală pentru a insera o înregistrare într-un tabel SQL.

Sintaxa generală pentru a insera o înregistrare într-un tabel SQL este următoarea:

```sql
INSERT INTO nume_tabel (coloana1, coloana2, ...) VALUES (valoare1, valoare2, ...);
```

Înlocuiți următoarele:

* **nume_tabel**: Cu numele tabelului în care doriți să inserați înregistrarea (""Persons"" în cazul dvs.).
* **coloana1, coloana2, ...**: Cu numele coloanelor în care doriți să introduceți valori.
* **valoare1, valoare2, ...**: Cu valorile pe care doriți să le introduceți în coloanele respective. 

De exemplu, să presupunem că tabelul ""Persons"" are coloanele ""FirstName"", ""LastName"" și ""Age"". Următoarea declarație SQL ar insera o nouă persoană numită ""John"", ""Doe"", în vârstă de 30 de ani:

```sql
INSERT INTO Persons (FirstName, LastName, Age) VALUES ('John', 'Doe', 30);
``` 

Asigurați-vă că înlocuiți numele coloanelor și valorile cu cele specifice tabelului dvs. ""Persons"". 
","Folosind SQL, cum se inserează o înregistrare nouă în tabelul ""Persons""?","['7.1.1. Adăugare o nouă \nînregistrare\nExemplu \nInserează în tabela Angajati datele personale, \nprecum şi data când acestea au fost introduse, prin \nutilizarea comenzii SYSDATE, care reprezintă data \nsistemului. \nCurs 7 - BAZE DE DATE 14', '7.1.1. Adăugare o nouă \nînregistrare\nExemplu \nInserează în tabela Angajati datele personale, \nprecum şi data când acestea au fost introduse, prin \nutilizarea comenzii SYSDATE, care reprezintă data \nsistemului. \nCurs 7 - BAZE DE DATE 14', '7.1.1. Adăugare o nouă \nînregistrare\nExemplu \nInserează în tabela Angajati datele personale, \nprecum şi data când acestea au fost introduse, prin \nutilizarea comenzii SYSDATE, care reprezintă data \nsistemului. \nCurs 7 - BAZE DE DATE 14', '7.1.1. Adăugare o nouă \nînregistrare\nExemplu \nInserează în tabela Angajati datele personale, \nprecum şi data când acestea au fost introduse, prin \nutilizarea comenzii SYSDATE, care reprezintă data \nsistemului. \nCurs 7 - BAZE DE DATE 14', ""3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46"", ""3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46"", ""3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46"", ""3. Sinonime\nIn felul acesta nu vom mai fi obligati sa accesam in \ncererile noastre SQL tabela de departamente prin \nscrierea numelui tabelei 'department' si este suficienta \ndoar utilizarea denumirii noi create: 'dep'\nSELECT * FROM dep;\nCurs - BAZE DE DATE 46"", 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3', 'Limbajul SQL\nInterogări SELECT pe o singură tabelă (partea II)\n4.1. Funcţii\n4.2. Funcţii referitoare la o singură înregistrare\nCurs 4 - BAZE DE DATE 3']","Contextul furnizat nu oferă informații specifice despre cum să introduceți o nouă înregistrare într-un tabel numit ""Persoane"" utilizând SQL. 

Totuși, contextul menționează adăugarea de înregistrări în tabela ""Angajati"". Putem deduce sintaxa generală pentru a insera o înregistrare într-un tabel SQL.

Sintaxa generală pentru a insera o înregistrare într-un tabel SQL este următoarea:

```sql
INSERT INTO nume_tabel (coloana1, coloana2, ...) VALUES (valoare1, valoare2, ...);
```

Înlocuiți următoarele:

* **nume_tabel**: Cu numele tabelului în care doriți să inserați înregistrarea (""Persons"" în cazul dvs.).
* **coloana1, coloana2, ...**: Cu numele coloanelor în care doriți să introduceți valori.
* **valoare1, valoare2, ...**: Cu valorile pe care doriți să le introduceți în coloanele respective. 

De exemplu, să presupunem că tabelul ""Persons"" are coloanele ""FirstName"", ""LastName"" și ""Age"". Următoarea declarație SQL ar insera o nouă persoană numită ""John"", ""Doe"", în vârstă de 30 de ani:

```sql
INSERT INTO Persons (FirstName, LastName, Age) VALUES ('John', 'Doe', 30);
``` 

Asigurați-vă că înlocuiți numele coloanelor și valorile cu cele specifice tabelului dvs. ""Persons"". 
","INSERT INTO Persons VALUES ('Jimmy', 'Jackson')",,,,,0.0,0.0425531914893617,
58,Manual - Test 2,,,5,"Folosind SQL, cum se inserează ""Olsen"" ca ""LastName"" în tabelul ""Persons""?",INSERT INTO Persons (LastName) VALUES ('Olsen'),Este corect,,"['2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38']","Contextul furnizat nu conține informații despre cum să inserezi valori în tabelul ""Persons"" folosind SQL. Totuși, pot oferi o instrucțiune SQL generică pentru a face asta:

```sql
INSERT INTO Persons (LastName, FirstName, ...) 
VALUES ('Olsen', 'numele_mic', ...);
```

**Explicație:**

* **INSERT INTO Persons**: Această parte specifică tabelul în care vrei să adaugi date.
* **(LastName, FirstName, ... )**:  Aici trebuie să listezi toate coloanele în care dorești să inserezi valori. Am inclus ""LastName"" și ""FirstName"" ca exemplu, dar trebuie să le adaptezi la structura reală a tabelului tău.
* **VALUES ('Olsen', 'numele_mic', ... )**:  Aici specifici valorile pe care dorești să le inserezi în coloanele menționate anterior.  Asigură-te că ordinea valorilor corespunde cu ordinea coloanelor. Înlocuiește ""numele_mic"" cu prenumele pe care dorești să-l adaugi.

**Important!**  

* Asigură-te că înlocuiești  ""..."" cu coloanele rămase din tabelul ""Persons"" și valorile corespunzătoare pentru fiecare coloană. 
*  Această interogare presupune că tabelul ""Persons"" există și că ai permisiunile necesare pentru a insera date în el. 
","Folosind SQL, cum se inserează ""Olsen"" ca ""LastName"" în tabelul ""Persons""?","['2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', '2. Indecșii\nUrmatorul query poate fi folosit pentru tabela \n\'dept\'.\nSELECT ic.index_name, ic.column_name,              \nic.column_position col_pos, ix.uniqueness\nFROM   user_indexes ix, user_ind_columns ic\nWHERE  ic.table_name = ix.index_name\nAND      ic.table_name = ""dept"";\nCurs - BAZE DE DATE 36', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38']","Contextul furnizat nu conține informații despre cum să inserezi valori în tabelul ""Persons"" folosind SQL. Totuși, pot oferi o instrucțiune SQL generică pentru a face asta:

```sql
INSERT INTO Persons (LastName, FirstName, ...) 
VALUES ('Olsen', 'numele_mic', ...);
```

**Explicație:**

* **INSERT INTO Persons**: Această parte specifică tabelul în care vrei să adaugi date.
* **(LastName, FirstName, ... )**:  Aici trebuie să listezi toate coloanele în care dorești să inserezi valori. Am inclus ""LastName"" și ""FirstName"" ca exemplu, dar trebuie să le adaptezi la structura reală a tabelului tău.
* **VALUES ('Olsen', 'numele_mic', ... )**:  Aici specifici valorile pe care dorești să le inserezi în coloanele menționate anterior.  Asigură-te că ordinea valorilor corespunde cu ordinea coloanelor. Înlocuiește ""numele_mic"" cu prenumele pe care dorești să-l adaugi.

**Important!**  

* Asigură-te că înlocuiești  ""..."" cu coloanele rămase din tabelul ""Persons"" și valorile corespunzătoare pentru fiecare coloană. 
*  Această interogare presupune că tabelul ""Persons"" există și că ai permisiunile necesare pentru a insera date în el. 
",INSERT INTO Persons (LastName) VALUES ('Olsen'),,,,,0.022869567780619007,0.0689655172413793,
59,Manual - Test 2,,,6,"Cum se poate schimba ""Hansen"" în ""Nilsen"" în coloana ""LastName"" din tabelul ""Persons""?",UPDATE Persons SET LastName='Nilsen' WHERE LastName='Hansen',Este corect,,"['Modificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21', 'Modificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21', 'Modificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21', 'Modificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21', '3. Sinonime\n➢Un sinonim nu poate fi schimbat odata creat. \n➢El poate sa fie doar distrus. \n➢Distrugerea unui sinonim nu implica si distrugerea \nobiectului de care aliasul este atasat. \n➢Distrugerea unui sinonim este facuta folosind o \ninterogare SQL de tipul urmator:\nDROP [PUBLIC] SYNONYM nume_sinonim\nunde nume_sinonim este numele sinonimului care sa fie \ndistrus.\nCurs - BAZE DE DATE 48', '3. Sinonime\n➢Un sinonim nu poate fi schimbat odata creat. \n➢El poate sa fie doar distrus. \n➢Distrugerea unui sinonim nu implica si distrugerea \nobiectului de care aliasul este atasat. \n➢Distrugerea unui sinonim este facuta folosind o \ninterogare SQL de tipul urmator:\nDROP [PUBLIC] SYNONYM nume_sinonim\nunde nume_sinonim este numele sinonimului care sa fie \ndistrus.\nCurs - BAZE DE DATE 48', '3. Sinonime\n➢Un sinonim nu poate fi schimbat odata creat. \n➢El poate sa fie doar distrus. \n➢Distrugerea unui sinonim nu implica si distrugerea \nobiectului de care aliasul este atasat. \n➢Distrugerea unui sinonim este facuta folosind o \ninterogare SQL de tipul urmator:\nDROP [PUBLIC] SYNONYM nume_sinonim\nunde nume_sinonim este numele sinonimului care sa fie \ndistrus.\nCurs - BAZE DE DATE 48', '3. Sinonime\n➢Un sinonim nu poate fi schimbat odata creat. \n➢El poate sa fie doar distrus. \n➢Distrugerea unui sinonim nu implica si distrugerea \nobiectului de care aliasul este atasat. \n➢Distrugerea unui sinonim este facuta folosind o \ninterogare SQL de tipul urmator:\nDROP [PUBLIC] SYNONYM nume_sinonim\nunde nume_sinonim este numele sinonimului care sa fie \ndistrus.\nCurs - BAZE DE DATE 48', ""Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista 'ALLEN', 'WARD', 'FORD'. \n 51\n"", ""Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista 'ALLEN', 'WARD', 'FORD'. \n 51\n""]","Contextul furnizat nu oferă informații despre modificarea numelui în coloana ""LastName"" din tabelul ""Persons"". Informațiile se referă la modificarea secvențelor și ștergerea sinonimelor în SQL. 

Pentru a schimba ""Hansen"" în ""Nilsen"" în coloana ""LastName"", se poate folosi o interogare SQL de tip UPDATE:

```sql
UPDATE Persons
SET LastName = 'Nilsen'
WHERE LastName = 'Hansen';
```

Această interogare va actualiza toate înregistrările din tabelul ""Persons"" unde ""LastName"" este ""Hansen"", schimbând valoarea în ""Nilsen"". 
","Cum se poate schimba ""Hansen"" în ""Nilsen"" în coloana ""LastName"" din tabelul ""Persons""?","['Modificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21', 'Modificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21', 'Modificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21', 'Modificarea secventelor\nO secventa poate fi modificata folosind urmatoarea interogare generica:\nunde nume_secventa este numele secventei care se doreste a fi modificata. \nAceasta metoda este utila de exemplu pentru cazul in care secventa atinge \nvaloarea maxima si in cazul dorintei de a o folosi in continuare ea intoarce o \neroare.\nALTER SEQUENCE nume_secventa\n [INCREMENT BY n]\n [START WITH n]\n [{MAXVALUE n| NOMAXVALUE}]\n [{MINVALUE n| NOMINVALUE}]\n [{CYCLE | NOCYCLE}] \n [{CACHE |NOCACHE}];\nCurs - BAZE DE DATE 21', '3. Sinonime\n➢Un sinonim nu poate fi schimbat odata creat. \n➢El poate sa fie doar distrus. \n➢Distrugerea unui sinonim nu implica si distrugerea \nobiectului de care aliasul este atasat. \n➢Distrugerea unui sinonim este facuta folosind o \ninterogare SQL de tipul urmator:\nDROP [PUBLIC] SYNONYM nume_sinonim\nunde nume_sinonim este numele sinonimului care sa fie \ndistrus.\nCurs - BAZE DE DATE 48', '3. Sinonime\n➢Un sinonim nu poate fi schimbat odata creat. \n➢El poate sa fie doar distrus. \n➢Distrugerea unui sinonim nu implica si distrugerea \nobiectului de care aliasul este atasat. \n➢Distrugerea unui sinonim este facuta folosind o \ninterogare SQL de tipul urmator:\nDROP [PUBLIC] SYNONYM nume_sinonim\nunde nume_sinonim este numele sinonimului care sa fie \ndistrus.\nCurs - BAZE DE DATE 48', '3. Sinonime\n➢Un sinonim nu poate fi schimbat odata creat. \n➢El poate sa fie doar distrus. \n➢Distrugerea unui sinonim nu implica si distrugerea \nobiectului de care aliasul este atasat. \n➢Distrugerea unui sinonim este facuta folosind o \ninterogare SQL de tipul urmator:\nDROP [PUBLIC] SYNONYM nume_sinonim\nunde nume_sinonim este numele sinonimului care sa fie \ndistrus.\nCurs - BAZE DE DATE 48', '3. Sinonime\n➢Un sinonim nu poate fi schimbat odata creat. \n➢El poate sa fie doar distrus. \n➢Distrugerea unui sinonim nu implica si distrugerea \nobiectului de care aliasul este atasat. \n➢Distrugerea unui sinonim este facuta folosind o \ninterogare SQL de tipul urmator:\nDROP [PUBLIC] SYNONYM nume_sinonim\nunde nume_sinonim este numele sinonimului care sa fie \ndistrus.\nCurs - BAZE DE DATE 48', ""Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista 'ALLEN', 'WARD', 'FORD'. \n 51\n"", ""Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au numele \nîn lista 'ALLEN', 'WARD', 'FORD'. \n 51\n""]","Contextul furnizat nu oferă informații despre modificarea numelui în coloana ""LastName"" din tabelul ""Persons"". Informațiile se referă la modificarea secvențelor și ștergerea sinonimelor în SQL. 

Pentru a schimba ""Hansen"" în ""Nilsen"" în coloana ""LastName"", se poate folosi o interogare SQL de tip UPDATE:

```sql
UPDATE Persons
SET LastName = 'Nilsen'
WHERE LastName = 'Hansen';
```

Această interogare va actualiza toate înregistrările din tabelul ""Persons"" unde ""LastName"" este ""Hansen"", schimbând valoarea în ""Nilsen"". 
",UPDATE Persons SET LastName='Nilsen' WHERE LastName='Hansen',,,,,0.025540496664715903,0.1951219512195122,
60,Manual - Test 2,,,7,"Folosind SQL, cum se șterg înregistrările din tabelul ""Persons"" unde ""FirstName"" este ""Peter""?",DELETE FROM Persons WHERE FirstName = 'Peter',Este corect,,"['2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '3. Sinonime\n➢Daca dorim sa accesam o tabela pe care un alt utilizator \na creat-o in prealabil si careia ii dorim asignarea unui \nsinonim suntem obligati sa introducem inaintea numelui \ntabelei si numele utilizatorului care a creat tabela, in \nfata numelui tabelei, despartite de un punct.\nExemplu 1 - In acest exemplu vom incerca sa cream un \nsinonim pentru tabela departamente care are un nume \ndestul de lung.\nCREATE PUBLIC SYNONYM dep\nFOR dept;\nCurs - BAZE DE DATE 45', '3. Sinonime\n➢Daca dorim sa accesam o tabela pe care un alt utilizator \na creat-o in prealabil si careia ii dorim asignarea unui \nsinonim suntem obligati sa introducem inaintea numelui \ntabelei si numele utilizatorului care a creat tabela, in \nfata numelui tabelei, despartite de un punct.\nExemplu 1 - In acest exemplu vom incerca sa cream un \nsinonim pentru tabela departamente care are un nume \ndestul de lung.\nCREATE PUBLIC SYNONYM dep\nFOR dept;\nCurs - BAZE DE DATE 45', '3. Sinonime\n➢Daca dorim sa accesam o tabela pe care un alt utilizator \na creat-o in prealabil si careia ii dorim asignarea unui \nsinonim suntem obligati sa introducem inaintea numelui \ntabelei si numele utilizatorului care a creat tabela, in \nfata numelui tabelei, despartite de un punct.\nExemplu 1 - In acest exemplu vom incerca sa cream un \nsinonim pentru tabela departamente care are un nume \ndestul de lung.\nCREATE PUBLIC SYNONYM dep\nFOR dept;\nCurs - BAZE DE DATE 45', '3. Sinonime\n➢Daca dorim sa accesam o tabela pe care un alt utilizator \na creat-o in prealabil si careia ii dorim asignarea unui \nsinonim suntem obligati sa introducem inaintea numelui \ntabelei si numele utilizatorului care a creat tabela, in \nfata numelui tabelei, despartite de un punct.\nExemplu 1 - In acest exemplu vom incerca sa cream un \nsinonim pentru tabela departamente care are un nume \ndestul de lung.\nCREATE PUBLIC SYNONYM dep\nFOR dept;\nCurs - BAZE DE DATE 45', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23']","```sql
DELETE FROM Persons WHERE FirstName = 'Peter';
``` 
","Folosind SQL, cum se șterg înregistrările din tabelul ""Persons"" unde ""FirstName"" este ""Peter""?","['2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '3. Sinonime\n➢Daca dorim sa accesam o tabela pe care un alt utilizator \na creat-o in prealabil si careia ii dorim asignarea unui \nsinonim suntem obligati sa introducem inaintea numelui \ntabelei si numele utilizatorului care a creat tabela, in \nfata numelui tabelei, despartite de un punct.\nExemplu 1 - In acest exemplu vom incerca sa cream un \nsinonim pentru tabela departamente care are un nume \ndestul de lung.\nCREATE PUBLIC SYNONYM dep\nFOR dept;\nCurs - BAZE DE DATE 45', '3. Sinonime\n➢Daca dorim sa accesam o tabela pe care un alt utilizator \na creat-o in prealabil si careia ii dorim asignarea unui \nsinonim suntem obligati sa introducem inaintea numelui \ntabelei si numele utilizatorului care a creat tabela, in \nfata numelui tabelei, despartite de un punct.\nExemplu 1 - In acest exemplu vom incerca sa cream un \nsinonim pentru tabela departamente care are un nume \ndestul de lung.\nCREATE PUBLIC SYNONYM dep\nFOR dept;\nCurs - BAZE DE DATE 45', '3. Sinonime\n➢Daca dorim sa accesam o tabela pe care un alt utilizator \na creat-o in prealabil si careia ii dorim asignarea unui \nsinonim suntem obligati sa introducem inaintea numelui \ntabelei si numele utilizatorului care a creat tabela, in \nfata numelui tabelei, despartite de un punct.\nExemplu 1 - In acest exemplu vom incerca sa cream un \nsinonim pentru tabela departamente care are un nume \ndestul de lung.\nCREATE PUBLIC SYNONYM dep\nFOR dept;\nCurs - BAZE DE DATE 45', '3. Sinonime\n➢Daca dorim sa accesam o tabela pe care un alt utilizator \na creat-o in prealabil si careia ii dorim asignarea unui \nsinonim suntem obligati sa introducem inaintea numelui \ntabelei si numele utilizatorului care a creat tabela, in \nfata numelui tabelei, despartite de un punct.\nExemplu 1 - In acest exemplu vom incerca sa cream un \nsinonim pentru tabela departamente care are un nume \ndestul de lung.\nCREATE PUBLIC SYNONYM dep\nFOR dept;\nCurs - BAZE DE DATE 45', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23', 'O alternativă la alias-urile utilizate în cererea SQL \nsunt alias-urile plasate după CREATE, înaintea cererii \nSELECT.\nDe data aceasta vom crea o vedere cu persoanele \ndin departamentul 30. \nCurs - BAZE DE DATE 23']","```sql
DELETE FROM Persons WHERE FirstName = 'Peter';
``` 
",DELETE FROM Persons WHERE FirstName = 'Peter',,,,,0.40016016019225004,0.923076923076923,
61,Manual - Test 2,,,8,"Folosind SQL, cum se returnează numărul de înregistrări din tabelul ""Persons""?",SELECT COUNT(*) FROM Persons,Este corect,,"['2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', 'Avantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6', 'Avantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6', 'Avantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6', 'Avantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6', 'Funcţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11', 'Funcţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11']","Pentru a returna numărul de înregistrări din tabelul ""Persons"" folosind SQL, se poate utiliza următoarea interogare:

```sql
SELECT COUNT(*) FROM Persons;
```

Această interogare va număra toate înregistrările din tabelul ""Persons"" și va returna numărul total. 

**Explicație:**

* `SELECT COUNT(*)`: Această clauză selectează numărul de rânduri. `COUNT(*)` este o funcție agregată care numără toate rândurile dintr-un tabel, indiferent dacă coloanele conțin valori NULL sau non-NULL.
* `FROM Persons`: Această clauză specifică tabelul din care se vor număra înregistrările, în acest caz, ""Persons"". 
","Folosind SQL, cum se returnează numărul de înregistrări din tabelul ""Persons""?","['2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', '2. Indecșii\nExemplu 2: - Index bazat pe o functie SQL\n➢ Indexul urmator este folosit pentru o tabela de angajati care \neste foarte mare si in general in aplicatii se folosesc \nextragerile de o singura inregistrare din baza de date. \n➢ Daca presupunem ca cea mai frecventa metoda de filtrare a \ncererii SQL este dupa nume si prenume putem crea un index \npe cele doua campuri reunite:\nCREATE INDEX employees_name\nON emp( CONCAT(ename, job) ) \nCurs - BAZE DE DATE 38', 'Avantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6', 'Avantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6', 'Avantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6', 'Avantajele utilizării vederilor\n• Vederile pot fi folosite în cereri SQL simple \ncând de fapt ele întorc rezultatul unor cereri \nSQL complexe. \n– Deci putem utiliza vederile în interogarea mai \nmultor tabele fără a şti ce este un join de tabele. \n• O vedere poate fi folosită pentru a obţine date \ndin mai multe tabele.\n• Vederile oferă drepturi de acces pentru grupuri \nde utilizatori.\nCurs - BAZE DE DATE 6', 'Funcţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11', 'Funcţii\n Diferenţa dintre cele două tipuri de funcţii \neste numărul de înregistrări pe care acţionează: \n➢Funcţiile referitoare la o singură înregistrare \nreturnează un singur rezultat pentru fiecare \nrând al tabelei, \n➢pe când funcţiile referitoare la mai multe \nînregistrări returnează un singur rezultat \npentru fiecare grup de înregistrări din tabela.\nCurs 5 - BAZE DE DATE 11']","Pentru a returna numărul de înregistrări din tabelul ""Persons"" folosind SQL, se poate utiliza următoarea interogare:

```sql
SELECT COUNT(*) FROM Persons;
```

Această interogare va număra toate înregistrările din tabelul ""Persons"" și va returna numărul total. 

**Explicație:**

* `SELECT COUNT(*)`: Această clauză selectează numărul de rânduri. `COUNT(*)` este o funcție agregată care numără toate rândurile dintr-un tabel, indiferent dacă coloanele conțin valori NULL sau non-NULL.
* `FROM Persons`: Această clauză specifică tabelul din care se vor număra înregistrările, în acest caz, ""Persons"". 
",SELECT COUNT(*) FROM Persons,,,,,0.10878661088699644,0.07999999999999999,
62,Manual - Test 2,,,9,Care este cel mai cunoscut tip de join?,INNER JOIN,Este corect,,"['6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23', '6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23', '6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23', '6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23', '6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24', '6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24', '6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24', '6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24', '1.6. Modelul de date reţea\nModelul de date reţea (Network Model) \nfoloseşte o structură de graf pentru definirea \nschemei conceptuale a bazei de date:\n➢nodurile grafului sunt tipuri de entităţi \n(înregistrări, records), \n➢iar muchiile grafului reprezintă în mod explicit \nasocierile (legăturile, links) dintre tipurile de \nentităţi.\n 64', '1.6. Modelul de date reţea\nModelul de date reţea (Network Model) \nfoloseşte o structură de graf pentru definirea \nschemei conceptuale a bazei de date:\n➢nodurile grafului sunt tipuri de entităţi \n(înregistrări, records), \n➢iar muchiile grafului reprezintă în mod explicit \nasocierile (legăturile, links) dintre tipurile de \nentităţi.\n 64']","Informațiile furnizate nu conțin detalii despre tipurile de ""join"" din bazele de date. Prin urmare, nu pot răspunde la întrebarea ta. 
",Care este cel mai cunoscut tip de join?,"['6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23', '6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23', '6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23', '6.1. SINGLE ROW SUBQUERIES\n Aplicatii rezolvate\n1) Care este numele membrilor din personalul de la \nfirma “COSTICA S.R.L.”, al căror salariu este mai mare \ndecât angajatul cu ID-ul 7698?\n2) Care dintre angajatii Oracle au acelasi id al \ndepartamentului ca si cel corespunzator cu \ndepartamentul RESEARCH?\nCurs 6 - BAZE DE DATE 23', '6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24', '6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24', '6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24', '6.1. SINGLE ROW SUBQUERIES\n1) Care este numele membrilor din personalul de la firma \n“COSTICA S.R.L.”, al căror salariu este mai mare decât \nangajatul cu ID-ul 7698?\nSELECT ename\nFROM EMP\nWHERE sal >\n    ( SELECT sal \n      FROM EMP\n      WHERE empno = 7698 );\nCurs 6 - BAZE DE DATE 24', '1.6. Modelul de date reţea\nModelul de date reţea (Network Model) \nfoloseşte o structură de graf pentru definirea \nschemei conceptuale a bazei de date:\n➢nodurile grafului sunt tipuri de entităţi \n(înregistrări, records), \n➢iar muchiile grafului reprezintă în mod explicit \nasocierile (legăturile, links) dintre tipurile de \nentităţi.\n 64', '1.6. Modelul de date reţea\nModelul de date reţea (Network Model) \nfoloseşte o structură de graf pentru definirea \nschemei conceptuale a bazei de date:\n➢nodurile grafului sunt tipuri de entităţi \n(înregistrări, records), \n➢iar muchiile grafului reprezintă în mod explicit \nasocierile (legăturile, links) dintre tipurile de \nentităţi.\n 64']","Informațiile furnizate nu conțin detalii despre tipurile de ""join"" din bazele de date. Prin urmare, nu pot răspunde la întrebarea ta. 
",INNER JOIN,,,,,0.0,0.07692307692307693,
63,Manual - Test 2,,,10,Ce operator este folosit pentru a selecta valori dintr-un interval?,BETWEEN,Este corect,,"['6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30', '6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY - Acest operator este \nfolosit atunci când dorim ca \ninterogarea exterioară să selecteze \nvalori egale, mai mici sau mai mari \ndecât cel puţin o valoare dintre cele \nextrase de subquery.\nCurs 6 - BAZE DE DATE 33\n', '6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY - Acest operator este \nfolosit atunci când dorim ca \ninterogarea exterioară să selecteze \nvalori egale, mai mici sau mai mari \ndecât cel puţin o valoare dintre cele \nextrase de subquery.\nCurs 6 - BAZE DE DATE 33\n']","Conform contextului furnizat, operatorul folosit pentru a selecta valori dintr-un interval este **operatorul ANY**. 

Acest operator este utilizat în combinație cu operatori de comparație (>, <, =, etc.) pentru a verifica dacă o valoare din exteriorul subinterogării se încadrează în intervalul definit de rezultatele subinterogării. 

De exemplu, pentru a selecta angajații cu un salariu mai mare decât cel puțin un salariu din departamentul 20, am putea folosi o interogare cu operatorul ANY:

```sql
SELECT ename, sal, deptno
FROM EMP
WHERE sal > ANY (SELECT sal FROM EMP WHERE deptno = 20);
```
 
Pe de altă parte, **operatorul IN** verifică dacă o valoare se regăsește într-o listă de valori returnate de subinterogare. 
",Ce operator este folosit pentru a selecta valori dintr-un interval?,"['6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN - Operatorul IN este folosit dacă în interogarea exterioară clauza \nWHERE este folosită pentru a selecta acele valori care sunt egale cu una dintre \nvalorile din lista returnată de subinterogare (inner query).\nCurs 6 - BAZE DE DATE 31\n', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30', '6.2. MULTIPLE ROW SUBQUERIES\n1. Operatorul IN\n  Operatorul IN este folosit dacă în interogarea \nexterioară clauza WHERE este folosită pentru a selecta \nacele valori care sunt egale cu una dintre valorile din \nlista returnată de subinterogare (inner query).\nSELECT ename, sal, deptno\nFROM EMP\nWHERE sal IN \n     ( SELECT MIN(sal)\n       FROM EMP\n       GROUP BY deptno );\nCurs 6 - BAZE DE DATE 30', '6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY - Acest operator este \nfolosit atunci când dorim ca \ninterogarea exterioară să selecteze \nvalori egale, mai mici sau mai mari \ndecât cel puţin o valoare dintre cele \nextrase de subquery.\nCurs 6 - BAZE DE DATE 33\n', '6.2. MULTIPLE ROW SUBQUERIES\n2. Operatorul ANY - Acest operator este \nfolosit atunci când dorim ca \ninterogarea exterioară să selecteze \nvalori egale, mai mici sau mai mari \ndecât cel puţin o valoare dintre cele \nextrase de subquery.\nCurs 6 - BAZE DE DATE 33\n']","Conform contextului furnizat, operatorul folosit pentru a selecta valori dintr-un interval este **operatorul ANY**. 

Acest operator este utilizat în combinație cu operatori de comparație (>, <, =, etc.) pentru a verifica dacă o valoare din exteriorul subinterogării se încadrează în intervalul definit de rezultatele subinterogării. 

De exemplu, pentru a selecta angajații cu un salariu mai mare decât cel puțin un salariu din departamentul 20, am putea folosi o interogare cu operatorul ANY:

```sql
SELECT ename, sal, deptno
FROM EMP
WHERE sal > ANY (SELECT sal FROM EMP WHERE deptno = 20);
```
 
Pe de altă parte, **operatorul IN** verifică dacă o valoare se regăsește într-o listă de valori returnate de subinterogare. 
",BETWEEN,,,,,0.0,0.0,
64,Manual - Test 2,,,11,Constrângerea NOT NULL impune ca o coloană să nu accepte valori NULL.,Adevărat,Este corect,,"['Constrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17', 'Constrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17', 'Constrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17', 'Constrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17', 'Constrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13', 'Constrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13', 'Constrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13', 'Constrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13', 'Clauza WHERE\n4. Conditia IS NULL \n  Pentru a verifica valorile de tip NULL există condiţia IS \nNULL sau negarea acesteia IS NOT NULL. \nO valoare nulă este o valoare care este sau incorectă, sau \nnecunoscută, sau inaplicabilă de aceea nu poate fi testată cu \n""="". \nO valoare nulă nu este la fel cu ""zero"" care este un \nnumăr.\nDacă valoarea NULL este utilizată într-o comparaţie, \natunci operatorul de comparaţie trebuie să fie IS NULL sau IS \nNOT NULL altfel rezultatul este întotdeauna FALSE. \n 60', 'Clauza WHERE\n4. Conditia IS NULL \n  Pentru a verifica valorile de tip NULL există condiţia IS \nNULL sau negarea acesteia IS NOT NULL. \nO valoare nulă este o valoare care este sau incorectă, sau \nnecunoscută, sau inaplicabilă de aceea nu poate fi testată cu \n""="". \nO valoare nulă nu este la fel cu ""zero"" care este un \nnumăr.\nDacă valoarea NULL este utilizată într-o comparaţie, \natunci operatorul de comparaţie trebuie să fie IS NULL sau IS \nNOT NULL altfel rezultatul este întotdeauna FALSE. \n 60']","Afirmația ""Constrângerea NOT NULL impune ca o coloană să nu accepte valori NULL"" este **corectă**. 

Contextul ne oferă informații despre constrângerea NOT NULL în fragmentul:

""Constrângerea NOT NULL
 • Constrângerea de tip NOT NULL asigură 
 faptul că o coloană să nu conțină valoarea 
 nulă.""

Această definiție confirmă că o coloană cu constrângerea NOT NULL nu poate conține valori NULL. 
",Constrângerea NOT NULL impune ca o coloană să nu accepte valori NULL.,"['Constrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17', 'Constrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17', 'Constrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17', 'Constrângerea UNIQUE\nConstrângerea UNIQUE de integritate impune ca fiecare \nvaloare a unei coloane sau set de coloane să fie unică -\ndouă rânduri ale aceluiaşi tabele să nu aibă aceleaşi \nvalori într-o anumită coloana sau set de coloane. \nPermite includerea de valori nule numai dacă \nconstrângerea NOT NULL nu este definită pentru \naceeaşi coloană (valoarea nulă nu este considerată a fi \nechivalentă cu ceva). \nConstrângerea UNIQUE poate fi definită atât la nivel de \nlinie cât şi la nivel de tabelă.\nCurs 8 - BAZE DE DATE 17', 'Constrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13', 'Constrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13', 'Constrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13', 'Constrângerea NOT NULL\n• Constrângerea de tip NOT NULL asigură \nfaptul că o coloană să nu conţină valoarea \nnulă. \n• Ea poate fi specificată la nivel de coloană şi \nnu la nivel de tabela. \nCurs 8 - BAZE DE DATE 13', 'Clauza WHERE\n4. Conditia IS NULL \n  Pentru a verifica valorile de tip NULL există condiţia IS \nNULL sau negarea acesteia IS NOT NULL. \nO valoare nulă este o valoare care este sau incorectă, sau \nnecunoscută, sau inaplicabilă de aceea nu poate fi testată cu \n""="". \nO valoare nulă nu este la fel cu ""zero"" care este un \nnumăr.\nDacă valoarea NULL este utilizată într-o comparaţie, \natunci operatorul de comparaţie trebuie să fie IS NULL sau IS \nNOT NULL altfel rezultatul este întotdeauna FALSE. \n 60', 'Clauza WHERE\n4. Conditia IS NULL \n  Pentru a verifica valorile de tip NULL există condiţia IS \nNULL sau negarea acesteia IS NOT NULL. \nO valoare nulă este o valoare care este sau incorectă, sau \nnecunoscută, sau inaplicabilă de aceea nu poate fi testată cu \n""="". \nO valoare nulă nu este la fel cu ""zero"" care este un \nnumăr.\nDacă valoarea NULL este utilizată într-o comparaţie, \natunci operatorul de comparaţie trebuie să fie IS NULL sau IS \nNOT NULL altfel rezultatul este întotdeauna FALSE. \n 60']","Afirmația ""Constrângerea NOT NULL impune ca o coloană să nu accepte valori NULL"" este **corectă**. 

Contextul ne oferă informații despre constrângerea NOT NULL în fragmentul:

""Constrângerea NOT NULL
 • Constrângerea de tip NOT NULL asigură 
 faptul că o coloană să nu conțină valoarea 
 nulă.""

Această definiție confirmă că o coloană cu constrângerea NOT NULL nu poate conține valori NULL. 
",Adevărat,,,,,0.0,0.0,
65,Manual - Test 2,,,12,Ce operator este folosit pentru a căuta un model specificat într-o coloană?,LIKE,Este corect,,"['Clauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52', 'Clauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52', 'Clauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52', 'Clauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52', 'NOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n', 'NOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n', 'NOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n', 'NOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n', '6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9', '6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9']","Operatorul folosit pentru a căuta un model specificat într-o coloană este **LIKE**.

Informația este preluată din context, unde se specifică: ""Dacă nu se cunoaște valoarea exactă căutată, cu ajutorul condiției LIKE putem să selectăm rândurile care se potrivesc cu un model specificat de caractere."" 
",Ce operator este folosit pentru a căuta un model specificat într-o coloană?,"['Clauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52', 'Clauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52', 'Clauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52', 'Clauza WHERE\n3. LIKE \n  Dacă nu se cunoaşte valoarea exactă căutată, cu ajutorul \ncondiţiei LIKE putem să selectăm rândurile care se potrivesc \ncu un model specificat de caractere. \n  Operaţia de căutare după un model poate fi asemănată \ncu o căutare ""wildcard"".\n  Pentru construirea modelului şirului căutat pot fi folosite \n2 simboluri: \n% : orice secvenţă de 0 sau mai multe caractere \n_ :  un singur caracter (oarecare)\nAceste simboluri pot fi folosite în orice combinaţie de \ncaractere literale. \n 52', 'NOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n', 'NOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n', 'NOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n', 'NOTĂ:\n➢Când o coloană a vederii este o funcţie sau o expresie \ntrebuie folosit alias de coloană. \n➢Conţinutul vederii este afişat în acelaşi mod ca până \nacum. \nExerciţiu: Afişaţi conţinutul vederii dept_sal. \nCurs - BAZE DE DATE 33\n', '6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9', '6. SUBQUERIES (Subinterogari)\nSunt două tipuri de subinterogări(subqueries):\n1) single-row subqueries – care folosesc operatorii single-\nrow: >, =, >=, <, <= şi dau ca rezultat o singură linie.\n2) multiple-row subqueries – care folosesc operatorii \nmultiple-row: IN, ANY , ALL şi dau ca rezultat mai multe \nlinii.\nCurs 6 - BAZE DE DATE 9']","Operatorul folosit pentru a căuta un model specificat într-o coloană este **LIKE**.

Informația este preluată din context, unde se specifică: ""Dacă nu se cunoaște valoarea exactă căutată, cu ajutorul condiției LIKE putem să selectăm rândurile care se potrivesc cu un model specificat de caractere."" 
",LIKE,,,,,0.006609918289641935,0.03773584905660378,
66,Manual - Test 2,,,13,"Ce instrucțiune SQL este folosită pentru a crea un tabel de bază de date numit ""Customers""?",CREATE TABLE Customers,Este corect,,"['Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63', '• Indecsii sunt creati folosind urmatoarea cerere SQL la \nbaza de date:\n• unde numele_index este numele pe care il are \nindexul, numele_tabelei este numele tabelei din baza \nde date pentru a carei campuri indexul va fi creat si \ncamp1, camp2... sunt numele campurilor din tabela \npentru care se creaza acest index. \n• Un index poate fi creat pentru una sau mai multe \ncoloane din aceeasi tabela.\nCREATE INDEX numele_index\nON numele_tabelei (camp1[, camp2].... )\nCurs - BAZE DE DATE 29', '• Indecsii sunt creati folosind urmatoarea cerere SQL la \nbaza de date:\n• unde numele_index este numele pe care il are \nindexul, numele_tabelei este numele tabelei din baza \nde date pentru a carei campuri indexul va fi creat si \ncamp1, camp2... sunt numele campurilor din tabela \npentru care se creaza acest index. \n• Un index poate fi creat pentru una sau mai multe \ncoloane din aceeasi tabela.\nCREATE INDEX numele_index\nON numele_tabelei (camp1[, camp2].... )\nCurs - BAZE DE DATE 29', '• Indecsii sunt creati folosind urmatoarea cerere SQL la \nbaza de date:\n• unde numele_index este numele pe care il are \nindexul, numele_tabelei este numele tabelei din baza \nde date pentru a carei campuri indexul va fi creat si \ncamp1, camp2... sunt numele campurilor din tabela \npentru care se creaza acest index. \n• Un index poate fi creat pentru una sau mai multe \ncoloane din aceeasi tabela.\nCREATE INDEX numele_index\nON numele_tabelei (camp1[, camp2].... )\nCurs - BAZE DE DATE 29', '• Indecsii sunt creati folosind urmatoarea cerere SQL la \nbaza de date:\n• unde numele_index este numele pe care il are \nindexul, numele_tabelei este numele tabelei din baza \nde date pentru a carei campuri indexul va fi creat si \ncamp1, camp2... sunt numele campurilor din tabela \npentru care se creaza acest index. \n• Un index poate fi creat pentru una sau mai multe \ncoloane din aceeasi tabela.\nCREATE INDEX numele_index\nON numele_tabelei (camp1[, camp2].... )\nCurs - BAZE DE DATE 29', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58']","Contextul furnizat menționează că instrucțiunea **CREATE** este utilizată pentru a crea structura unei baze de date sau a unei tabele în limbajul SQL. 

Deși nu oferă sintaxa exactă pentru crearea unui tabel numit ""Customers"", putem deduce că instrucțiunea SQL va arăta similar cu aceasta:

```sql
CREATE TABLE Customers (
    -- Aici se definesc coloanele tabelului și tipurile lor de date
    -- De exemplu:
    CustomerID INT PRIMARY KEY,
    CustomerName VARCHAR(255),
    ContactName VARCHAR(255),
    Address VARCHAR(255),
    City VARCHAR(255),
    PostalCode VARCHAR(10),
    Country VARCHAR(255)
);
```

Această instrucțiune va crea un tabel numit ""Customers"" cu coloanele specificate.  
","Ce instrucțiune SQL este folosită pentru a crea un tabel de bază de date numit ""Customers""?","['Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63', 'Limbajul SQL\n3. Limbajul de definire a datelor (LDD) permite definirea \nstructurii tabelelor ce compun bazele de date. \nComenzile utilizate sunt:\n1. CREATE – pentru crearea structurii unei baze de date \nsau a unei tabele\n2. ALTER – pentru modificarea structurii unei baze de \ndate sau a unei tabele\n3. DROP – pentru ştergerea structurii bazei de date\n4. RENAME – schimbarea numelui unei tabele\n5. TRUNCATE – ştergerea conţinutului unei tabele\n63', '• Indecsii sunt creati folosind urmatoarea cerere SQL la \nbaza de date:\n• unde numele_index este numele pe care il are \nindexul, numele_tabelei este numele tabelei din baza \nde date pentru a carei campuri indexul va fi creat si \ncamp1, camp2... sunt numele campurilor din tabela \npentru care se creaza acest index. \n• Un index poate fi creat pentru una sau mai multe \ncoloane din aceeasi tabela.\nCREATE INDEX numele_index\nON numele_tabelei (camp1[, camp2].... )\nCurs - BAZE DE DATE 29', '• Indecsii sunt creati folosind urmatoarea cerere SQL la \nbaza de date:\n• unde numele_index este numele pe care il are \nindexul, numele_tabelei este numele tabelei din baza \nde date pentru a carei campuri indexul va fi creat si \ncamp1, camp2... sunt numele campurilor din tabela \npentru care se creaza acest index. \n• Un index poate fi creat pentru una sau mai multe \ncoloane din aceeasi tabela.\nCREATE INDEX numele_index\nON numele_tabelei (camp1[, camp2].... )\nCurs - BAZE DE DATE 29', '• Indecsii sunt creati folosind urmatoarea cerere SQL la \nbaza de date:\n• unde numele_index este numele pe care il are \nindexul, numele_tabelei este numele tabelei din baza \nde date pentru a carei campuri indexul va fi creat si \ncamp1, camp2... sunt numele campurilor din tabela \npentru care se creaza acest index. \n• Un index poate fi creat pentru una sau mai multe \ncoloane din aceeasi tabela.\nCREATE INDEX numele_index\nON numele_tabelei (camp1[, camp2].... )\nCurs - BAZE DE DATE 29', '• Indecsii sunt creati folosind urmatoarea cerere SQL la \nbaza de date:\n• unde numele_index este numele pe care il are \nindexul, numele_tabelei este numele tabelei din baza \nde date pentru a carei campuri indexul va fi creat si \ncamp1, camp2... sunt numele campurilor din tabela \npentru care se creaza acest index. \n• Un index poate fi creat pentru una sau mai multe \ncoloane din aceeasi tabela.\nCREATE INDEX numele_index\nON numele_tabelei (camp1[, camp2].... )\nCurs - BAZE DE DATE 29', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58']","Contextul furnizat menționează că instrucțiunea **CREATE** este utilizată pentru a crea structura unei baze de date sau a unei tabele în limbajul SQL. 

Deși nu oferă sintaxa exactă pentru crearea unui tabel numit ""Customers"", putem deduce că instrucțiunea SQL va arăta similar cu aceasta:

```sql
CREATE TABLE Customers (
    -- Aici se definesc coloanele tabelului și tipurile lor de date
    -- De exemplu:
    CustomerID INT PRIMARY KEY,
    CustomerName VARCHAR(255),
    ContactName VARCHAR(255),
    Address VARCHAR(255),
    City VARCHAR(255),
    PostalCode VARCHAR(10),
    Country VARCHAR(255)
);
```

Această instrucțiune va crea un tabel numit ""Customers"" cu coloanele specificate.  
",CREATE TABLE Customers,,,,,0.01387819277861591,0.05882352941176471,
67,Manual - Test 3,Hard,,1,Care interogare actualizează salariul tuturor angajaților din departamentul 10 astfel încât să fie mărit cu 10% din salariul mediu al companiei?,UPDATE EMP SET SAL = SAL + 0.10 * (SELECT AVG(SAL) FROM EMP) WHERE DEPTNO = 10;,Este corect,,"['Probleme propuse\n3. Actualizati salariile tuturor angajaților din \ntabela Copy_EMP, prin indexare cu 10%. \nAfișați angajații cu noile salarii în ordinea \ndescrescătoare a acestora. \nCurs 7 - BAZE DE DATE 61', 'Probleme propuse\n3. Actualizati salariile tuturor angajaților din \ntabela Copy_EMP, prin indexare cu 10%. \nAfișați angajații cu noile salarii în ordinea \ndescrescătoare a acestora. \nCurs 7 - BAZE DE DATE 61', 'Probleme propuse\n3. Actualizati salariile tuturor angajaților din \ntabela Copy_EMP, prin indexare cu 10%. \nAfișați angajații cu noile salarii în ordinea \ndescrescătoare a acestora. \nCurs 7 - BAZE DE DATE 61', 'Probleme propuse\n3. Actualizati salariile tuturor angajaților din \ntabela Copy_EMP, prin indexare cu 10%. \nAfișați angajații cu noile salarii în ordinea \ndescrescătoare a acestora. \nCurs 7 - BAZE DE DATE 61', 'Clauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n', 'Clauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n', 'Clauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n', 'Clauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n', 'Clauza WHERE\nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10.\n 41\n', 'Clauza WHERE\nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10.\n 41\n']","Pe baza contextului furnizat, iată o interogare SQL care ar trebui să funcționeze:

```sql
UPDATE Copy_EMP
SET sal = sal + (SELECT 0.1 * AVG(sal) FROM Copy_EMP)
WHERE deptno = 10;
```

Explicație:

1. **UPDATE Copy_EMP**: Această parte a interogării indică faptul că dorim să actualizăm datele din tabela `Copy_EMP`.
2. **SET sal = sal + ...**: Aici specificăm că dorim să modificăm coloana `sal` (salariu). Noua valoare a salariului va fi egală cu valoarea curentă plus 10% din salariul mediu al companiei.
3. **(SELECT 0.1 * AVG(sal) FROM Copy_EMP)**: Această subinterogare calculează 10% din salariul mediu al tuturor angajaților din tabela `Copy_EMP`.
4. **WHERE deptno = 10**: Această clauză specifică faptul că actualizarea se va aplica doar angajaților din departamentul cu numărul 10.

**Notă:**

* Această interogare presupune că tabela `Copy_EMP` are o coloană numită `deptno` care stochează numărul departamentului pentru fiecare angajat.
* Este posibil ca sintaxa SQL să varieze ușor în funcție de sistemul de gestionare a bazelor de date (DBMS) utilizat. 
",Care interogare actualizează salariul tuturor angajaților din departamentul 10 astfel încât să fie mărit cu 10% din salariul mediu al companiei?,"['Probleme propuse\n3. Actualizati salariile tuturor angajaților din \ntabela Copy_EMP, prin indexare cu 10%. \nAfișați angajații cu noile salarii în ordinea \ndescrescătoare a acestora. \nCurs 7 - BAZE DE DATE 61', 'Probleme propuse\n3. Actualizati salariile tuturor angajaților din \ntabela Copy_EMP, prin indexare cu 10%. \nAfișați angajații cu noile salarii în ordinea \ndescrescătoare a acestora. \nCurs 7 - BAZE DE DATE 61', 'Probleme propuse\n3. Actualizati salariile tuturor angajaților din \ntabela Copy_EMP, prin indexare cu 10%. \nAfișați angajații cu noile salarii în ordinea \ndescrescătoare a acestora. \nCurs 7 - BAZE DE DATE 61', 'Probleme propuse\n3. Actualizati salariile tuturor angajaților din \ntabela Copy_EMP, prin indexare cu 10%. \nAfișați angajații cu noile salarii în ordinea \ndescrescătoare a acestora. \nCurs 7 - BAZE DE DATE 61', 'Clauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n', 'Clauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n', 'Clauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n', 'Clauza WHERE\nExemplu: Listeaza toti angajatii care sunt in \ndepartamentul 10.\nSELECT ename, job, sal\nFROM EMP\nWHERE deptno = 10;  40\n', 'Clauza WHERE\nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10.\n 41\n', 'Clauza WHERE\nRezultatul obtinut - Listeaza toti angajatii care sunt in \ndepartamentul 10.\n 41\n']","Pe baza contextului furnizat, iată o interogare SQL care ar trebui să funcționeze:

```sql
UPDATE Copy_EMP
SET sal = sal + (SELECT 0.1 * AVG(sal) FROM Copy_EMP)
WHERE deptno = 10;
```

Explicație:

1. **UPDATE Copy_EMP**: Această parte a interogării indică faptul că dorim să actualizăm datele din tabela `Copy_EMP`.
2. **SET sal = sal + ...**: Aici specificăm că dorim să modificăm coloana `sal` (salariu). Noua valoare a salariului va fi egală cu valoarea curentă plus 10% din salariul mediu al companiei.
3. **(SELECT 0.1 * AVG(sal) FROM Copy_EMP)**: Această subinterogare calculează 10% din salariul mediu al tuturor angajaților din tabela `Copy_EMP`.
4. **WHERE deptno = 10**: Această clauză specifică faptul că actualizarea se va aplica doar angajaților din departamentul cu numărul 10.

**Notă:**

* Această interogare presupune că tabela `Copy_EMP` are o coloană numită `deptno` care stochează numărul departamentului pentru fiecare angajat.
* Este posibil ca sintaxa SQL să varieze ușor în funcție de sistemul de gestionare a bazelor de date (DBMS) utilizat. 
",UPDATE EMP SET SAL = SAL + 0.10 * (SELECT AVG(SAL) FROM EMP) WHERE DEPTNO = 10;,,,,,0.06861289152387096,0.15706806282722513,
68,Manual - Test 3,Hard,,,Care interogare șterge angajații al căror salariu este mai mic decât salariul mediu al departamentului lor și returnează numărul de rânduri afectate?,DELETE FROM EMP WHERE SAL < (SELECT AVG(SAL) FROM EMP WHERE DEPTNO = EMP.DEPTNO);,Este corect,,"['6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42', '6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42', '6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42', '6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42', 'Exemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n', 'Exemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n', 'Exemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n', 'Exemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n', 'Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul mai mic sau egal cu 3000:\n 34\n', 'Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul mai mic sau egal cu 3000:\n 34\n']","Contextul furnizat nu conține o interogare care să șteargă angajați. Contextul prezintă exemple de interogări pentru selectarea datelor, dar nu și pentru ștergerea lor. 

Pentru a șterge angajații al căror salariu este mai mic decât salariul mediu al departamentului lor și a returna numărul de rânduri afectate, ai nevoie de o interogare DELETE cu o subinterogare. 

Iată un exemplu de interogare care ar putea funcționa, presupunând că ai o tabelă numită ""Angajati"" cu coloanele ""Nume"", ""Salariu"" și ""Departament"":

```sql
DELETE FROM Angajati
WHERE Salariu < (SELECT AVG(Salariu) 
                FROM Angajati AS A2 
                WHERE A2.Departament = Angajati.Departament);

SELECT ROW_COUNT();
```

Această interogare:

1. **`DELETE FROM Angajati`**: Specifică tabela din care se vor șterge date.
2. **`WHERE Salariu < (subinterogare)`**: Stabilește condiția de ștergere - salariul angajatului trebuie să fie mai mic decât salariul mediu al departamentului său.
3. **`SELECT AVG(Salariu) FROM Angajati AS A2 WHERE A2.Departament = Angajati.Departament`**: Subinterogarea calculează salariul mediu pentru departamentul angajatului curent din tabela principală.
4. **`SELECT ROW_COUNT();`**: Această linie este executată după ștergere și returnează numărul de rânduri șterse.

**Important**: Adaptează numele tabelei și ale coloanelor la structura bazei tale de date. Este recomandat să faci o copie de siguranță a datelor înainte de a executa orice interogare DELETE. 
",Care interogare șterge angajații al căror salariu este mai mic decât salariul mediu al departamentului lor și returnează numărul de rânduri afectate?,"['6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42', '6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42', '6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42', '6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42', 'Exemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n', 'Exemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n', 'Exemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n', 'Exemplu - Gasiti \nangajatii care au un \nsalariu superior \nsalariului mediu al \ndepartamentului lor.\nCurs 6 - BAZE DE DATE 58\n', 'Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul mai mic sau egal cu 3000:\n 34\n', 'Clauza WHERE\nRezultatul obtinut - Listează toţi angajaţii care au \nsalariul mai mic sau egal cu 3000:\n 34\n']","Contextul furnizat nu conține o interogare care să șteargă angajați. Contextul prezintă exemple de interogări pentru selectarea datelor, dar nu și pentru ștergerea lor. 

Pentru a șterge angajații al căror salariu este mai mic decât salariul mediu al departamentului lor și a returna numărul de rânduri afectate, ai nevoie de o interogare DELETE cu o subinterogare. 

Iată un exemplu de interogare care ar putea funcționa, presupunând că ai o tabelă numită ""Angajati"" cu coloanele ""Nume"", ""Salariu"" și ""Departament"":

```sql
DELETE FROM Angajati
WHERE Salariu < (SELECT AVG(Salariu) 
                FROM Angajati AS A2 
                WHERE A2.Departament = Angajati.Departament);

SELECT ROW_COUNT();
```

Această interogare:

1. **`DELETE FROM Angajati`**: Specifică tabela din care se vor șterge date.
2. **`WHERE Salariu < (subinterogare)`**: Stabilește condiția de ștergere - salariul angajatului trebuie să fie mai mic decât salariul mediu al departamentului său.
3. **`SELECT AVG(Salariu) FROM Angajati AS A2 WHERE A2.Departament = Angajati.Departament`**: Subinterogarea calculează salariul mediu pentru departamentul angajatului curent din tabela principală.
4. **`SELECT ROW_COUNT();`**: Această linie este executată după ștergere și returnează numărul de rânduri șterse.

**Important**: Adaptează numele tabelei și ale coloanelor la structura bazei tale de date. Este recomandat să faci o copie de siguranță a datelor înainte de a executa orice interogare DELETE. 
",DELETE FROM EMP WHERE SAL < (SELECT AVG(SAL) FROM EMP WHERE DEPTNO = EMP.DEPTNO);,,,,,0.0,0.05982905982905982,
69,Manual - Test 3,Hard,,,"Scrie o interogare care actualizează salariul fiecărui angajat din departamentul 30, mărindu-l cu 5% din salariul mediu al departamentului său.","UPDATE EMP 
SET SAL = SAL + 0.05 * (SELECT AVG(SAL) FROM EMP WHERE DEPTNO = 30) 
WHERE DEPTNO = 30;
",Este corect,,"['Exemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n', 'Exemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n', 'Exemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n', 'Exemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n', '6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42', '6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42', '6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42', '6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42', 'Exemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50', 'Exemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50']","```sql
UPDATE angajati
SET sal = sal + (0.05 * (SELECT AVG(sal) FROM angajati WHERE deptno = 30))
WHERE deptno = 30;
```

Această interogare va actualiza salariul fiecărui angajat din departamentul 30, adăugând 5% din salariul mediu al departamentului la salariul lor actual. 

Iată cum funcționează:

1. **`UPDATE angajati`**: Această clauză specifică tabela `angajati` ca fiind tabela care urmează să fie actualizată.
2. **`SET sal = sal + (0.05 * (SELECT AVG(sal) FROM angajati WHERE deptno = 30))`**: Această clauză specifică coloana care trebuie actualizată (`sal`) și noua valoare a acesteia. Noua valoare este calculată prin adăugarea a 5% (0.05) din salariul mediu al departamentului 30 la salariul actual al angajatului.
3. **`WHERE deptno = 30`**: Această clauză specifică faptul că actualizarea trebuie să fie aplicată doar la rândurile (angajații) unde coloana `deptno` este egală cu 30.

Această interogare presupune că aveți o tabelă numită `angajati` cu coloane pentru `sal` (salariu) și `deptno` (numărul departamentului).  Asigurați-vă că numele tabelului și ale coloanelor se potrivesc cu cele din baza de date.
","Scrie o interogare care actualizează salariul fiecărui angajat din departamentul 30, mărindu-l cu 5% din salariul mediu al departamentului său.","['Exemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n', 'Exemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n', 'Exemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n', 'Exemplu ALL - Gasiti \nangajatii care au salariul \nmai mic decat oricare \n(toti) angajatii de la \ndepartamentul 30.\n \nCurs 6 - BAZE DE DATE 51\n', '6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42', '6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42', '6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42', '6.2. MULTIPLE ROW SUBQUERIES\n2) Scopul interogării următoare este de a afişa salariul minim \npentru fiecare departament al cărui salariu minim este mai mic \ndecât cel mai mic salariu al angajaţilor din departamentul 30.\n  Oricum, subinterogarea nu se execută deoarece are 5 erori. \nGăsiţi erorile şi corectaţi-le.\nSELECT deptno\nFROM EMP\nWHERE MIN(sal)\nHAVING MIN(sal) >\n    GROUP BY deptno\n    SELECT MIN(sal)\n    WHERE deptno < 30;\n1\n2\n 3\n4\n5\nCurs 6 - BAZE DE DATE 42', 'Exemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50', 'Exemplu ALL \n Gasiti angajatii care au salariul mai mic decat \noricare (toti) angajatii de la departamentul 30.\n \nSELECT ename, deptno, sal\nFROM EMP\nWHERE sal < ALL\n                ( SELECT sal\n                   FROM EMP\n                   WHERE deptno = 30 )\nAND deptno <> 30;\nCurs 6 - BAZE DE DATE 50']","```sql
UPDATE angajati
SET sal = sal + (0.05 * (SELECT AVG(sal) FROM angajati WHERE deptno = 30))
WHERE deptno = 30;
```

Această interogare va actualiza salariul fiecărui angajat din departamentul 30, adăugând 5% din salariul mediu al departamentului la salariul lor actual. 

Iată cum funcționează:

1. **`UPDATE angajati`**: Această clauză specifică tabela `angajati` ca fiind tabela care urmează să fie actualizată.
2. **`SET sal = sal + (0.05 * (SELECT AVG(sal) FROM angajati WHERE deptno = 30))`**: Această clauză specifică coloana care trebuie actualizată (`sal`) și noua valoare a acesteia. Noua valoare este calculată prin adăugarea a 5% (0.05) din salariul mediu al departamentului 30 la salariul actual al angajatului.
3. **`WHERE deptno = 30`**: Această clauză specifică faptul că actualizarea trebuie să fie aplicată doar la rândurile (angajații) unde coloana `deptno` este egală cu 30.

Această interogare presupune că aveți o tabelă numită `angajati` cu coloane pentru `sal` (salariu) și `deptno` (numărul departamentului).  Asigurați-vă că numele tabelului și ale coloanelor se potrivesc cu cele din baza de date.
","UPDATE EMP 
SET SAL = SAL + 0.05 * (SELECT AVG(SAL) FROM EMP WHERE DEPTNO = 30) 
WHERE DEPTNO = 30;
",,,,,0.13798696881046066,0.16494845360824742,
70,Manual - Test 3,Hard,,,Scrie o interogare care modifică funcția (JOB) angajaților care au fost angajați înainte de anul 2000 și le schimbă funcția în 'SENIOR'.,"UPDATE EMP 
SET JOB = 'SENIOR' 
WHERE EXTRACT(YEAR FROM HIREDATE) < 2000;",Este corect,,"['UPDATE   emp20\nSET    sal_anual = 70000 \nWHERE   cod = 9999\nNotă:\nSe observă că nu se poate schimba codul \ndepartamentului pentru că atunci vederea nu ar mai \nvedea respectiva persoană. \nDeci cu ajutorul clauzei WITH CHECK OPTION \nvederea permite vizualizarea persoanelor din \ndepartamentul 20 şi nu permite schimbarea codului \npentru persoanele selectate în vedere. \n \nCurs - BAZE DE DATE 43', 'UPDATE   emp20\nSET    sal_anual = 70000 \nWHERE   cod = 9999\nNotă:\nSe observă că nu se poate schimba codul \ndepartamentului pentru că atunci vederea nu ar mai \nvedea respectiva persoană. \nDeci cu ajutorul clauzei WITH CHECK OPTION \nvederea permite vizualizarea persoanelor din \ndepartamentul 20 şi nu permite schimbarea codului \npentru persoanele selectate în vedere. \n \nCurs - BAZE DE DATE 43', 'UPDATE   emp20\nSET    sal_anual = 70000 \nWHERE   cod = 9999\nNotă:\nSe observă că nu se poate schimba codul \ndepartamentului pentru că atunci vederea nu ar mai \nvedea respectiva persoană. \nDeci cu ajutorul clauzei WITH CHECK OPTION \nvederea permite vizualizarea persoanelor din \ndepartamentul 20 şi nu permite schimbarea codului \npentru persoanele selectate în vedere. \n \nCurs - BAZE DE DATE 43', 'UPDATE   emp20\nSET    sal_anual = 70000 \nWHERE   cod = 9999\nNotă:\nSe observă că nu se poate schimba codul \ndepartamentului pentru că atunci vederea nu ar mai \nvedea respectiva persoană. \nDeci cu ajutorul clauzei WITH CHECK OPTION \nvederea permite vizualizarea persoanelor din \ndepartamentul 20 şi nu permite schimbarea codului \npentru persoanele selectate în vedere. \n \nCurs - BAZE DE DATE 43', 'Probleme propuse\n2. Creati o copie a tabelei EMP cu numele \nCopy_EMP care sa conțină toate campurile \ntabelei originale. \nAfisati din tabela Copy_EMP numele, salariul și \ndepartamentul pentru toți angajații care au \nsalariul cuprins intre 1000 si 2000. \nCurs 7 - BAZE DE DATE 60', 'Probleme propuse\n2. Creati o copie a tabelei EMP cu numele \nCopy_EMP care sa conțină toate campurile \ntabelei originale. \nAfisati din tabela Copy_EMP numele, salariul și \ndepartamentul pentru toți angajații care au \nsalariul cuprins intre 1000 si 2000. \nCurs 7 - BAZE DE DATE 60', 'Probleme propuse\n2. Creati o copie a tabelei EMP cu numele \nCopy_EMP care sa conțină toate campurile \ntabelei originale. \nAfisati din tabela Copy_EMP numele, salariul și \ndepartamentul pentru toți angajații care au \nsalariul cuprins intre 1000 si 2000. \nCurs 7 - BAZE DE DATE 60', 'Probleme propuse\n2. Creati o copie a tabelei EMP cu numele \nCopy_EMP care sa conțină toate campurile \ntabelei originale. \nAfisati din tabela Copy_EMP numele, salariul și \ndepartamentul pentru toți angajații care au \nsalariul cuprins intre 1000 si 2000. \nCurs 7 - BAZE DE DATE 60', ""Clauza WHERE\nDar ordinea se poate modifica dacă se folosesc \nparanteze. \nSELECT *\nFROM EMP\nWHERE (job = 'MANAGER' OR job = 'ANALYST')\nAND sal < 3000;\n 67\n"", ""Clauza WHERE\nDar ordinea se poate modifica dacă se folosesc \nparanteze. \nSELECT *\nFROM EMP\nWHERE (job = 'MANAGER' OR job = 'ANALYST')\nAND sal < 3000;\n 67\n""]","```sql
UPDATE nume_tabel
SET job = 'SENIOR'
WHERE data_angajarii < '2000-01-01';
```

Asigură-te că înlocuiești `nume_tabel` cu numele tabelei tale și `data_angajarii` cu numele coloanei care stochează data angajării. 
",Scrie o interogare care modifică funcția (JOB) angajaților care au fost angajați înainte de anul 2000 și le schimbă funcția în 'SENIOR'.,"['UPDATE   emp20\nSET    sal_anual = 70000 \nWHERE   cod = 9999\nNotă:\nSe observă că nu se poate schimba codul \ndepartamentului pentru că atunci vederea nu ar mai \nvedea respectiva persoană. \nDeci cu ajutorul clauzei WITH CHECK OPTION \nvederea permite vizualizarea persoanelor din \ndepartamentul 20 şi nu permite schimbarea codului \npentru persoanele selectate în vedere. \n \nCurs - BAZE DE DATE 43', 'UPDATE   emp20\nSET    sal_anual = 70000 \nWHERE   cod = 9999\nNotă:\nSe observă că nu se poate schimba codul \ndepartamentului pentru că atunci vederea nu ar mai \nvedea respectiva persoană. \nDeci cu ajutorul clauzei WITH CHECK OPTION \nvederea permite vizualizarea persoanelor din \ndepartamentul 20 şi nu permite schimbarea codului \npentru persoanele selectate în vedere. \n \nCurs - BAZE DE DATE 43', 'UPDATE   emp20\nSET    sal_anual = 70000 \nWHERE   cod = 9999\nNotă:\nSe observă că nu se poate schimba codul \ndepartamentului pentru că atunci vederea nu ar mai \nvedea respectiva persoană. \nDeci cu ajutorul clauzei WITH CHECK OPTION \nvederea permite vizualizarea persoanelor din \ndepartamentul 20 şi nu permite schimbarea codului \npentru persoanele selectate în vedere. \n \nCurs - BAZE DE DATE 43', 'UPDATE   emp20\nSET    sal_anual = 70000 \nWHERE   cod = 9999\nNotă:\nSe observă că nu se poate schimba codul \ndepartamentului pentru că atunci vederea nu ar mai \nvedea respectiva persoană. \nDeci cu ajutorul clauzei WITH CHECK OPTION \nvederea permite vizualizarea persoanelor din \ndepartamentul 20 şi nu permite schimbarea codului \npentru persoanele selectate în vedere. \n \nCurs - BAZE DE DATE 43', 'Probleme propuse\n2. Creati o copie a tabelei EMP cu numele \nCopy_EMP care sa conțină toate campurile \ntabelei originale. \nAfisati din tabela Copy_EMP numele, salariul și \ndepartamentul pentru toți angajații care au \nsalariul cuprins intre 1000 si 2000. \nCurs 7 - BAZE DE DATE 60', 'Probleme propuse\n2. Creati o copie a tabelei EMP cu numele \nCopy_EMP care sa conțină toate campurile \ntabelei originale. \nAfisati din tabela Copy_EMP numele, salariul și \ndepartamentul pentru toți angajații care au \nsalariul cuprins intre 1000 si 2000. \nCurs 7 - BAZE DE DATE 60', 'Probleme propuse\n2. Creati o copie a tabelei EMP cu numele \nCopy_EMP care sa conțină toate campurile \ntabelei originale. \nAfisati din tabela Copy_EMP numele, salariul și \ndepartamentul pentru toți angajații care au \nsalariul cuprins intre 1000 si 2000. \nCurs 7 - BAZE DE DATE 60', 'Probleme propuse\n2. Creati o copie a tabelei EMP cu numele \nCopy_EMP care sa conțină toate campurile \ntabelei originale. \nAfisati din tabela Copy_EMP numele, salariul și \ndepartamentul pentru toți angajații care au \nsalariul cuprins intre 1000 si 2000. \nCurs 7 - BAZE DE DATE 60', ""Clauza WHERE\nDar ordinea se poate modifica dacă se folosesc \nparanteze. \nSELECT *\nFROM EMP\nWHERE (job = 'MANAGER' OR job = 'ANALYST')\nAND sal < 3000;\n 67\n"", ""Clauza WHERE\nDar ordinea se poate modifica dacă se folosesc \nparanteze. \nSELECT *\nFROM EMP\nWHERE (job = 'MANAGER' OR job = 'ANALYST')\nAND sal < 3000;\n 67\n""]","```sql
UPDATE nume_tabel
SET job = 'SENIOR'
WHERE data_angajarii < '2000-01-01';
```

Asigură-te că înlocuiești `nume_tabel` cu numele tabelei tale și `data_angajarii` cu numele coloanei care stochează data angajării. 
","UPDATE EMP 
SET JOB = 'SENIOR' 
WHERE EXTRACT(YEAR FROM HIREDATE) < 2000;",,,,,0.03286851896957949,0.26086956521739124,
71,Manual - Test 4,Negativ,,,Cum e vremea la galati ?,Nu am gasit informatii in curs despre intrebarea ta,,,"['Întrebări?\n 69', 'Întrebări?\n 69', 'Întrebări?\n 69', 'Întrebări?\n 69', 'Întrebări?\n 86', 'Întrebări?\n 86', 'Întrebări?\n 86', 'Întrebări?\n 86', 'Întrebări?\n77', 'Întrebări?\n77']","I'm sorry, but the text you provided as context does not contain information about the weather in Galati. Therefore, I cannot answer your question using the provided context. 
",Cum e vremea la galati ?,"['Întrebări?\n 69', 'Întrebări?\n 69', 'Întrebări?\n 69', 'Întrebări?\n 69', 'Întrebări?\n 86', 'Întrebări?\n 86', 'Întrebări?\n 86', 'Întrebări?\n 86', 'Întrebări?\n77', 'Întrebări?\n77']","I'm sorry, but the text you provided as context does not contain information about the weather in Galati. Therefore, I cannot answer your question using the provided context. 
",Nu am gasit informatii in curs despre intrebarea ta,,,,,0.020244462660665506,0.05263157894736842,
72,Manual - Test 4,Negativ,,,Cati ani a trait Michael Jackson ?,Nu am gasit informatii in curs despre intrebarea ta,,,"['Întrebări?\n 69', 'Întrebări?\n 69', 'Întrebări?\n 69', 'Întrebări?\n 69', 'Întrebări?\n77', 'Întrebări?\n77', 'Întrebări?\n77', 'Întrebări?\n77', 'Întrebări?\nCurs - BAZE DE DATE 51', 'Întrebări?\nCurs - BAZE DE DATE 51']","I'm sorry, I cannot answer your question using the context provided. The context does not contain information about Michael Jackson's lifespan. 
",Cati ani a trait Michael Jackson ?,"['Întrebări?\n 69', 'Întrebări?\n 69', 'Întrebări?\n 69', 'Întrebări?\n 69', 'Întrebări?\n77', 'Întrebări?\n77', 'Întrebări?\n77', 'Întrebări?\n77', 'Întrebări?\nCurs - BAZE DE DATE 51', 'Întrebări?\nCurs - BAZE DE DATE 51']","I'm sorry, I cannot answer your question using the context provided. The context does not contain information about Michael Jackson's lifespan. 
",Nu am gasit informatii in curs despre intrebarea ta,,,,,0.0,0.0,
73,Manual - Test 4,Negativ,,,Ce o carte ?,Nu am gasit informatii in curs despre intrebarea ta,,,"['Întrebări?\n77', 'Întrebări?\n77', 'Întrebări?\n77', 'Întrebări?\n77', 'Întrebări?\n 69', 'Întrebări?\n 69', 'Întrebări?\n 69', 'Întrebări?\n 69', 'Întrebări?\n 86', 'Întrebări?\n 86']","I'm sorry, I cannot answer your question using the context provided. The context seems to contain a list of repetitive phrases ""Întrebări?\n"" followed by numbers, which are not relevant to the question ""Ce o carte?"" (What is a book?). Please provide more context or rephrase your question. 
",Ce o carte ?,"['Întrebări?\n77', 'Întrebări?\n77', 'Întrebări?\n77', 'Întrebări?\n77', 'Întrebări?\n 69', 'Întrebări?\n 69', 'Întrebări?\n 69', 'Întrebări?\n 69', 'Întrebări?\n 86', 'Întrebări?\n 86']","I'm sorry, I cannot answer your question using the context provided. The context seems to contain a list of repetitive phrases ""Întrebări?\n"" followed by numbers, which are not relevant to the question ""Ce o carte?"" (What is a book?). Please provide more context or rephrase your question. 
",Nu am gasit informatii in curs despre intrebarea ta,,,,,0.0,0.0,
74,Manual - Test 4,Negativ,,,Cat face 2 + 2 ?,Nu am gasit informatii in curs despre intrebarea ta,,,"['Cuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5', 'Cuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5', 'Cuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5', 'Cuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5', 'Curs 3 \nLimbajul SQL \n 2', 'Curs 3 \nLimbajul SQL \n 2', 'Curs 3 \nLimbajul SQL \n 2', 'Curs 3 \nLimbajul SQL \n 2', 'Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2', 'Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2']","The provided context does not contain the answer to what 2 + 2 is. It appears to be a list of document titles or contents related to databases and SQL. 

However, I can tell you that 2 + 2 = 4. 
",Cat face 2 + 2 ?,"['Cuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5', 'Cuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5', 'Cuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5', 'Cuprins\n 1. Secvente\n 2. Indecsi\n 3. Sinonime\nCurs - BAZE DE DATE 5', 'Curs 3 \nLimbajul SQL \n 2', 'Curs 3 \nLimbajul SQL \n 2', 'Curs 3 \nLimbajul SQL \n 2', 'Curs 3 \nLimbajul SQL \n 2', 'Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2', 'Curs 2 \nSistemul de gestiune a bazelor de date\nORACLE\n2']","The provided context does not contain the answer to what 2 + 2 is. It appears to be a list of document titles or contents related to databases and SQL. 

However, I can tell you that 2 + 2 = 4. 
",Nu am gasit informatii in curs despre intrebarea ta,,,,,0.0,0.0,
75,Manual - Test 4,Negativ,,,Care dintre următoarele afirmații este corectă cu privire la diferențele dintre bazele de date distribuite și NoSQL?,Nu am gasit informatii in curs despre intrebarea ta,,,"['Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'S.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4', 'S.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4']","Nu există informații în context despre bazele de date distribuite sau NoSQL, ci despre limbajul SQL și comenzile sale. Prin urmare, nu pot răspunde la întrebarea ta. 
",Care dintre următoarele afirmații este corectă cu privire la diferențele dintre bazele de date distribuite și NoSQL?,"['Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'S.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4', 'S.G.B.D. ORACLE\n2.5. Limbajul SQL. Categorii de comenzi ale limbajului SQL:\n       2.5.1. Comenzi ale sublimbajului de interogare (DQL - \ndata query language)\n       2.5.2. Comenzi ale sublimbajului de manipulare (DML - \ndata manipulation language)\n       2.5.3. Comenzi ale sublimbajului de definire a datelor \n(DDL - data definition language)\n       2.5.4. Comenzi ale sublimbajului de control al datelor \n(DCL - data control language)\n       2.5.5. Comenzi ale sublimbajului de control al \ntranzactiilor (TCL - transaction control language)\n2.6. Elemente ale limbajului SQL\n4']","Nu există informații în context despre bazele de date distribuite sau NoSQL, ci despre limbajul SQL și comenzile sale. Prin urmare, nu pot răspunde la întrebarea ta. 
",Nu am gasit informatii in curs despre intrebarea ta,,,,,0.02276859592073037,0.15789473684210528,
76,Manual - Test 4,Negativ,,,Ce avantaj major oferă bazele de date NoSQL față de bazele de date distribuite tradiționale?,Nu am gasit informatii in curs despre intrebarea ta,,,"['Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68']","Contextul furnizat se referă la baze de date SQL (Limbajul SQL, subinterogări) și nu oferă informații despre bazele de date NoSQL sau despre avantajele lor față de bazele de date distribuite tradiționale. Prin urmare, nu pot răspunde la întrebarea ta folosind doar acest context. 
",Ce avantaj major oferă bazele de date NoSQL față de bazele de date distribuite tradiționale?,"['Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68', 'Concluzii\n1. O subinterogare este o instructiune SELECT\ninclusa într-o clauza a altei instructiuni SQL. \n2. Subinterogarile sunt folositoare atunci cînd \ninterogarea se bazeaza pe criterii necunoscute.\n3. Subinterogarile au urmatoarele caracteristici:\na) Pot transmite un rand de date instructiunii principale care \ncontine un operator single-row, precum: =, <>, >, >=, < sau <=;\nb) Pot transmite rînduri multiple de date instructiunii  principale \ncare contine un operator multiple-row, precum: IN, ANY sau \nALL;\nc) Sunt primele procesate de catre server-ul Oracle, iar clauzele \nWHERE si HAVING folosesc rezultatele;\nd) Pot contine functii de grup.Curs 6 - BAZE DE DATE 68']","Contextul furnizat se referă la baze de date SQL (Limbajul SQL, subinterogări) și nu oferă informații despre bazele de date NoSQL sau despre avantajele lor față de bazele de date distribuite tradiționale. Prin urmare, nu pot răspunde la întrebarea ta folosind doar acest context. 
",Nu am gasit informatii in curs despre intrebarea ta,,,,,0.010559717178170818,0.10526315789473684,
77,Manual - Test 4,Negativ,,,Descrie scenariile în care o bază de date distribuită ar fi mai potrivită decât o bază de date NoSQL.,Nu am gasit informatii in curs despre intrebarea ta,,,"['Indecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37', 'Indecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37', 'Indecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37', 'Indecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37', 'Conţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\n 14\n', 'Conţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\n 14\n', 'Conţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\n 14\n', 'Conţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\n 14\n', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58']","Informațiile furnizate din context nu conțin detalii despre bazele de date distribuite sau NoSQL. Prin urmare, nu pot răspunde la întrebarea ta folosind contextul furnizat. 

Pentru a putea răspunde corect, aș avea nevoie de informații despre:

* **Bazele de date distribuite:** Cum funcționează, care sunt avantajele și dezavantajele lor.
* **Bazele de date NoSQL:**  Ce tipuri de baze de date NoSQL există, care sunt avantajele și dezavantajele lor.

Cu aceste informații, pot compara cele două tipuri de baze de date și pot identifica scenariile în care o bază de date distribuită ar fi mai potrivită decât o bază de date NoSQL. 
",Descrie scenariile în care o bază de date distribuită ar fi mai potrivită decât o bază de date NoSQL.,"['Indecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37', 'Indecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37', 'Indecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37', 'Indecșii bazați pe expresii\n➢Indecsi mai pot fi adaugati nu numai pe campuri \nsimple din baza de date. \n➢Ei pot sa fie folositi de asemenea pe anumite \nexpresii. \n➢Aceste expresii pot fi construite din campuri din \ntabela, constante, functii SQL sau functii definite de \ncatre utilizator. \n➢In felul acesta se pot optimiza cererile de extragere \ncare contin conditii complexe bazate pe calcule.\nCurs - BAZE DE DATE 37', 'Conţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\n 14\n', 'Conţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\n 14\n', 'Conţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\n 14\n', 'Conţinutul cursului\nLimbajul de interogare a bazelor de date în care se \nvor face exemplificările noţiunilor teoretice va fi \nSQL (Structured Query Language).\n 14\n', 'Interogarea bazelor de date - \nLimbajul SQL \n58', 'Interogarea bazelor de date - \nLimbajul SQL \n58']","Informațiile furnizate din context nu conțin detalii despre bazele de date distribuite sau NoSQL. Prin urmare, nu pot răspunde la întrebarea ta folosind contextul furnizat. 

Pentru a putea răspunde corect, aș avea nevoie de informații despre:

* **Bazele de date distribuite:** Cum funcționează, care sunt avantajele și dezavantajele lor.
* **Bazele de date NoSQL:**  Ce tipuri de baze de date NoSQL există, care sunt avantajele și dezavantajele lor.

Cu aceste informații, pot compara cele două tipuri de baze de date și pot identifica scenariile în care o bază de date distribuită ar fi mai potrivită decât o bază de date NoSQL. 
",Nu am gasit informatii in curs despre intrebarea ta,,,,,0.028398387225677894,0.06896551724137931,
78,Manual - Test 4,Negativ,,,Care sunt principalele provocări ale utilizării bazelor de date NoSQL într-un sistem distribuit?,Nu am gasit informatii in curs despre intrebarea ta,,,"['2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61', '2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61', '2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61', '2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul. \n', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul. \n', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul. \n', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul. \n', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3']","Informația oferită în context nu menționează bazele de date NoSQL sau provocările utilizării lor în sisteme distribuite. Textul se concentrează pe limbajul SQL și pe componentele unui sistem de baze de date relaționale. 

Pentru a răspunde la întrebarea despre provocările utilizării bazelor de date NoSQL într-un sistem distribuit, ar fi nevoie de informații suplimentare despre:

* **Tipuri de baze de date NoSQL:** Există diferite tipuri, precum cele orientate pe documente, grafului, coloane sau valori cheie. Fiecare tip are propriile provocări.
* **Aspecte specifice sistemelor distribuite:** Cum ar fi consistența datelor, toleranța la erori și scalabilitatea.

Iată câteva exemple generale de provocări ale utilizării bazelor de date NoSQL într-un sistem distribuit:

* **Consistența datelor:** Menținerea consistenței datelor pe mai multe noduri poate fi dificilă, mai ales în cazul partiționării rețelei.
* **Administrare complexă:** Gestionarea unui cluster de baze de date NoSQL distribuite poate fi mai complexă decât administrarea unei baze de date relaționale centralizate.
* **Securitate:** Asigurarea securității datelor distribuite pe mai multe noduri poate fi o provocare.

Pentru un răspuns mai precis și detaliat, te rog să oferi mai multe detalii despre tipul de bază de date NoSQL și despre sistemul distribuit în cauză. 
",Care sunt principalele provocări ale utilizării bazelor de date NoSQL într-un sistem distribuit?,"['2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61', '2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61', '2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61', '2.5. Limbajul SQ\n SQL utilizează o sintaxă foarte simplă şi uşor de \nfolosit. \n  Comenzile SQL sunt grupate în cinci categorii, \nastfel:\n1. Limbajul de interogare permite regăsirea liniilor \nmemorate în tabelele bazelor de date. \n  Comanda utilizată este SELECT.\n61', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul. \n', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul. \n', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul. \n', '3 \n \n2. Software \nSoftware-ul este componenta care gestionează și controlează baza de date. Principalele elemente \ninclud: \n✓ Sistemul de Gestionare a Bazelor de Date \n(SGBD) - Software care permite crearea, \nmanipularea și interogarea bazelor de date. \nExemple de SGBD -uri: MySQL, \nPostgreSQL, Oracle, Microsoft SQL \nServer. \n✓ Sistemul de operare  - Asigură \ninteracțiunea dintre hardware și software-ul \nbazei de date. \n✓ Aplicațiile utilizatorilor - Programe care interacționează cu baza de date pentru a furniza \nservicii specifice. \n \n3. Date \nDatele reprezintă componenta centrală a oricărui \nsistem de baze de date. Acestea pot fi: \n✓ Date brute  - Informațiile primare stocate în \ntabele. \n✓ Metadate - Informații despre structura bazei \nde date, precum tipurile de date și relațiile \ndintre tabele. \n✓ Indexuri - Structuri utilizate pentru a accelera \ncăutările și interogările în baze de date mari. \n \n4. Utilizatori \nUtilizatorii bazei de date pot fi clasificați în mai multe \ncategorii: \n✓ Administratorii bazei de date (DBA)  - \nResponsabili pentru gestionarea și întreținerea bazei \nde date. \n✓ Dezvoltatorii de aplicații  - Creează software care \ninteracționează cu baza de date. \n✓ Utilizatori finali  - Accesează baza de date prin \naplicații sau interfețe specifice pentru a introduce \nsau interoga date. \n \n5. Proceduri și politici \nProcedurile și politicile definesc regulile și bunele practici pentru utilizarea bazei de date. Acestea \ninclud: \n✓ Reguli de securitate - Politici de acces și autentificare. \n✓ Proceduri de backup și recuperare - Planuri pentru protejarea datelor împotriva pierderii \naccidentale. \n✓ Norme de utilizare  - Standardele stabilite pentru gestionarea datelor și interacțiunea \nutilizatorilor cu sistemul. \n', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3', 'Limbajul SQL\nAlte obiecte din baza de date:\n \n    1. Secvente\n 2. Indecși\n 3. Sinonime \nCurs - BAZE DE DATE 3']","Informația oferită în context nu menționează bazele de date NoSQL sau provocările utilizării lor în sisteme distribuite. Textul se concentrează pe limbajul SQL și pe componentele unui sistem de baze de date relaționale. 

Pentru a răspunde la întrebarea despre provocările utilizării bazelor de date NoSQL într-un sistem distribuit, ar fi nevoie de informații suplimentare despre:

* **Tipuri de baze de date NoSQL:** Există diferite tipuri, precum cele orientate pe documente, grafului, coloane sau valori cheie. Fiecare tip are propriile provocări.
* **Aspecte specifice sistemelor distribuite:** Cum ar fi consistența datelor, toleranța la erori și scalabilitatea.

Iată câteva exemple generale de provocări ale utilizării bazelor de date NoSQL într-un sistem distribuit:

* **Consistența datelor:** Menținerea consistenței datelor pe mai multe noduri poate fi dificilă, mai ales în cazul partiționării rețelei.
* **Administrare complexă:** Gestionarea unui cluster de baze de date NoSQL distribuite poate fi mai complexă decât administrarea unei baze de date relaționale centralizate.
* **Securitate:** Asigurarea securității datelor distribuite pe mai multe noduri poate fi o provocare.

Pentru un răspuns mai precis și detaliat, te rog să oferi mai multe detalii despre tipul de bază de date NoSQL și despre sistemul distribuit în cauză. 
",Nu am gasit informatii in curs despre intrebarea ta,,,,,0.0,0.017777777777777778,
